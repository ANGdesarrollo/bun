// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __legacyDecorateClassTS = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1;i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __legacyMetadataTS = (k, v) => {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS((exports) => {
  var isAnyArrayBuffer = function(value14) {
    return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value14));
  };
  var isUint8Array = function(value14) {
    return Object.prototype.toString.call(value14) === "[object Uint8Array]";
  };
  var isRegExp = function(d2) {
    return Object.prototype.toString.call(d2) === "[object RegExp]";
  };
  var isMap = function(d2) {
    return Object.prototype.toString.call(d2) === "[object Map]";
  };
  var isDate = function(d2) {
    return Object.prototype.toString.call(d2) === "[object Date]";
  };
  var defaultInspect = function(x, _options) {
    return JSON.stringify(x, (k, v2) => {
      if (typeof v2 === "bigint") {
        return { $numberLong: `${v2}` };
      } else if (isMap(v2)) {
        return Object.fromEntries(v2);
      }
      return v2;
    });
  };
  var getStylizeFunction = function(options) {
    const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
    if (stylizeExists) {
      return options.stylize;
    }
  };
  var validateUtf8 = function(bytes, start, end) {
    let continuation = 0;
    for (let i2 = start;i2 < end; i2 += 1) {
      const byte = bytes[i2];
      if (continuation) {
        if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
          return false;
        }
        continuation -= 1;
      } else if (byte & FIRST_BIT) {
        if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
          continuation = 1;
        } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
          continuation = 2;
        } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
          continuation = 3;
        } else {
          return false;
        }
      }
    }
    return !continuation;
  };
  var tryLatin = function(uint8array4, start, end) {
    if (uint8array4.length === 0) {
      return "";
    }
    const stringByteLength = end - start;
    if (stringByteLength === 0) {
      return "";
    }
    if (stringByteLength > 20) {
      return null;
    }
    if (stringByteLength === 1 && uint8array4[start] < 128) {
      return String.fromCharCode(uint8array4[start]);
    }
    if (stringByteLength === 2 && uint8array4[start] < 128 && uint8array4[start + 1] < 128) {
      return String.fromCharCode(uint8array4[start]) + String.fromCharCode(uint8array4[start + 1]);
    }
    if (stringByteLength === 3 && uint8array4[start] < 128 && uint8array4[start + 1] < 128 && uint8array4[start + 2] < 128) {
      return String.fromCharCode(uint8array4[start]) + String.fromCharCode(uint8array4[start + 1]) + String.fromCharCode(uint8array4[start + 2]);
    }
    const latinBytes = [];
    for (let i2 = start;i2 < end; i2++) {
      const byte = uint8array4[i2];
      if (byte > 127) {
        return null;
      }
      latinBytes.push(byte);
    }
    return String.fromCharCode(...latinBytes);
  };
  var nodejsMathRandomBytes = function(byteLength) {
    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  };
  var isReactNative = function() {
    const { navigator } = globalThis;
    return typeof navigator === "object" && navigator.product === "ReactNative";
  };
  var webMathRandomBytes = function(byteLength) {
    if (byteLength < 0) {
      throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
    }
    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  };
  var isDBRefLike = function(value14) {
    return value14 != null && typeof value14 === "object" && "$id" in value14 && value14.$id != null && "$ref" in value14 && typeof value14.$ref === "string" && (!("$db" in value14) || ("$db" in value14) && typeof value14.$db === "string");
  };
  var isDigit = function(value14) {
    return !isNaN(parseInt(value14, 10));
  };
  var divideu128 = function(value14) {
    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
    let _rem = Long.fromNumber(0);
    if (!value14.parts[0] && !value14.parts[1] && !value14.parts[2] && !value14.parts[3]) {
      return { quotient: value14, rem: _rem };
    }
    for (let i2 = 0;i2 <= 3; i2++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long(value14.parts[i2], 0));
      value14.parts[i2] = _rem.div(DIVISOR).low;
      _rem = _rem.modulo(DIVISOR);
    }
    return { quotient: value14, rem: _rem };
  };
  var multiply64x2 = function(left, right) {
    if (!left && !right) {
      return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
    }
    const leftHigh = left.shiftRightUnsigned(32);
    const leftLow = new Long(left.getLowBits(), 0);
    const rightHigh = right.shiftRightUnsigned(32);
    const rightLow = new Long(right.getLowBits(), 0);
    let productHigh = leftHigh.multiply(rightHigh);
    let productMid = leftHigh.multiply(rightLow);
    const productMid2 = leftLow.multiply(rightHigh);
    let productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
    return { high: productHigh, low: productLow };
  };
  var lessThan = function(left, right) {
    const uhleft = left.high >>> 0;
    const uhright = right.high >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      const ulleft = left.low >>> 0;
      const ulright = right.low >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  };
  var invalidErr = function(string6, message) {
    throw new BSONError(`"${string6}" is not a valid Decimal128 string - ${message}`);
  };
  var internalCalculateObjectSize = function(object12, serializeFunctions, ignoreUndefined) {
    let totalLength = 4 + 1;
    if (Array.isArray(object12)) {
      for (let i2 = 0;i2 < object12.length; i2++) {
        totalLength += calculateElement(i2.toString(), object12[i2], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (typeof object12?.toBSON === "function") {
        object12 = object12.toBSON();
      }
      for (const key of Object.keys(object12)) {
        totalLength += calculateElement(key, object12[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  };
  var calculateElement = function(name, value14, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
    if (typeof value14?.toBSON === "function") {
      value14 = value14.toBSON();
    }
    switch (typeof value14) {
      case "string":
        return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value14) + 1;
      case "number":
        if (Math.floor(value14) === value14 && value14 >= JS_INT_MIN && value14 <= JS_INT_MAX) {
          if (value14 >= BSON_INT32_MIN && value14 <= BSON_INT32_MAX) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
      case "object":
        if (value14 != null && typeof value14._bsontype === "string" && value14[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value14 == null || value14._bsontype === "MinKey" || value14._bsontype === "MaxKey") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        } else if (value14._bsontype === "ObjectId") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
        } else if (value14 instanceof Date || isDate(value14)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (ArrayBuffer.isView(value14) || value14 instanceof ArrayBuffer || isAnyArrayBuffer(value14)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value14.byteLength;
        } else if (value14._bsontype === "Long" || value14._bsontype === "Double" || value14._bsontype === "Timestamp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (value14._bsontype === "Decimal128") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
        } else if (value14._bsontype === "Code") {
          if (value14.scope != null && Object.keys(value14.scope).length > 0) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value14.code.toString()) + 1 + internalCalculateObjectSize(value14.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value14.code.toString()) + 1;
          }
        } else if (value14._bsontype === "Binary") {
          const binary = value14;
          if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
          }
        } else if (value14._bsontype === "Symbol") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value14.value) + 4 + 1 + 1;
        } else if (value14._bsontype === "DBRef") {
          const ordered_values = Object.assign({
            $ref: value14.collection,
            $id: value14.oid
          }, value14.fields);
          if (value14.db != null) {
            ordered_values["$db"] = value14.db;
          }
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value14 instanceof RegExp || isRegExp(value14)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value14.source) + 1 + (value14.global ? 1 : 0) + (value14.ignoreCase ? 1 : 0) + (value14.multiline ? 1 : 0) + 1;
        } else if (value14._bsontype === "BSONRegExp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value14.pattern) + 1 + ByteUtils.utf8ByteLength(value14.options) + 1;
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value14, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (serializeFunctions) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value14.toString()) + 1;
        }
    }
    return 0;
  };
  var alphabetize = function(str) {
    return str.split("").sort().join("");
  };
  var internalDeserialize = function(buffer2, options, isArray) {
    options = options == null ? {} : options;
    const index = options && options.index ? options.index : 0;
    const size = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
    if (size < 5) {
      throw new BSONError(`bson size must be >= 5, is ${size}`);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
      throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
      throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
    }
    if (size + index > buffer2.byteLength) {
      throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
    }
    if (buffer2[index + size - 1] !== 0) {
      throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer2, index, options, isArray);
  };
  var deserializeObject = function(buffer2, index, options, isArray = false) {
    const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    const raw = options["raw"] == null ? false : options["raw"];
    const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    const promoteBuffers = options.promoteBuffers ?? false;
    const promoteLongs = options.promoteLongs ?? true;
    const promoteValues = options.promoteValues ?? true;
    const useBigInt64 = options.useBigInt64 ?? false;
    if (useBigInt64 && !promoteValues) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    if (useBigInt64 && !promoteLongs) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    const validation = options.validation == null ? { utf8: true } : options.validation;
    let globalUTFValidation = true;
    let validationSetting;
    const utf8KeysSet = new Set;
    const utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === "boolean") {
      validationSetting = utf8ValidatedKeys;
    } else {
      globalUTFValidation = false;
      const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
        return utf8ValidatedKeys[key];
      });
      if (utf8ValidationValues.length === 0) {
        throw new BSONError("UTF-8 validation setting cannot be empty");
      }
      if (typeof utf8ValidationValues[0] !== "boolean") {
        throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
      }
      validationSetting = utf8ValidationValues[0];
      if (!utf8ValidationValues.every((item) => item === validationSetting)) {
        throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
      }
    }
    if (!globalUTFValidation) {
      for (const key of Object.keys(utf8ValidatedKeys)) {
        utf8KeysSet.add(key);
      }
    }
    const startIndex = index;
    if (buffer2.length < 5)
      throw new BSONError("corrupt bson message < 5 bytes long");
    const size = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    if (size < 5 || size > buffer2.length)
      throw new BSONError("corrupt bson message");
    const object12 = isArray ? [] : {};
    let arrayIndex = 0;
    const done = false;
    let isPossibleDBRef = isArray ? false : null;
    const dataview = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
    while (!done) {
      const elementType = buffer2[index++];
      if (elementType === 0)
        break;
      let i2 = index;
      while (buffer2[i2] !== 0 && i2 < buffer2.length) {
        i2++;
      }
      if (i2 >= buffer2.byteLength)
        throw new BSONError("Bad BSON Document: illegal CString");
      const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i2, false);
      let shouldValidateKey = true;
      if (globalUTFValidation || utf8KeysSet.has(name)) {
        shouldValidateKey = validationSetting;
      } else {
        shouldValidateKey = !validationSetting;
      }
      if (isPossibleDBRef !== false && name[0] === "$") {
        isPossibleDBRef = allowedDBRefKeys.test(name);
      }
      let value14;
      index = i2 + 1;
      if (elementType === BSON_DATA_STRING) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        value14 = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_OID) {
        const oid = ByteUtils.allocate(12);
        oid.set(buffer2.subarray(index, index + 12));
        value14 = new ObjectId(oid);
        index = index + 12;
      } else if (elementType === BSON_DATA_INT && promoteValues === false) {
        value14 = new Int32(buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24);
      } else if (elementType === BSON_DATA_INT) {
        value14 = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {
        value14 = new Double(dataview.getFloat64(index, true));
        index = index + 8;
      } else if (elementType === BSON_DATA_NUMBER) {
        value14 = dataview.getFloat64(index, true);
        index = index + 8;
      } else if (elementType === BSON_DATA_DATE) {
        const lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        value14 = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON_DATA_BOOLEAN) {
        if (buffer2[index] !== 0 && buffer2[index] !== 1)
          throw new BSONError("illegal boolean type value");
        value14 = buffer2[index++] === 1;
      } else if (elementType === BSON_DATA_OBJECT) {
        const _index = index;
        const objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
        if (objectSize <= 0 || objectSize > buffer2.length - index)
          throw new BSONError("bad embedded document length in bson");
        if (raw) {
          value14 = buffer2.slice(index, index + objectSize);
        } else {
          let objectOptions = options;
          if (!globalUTFValidation) {
            objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
          }
          value14 = deserializeObject(buffer2, _index, objectOptions, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON_DATA_ARRAY) {
        const _index = index;
        const objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
        let arrayOptions = options;
        const stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = { ...options, raw: true };
        }
        if (!globalUTFValidation) {
          arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
        }
        value14 = deserializeObject(buffer2, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer2[index - 1] !== 0)
          throw new BSONError("invalid array terminator byte");
        if (index !== stopIndex)
          throw new BSONError("corrupted array bson");
      } else if (elementType === BSON_DATA_UNDEFINED) {
        value14 = undefined;
      } else if (elementType === BSON_DATA_NULL) {
        value14 = null;
      } else if (elementType === BSON_DATA_LONG) {
        const dataview2 = BSONDataView.fromUint8Array(buffer2.subarray(index, index + 8));
        const lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const long = new Long(lowBits, highBits);
        if (useBigInt64) {
          value14 = dataview2.getBigInt64(0, true);
        } else if (promoteLongs && promoteValues === true) {
          value14 = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
        } else {
          value14 = long;
        }
      } else if (elementType === BSON_DATA_DECIMAL128) {
        const bytes = ByteUtils.allocate(16);
        bytes.set(buffer2.subarray(index, index + 16), 0);
        index = index + 16;
        value14 = new Decimal128(bytes);
      } else if (elementType === BSON_DATA_BINARY) {
        let binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const totalBinarySize = binarySize;
        const subType = buffer2[index++];
        if (binarySize < 0)
          throw new BSONError("Negative binary type element size found");
        if (binarySize > buffer2.byteLength)
          throw new BSONError("Binary type size larger than document size");
        if (buffer2["slice"] != null) {
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          if (promoteBuffers && promoteValues) {
            value14 = ByteUtils.toLocalBufferType(buffer2.slice(index, index + binarySize));
          } else {
            value14 = new Binary(buffer2.slice(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value14)) {
              value14 = value14.toUUID();
            }
          }
        } else {
          const _buffer = ByteUtils.allocate(binarySize);
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          for (i2 = 0;i2 < binarySize; i2++) {
            _buffer[i2] = buffer2[index + i2];
          }
          if (promoteBuffers && promoteValues) {
            value14 = _buffer;
          } else {
            value14 = new Binary(buffer2.slice(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value14)) {
              value14 = value14.toUUID();
            }
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
        i2 = index;
        while (buffer2[i2] !== 0 && i2 < buffer2.length) {
          i2++;
        }
        if (i2 >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i2, false);
        index = i2 + 1;
        i2 = index;
        while (buffer2[i2] !== 0 && i2 < buffer2.length) {
          i2++;
        }
        if (i2 >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i2, false);
        index = i2 + 1;
        const optionsArray = new Array(regExpOptions.length);
        for (i2 = 0;i2 < regExpOptions.length; i2++) {
          switch (regExpOptions[i2]) {
            case "m":
              optionsArray[i2] = "m";
              break;
            case "s":
              optionsArray[i2] = "g";
              break;
            case "i":
              optionsArray[i2] = "i";
              break;
          }
        }
        value14 = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
        i2 = index;
        while (buffer2[i2] !== 0 && i2 < buffer2.length) {
          i2++;
        }
        if (i2 >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i2, false);
        index = i2 + 1;
        i2 = index;
        while (buffer2[i2] !== 0 && i2 < buffer2.length) {
          i2++;
        }
        if (i2 >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i2, false);
        index = i2 + 1;
        value14 = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON_DATA_SYMBOL) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const symbol4 = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value14 = promoteValues ? symbol4 : new BSONSymbol(symbol4);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_TIMESTAMP) {
        const i3 = buffer2[index++] + buffer2[index++] * (1 << 8) + buffer2[index++] * (1 << 16) + buffer2[index++] * (1 << 24);
        const t2 = buffer2[index++] + buffer2[index++] * (1 << 8) + buffer2[index++] * (1 << 16) + buffer2[index++] * (1 << 24);
        value14 = new Timestamp({ i: i3, t: t2 });
      } else if (elementType === BSON_DATA_MIN_KEY) {
        value14 = new MinKey;
      } else if (elementType === BSON_DATA_MAX_KEY) {
        value14 = new MaxKey;
      } else if (elementType === BSON_DATA_CODE) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value14 = new Code(functionString);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
        const totalSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new BSONError("code_w_scope total size shorter minimum expected length");
        }
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const _index = index;
        const objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
        const scopeObject = deserializeObject(buffer2, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too long, clips outer document");
        }
        value14 = new Code(functionString, scopeObject);
      } else if (elementType === BSON_DATA_DBPOINTER) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
          throw new BSONError("bad string length in bson");
        if (validation != null && validation.utf8) {
          if (!validateUtf8(buffer2, index, index + stringSize - 1)) {
            throw new BSONError("Invalid UTF-8 string in BSON document");
          }
        }
        const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, false);
        index = index + stringSize;
        const oidBuffer = ByteUtils.allocate(12);
        oidBuffer.set(buffer2.subarray(index, index + 12), 0);
        const oid = new ObjectId(oidBuffer);
        index = index + 12;
        value14 = new DBRef(namespace, oid);
      } else {
        throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
      }
      if (name === "__proto__") {
        Object.defineProperty(object12, name, {
          value: value14,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        object12[name] = value14;
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new BSONError("corrupt array bson");
      throw new BSONError("corrupt object bson");
    }
    if (!isPossibleDBRef)
      return object12;
    if (isDBRefLike(object12)) {
      const copy = Object.assign({}, object12);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(object12.$ref, object12.$id, object12.$db, copy);
    }
    return object12;
  };
  var serializeString = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_STRING;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes + 1;
    buffer2[index - 1] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value14, index + 4);
    buffer2[index + 3] = size + 1 >> 24 & 255;
    buffer2[index + 2] = size + 1 >> 16 & 255;
    buffer2[index + 1] = size + 1 >> 8 & 255;
    buffer2[index] = size + 1 & 255;
    index = index + 4 + size;
    buffer2[index++] = 0;
    return index;
  };
  var serializeNumber = function(buffer2, key, value14, index) {
    const isNegativeZero = Object.is(value14, -0);
    const type73 = !isNegativeZero && Number.isSafeInteger(value14) && value14 <= BSON_INT32_MAX && value14 >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
    if (type73 === BSON_DATA_INT) {
      NUMBER_SPACE.setInt32(0, value14, true);
    } else {
      NUMBER_SPACE.setFloat64(0, value14, true);
    }
    const bytes = type73 === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;
    buffer2[index++] = type73;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2.set(bytes, index);
    index += bytes.byteLength;
    return index;
  };
  var serializeBigInt = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_LONG;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index += numberOfWrittenBytes;
    buffer2[index++] = 0;
    NUMBER_SPACE.setBigInt64(0, value14, true);
    buffer2.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;
    return index;
  };
  var serializeNull = function(buffer2, key, _, index) {
    buffer2[index++] = BSON_DATA_NULL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  };
  var serializeBoolean = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_BOOLEAN;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value14 ? 1 : 0;
    return index;
  };
  var serializeDate = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_DATE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const dateInMilis = Long.fromNumber(value14.getTime());
    const lowBits = dateInMilis.getLowBits();
    const highBits = dateInMilis.getHighBits();
    buffer2[index++] = lowBits & 255;
    buffer2[index++] = lowBits >> 8 & 255;
    buffer2[index++] = lowBits >> 16 & 255;
    buffer2[index++] = lowBits >> 24 & 255;
    buffer2[index++] = highBits & 255;
    buffer2[index++] = highBits >> 8 & 255;
    buffer2[index++] = highBits >> 16 & 255;
    buffer2[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeRegExp = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value14.source && value14.source.match(regexp3) != null) {
      throw new BSONError("value " + value14.source + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value14.source, index);
    buffer2[index++] = 0;
    if (value14.ignoreCase)
      buffer2[index++] = 105;
    if (value14.global)
      buffer2[index++] = 115;
    if (value14.multiline)
      buffer2[index++] = 109;
    buffer2[index++] = 0;
    return index;
  };
  var serializeBSONRegExp = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value14.pattern.match(regexp3) != null) {
      throw new BSONError("pattern " + value14.pattern + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value14.pattern, index);
    buffer2[index++] = 0;
    const sortedOptions = value14.options.split("").sort().join("");
    index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
    buffer2[index++] = 0;
    return index;
  };
  var serializeMinMax = function(buffer2, key, value14, index) {
    if (value14 === null) {
      buffer2[index++] = BSON_DATA_NULL;
    } else if (value14._bsontype === "MinKey") {
      buffer2[index++] = BSON_DATA_MIN_KEY;
    } else {
      buffer2[index++] = BSON_DATA_MAX_KEY;
    }
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  };
  var serializeObjectId = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_OID;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const idValue = value14.id;
    if (isUint8Array(idValue)) {
      for (let i2 = 0;i2 < 12; i2++) {
        buffer2[index++] = idValue[i2];
      }
    } else {
      throw new BSONError("object [" + JSON.stringify(value14) + "] is not a valid ObjectId");
    }
    return index;
  };
  var serializeBuffer = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = value14.length;
    buffer2[index++] = size & 255;
    buffer2[index++] = size >> 8 & 255;
    buffer2[index++] = size >> 16 & 255;
    buffer2[index++] = size >> 24 & 255;
    buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
    buffer2.set(value14, index);
    index = index + size;
    return index;
  };
  var serializeObject = function(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
    if (path.has(value14)) {
      throw new BSONError("Cannot convert circular structure to BSON");
    }
    path.add(value14);
    buffer2[index++] = Array.isArray(value14) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const endIndex = serializeInto(buffer2, value14, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.delete(value14);
    return endIndex;
  };
  var serializeDecimal128 = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_DECIMAL128;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2.set(value14.bytes.subarray(0, 16), index);
    return index + 16;
  };
  var serializeLong = function(buffer2, key, value14, index) {
    buffer2[index++] = value14._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const lowBits = value14.getLowBits();
    const highBits = value14.getHighBits();
    buffer2[index++] = lowBits & 255;
    buffer2[index++] = lowBits >> 8 & 255;
    buffer2[index++] = lowBits >> 16 & 255;
    buffer2[index++] = lowBits >> 24 & 255;
    buffer2[index++] = highBits & 255;
    buffer2[index++] = highBits >> 8 & 255;
    buffer2[index++] = highBits >> 16 & 255;
    buffer2[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeInt32 = function(buffer2, key, value14, index) {
    value14 = value14.valueOf();
    buffer2[index++] = BSON_DATA_INT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value14 & 255;
    buffer2[index++] = value14 >> 8 & 255;
    buffer2[index++] = value14 >> 16 & 255;
    buffer2[index++] = value14 >> 24 & 255;
    return index;
  };
  var serializeDouble = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_NUMBER;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    NUMBER_SPACE.setFloat64(0, value14.value, true);
    buffer2.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
    index = index + 8;
    return index;
  };
  var serializeFunction = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_CODE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const functionString = value14.toString();
    const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    buffer2[index] = size & 255;
    buffer2[index + 1] = size >> 8 & 255;
    buffer2[index + 2] = size >> 16 & 255;
    buffer2[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  };
  var serializeCode = function(buffer2, key, value14, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
    if (value14.scope && typeof value14.scope === "object") {
      buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      const functionString = value14.code;
      index = index + 4;
      const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      buffer2[index] = codeSize & 255;
      buffer2[index + 1] = codeSize >> 8 & 255;
      buffer2[index + 2] = codeSize >> 16 & 255;
      buffer2[index + 3] = codeSize >> 24 & 255;
      buffer2[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      const endIndex = serializeInto(buffer2, value14.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      index = endIndex - 1;
      const totalSize = endIndex - startIndex;
      buffer2[startIndex++] = totalSize & 255;
      buffer2[startIndex++] = totalSize >> 8 & 255;
      buffer2[startIndex++] = totalSize >> 16 & 255;
      buffer2[startIndex++] = totalSize >> 24 & 255;
      buffer2[index++] = 0;
    } else {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value14.code.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      buffer2[index] = size & 255;
      buffer2[index + 1] = size >> 8 & 255;
      buffer2[index + 2] = size >> 16 & 255;
      buffer2[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
    }
    return index;
  };
  var serializeBinary = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const data = value14.buffer;
    let size = value14.position;
    if (value14.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    buffer2[index++] = size & 255;
    buffer2[index++] = size >> 8 & 255;
    buffer2[index++] = size >> 16 & 255;
    buffer2[index++] = size >> 24 & 255;
    buffer2[index++] = value14.sub_type;
    if (value14.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      buffer2[index++] = size & 255;
      buffer2[index++] = size >> 8 & 255;
      buffer2[index++] = size >> 16 & 255;
      buffer2[index++] = size >> 24 & 255;
    }
    buffer2.set(data, index);
    index = index + value14.position;
    return index;
  };
  var serializeSymbol = function(buffer2, key, value14, index) {
    buffer2[index++] = BSON_DATA_SYMBOL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value14.value, index + 4) + 1;
    buffer2[index] = size & 255;
    buffer2[index + 1] = size >> 8 & 255;
    buffer2[index + 2] = size >> 16 & 255;
    buffer2[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  };
  var serializeDBRef = function(buffer2, key, value14, index, depth, serializeFunctions, path) {
    buffer2[index++] = BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    let startIndex = index;
    let output = {
      $ref: value14.collection || value14.namespace,
      $id: value14.oid
    };
    if (value14.db != null) {
      output.$db = value14.db;
    }
    output = Object.assign(output, value14.fields);
    const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
    const size = endIndex - startIndex;
    buffer2[startIndex++] = size & 255;
    buffer2[startIndex++] = size >> 8 & 255;
    buffer2[startIndex++] = size >> 16 & 255;
    buffer2[startIndex++] = size >> 24 & 255;
    return endIndex;
  };
  var serializeInto = function(buffer2, object12, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    if (path == null) {
      if (object12 == null) {
        buffer2[0] = 5;
        buffer2[1] = 0;
        buffer2[2] = 0;
        buffer2[3] = 0;
        buffer2[4] = 0;
        return 5;
      }
      if (Array.isArray(object12)) {
        throw new BSONError("serialize does not support an array as the root input");
      }
      if (typeof object12 !== "object") {
        throw new BSONError("serialize does not support non-object as the root input");
      } else if ("_bsontype" in object12 && typeof object12._bsontype === "string") {
        throw new BSONError(`BSON types cannot be serialized as a document`);
      } else if (isDate(object12) || isRegExp(object12) || isUint8Array(object12) || isAnyArrayBuffer(object12)) {
        throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
      }
      path = new Set;
    }
    path.add(object12);
    let index = startingIndex + 4;
    if (Array.isArray(object12)) {
      for (let i2 = 0;i2 < object12.length; i2++) {
        const key = `${i2}`;
        let value14 = object12[i2];
        if (typeof value14?.toBSON === "function") {
          value14 = value14.toBSON();
        }
        if (typeof value14 === "string") {
          index = serializeString(buffer2, key, value14, index);
        } else if (typeof value14 === "number") {
          index = serializeNumber(buffer2, key, value14, index);
        } else if (typeof value14 === "bigint") {
          index = serializeBigInt(buffer2, key, value14, index);
        } else if (typeof value14 === "boolean") {
          index = serializeBoolean(buffer2, key, value14, index);
        } else if (value14 instanceof Date || isDate(value14)) {
          index = serializeDate(buffer2, key, value14, index);
        } else if (value14 === undefined) {
          index = serializeNull(buffer2, key, value14, index);
        } else if (value14 === null) {
          index = serializeNull(buffer2, key, value14, index);
        } else if (isUint8Array(value14)) {
          index = serializeBuffer(buffer2, key, value14, index);
        } else if (value14 instanceof RegExp || isRegExp(value14)) {
          index = serializeRegExp(buffer2, key, value14, index);
        } else if (typeof value14 === "object" && value14._bsontype == null) {
          index = serializeObject(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value14 === "object" && value14[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value14._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value14, index);
        } else if (value14._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value14, index);
        } else if (value14._bsontype === "Long" || value14._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value14, index);
        } else if (value14._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value14, index);
        } else if (typeof value14 === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value14, index);
        } else if (value14._bsontype === "Code") {
          index = serializeCode(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (value14._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value14, index);
        } else if (value14._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value14, index);
        } else if (value14._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value14, index, depth, serializeFunctions, path);
        } else if (value14._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value14, index);
        } else if (value14._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value14, index);
        } else if (value14._bsontype === "MinKey" || value14._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value14, index);
        } else if (typeof value14._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value14._bsontype)}`);
        }
      }
    } else if (object12 instanceof Map || isMap(object12)) {
      const iterator4 = object12.entries();
      let done = false;
      while (!done) {
        const entry = iterator4.next();
        done = !!entry.done;
        if (done)
          continue;
        const key = entry.value[0];
        let value14 = entry.value[1];
        if (typeof value14?.toBSON === "function") {
          value14 = value14.toBSON();
        }
        const type73 = typeof value14;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp3) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (type73 === "string") {
          index = serializeString(buffer2, key, value14, index);
        } else if (type73 === "number") {
          index = serializeNumber(buffer2, key, value14, index);
        } else if (type73 === "bigint") {
          index = serializeBigInt(buffer2, key, value14, index);
        } else if (type73 === "boolean") {
          index = serializeBoolean(buffer2, key, value14, index);
        } else if (value14 instanceof Date || isDate(value14)) {
          index = serializeDate(buffer2, key, value14, index);
        } else if (value14 === null || value14 === undefined && ignoreUndefined === false) {
          index = serializeNull(buffer2, key, value14, index);
        } else if (isUint8Array(value14)) {
          index = serializeBuffer(buffer2, key, value14, index);
        } else if (value14 instanceof RegExp || isRegExp(value14)) {
          index = serializeRegExp(buffer2, key, value14, index);
        } else if (type73 === "object" && value14._bsontype == null) {
          index = serializeObject(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value14 === "object" && value14[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value14._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value14, index);
        } else if (type73 === "object" && value14._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value14, index);
        } else if (value14._bsontype === "Long" || value14._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value14, index);
        } else if (value14._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value14, index);
        } else if (value14._bsontype === "Code") {
          index = serializeCode(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value14 === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value14, index);
        } else if (value14._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value14, index);
        } else if (value14._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value14, index);
        } else if (value14._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value14, index, depth, serializeFunctions, path);
        } else if (value14._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value14, index);
        } else if (value14._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value14, index);
        } else if (value14._bsontype === "MinKey" || value14._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value14, index);
        } else if (typeof value14._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value14._bsontype)}`);
        }
      }
    } else {
      if (typeof object12?.toBSON === "function") {
        object12 = object12.toBSON();
        if (object12 != null && typeof object12 !== "object") {
          throw new BSONError("toBSON function did not return an object");
        }
      }
      for (const key of Object.keys(object12)) {
        let value14 = object12[key];
        if (typeof value14?.toBSON === "function") {
          value14 = value14.toBSON();
        }
        const type73 = typeof value14;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp3) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (type73 === "string") {
          index = serializeString(buffer2, key, value14, index);
        } else if (type73 === "number") {
          index = serializeNumber(buffer2, key, value14, index);
        } else if (type73 === "bigint") {
          index = serializeBigInt(buffer2, key, value14, index);
        } else if (type73 === "boolean") {
          index = serializeBoolean(buffer2, key, value14, index);
        } else if (value14 instanceof Date || isDate(value14)) {
          index = serializeDate(buffer2, key, value14, index);
        } else if (value14 === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value14, index);
        } else if (value14 === null) {
          index = serializeNull(buffer2, key, value14, index);
        } else if (isUint8Array(value14)) {
          index = serializeBuffer(buffer2, key, value14, index);
        } else if (value14 instanceof RegExp || isRegExp(value14)) {
          index = serializeRegExp(buffer2, key, value14, index);
        } else if (type73 === "object" && value14._bsontype == null) {
          index = serializeObject(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value14 === "object" && value14[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value14._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value14, index);
        } else if (type73 === "object" && value14._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value14, index);
        } else if (value14._bsontype === "Long" || value14._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value14, index);
        } else if (value14._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value14, index);
        } else if (value14._bsontype === "Code") {
          index = serializeCode(buffer2, key, value14, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value14 === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value14, index);
        } else if (value14._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value14, index);
        } else if (value14._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value14, index);
        } else if (value14._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value14, index, depth, serializeFunctions, path);
        } else if (value14._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value14, index);
        } else if (value14._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value14, index);
        } else if (value14._bsontype === "MinKey" || value14._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value14, index);
        } else if (typeof value14._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value14._bsontype)}`);
        }
      }
    }
    path.delete(object12);
    buffer2[index++] = 0;
    const size = index - startingIndex;
    buffer2[startingIndex++] = size & 255;
    buffer2[startingIndex++] = size >> 8 & 255;
    buffer2[startingIndex++] = size >> 16 & 255;
    buffer2[startingIndex++] = size >> 24 & 255;
    return index;
  };
  var isBSONType = function(value14) {
    return value14 != null && typeof value14 === "object" && "_bsontype" in value14 && typeof value14._bsontype === "string";
  };
  var deserializeValue = function(value14, options = {}) {
    if (typeof value14 === "number") {
      const in32BitRange = value14 <= BSON_INT32_MAX && value14 >= BSON_INT32_MIN;
      const in64BitRange = value14 <= BSON_INT64_MAX && value14 >= BSON_INT64_MIN;
      if (options.relaxed || options.legacy) {
        return value14;
      }
      if (Number.isInteger(value14) && !Object.is(value14, -0)) {
        if (in32BitRange) {
          return new Int32(value14);
        }
        if (in64BitRange) {
          if (options.useBigInt64) {
            return BigInt(value14);
          }
          return Long.fromNumber(value14);
        }
      }
      return new Double(value14);
    }
    if (value14 == null || typeof value14 !== "object")
      return value14;
    if (value14.$undefined)
      return null;
    const keys = Object.keys(value14).filter((k) => k.startsWith("$") && value14[k] != null);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const c2 = keysToCodecs[keys[i2]];
      if (c2)
        return c2.fromExtendedJSON(value14, options);
    }
    if (value14.$date != null) {
      const d2 = value14.$date;
      const date4 = new Date;
      if (options.legacy) {
        if (typeof d2 === "number")
          date4.setTime(d2);
        else if (typeof d2 === "string")
          date4.setTime(Date.parse(d2));
        else if (typeof d2 === "bigint")
          date4.setTime(Number(d2));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d2}`);
      } else {
        if (typeof d2 === "string")
          date4.setTime(Date.parse(d2));
        else if (Long.isLong(d2))
          date4.setTime(d2.toNumber());
        else if (typeof d2 === "number" && options.relaxed)
          date4.setTime(d2);
        else if (typeof d2 === "bigint")
          date4.setTime(Number(d2));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d2}`);
      }
      return date4;
    }
    if (value14.$code != null) {
      const copy = Object.assign({}, value14);
      if (value14.$scope) {
        copy.$scope = deserializeValue(value14.$scope);
      }
      return Code.fromExtendedJSON(value14);
    }
    if (isDBRefLike(value14) || value14.$dbPointer) {
      const v2 = value14.$ref ? value14 : value14.$dbPointer;
      if (v2 instanceof DBRef)
        return v2;
      const dollarKeys = Object.keys(v2).filter((k) => k.startsWith("$"));
      let valid = true;
      dollarKeys.forEach((k) => {
        if (["$ref", "$id", "$db"].indexOf(k) === -1)
          valid = false;
      });
      if (valid)
        return DBRef.fromExtendedJSON(v2);
    }
    return value14;
  };
  var serializeArray = function(array4, options) {
    return array4.map((v2, index) => {
      options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
      try {
        return serializeValue(v2, options);
      } finally {
        options.seenObjects.pop();
      }
    });
  };
  var getISOString = function(date4) {
    const isoStr = date4.toISOString();
    return date4.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
  };
  var serializeValue = function(value14, options) {
    if (value14 instanceof Map || isMap(value14)) {
      const obj = Object.create(null);
      for (const [k, v2] of value14) {
        if (typeof k !== "string") {
          throw new BSONError("Can only serialize maps with string keys");
        }
        obj[k] = v2;
      }
      return serializeValue(obj, options);
    }
    if ((typeof value14 === "object" || typeof value14 === "function") && value14 !== null) {
      const index = options.seenObjects.findIndex((entry) => entry.obj === value14);
      if (index !== -1) {
        const props = options.seenObjects.map((entry) => entry.propertyName);
        const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
        const alreadySeen = props[index];
        const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
        const current = props[props.length - 1];
        const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
        const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
        throw new BSONError("Converting circular structure to EJSON:\n" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` + `    ${leadingSpace}\\${dashes}/`);
      }
      options.seenObjects[options.seenObjects.length - 1].obj = value14;
    }
    if (Array.isArray(value14))
      return serializeArray(value14, options);
    if (value14 === undefined)
      return null;
    if (value14 instanceof Date || isDate(value14)) {
      const dateNum = value14.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;
      if (options.legacy) {
        return options.relaxed && inRange ? { $date: value14.getTime() } : { $date: getISOString(value14) };
      }
      return options.relaxed && inRange ? { $date: getISOString(value14) } : { $date: { $numberLong: value14.getTime().toString() } };
    }
    if (typeof value14 === "number" && (!options.relaxed || !isFinite(value14))) {
      if (Number.isInteger(value14) && !Object.is(value14, -0)) {
        if (value14 >= BSON_INT32_MIN && value14 <= BSON_INT32_MAX) {
          return { $numberInt: value14.toString() };
        }
        if (value14 >= BSON_INT64_MIN && value14 <= BSON_INT64_MAX) {
          return { $numberLong: value14.toString() };
        }
      }
      return { $numberDouble: Object.is(value14, -0) ? "-0.0" : value14.toString() };
    }
    if (typeof value14 === "bigint") {
      if (!options.relaxed) {
        return { $numberLong: BigInt.asIntN(64, value14).toString() };
      }
      return Number(BigInt.asIntN(64, value14));
    }
    if (value14 instanceof RegExp || isRegExp(value14)) {
      let flags = value14.flags;
      if (flags === undefined) {
        const match = value14.toString().match(/[gimuy]*$/);
        if (match) {
          flags = match[0];
        }
      }
      const rx = new BSONRegExp(value14.source, flags);
      return rx.toExtendedJSON(options);
    }
    if (value14 != null && typeof value14 === "object")
      return serializeDocument(value14, options);
    return value14;
  };
  var serializeDocument = function(doc, options) {
    if (doc == null || typeof doc !== "object")
      throw new BSONError("not an object instance");
    const bsontype = doc._bsontype;
    if (typeof bsontype === "undefined") {
      const _doc = {};
      for (const name of Object.keys(doc)) {
        options.seenObjects.push({ propertyName: name, obj: null });
        try {
          const value14 = serializeValue(doc[name], options);
          if (name === "__proto__") {
            Object.defineProperty(_doc, name, {
              value: value14,
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            _doc[name] = value14;
          }
        } finally {
          options.seenObjects.pop();
        }
      }
      return _doc;
    } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
      throw new BSONVersionError;
    } else if (isBSONType(doc)) {
      let outDoc = doc;
      if (typeof outDoc.toExtendedJSON !== "function") {
        const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
        if (!mapper) {
          throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
        }
        outDoc = mapper(outDoc);
      }
      if (bsontype === "Code" && outDoc.scope) {
        outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
      } else if (bsontype === "DBRef" && outDoc.oid) {
        outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
      }
      return outDoc.toExtendedJSON(options);
    } else {
      throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
    }
  };
  var parse4 = function(text, options) {
    const ejsonOptions = {
      useBigInt64: options?.useBigInt64 ?? false,
      relaxed: options?.relaxed ?? true,
      legacy: options?.legacy ?? false
    };
    return JSON.parse(text, (key, value14) => {
      if (key.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
      }
      return deserializeValue(value14, ejsonOptions);
    });
  };
  var stringify = function(value14, replacer, space, options) {
    if (space != null && typeof space === "object") {
      options = space;
      space = 0;
    }
    if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
      options = replacer;
      replacer = undefined;
      space = 0;
    }
    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
      seenObjects: [{ propertyName: "(root)", obj: null }]
    });
    const doc = serializeValue(value14, serializeOptions);
    return JSON.stringify(doc, replacer, space);
  };
  var EJSONserialize = function(value14, options) {
    options = options || {};
    return JSON.parse(stringify(value14, options));
  };
  var EJSONdeserialize = function(ejson, options) {
    options = options || {};
    return parse4(JSON.stringify(ejson), options);
  };
  var setInternalBufferSize = function(size) {
    if (buffer.length < size) {
      buffer = ByteUtils.allocate(size);
    }
  };
  var serialize = function(object12, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = ByteUtils.allocate(minInternalBufferSize);
    }
    const serializationIndex = serializeInto(buffer, object12, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    const finishedBuffer = ByteUtils.allocate(serializationIndex);
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    return finishedBuffer;
  };
  var serializeWithBufferAndIndex = function(object12, finalBuffer, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const startIndex = typeof options.index === "number" ? options.index : 0;
    const serializationIndex = serializeInto(buffer, object12, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    return startIndex + serializationIndex - 1;
  };
  var deserialize = function(buffer2, options = {}) {
    return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
  };
  var calculateObjectSize = function(object12, options = {}) {
    options = options || {};
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return internalCalculateObjectSize(object12, serializeFunctions, ignoreUndefined);
  };
  var deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    const bufferData = ByteUtils.toLocalBufferType(data);
    let index = startIndex;
    for (let i2 = 0;i2 < numberOfDocuments; i2++) {
      const size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;
      internalOptions.index = index;
      documents[docStartIndex + i2] = internalDeserialize(bufferData, internalOptions);
      index = index + size;
    }
    return index;
  };
  var BSON_MAJOR_VERSION = 6;
  var BSON_INT32_MAX = 2147483647;
  var BSON_INT32_MIN = -2147483648;
  var BSON_INT64_MAX = Math.pow(2, 63) - 1;
  var BSON_INT64_MIN = -Math.pow(2, 63);
  var JS_INT_MAX = Math.pow(2, 53);
  var JS_INT_MIN = -Math.pow(2, 53);
  var BSON_DATA_NUMBER = 1;
  var BSON_DATA_STRING = 2;
  var BSON_DATA_OBJECT = 3;
  var BSON_DATA_ARRAY = 4;
  var BSON_DATA_BINARY = 5;
  var BSON_DATA_UNDEFINED = 6;
  var BSON_DATA_OID = 7;
  var BSON_DATA_BOOLEAN = 8;
  var BSON_DATA_DATE = 9;
  var BSON_DATA_NULL = 10;
  var BSON_DATA_REGEXP = 11;
  var BSON_DATA_DBPOINTER = 12;
  var BSON_DATA_CODE = 13;
  var BSON_DATA_SYMBOL = 14;
  var BSON_DATA_CODE_W_SCOPE = 15;
  var BSON_DATA_INT = 16;
  var BSON_DATA_TIMESTAMP = 17;
  var BSON_DATA_LONG = 18;
  var BSON_DATA_DECIMAL128 = 19;
  var BSON_DATA_MIN_KEY = 255;
  var BSON_DATA_MAX_KEY = 127;
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
  var BSONType = Object.freeze({
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: -1,
    maxKey: 127
  });

  class BSONError extends Error {
    get bsonError() {
      return true;
    }
    get name() {
      return "BSONError";
    }
    constructor(message, options) {
      super(message, options);
    }
    static isBSONError(value14) {
      return value14 != null && typeof value14 === "object" && "bsonError" in value14 && value14.bsonError === true && "name" in value14 && "message" in value14 && "stack" in value14;
    }
  }

  class BSONVersionError extends BSONError {
    get name() {
      return "BSONVersionError";
    }
    constructor() {
      super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
    }
  }

  class BSONRuntimeError extends BSONError {
    get name() {
      return "BSONRuntimeError";
    }
    constructor(message) {
      super(message);
    }
  }
  var FIRST_BIT = 128;
  var FIRST_TWO_BITS = 192;
  var FIRST_THREE_BITS = 224;
  var FIRST_FOUR_BITS = 240;
  var FIRST_FIVE_BITS = 248;
  var TWO_BIT_CHAR = 192;
  var THREE_BIT_CHAR = 224;
  var FOUR_BIT_CHAR = 240;
  var CONTINUING_CHAR = 128;
  var nodejsRandomBytes = (() => {
    try {
      return import.meta.require("crypto").randomBytes;
    } catch {
      return nodejsMathRandomBytes;
    }
  })();
  var nodeJsByteUtils = {
    toLocalBufferType(potentialBuffer) {
      if (Buffer.isBuffer(potentialBuffer)) {
        return potentialBuffer;
      }
      if (ArrayBuffer.isView(potentialBuffer)) {
        return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
      }
      const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return Buffer.from(potentialBuffer);
      }
      throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);
    },
    allocate(size) {
      return Buffer.alloc(size);
    },
    equals(a2, b2) {
      return nodeJsByteUtils.toLocalBufferType(a2).equals(b2);
    },
    fromNumberArray(array4) {
      return Buffer.from(array4);
    },
    fromBase64(base64) {
      return Buffer.from(base64, "base64");
    },
    toBase64(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
    },
    fromISO88591(codePoints) {
      return Buffer.from(codePoints, "binary");
    },
    toISO88591(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
    },
    fromHex(hex) {
      return Buffer.from(hex, "hex");
    },
    toHex(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
    },
    fromUTF8(text) {
      return Buffer.from(text, "utf8");
    },
    toUTF8(buffer2, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryLatin(buffer2, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      const string6 = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
      if (fatal) {
        for (let i2 = 0;i2 < string6.length; i2++) {
          if (string6.charCodeAt(i2) === 65533) {
            if (!validateUtf8(buffer2, start, end)) {
              throw new BSONError("Invalid UTF-8 string in BSON document");
            }
            break;
          }
        }
      }
      return string6;
    },
    utf8ByteLength(input) {
      return Buffer.byteLength(input, "utf8");
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, undefined, "utf8");
    },
    randomBytes: nodejsRandomBytes
  };
  var webRandomBytes = (() => {
    const { crypto: crypto2 } = globalThis;
    if (crypto2 != null && typeof crypto2.getRandomValues === "function") {
      return (byteLength) => {
        return crypto2.getRandomValues(webByteUtils.allocate(byteLength));
      };
    } else {
      if (isReactNative()) {
        const { console: console2 } = globalThis;
        console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
      }
      return webMathRandomBytes;
    }
  })();
  var HEX_DIGIT = /(\d|[a-f])/i;
  var webByteUtils = {
    toLocalBufferType(potentialUint8array) {
      const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
      if (stringTag === "Uint8Array") {
        return potentialUint8array;
      }
      if (ArrayBuffer.isView(potentialUint8array)) {
        return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
      }
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return new Uint8Array(potentialUint8array);
      }
      throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);
    },
    allocate(size) {
      if (typeof size !== "number") {
        throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
      }
      return new Uint8Array(size);
    },
    equals(a2, b2) {
      if (a2.byteLength !== b2.byteLength) {
        return false;
      }
      for (let i2 = 0;i2 < a2.byteLength; i2++) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    },
    fromNumberArray(array4) {
      return Uint8Array.from(array4);
    },
    fromBase64(base64) {
      return Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0));
    },
    toBase64(uint8array4) {
      return btoa(webByteUtils.toISO88591(uint8array4));
    },
    fromISO88591(codePoints) {
      return Uint8Array.from(codePoints, (c2) => c2.charCodeAt(0) & 255);
    },
    toISO88591(uint8array4) {
      return Array.from(Uint16Array.from(uint8array4), (b2) => String.fromCharCode(b2)).join("");
    },
    fromHex(hex) {
      const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
      const buffer2 = [];
      for (let i2 = 0;i2 < evenLengthHex.length; i2 += 2) {
        const firstDigit = evenLengthHex[i2];
        const secondDigit = evenLengthHex[i2 + 1];
        if (!HEX_DIGIT.test(firstDigit)) {
          break;
        }
        if (!HEX_DIGIT.test(secondDigit)) {
          break;
        }
        const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
        buffer2.push(hexDigit);
      }
      return Uint8Array.from(buffer2);
    },
    toHex(uint8array4) {
      return Array.from(uint8array4, (byte) => byte.toString(16).padStart(2, "0")).join("");
    },
    fromUTF8(text) {
      return new TextEncoder().encode(text);
    },
    toUTF8(uint8array4, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryLatin(uint8array4, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      if (fatal) {
        try {
          return new TextDecoder("utf8", { fatal }).decode(uint8array4.slice(start, end));
        } catch (cause) {
          throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
        }
      }
      return new TextDecoder("utf8", { fatal }).decode(uint8array4.slice(start, end));
    },
    utf8ByteLength(input) {
      return webByteUtils.fromUTF8(input).byteLength;
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      const bytes = webByteUtils.fromUTF8(source);
      buffer2.set(bytes, byteOffset);
      return bytes.byteLength;
    },
    randomBytes: webRandomBytes
  };
  var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
  var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;

  class BSONDataView extends DataView {
    static fromUint8Array(input) {
      return new DataView(input.buffer, input.byteOffset, input.byteLength);
    }
  }

  class BSONValue {
    get [Symbol.for("@@mdb.bson.version")]() {
      return BSON_MAJOR_VERSION;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
      return this.inspect(depth, options, inspect);
    }
  }

  class Binary extends BSONValue {
    get _bsontype() {
      return "Binary";
    }
    constructor(buffer2, subType) {
      super();
      if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
        throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
      }
      this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer2 == null) {
        this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
        this.position = 0;
      } else {
        this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
        this.position = this.buffer.byteLength;
      }
    }
    put(byteValue) {
      if (typeof byteValue === "string" && byteValue.length !== 1) {
        throw new BSONError("only accepts single character String");
      } else if (typeof byteValue !== "number" && byteValue.length !== 1)
        throw new BSONError("only accepts single character Uint8Array or Array");
      let decodedByte;
      if (typeof byteValue === "string") {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === "number") {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
    write(sequence, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === "string") {
        throw new BSONError("input cannot be string");
      }
    }
    read(position, length) {
      length = length && length > 0 ? length : this.position;
      return this.buffer.slice(position, position + length);
    }
    value() {
      return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
    }
    length() {
      return this.position;
    }
    toJSON() {
      return ByteUtils.toBase64(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.buffer);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.buffer);
      if (encoding === "utf8" || encoding === "utf-8")
        return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength, false);
      return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength, false);
    }
    toExtendedJSON(options) {
      options = options || {};
      const base64String = ByteUtils.toBase64(this.buffer);
      const subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? "0" + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? "0" + subType : subType
        }
      };
    }
    toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.slice(0, this.position));
      }
      throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`);
    }
    static createFromHexString(hex, subType) {
      return new Binary(ByteUtils.fromHex(hex), subType);
    }
    static createFromBase64(base64, subType) {
      return new Binary(ByteUtils.fromBase64(base64), subType);
    }
    static fromExtendedJSON(doc, options) {
      options = options || {};
      let data;
      let type73;
      if ("$binary" in doc) {
        if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
          type73 = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== "string") {
            type73 = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ("$uuid" in doc) {
        type73 = 4;
        data = UUID.bytesFromString(doc.$uuid);
      }
      if (!data) {
        throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
      }
      return type73 === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type73);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      const base64Arg = inspect(base64, options);
      const subTypeArg = inspect(this.sub_type, options);
      return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
    }
  }
  Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  Binary.BUFFER_SIZE = 256;
  Binary.SUBTYPE_DEFAULT = 0;
  Binary.SUBTYPE_FUNCTION = 1;
  Binary.SUBTYPE_BYTE_ARRAY = 2;
  Binary.SUBTYPE_UUID_OLD = 3;
  Binary.SUBTYPE_UUID = 4;
  Binary.SUBTYPE_MD5 = 5;
  Binary.SUBTYPE_ENCRYPTED = 6;
  Binary.SUBTYPE_COLUMN = 7;
  Binary.SUBTYPE_USER_DEFINED = 128;
  var UUID_BYTE_LENGTH = 16;
  var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
  var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

  class UUID extends Binary {
    constructor(input) {
      let bytes;
      if (input == null) {
        bytes = UUID.generate();
      } else if (input instanceof UUID) {
        bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
        bytes = ByteUtils.toLocalBufferType(input);
      } else if (typeof input === "string") {
        bytes = UUID.bytesFromString(input);
      } else {
        throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      }
      super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
    }
    get id() {
      return this.buffer;
    }
    set id(value14) {
      this.buffer = value14;
    }
    toHexString(includeDashes = true) {
      if (includeDashes) {
        return [
          ByteUtils.toHex(this.buffer.subarray(0, 4)),
          ByteUtils.toHex(this.buffer.subarray(4, 6)),
          ByteUtils.toHex(this.buffer.subarray(6, 8)),
          ByteUtils.toHex(this.buffer.subarray(8, 10)),
          ByteUtils.toHex(this.buffer.subarray(10, 16))
        ].join("-");
      }
      return ByteUtils.toHex(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.id);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch {
        return false;
      }
    }
    toBinary() {
      return new Binary(this.id, Binary.SUBTYPE_UUID);
    }
    static generate() {
      const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      return bytes;
    }
    static isValid(input) {
      if (!input) {
        return false;
      }
      if (typeof input === "string") {
        return UUID.isValidUUIDString(input);
      }
      if (isUint8Array(input)) {
        return input.byteLength === UUID_BYTE_LENGTH;
      }
      return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
    }
    static createFromHexString(hexString) {
      const buffer2 = UUID.bytesFromString(hexString);
      return new UUID(buffer2);
    }
    static createFromBase64(base64) {
      return new UUID(ByteUtils.fromBase64(base64));
    }
    static bytesFromString(representation) {
      if (!UUID.isValidUUIDString(representation)) {
        throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
      }
      return ByteUtils.fromHex(representation.replace(/-/g, ""));
    }
    static isValidUUIDString(representation) {
      return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new UUID(${inspect(this.toHexString(), options)})`;
    }
  }

  class Code extends BSONValue {
    get _bsontype() {
      return "Code";
    }
    constructor(code, scope) {
      super();
      this.code = code.toString();
      this.scope = scope ?? null;
    }
    toJSON() {
      if (this.scope != null) {
        return { code: this.code, scope: this.scope };
      }
      return { code: this.code };
    }
    toExtendedJSON() {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    }
    static fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      let parametersString = inspect(this.code, options);
      const multiLineFn = parametersString.includes("\n");
      if (this.scope != null) {
        parametersString += `,${multiLineFn ? "\n" : " "}${inspect(this.scope, options)}`;
      }
      const endingNewline = multiLineFn && this.scope === null;
      return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
    }
  }

  class DBRef extends BSONValue {
    get _bsontype() {
      return "DBRef";
    }
    constructor(collection, oid, db, fields) {
      super();
      const parts = collection.split(".");
      if (parts.length === 2) {
        db = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db;
      this.fields = fields || {};
    }
    get namespace() {
      return this.collection;
    }
    set namespace(value14) {
      this.collection = value14;
    }
    toJSON() {
      const o2 = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null)
        o2.$db = this.db;
      return o2;
    }
    toExtendedJSON(options) {
      options = options || {};
      let o2 = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o2;
      }
      if (this.db)
        o2.$db = this.db;
      o2 = Object.assign(o2, this.fields);
      return o2;
    }
    static fromExtendedJSON(doc) {
      const copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const args = [
        inspect(this.namespace, options),
        inspect(this.oid, options),
        ...this.db ? [inspect(this.db, options)] : [],
        ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
      ];
      args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
      return `new DBRef(${args.join(", ")})`;
    }
  }
  var wasm = undefined;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch {
  }
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  var MAX_INT64_STRING_LENGTH = 20;
  var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;

  class Long extends BSONValue {
    get _bsontype() {
      return "Long";
    }
    get __isLong__() {
      return true;
    }
    constructor(low = 0, high, unsigned) {
      super();
      if (typeof low === "bigint") {
        Object.assign(this, Long.fromBigInt(low, !!high));
      } else if (typeof low === "string") {
        Object.assign(this, Long.fromString(low, !!high));
      } else {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
    }
    static fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    static fromInt(value14, unsigned) {
      let obj, cachedObj, cache;
      if (unsigned) {
        value14 >>>= 0;
        if (cache = 0 <= value14 && value14 < 256) {
          cachedObj = UINT_CACHE[value14];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value14, (value14 | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value14] = obj;
        return obj;
      } else {
        value14 |= 0;
        if (cache = -128 <= value14 && value14 < 128) {
          cachedObj = INT_CACHE[value14];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value14, value14 < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value14] = obj;
        return obj;
      }
    }
    static fromNumber(value14, unsigned) {
      if (isNaN(value14))
        return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value14 < 0)
          return Long.UZERO;
        if (value14 >= TWO_PWR_64_DBL)
          return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value14 <= -TWO_PWR_63_DBL)
          return Long.MIN_VALUE;
        if (value14 + 1 >= TWO_PWR_63_DBL)
          return Long.MAX_VALUE;
      }
      if (value14 < 0)
        return Long.fromNumber(-value14, unsigned).neg();
      return Long.fromBits(value14 % TWO_PWR_32_DBL | 0, value14 / TWO_PWR_32_DBL | 0, unsigned);
    }
    static fromBigInt(value14, unsigned) {
      return Long.fromString(value14.toString(), unsigned);
    }
    static fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw new BSONError("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return Long.ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      let p2;
      if ((p2 = str.indexOf("-")) > 0)
        throw new BSONError("interior hyphen");
      else if (p2 === 0) {
        return Long.fromString(str.substring(1), unsigned, radix).neg();
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 8));
      let result = Long.ZERO;
      for (let i2 = 0;i2 < str.length; i2 += 8) {
        const size = Math.min(8, str.length - i2), value14 = parseInt(str.substring(i2, i2 + size), radix);
        if (size < 8) {
          const power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value14));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value14));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    static fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
    static fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
    static fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
    static isLong(value14) {
      return value14 != null && typeof value14 === "object" && "__isLong__" in value14 && value14.__isLong__ === true;
    }
    static fromValue(val, unsigned) {
      if (typeof val === "number")
        return Long.fromNumber(val, unsigned);
      if (typeof val === "string")
        return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    add(addend) {
      if (!Long.isLong(addend))
        addend = Long.fromValue(addend);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = addend.high >>> 16;
      const b32 = addend.high & 65535;
      const b16 = addend.low >>> 16;
      const b00 = addend.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    and(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
    compare(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.eq(other))
        return 0;
      const thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    comp(other) {
      return this.compare(other);
    }
    divide(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (divisor.isZero())
        throw new BSONError("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Long.UZERO : Long.ZERO;
      let approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
            return Long.MIN_VALUE;
          else if (divisor.eq(Long.MIN_VALUE))
            return Long.ONE;
          else {
            const halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE))
          return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return Long.UZERO;
        if (divisor.gt(this.shru(1)))
          return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        const log2 = Math.ceil(Math.log(approx) / Math.LN2);
        const delta3 = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        let approxRes = Long.fromNumber(approx);
        let approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta3;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
    div(divisor) {
      return this.divide(divisor);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    eq(other) {
      return this.equals(other);
    }
    getHighBits() {
      return this.high;
    }
    getHighBitsUnsigned() {
      return this.high >>> 0;
    }
    getLowBits() {
      return this.low;
    }
    getLowBitsUnsigned() {
      return this.low >>> 0;
    }
    getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      const val = this.high !== 0 ? this.high : this.low;
      let bit;
      for (bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) !== 0)
          break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    greaterThan(other) {
      return this.comp(other) > 0;
    }
    gt(other) {
      return this.greaterThan(other);
    }
    greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
    gte(other) {
      return this.greaterThanOrEqual(other);
    }
    ge(other) {
      return this.greaterThanOrEqual(other);
    }
    isEven() {
      return (this.low & 1) === 0;
    }
    isNegative() {
      return !this.unsigned && this.high < 0;
    }
    isOdd() {
      return (this.low & 1) === 1;
    }
    isPositive() {
      return this.unsigned || this.high >= 0;
    }
    isZero() {
      return this.high === 0 && this.low === 0;
    }
    lessThan(other) {
      return this.comp(other) < 0;
    }
    lt(other) {
      return this.lessThan(other);
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    lte(other) {
      return this.lessThanOrEqual(other);
    }
    modulo(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (wasm) {
        const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
    mod(divisor) {
      return this.modulo(divisor);
    }
    rem(divisor) {
      return this.modulo(divisor);
    }
    multiply(multiplier) {
      if (this.isZero())
        return Long.ZERO;
      if (!Long.isLong(multiplier))
        multiplier = Long.fromValue(multiplier);
      if (wasm) {
        const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return Long.ZERO;
      if (this.eq(Long.MIN_VALUE))
        return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE))
        return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))
        return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = multiplier.high >>> 16;
      const b32 = multiplier.high & 65535;
      const b16 = multiplier.low >>> 16;
      const b00 = multiplier.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    mul(multiplier) {
      return this.multiply(multiplier);
    }
    negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE))
        return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
    neg() {
      return this.negate();
    }
    not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
    notEquals(other) {
      return !this.equals(other);
    }
    neq(other) {
      return this.notEquals(other);
    }
    ne(other) {
      return this.notEquals(other);
    }
    or(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
    shiftLeft(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
    shl(numBits) {
      return this.shiftLeft(numBits);
    }
    shiftRight(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
    shr(numBits) {
      return this.shiftRight(numBits);
    }
    shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        const high = this.high;
        if (numBits < 32) {
          const low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return Long.fromBits(high, 0, this.unsigned);
        else
          return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
    shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    subtract(subtrahend) {
      if (!Long.isLong(subtrahend))
        subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
    sub(subtrahend) {
      return this.subtract(subtrahend);
    }
    toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
    toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    toBigInt() {
      return BigInt(this.toString());
    }
    toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
    toBytesLE() {
      const hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    toBytesBE() {
      const hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    }
    toSigned() {
      if (!this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, false);
    }
    toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      let rem = this;
      let result = "";
      while (true) {
        const remDiv = rem.div(radixToPower);
        const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        let digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    }
    toUnsigned() {
      if (this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, true);
    }
    xor(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
    eqz() {
      return this.isZero();
    }
    le(other) {
      return this.lessThanOrEqual(other);
    }
    toExtendedJSON(options) {
      if (options && options.relaxed)
        return this.toNumber();
      return { $numberLong: this.toString() };
    }
    static fromExtendedJSON(doc, options) {
      const { useBigInt64 = false, relaxed = true } = { ...options };
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError("$numberLong string is too long");
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError(`\$numberLong string "${doc.$numberLong}" is in an invalid format`);
      }
      if (useBigInt64) {
        const bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      const longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const longVal = inspect(this.toString(), options);
      const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
      return `new Long(${longVal}${unsignedVal})`;
    }
  }
  Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
  Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.ZERO = Long.fromInt(0);
  Long.UZERO = Long.fromInt(0, true);
  Long.ONE = Long.fromInt(1);
  Long.UONE = Long.fromInt(1, true);
  Long.NEG_ONE = Long.fromInt(-1);
  Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = ByteUtils.fromNumberArray([
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;

  class Decimal128 extends BSONValue {
    get _bsontype() {
      return "Decimal128";
    }
    constructor(bytes) {
      super();
      if (typeof bytes === "string") {
        this.bytes = Decimal128.fromString(bytes).bytes;
      } else if (isUint8Array(bytes)) {
        if (bytes.byteLength !== 16) {
          throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
        }
        this.bytes = bytes;
      } else {
        throw new BSONError("Decimal128 must take a Buffer or string");
      }
    }
    static fromString(representation) {
      return Decimal128._fromString(representation, { allowRounding: false });
    }
    static fromStringWithRounding(representation) {
      return Decimal128._fromString(representation, { allowRounding: true });
    }
    static _fromString(representation, options) {
      let isNegative = false;
      let sawSign = false;
      let sawRadix = false;
      let foundNonZero = false;
      let significantDigits = 0;
      let nDigitsRead = 0;
      let nDigits = 0;
      let radixPosition = 0;
      let firstNonZero = 0;
      const digits = [0];
      let nDigitsStored = 0;
      let digitsInsert = 0;
      let lastDigit = 0;
      let exponent = 0;
      let significandHigh = new Long(0, 0);
      let significandLow = new Long(0, 0);
      let biasedExponent = 0;
      let index = 0;
      if (representation.length >= 7000) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      const stringMatch = representation.match(PARSE_STRING_REGEXP);
      const infMatch = representation.match(PARSE_INF_REGEXP);
      const nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      if (stringMatch) {
        const unsignedNumber = stringMatch[2];
        const e2 = stringMatch[4];
        const expSign = stringMatch[5];
        const expNumber = stringMatch[6];
        if (e2 && expNumber === undefined)
          invalidErr(representation, "missing exponent power");
        if (e2 && unsignedNumber === undefined)
          invalidErr(representation, "missing exponent base");
        if (e2 === undefined && (expSign || expNumber)) {
          invalidErr(representation, "missing e before exponent");
        }
      }
      if (representation[index] === "+" || representation[index] === "-") {
        sawSign = true;
        isNegative = representation[index++] === "-";
      }
      if (!isDigit(representation[index]) && representation[index] !== ".") {
        if (representation[index] === "i" || representation[index] === "I") {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === "N") {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === ".") {
        if (representation[index] === ".") {
          if (sawRadix)
            invalidErr(representation, "contains multiple periods");
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < MAX_DIGITS) {
          if (representation[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero)
          nDigits = nDigits + 1;
        if (sawRadix)
          radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      if (representation[index] === "e" || representation[index] === "E") {
        const match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index])
        return new Decimal128(NAN_BUFFER);
      if (!nDigitsStored) {
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit >= MAX_DIGITS) {
          if (significantDigits === 0) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
        exponent = exponent - 1;
      }
      if (options.allowRounding) {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0 && significantDigits < nDigitsStored) {
            exponent = EXPONENT_MIN;
            significantDigits = 0;
            break;
          }
          if (nDigitsStored < nDigits) {
            nDigits = nDigits - 1;
          } else {
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            const digitsString = digits.join("");
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          let endOfString = nDigitsRead;
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          let roundBit = 0;
          if (roundDigit >= 5) {
            roundBit = 1;
            if (roundDigit === 5) {
              roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
              for (let i2 = firstNonZero + lastDigit + 2;i2 < endOfString; i2++) {
                if (parseInt(representation[i2], 10)) {
                  roundBit = 1;
                  break;
                }
              }
            }
          }
          if (roundBit) {
            let dIdx = lastDigit;
            for (;dIdx >= 0; dIdx--) {
              if (++digits[dIdx] > 9) {
                digits[dIdx] = 0;
                if (dIdx === 0) {
                  if (exponent < EXPONENT_MAX) {
                    exponent = exponent + 1;
                    digits[dIdx] = 1;
                  } else {
                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                  }
                }
              } else {
                break;
              }
            }
          }
        }
      } else {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MIN;
              break;
            }
            invalidErr(representation, "exponent underflow");
          }
          if (nDigitsStored < nDigits) {
            if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            nDigits = nDigits - 1;
          } else {
            if (digits[lastDigit] !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          if (roundDigit !== 0) {
            invalidErr(representation, "inexact rounding");
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit < 17) {
        let dIdx = 0;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        let dIdx = 0;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString("9223372036854775808"));
      }
      const buffer2 = ByteUtils.allocate(16);
      index = 0;
      buffer2[index++] = dec.low.low & 255;
      buffer2[index++] = dec.low.low >> 8 & 255;
      buffer2[index++] = dec.low.low >> 16 & 255;
      buffer2[index++] = dec.low.low >> 24 & 255;
      buffer2[index++] = dec.low.high & 255;
      buffer2[index++] = dec.low.high >> 8 & 255;
      buffer2[index++] = dec.low.high >> 16 & 255;
      buffer2[index++] = dec.low.high >> 24 & 255;
      buffer2[index++] = dec.high.low & 255;
      buffer2[index++] = dec.high.low >> 8 & 255;
      buffer2[index++] = dec.high.low >> 16 & 255;
      buffer2[index++] = dec.high.low >> 24 & 255;
      buffer2[index++] = dec.high.high & 255;
      buffer2[index++] = dec.high.high >> 8 & 255;
      buffer2[index++] = dec.high.high >> 16 & 255;
      buffer2[index++] = dec.high.high >> 24 & 255;
      return new Decimal128(buffer2);
    }
    toString() {
      let biased_exponent;
      let significand_digits = 0;
      const significand = new Array(36);
      for (let i2 = 0;i2 < significand.length; i2++)
        significand[i2] = 0;
      let index = 0;
      let is_zero = false;
      let significand_msb;
      let significand128 = { parts: [0, 0, 0, 0] };
      let j, k;
      const string6 = [];
      index = 0;
      const buffer2 = this.bytes;
      const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      index = 0;
      const dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string6.push("-");
      }
      const combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string6.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      const exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3;k >= 0; k--) {
          let least_digits = 0;
          const result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits)
            continue;
          for (j = 8;j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      const scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string6.push(`${0}`);
          if (exponent > 0)
            string6.push(`E+${exponent}`);
          else if (exponent < 0)
            string6.push(`E${exponent}`);
          return string6.join("");
        }
        string6.push(`${significand[index++]}`);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string6.push(".");
        }
        for (let i2 = 0;i2 < significand_digits; i2++) {
          string6.push(`${significand[index++]}`);
        }
        string6.push("E");
        if (scientific_exponent > 0) {
          string6.push(`+${scientific_exponent}`);
        } else {
          string6.push(`${scientific_exponent}`);
        }
      } else {
        if (exponent >= 0) {
          for (let i2 = 0;i2 < significand_digits; i2++) {
            string6.push(`${significand[index++]}`);
          }
        } else {
          let radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (let i2 = 0;i2 < radix_position; i2++) {
              string6.push(`${significand[index++]}`);
            }
          } else {
            string6.push("0");
          }
          string6.push(".");
          while (radix_position++ < 0) {
            string6.push("0");
          }
          for (let i2 = 0;i2 < significand_digits - Math.max(radix_position - 1, 0); i2++) {
            string6.push(`${significand[index++]}`);
          }
        }
      }
      return string6.join("");
    }
    toJSON() {
      return { $numberDecimal: this.toString() };
    }
    toExtendedJSON() {
      return { $numberDecimal: this.toString() };
    }
    static fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const d128string = inspect(this.toString(), options);
      return `new Decimal128(${d128string})`;
    }
  }

  class Double extends BSONValue {
    get _bsontype() {
      return "Double";
    }
    constructor(value14) {
      super();
      if (value14 instanceof Number) {
        value14 = value14.valueOf();
      }
      this.value = +value14;
    }
    valueOf() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: "-0.0" };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
    static fromExtendedJSON(doc, options) {
      const doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Double(${inspect(this.value, options)})`;
    }
  }

  class Int32 extends BSONValue {
    get _bsontype() {
      return "Int32";
    }
    constructor(value14) {
      super();
      if (value14 instanceof Number) {
        value14 = value14.valueOf();
      }
      this.value = +value14 | 0;
    }
    valueOf() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy))
        return this.value;
      return { $numberInt: this.value.toString() };
    }
    static fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Int32(${inspect(this.value, options)})`;
    }
  }

  class MaxKey extends BSONValue {
    get _bsontype() {
      return "MaxKey";
    }
    toExtendedJSON() {
      return { $maxKey: 1 };
    }
    static fromExtendedJSON() {
      return new MaxKey;
    }
    inspect() {
      return "new MaxKey()";
    }
  }

  class MinKey extends BSONValue {
    get _bsontype() {
      return "MinKey";
    }
    toExtendedJSON() {
      return { $minKey: 1 };
    }
    static fromExtendedJSON() {
      return new MinKey;
    }
    inspect() {
      return "new MinKey()";
    }
  }
  var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
  var PROCESS_UNIQUE = null;
  var kId = Symbol("id");

  class ObjectId extends BSONValue {
    get _bsontype() {
      return "ObjectId";
    }
    constructor(inputId) {
      super();
      let workingId;
      if (typeof inputId === "object" && inputId && "id" in inputId) {
        if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
          throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
        }
        if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
          workingId = ByteUtils.fromHex(inputId.toHexString());
        } else {
          workingId = inputId.id;
        }
      } else {
        workingId = inputId;
      }
      if (workingId == null || typeof workingId === "number") {
        this[kId] = ObjectId.generate(typeof workingId === "number" ? workingId : undefined);
      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
        this[kId] = ByteUtils.toLocalBufferType(workingId);
      } else if (typeof workingId === "string") {
        if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
          this[kId] = ByteUtils.fromHex(workingId);
        } else {
          throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
        }
      } else {
        throw new BSONError("Argument passed in does not match the accepted types");
      }
      if (ObjectId.cacheHexString) {
        this.__id = ByteUtils.toHex(this.id);
      }
    }
    get id() {
      return this[kId];
    }
    set id(value14) {
      this[kId] = value14;
      if (ObjectId.cacheHexString) {
        this.__id = ByteUtils.toHex(value14);
      }
    }
    toHexString() {
      if (ObjectId.cacheHexString && this.__id) {
        return this.__id;
      }
      const hexString = ByteUtils.toHex(this.id);
      if (ObjectId.cacheHexString && !this.__id) {
        this.__id = hexString;
      }
      return hexString;
    }
    static getInc() {
      return ObjectId.index = (ObjectId.index + 1) % 16777215;
    }
    static generate(time) {
      if (typeof time !== "number") {
        time = Math.floor(Date.now() / 1000);
      }
      const inc = ObjectId.getInc();
      const buffer2 = ByteUtils.allocate(12);
      BSONDataView.fromUint8Array(buffer2).setUint32(0, time, false);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer2[4] = PROCESS_UNIQUE[0];
      buffer2[5] = PROCESS_UNIQUE[1];
      buffer2[6] = PROCESS_UNIQUE[2];
      buffer2[7] = PROCESS_UNIQUE[3];
      buffer2[8] = PROCESS_UNIQUE[4];
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    }
    toString(encoding) {
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      if (encoding === "hex")
        return this.toHexString();
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    static is(variable) {
      return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
    }
    equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (ObjectId.is(otherId)) {
        return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);
      }
      if (typeof otherId === "string") {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
        const otherIdString = otherId.toHexString();
        const thisIdString = this.toHexString();
        return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
    getTimestamp() {
      const timestamp = new Date;
      const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    }
    static createPk() {
      return new ObjectId;
    }
    static createFromTime(time) {
      const buffer2 = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      BSONDataView.fromUint8Array(buffer2).setUint32(0, time, false);
      return new ObjectId(buffer2);
    }
    static createFromHexString(hexString) {
      if (hexString?.length !== 24) {
        throw new BSONError("hex string must be 24 characters");
      }
      return new ObjectId(ByteUtils.fromHex(hexString));
    }
    static createFromBase64(base64) {
      if (base64?.length !== 16) {
        throw new BSONError("base64 string must be 16 characters");
      }
      return new ObjectId(ByteUtils.fromBase64(base64));
    }
    static isValid(id) {
      if (id == null)
        return false;
      try {
        new ObjectId(id);
        return true;
      } catch {
        return false;
      }
    }
    toExtendedJSON() {
      if (this.toHexString)
        return { $oid: this.toHexString() };
      return { $oid: this.toString("hex") };
    }
    static fromExtendedJSON(doc) {
      return new ObjectId(doc.$oid);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new ObjectId(${inspect(this.toHexString(), options)})`;
    }
  }
  ObjectId.index = Math.floor(Math.random() * 16777215);

  class BSONRegExp extends BSONValue {
    get _bsontype() {
      return "BSONRegExp";
    }
    constructor(pattern3, options) {
      super();
      this.pattern = pattern3;
      this.options = alphabetize(options ?? "");
      if (this.pattern.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
      }
      if (this.options.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
      }
      for (let i2 = 0;i2 < this.options.length; i2++) {
        if (!(this.options[i2] === "i" || this.options[i2] === "m" || this.options[i2] === "x" || this.options[i2] === "l" || this.options[i2] === "s" || this.options[i2] === "u")) {
          throw new BSONError(`The regular expression option [${this.options[i2]}] is not supported`);
        }
      }
    }
    static parseOptions(options) {
      return options ? options.split("").sort().join("") : "";
    }
    toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return { $regularExpression: { pattern: this.pattern, options: this.options } };
    }
    static fromExtendedJSON(doc) {
      if ("$regex" in doc) {
        if (typeof doc.$regex !== "string") {
          if (doc.$regex._bsontype === "BSONRegExp") {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ("$regularExpression" in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
    }
    inspect(depth, options, inspect) {
      const stylize = getStylizeFunction(options) ?? ((v2) => v2);
      inspect ??= defaultInspect;
      const pattern3 = stylize(inspect(this.pattern), "regexp");
      const flags = stylize(inspect(this.options), "regexp");
      return `new BSONRegExp(${pattern3}, ${flags})`;
    }
  }

  class BSONSymbol extends BSONValue {
    get _bsontype() {
      return "BSONSymbol";
    }
    constructor(value14) {
      super();
      this.value = value14;
    }
    valueOf() {
      return this.value;
    }
    toString() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON() {
      return { $symbol: this.value };
    }
    static fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new BSONSymbol(${inspect(this.value, options)})`;
    }
  }
  var LongWithoutOverridesClass = Long;

  class Timestamp extends LongWithoutOverridesClass {
    get _bsontype() {
      return "Timestamp";
    }
    constructor(low) {
      if (low == null) {
        super(0, 0, true);
      } else if (typeof low === "bigint") {
        super(low, true);
      } else if (Long.isLong(low)) {
        super(low.low, low.high, true);
      } else if (typeof low === "object" && "t" in low && "i" in low) {
        if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
        }
        if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
        }
        const t2 = Number(low.t);
        const i2 = Number(low.i);
        if (t2 < 0 || Number.isNaN(t2)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
        }
        if (i2 < 0 || Number.isNaN(i2)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
        }
        if (t2 > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
        }
        if (i2 > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
        }
        super(i2, t2, true);
      } else {
        throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
      }
    }
    toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
    static fromInt(value14) {
      return new Timestamp(Long.fromInt(value14, true));
    }
    static fromNumber(value14) {
      return new Timestamp(Long.fromNumber(value14, true));
    }
    static fromBits(lowBits, highBits) {
      return new Timestamp({ i: lowBits, t: highBits });
    }
    static fromString(str, optRadix) {
      return new Timestamp(Long.fromString(str, true, optRadix));
    }
    toExtendedJSON() {
      return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
    }
    static fromExtendedJSON(doc) {
      const i2 = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      const t2 = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({ t: t2, i: i2 });
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const t2 = inspect(this.high >>> 0, options);
      const i2 = inspect(this.low >>> 0, options);
      return `new Timestamp({ t: ${t2}, i: ${i2} })`;
    }
  }
  Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
  var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
  var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
  var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
  var regexp3 = /\x00/;
  var ignoreKeys = new Set(["$db", "$ref", "$id", "$clusterTime"]);
  var NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);
  var FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);
  var EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);
  var keysToCodecs = {
    $oid: ObjectId,
    $binary: Binary,
    $uuid: Binary,
    $symbol: BSONSymbol,
    $numberInt: Int32,
    $numberDecimal: Decimal128,
    $numberDouble: Double,
    $numberLong: Long,
    $minKey: MinKey,
    $maxKey: MaxKey,
    $regex: BSONRegExp,
    $regularExpression: BSONRegExp,
    $timestamp: Timestamp
  };
  var BSON_TYPE_MAPPINGS = {
    Binary: (o2) => new Binary(o2.value(), o2.sub_type),
    Code: (o2) => new Code(o2.code, o2.scope),
    DBRef: (o2) => new DBRef(o2.collection || o2.namespace, o2.oid, o2.db, o2.fields),
    Decimal128: (o2) => new Decimal128(o2.bytes),
    Double: (o2) => new Double(o2.value),
    Int32: (o2) => new Int32(o2.value),
    Long: (o2) => Long.fromBits(o2.low != null ? o2.low : o2.low_, o2.low != null ? o2.high : o2.high_, o2.low != null ? o2.unsigned : o2.unsigned_),
    MaxKey: () => new MaxKey,
    MinKey: () => new MinKey,
    ObjectId: (o2) => new ObjectId(o2),
    BSONRegExp: (o2) => new BSONRegExp(o2.pattern, o2.options),
    BSONSymbol: (o2) => new BSONSymbol(o2.value),
    Timestamp: (o2) => Timestamp.fromBits(o2.low, o2.high)
  };
  var EJSON = Object.create(null);
  EJSON.parse = parse4;
  EJSON.stringify = stringify;
  EJSON.serialize = EJSONserialize;
  EJSON.deserialize = EJSONdeserialize;
  Object.freeze(EJSON);
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = ByteUtils.allocate(MAXSIZE);
  var bson = Object.freeze({
    __proto__: null,
    BSONError,
    BSONRegExp,
    BSONRuntimeError,
    BSONSymbol,
    BSONType,
    BSONValue,
    BSONVersionError,
    Binary,
    Code,
    DBRef,
    Decimal128,
    Double,
    EJSON,
    Int32,
    Long,
    MaxKey,
    MinKey,
    ObjectId,
    Timestamp,
    UUID,
    calculateObjectSize,
    deserialize,
    deserializeStream,
    serialize,
    serializeWithBufferAndIndex,
    setInternalBufferSize
  });
  exports.BSON = bson;
  exports.BSONError = BSONError;
  exports.BSONRegExp = BSONRegExp;
  exports.BSONRuntimeError = BSONRuntimeError;
  exports.BSONSymbol = BSONSymbol;
  exports.BSONType = BSONType;
  exports.BSONValue = BSONValue;
  exports.BSONVersionError = BSONVersionError;
  exports.Binary = Binary;
  exports.Code = Code;
  exports.DBRef = DBRef;
  exports.Decimal128 = Decimal128;
  exports.Double = Double;
  exports.EJSON = EJSON;
  exports.Int32 = Int32;
  exports.Long = Long;
  exports.MaxKey = MaxKey;
  exports.MinKey = MinKey;
  exports.ObjectId = ObjectId;
  exports.Timestamp = Timestamp;
  exports.UUID = UUID;
  exports.calculateObjectSize = calculateObjectSize;
  exports.deserialize = deserialize;
  exports.deserializeStream = deserializeStream;
  exports.serialize = serialize;
  exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
  exports.setInternalBufferSize = setInternalBufferSize;
});

// node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS((exports) => {
  var pluckBSONSerializeOptions = function(options) {
    const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options;
    return {
      fieldsAsRaw,
      useBigInt64,
      promoteValues,
      promoteBuffers,
      promoteLongs,
      serializeFunctions,
      ignoreUndefined,
      bsonRegExp,
      raw,
      enableUtf8Validation
    };
  };
  var resolveBSONOptions = function(options, parent) {
    const parentOptions = parent?.bsonOptions;
    return {
      raw: options?.raw ?? parentOptions?.raw ?? false,
      useBigInt64: options?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
      promoteLongs: options?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
      promoteValues: options?.promoteValues ?? parentOptions?.promoteValues ?? true,
      promoteBuffers: options?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
      ignoreUndefined: options?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
      bsonRegExp: options?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
      serializeFunctions: options?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
      fieldsAsRaw: options?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
      enableUtf8Validation: options?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveBSONOptions = exports.pluckBSONSerializeOptions = exports.UUID = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSON = exports.Binary = undefined;
  var bson_1 = require_bson();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_1.Binary;
  } });
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_1.BSON;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_1.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_1.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_1.BSONType;
  } });
  Object.defineProperty(exports, "calculateObjectSize", { enumerable: true, get: function() {
    return bson_1.calculateObjectSize;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_1.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_1.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_1.Decimal128;
  } });
  Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
    return bson_1.deserialize;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_1.Double;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_1.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_1.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_1.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_1.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_1.ObjectId;
  } });
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return bson_1.serialize;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_1.Timestamp;
  } });
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return bson_1.UUID;
  } });
  exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
  exports.resolveBSONOptions = resolveBSONOptions;
});

// node_modules/mongodb/lib/error.js
var require_error = __commonJS((exports) => {
  var isAggregateError = function(e2) {
    return "errors" in e2 && Array.isArray(e2.errors);
  };
  var isNetworkErrorBeforeHandshake = function(err) {
    return err[kBeforeHandshake] === true;
  };
  var makeWriteConcernResultObject = function(input) {
    const output = Object.assign({}, input);
    if (output.ok === 0) {
      output.ok = 1;
      delete output.errmsg;
      delete output.code;
      delete output.codeName;
    }
    return output;
  };
  var needsRetryableWriteLabel = function(error21, maxWireVersion) {
    if (error21 instanceof MongoNetworkError) {
      return true;
    }
    if (error21 instanceof MongoError) {
      if ((maxWireVersion >= 9 || isRetryableWriteError(error21)) && !error21.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
        return false;
      }
    }
    if (error21 instanceof MongoWriteConcernError) {
      return RETRYABLE_WRITE_ERROR_CODES.has(error21.result?.code ?? error21.code ?? 0);
    }
    if (error21 instanceof MongoError && typeof error21.code === "number") {
      return RETRYABLE_WRITE_ERROR_CODES.has(error21.code);
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error21.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error21.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  };
  var isRetryableWriteError = function(error21) {
    return error21.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError) || error21.hasErrorLabel(exports.MongoErrorLabel.PoolRequstedRetry);
  };
  var isRetryableReadError = function(error21) {
    const hasRetryableErrorCode = typeof error21.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error21.code) : false;
    if (hasRetryableErrorCode) {
      return true;
    }
    if (error21 instanceof MongoNetworkError) {
      return true;
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error21.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error21.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  };
  var isRecoveringError = function(err) {
    if (typeof err.code === "number") {
      return SDAM_RECOVERING_CODES.has(err.code);
    }
    return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
  };
  var isNotWritablePrimaryError = function(err) {
    if (typeof err.code === "number") {
      return SDAM_NOT_PRIMARY_CODES.has(err.code);
    }
    if (isRecoveringError(err)) {
      return false;
    }
    return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
  };
  var isNodeShuttingDownError = function(err) {
    return !!(typeof err.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
  };
  var isSDAMUnrecoverableError = function(error21) {
    if (error21 instanceof MongoParseError || error21 == null) {
      return true;
    }
    return isRecoveringError(error21) || isNotWritablePrimaryError(error21);
  };
  var isNetworkTimeoutError = function(err) {
    return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
  };
  var isResumableError = function(error21, wireVersion) {
    if (error21 == null || !(error21 instanceof MongoError)) {
      return false;
    }
    if (error21 instanceof MongoNetworkError) {
      return true;
    }
    if (wireVersion != null && wireVersion >= 9) {
      if (error21.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
        return true;
      }
      return error21.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
    }
    if (typeof error21.code === "number") {
      return exports.GET_MORE_RESUMABLE_CODES.has(error21.code);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isResumableError = exports.isNetworkTimeoutError = exports.isSDAMUnrecoverableError = exports.isNodeShuttingDownError = exports.isRetryableReadError = exports.isRetryableWriteError = exports.needsRetryableWriteLabel = exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.isNetworkErrorBeforeHandshake = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = undefined;
  var kErrorLabels = Symbol("errorLabels");
  exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
  exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
  exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
  exports.MONGODB_ERROR_CODES = Object.freeze({
    HostUnreachable: 6,
    HostNotFound: 7,
    NetworkTimeout: 89,
    ShutdownInProgress: 91,
    PrimarySteppedDown: 189,
    ExceededTimeLimit: 262,
    SocketException: 9001,
    NotWritablePrimary: 10107,
    InterruptedAtShutdown: 11600,
    InterruptedDueToReplStateChange: 11602,
    NotPrimaryNoSecondaryOk: 13435,
    NotPrimaryOrSecondary: 13436,
    StaleShardVersion: 63,
    StaleEpoch: 150,
    StaleConfig: 13388,
    RetryChangeStream: 234,
    FailedToSatisfyReadPreference: 133,
    CursorNotFound: 43,
    LegacyNotPrimary: 10058,
    WriteConcernFailed: 64,
    NamespaceNotFound: 26,
    IllegalOperation: 20,
    MaxTimeMSExpired: 50,
    UnknownReplWriteConcern: 79,
    UnsatisfiableWriteConcern: 100,
    Reauthenticate: 391
  });
  exports.GET_MORE_RESUMABLE_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
    exports.MONGODB_ERROR_CODES.StaleShardVersion,
    exports.MONGODB_ERROR_CODES.StaleEpoch,
    exports.MONGODB_ERROR_CODES.StaleConfig,
    exports.MONGODB_ERROR_CODES.RetryChangeStream,
    exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
    exports.MONGODB_ERROR_CODES.CursorNotFound
  ]);
  exports.MongoErrorLabel = Object.freeze({
    RetryableWriteError: "RetryableWriteError",
    TransientTransactionError: "TransientTransactionError",
    UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
    ResumableChangeStreamError: "ResumableChangeStreamError",
    HandshakeError: "HandshakeError",
    ResetPool: "ResetPool",
    PoolRequstedRetry: "PoolRequstedRetry",
    InterruptInUseConnections: "InterruptInUseConnections",
    NoWritesPerformed: "NoWritesPerformed"
  });

  class MongoError extends Error {
    constructor(message, options) {
      super(message, options);
      this[kErrorLabels] = new Set;
    }
    static buildErrorMessage(e2) {
      if (typeof e2 === "string") {
        return e2;
      }
      if (isAggregateError(e2) && e2.message.length === 0) {
        return e2.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e2.errors.map(({ message }) => message).join(", ");
      }
      return e2.message;
    }
    get name() {
      return "MongoError";
    }
    get errmsg() {
      return this.message;
    }
    hasErrorLabel(label) {
      return this[kErrorLabels].has(label);
    }
    addErrorLabel(label) {
      this[kErrorLabels].add(label);
    }
    get errorLabels() {
      return Array.from(this[kErrorLabels]);
    }
  }
  exports.MongoError = MongoError;

  class MongoServerError extends MongoError {
    constructor(message) {
      super(message.message || message.errmsg || message.$err || "n/a");
      if (message.errorLabels) {
        this[kErrorLabels] = new Set(message.errorLabels);
      }
      for (const name in message) {
        if (name !== "errorLabels" && name !== "errmsg" && name !== "message")
          this[name] = message[name];
      }
    }
    get name() {
      return "MongoServerError";
    }
  }
  exports.MongoServerError = MongoServerError;

  class MongoDriverError extends MongoError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoDriverError";
    }
  }
  exports.MongoDriverError = MongoDriverError;

  class MongoAPIError extends MongoDriverError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoAPIError";
    }
  }
  exports.MongoAPIError = MongoAPIError;

  class MongoRuntimeError extends MongoDriverError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoRuntimeError";
    }
  }
  exports.MongoRuntimeError = MongoRuntimeError;

  class MongoBatchReExecutionError extends MongoAPIError {
    constructor(message = "This batch has already been executed, create new batch to execute") {
      super(message);
    }
    get name() {
      return "MongoBatchReExecutionError";
    }
  }
  exports.MongoBatchReExecutionError = MongoBatchReExecutionError;

  class MongoDecompressionError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoDecompressionError";
    }
  }
  exports.MongoDecompressionError = MongoDecompressionError;

  class MongoNotConnectedError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoNotConnectedError";
    }
  }
  exports.MongoNotConnectedError = MongoNotConnectedError;

  class MongoTransactionError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoTransactionError";
    }
  }
  exports.MongoTransactionError = MongoTransactionError;

  class MongoExpiredSessionError extends MongoAPIError {
    constructor(message = "Cannot use a session that has ended") {
      super(message);
    }
    get name() {
      return "MongoExpiredSessionError";
    }
  }
  exports.MongoExpiredSessionError = MongoExpiredSessionError;

  class MongoKerberosError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoKerberosError";
    }
  }
  exports.MongoKerberosError = MongoKerberosError;

  class MongoAWSError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAWSError";
    }
  }
  exports.MongoAWSError = MongoAWSError;

  class MongoAzureError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAzureError";
    }
  }
  exports.MongoAzureError = MongoAzureError;

  class MongoChangeStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoChangeStreamError";
    }
  }
  exports.MongoChangeStreamError = MongoChangeStreamError;

  class MongoTailableCursorError extends MongoAPIError {
    constructor(message = "Tailable cursor does not support this operation") {
      super(message);
    }
    get name() {
      return "MongoTailableCursorError";
    }
  }
  exports.MongoTailableCursorError = MongoTailableCursorError;

  class MongoGridFSStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSStreamError";
    }
  }
  exports.MongoGridFSStreamError = MongoGridFSStreamError;

  class MongoGridFSChunkError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSChunkError";
    }
  }
  exports.MongoGridFSChunkError = MongoGridFSChunkError;

  class MongoUnexpectedServerResponseError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoUnexpectedServerResponseError";
    }
  }
  exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;

  class MongoCursorInUseError extends MongoAPIError {
    constructor(message = "Cursor is already initialized") {
      super(message);
    }
    get name() {
      return "MongoCursorInUseError";
    }
  }
  exports.MongoCursorInUseError = MongoCursorInUseError;

  class MongoServerClosedError extends MongoAPIError {
    constructor(message = "Server is closed") {
      super(message);
    }
    get name() {
      return "MongoServerClosedError";
    }
  }
  exports.MongoServerClosedError = MongoServerClosedError;

  class MongoCursorExhaustedError extends MongoAPIError {
    constructor(message) {
      super(message || "Cursor is exhausted");
    }
    get name() {
      return "MongoCursorExhaustedError";
    }
  }
  exports.MongoCursorExhaustedError = MongoCursorExhaustedError;

  class MongoTopologyClosedError extends MongoAPIError {
    constructor(message = "Topology is closed") {
      super(message);
    }
    get name() {
      return "MongoTopologyClosedError";
    }
  }
  exports.MongoTopologyClosedError = MongoTopologyClosedError;
  var kBeforeHandshake = Symbol("beforeHandshake");
  exports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;

  class MongoNetworkError extends MongoError {
    constructor(message, options) {
      super(message, { cause: options?.cause });
      if (options && typeof options.beforeHandshake === "boolean") {
        this[kBeforeHandshake] = options.beforeHandshake;
      }
    }
    get name() {
      return "MongoNetworkError";
    }
  }
  exports.MongoNetworkError = MongoNetworkError;

  class MongoNetworkTimeoutError extends MongoNetworkError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoNetworkTimeoutError";
    }
  }
  exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;

  class MongoParseError extends MongoDriverError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoParseError";
    }
  }
  exports.MongoParseError = MongoParseError;

  class MongoInvalidArgumentError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoInvalidArgumentError";
    }
  }
  exports.MongoInvalidArgumentError = MongoInvalidArgumentError;

  class MongoCompatibilityError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCompatibilityError";
    }
  }
  exports.MongoCompatibilityError = MongoCompatibilityError;

  class MongoMissingCredentialsError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoMissingCredentialsError";
    }
  }
  exports.MongoMissingCredentialsError = MongoMissingCredentialsError;

  class MongoMissingDependencyError extends MongoAPIError {
    constructor(message, options = {}) {
      super(message, options);
    }
    get name() {
      return "MongoMissingDependencyError";
    }
  }
  exports.MongoMissingDependencyError = MongoMissingDependencyError;

  class MongoSystemError extends MongoError {
    constructor(message, reason) {
      if (reason && reason.error) {
        super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
          cause: reason.error
        });
      } else {
        super(message);
      }
      if (reason) {
        this.reason = reason;
      }
      this.code = reason.error?.code;
    }
    get name() {
      return "MongoSystemError";
    }
  }
  exports.MongoSystemError = MongoSystemError;

  class MongoServerSelectionError extends MongoSystemError {
    constructor(message, reason) {
      super(message, reason);
    }
    get name() {
      return "MongoServerSelectionError";
    }
  }
  exports.MongoServerSelectionError = MongoServerSelectionError;

  class MongoWriteConcernError extends MongoServerError {
    constructor(message, result) {
      if (result && Array.isArray(result.errorLabels)) {
        message.errorLabels = result.errorLabels;
      }
      super(message);
      this.errInfo = message.errInfo;
      if (result != null) {
        this.result = makeWriteConcernResultObject(result);
      }
    }
    get name() {
      return "MongoWriteConcernError";
    }
  }
  exports.MongoWriteConcernError = MongoWriteConcernError;
  var RETRYABLE_READ_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
  ]);
  var RETRYABLE_WRITE_ERROR_CODES = new Set([
    ...RETRYABLE_READ_ERROR_CODES,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit
  ]);
  exports.needsRetryableWriteLabel = needsRetryableWriteLabel;
  exports.isRetryableWriteError = isRetryableWriteError;
  exports.isRetryableReadError = isRetryableReadError;
  var SDAM_RECOVERING_CODES = new Set([
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
  ]);
  var SDAM_NOT_PRIMARY_CODES = new Set([
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.LegacyNotPrimary
  ]);
  var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress
  ]);
  exports.isNodeShuttingDownError = isNodeShuttingDownError;
  exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
  exports.isNetworkTimeoutError = isNetworkTimeoutError;
  exports.isResumableError = isResumableError;
});

// node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadPreference = exports.ReadPreferenceMode = undefined;
  var error_1 = require_error();
  exports.ReadPreferenceMode = Object.freeze({
    primary: "primary",
    primaryPreferred: "primaryPreferred",
    secondary: "secondary",
    secondaryPreferred: "secondaryPreferred",
    nearest: "nearest"
  });

  class ReadPreference {
    constructor(mode, tags, options) {
      if (!ReadPreference.isValid(mode)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
      }
      if (options == null && typeof tags === "object" && !Array.isArray(tags)) {
        options = tags;
        tags = undefined;
      } else if (tags && !Array.isArray(tags)) {
        throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options?.hedge;
      this.maxStalenessSeconds = undefined;
      this.minWireVersion = undefined;
      options = options ?? {};
      if (options.maxStalenessSeconds != null) {
        if (options.maxStalenessSeconds <= 0) {
          throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
        }
      }
    }
    get preference() {
      return this.mode;
    }
    static fromString(mode) {
      return new ReadPreference(mode);
    }
    static fromOptions(options) {
      if (!options)
        return;
      const readPreference = options.readPreference ?? options.session?.transaction.options.readPreference;
      const readPreferenceTags = options.readPreferenceTags;
      if (readPreference == null) {
        return;
      }
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags, {
          maxStalenessSeconds: options.maxStalenessSeconds,
          hedge: options.hedge
        });
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds,
            hedge: options.hedge
          });
        }
      }
      if (readPreferenceTags) {
        readPreference.tags = readPreferenceTags;
      }
      return readPreference;
    }
    static translate(options) {
      if (options.readPreference == null)
        return options;
      const r = options.readPreference;
      if (typeof r === "string") {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
      }
      return options;
    }
    static isValid(mode) {
      const VALID_MODES = new Set([
        ReadPreference.PRIMARY,
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST,
        null
      ]);
      return VALID_MODES.has(mode);
    }
    isValid(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    }
    secondaryOk() {
      const NEEDS_SECONDARYOK = new Set([
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST
      ]);
      return NEEDS_SECONDARYOK.has(this.mode);
    }
    equals(readPreference) {
      return readPreference.mode === this.mode;
    }
    toJSON() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    }
  }
  ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
  ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
  ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
  ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
  ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
  ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
  ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
  ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
  ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
  ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
  exports.ReadPreference = ReadPreference;
});

// node_modules/mongodb/lib/sdam/common.js
var require_common = __commonJS((exports) => {
  var drainTimerQueue = function(queue) {
    queue.forEach(timers_1.clearTimeout);
    queue.clear();
  };
  var _advanceClusterTime = function(entity, $clusterTime) {
    if (entity.clusterTime == null) {
      entity.clusterTime = $clusterTime;
    } else {
      if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
        entity.clusterTime = $clusterTime;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._advanceClusterTime = exports.drainTimerQueue = exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = undefined;
  var timers_1 = import.meta.require("timers");
  exports.STATE_CLOSING = "closing";
  exports.STATE_CLOSED = "closed";
  exports.STATE_CONNECTING = "connecting";
  exports.STATE_CONNECTED = "connected";
  exports.TopologyType = Object.freeze({
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown",
    LoadBalanced: "LoadBalanced"
  });
  exports.ServerType = Object.freeze({
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown",
    LoadBalancer: "LoadBalancer"
  });
  exports.drainTimerQueue = drainTimerQueue;
  exports._advanceClusterTime = _advanceClusterTime;
});

// node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS((exports) => {
  var writableServerSelector = function() {
    return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter((s2) => s2.isWritable));
  };
  var sameServerSelector = function(description) {
    return (topologyDescription, servers) => {
      if (!description)
        return [];
      return servers.filter((sd) => {
        return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
      });
    };
  };
  var secondaryWritableServerSelector = function(wireVersion, readPreference) {
    if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
      return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
    }
    return readPreferenceServerSelector(readPreference);
  };
  var maxStalenessReducer = function(readPreference, topologyDescription, servers) {
    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
      return servers;
    }
    const maxStaleness = readPreference.maxStalenessSeconds;
    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;
    if (maxStaleness < maxStalenessVariance) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
    }
    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
      const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
      return servers.reduce((result, server) => {
        const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
      if (servers.length === 0) {
        return servers;
      }
      const sMax = servers.reduce((max, s2) => s2.lastWriteDate > max.lastWriteDate ? s2 : max);
      return servers.reduce((result, server) => {
        const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    return servers;
  };
  var tagSetMatch = function(tagSet, serverTags) {
    const keys = Object.keys(tagSet);
    const serverTagKeys = Object.keys(serverTags);
    for (let i2 = 0;i2 < keys.length; ++i2) {
      const key = keys[i2];
      if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
        return false;
      }
    }
    return true;
  };
  var tagSetReducer = function(readPreference, servers) {
    if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
      return servers;
    }
    for (let i2 = 0;i2 < readPreference.tags.length; ++i2) {
      const tagSet = readPreference.tags[i2];
      const serversMatchingTagset = servers.reduce((matched, server) => {
        if (tagSetMatch(tagSet, server.tags))
          matched.push(server);
        return matched;
      }, []);
      if (serversMatchingTagset.length) {
        return serversMatchingTagset;
      }
    }
    return [];
  };
  var latencyWindowReducer = function(topologyDescription, servers) {
    const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
    const high = low + topologyDescription.localThresholdMS;
    return servers.reduce((result, server) => {
      if (server.roundTripTime <= high && server.roundTripTime >= low)
        result.push(server);
      return result;
    }, []);
  };
  var primaryFilter = function(server) {
    return server.type === common_1.ServerType.RSPrimary;
  };
  var secondaryFilter = function(server) {
    return server.type === common_1.ServerType.RSSecondary;
  };
  var nearestFilter = function(server) {
    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
  };
  var knownFilter = function(server) {
    return server.type !== common_1.ServerType.Unknown;
  };
  var loadBalancerFilter = function(server) {
    return server.type === common_1.ServerType.LoadBalancer;
  };
  var readPreferenceServerSelector = function(readPreference) {
    if (!readPreference.isValid()) {
      throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
    }
    return (topologyDescription, servers) => {
      const commonWireVersion = topologyDescription.commonWireVersion;
      if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
        throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
      }
      if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
        return servers.filter(loadBalancerFilter);
      }
      if (topologyDescription.type === common_1.TopologyType.Unknown) {
        return [];
      }
      if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {
        return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
      }
      const mode = readPreference.mode;
      if (mode === read_preference_1.ReadPreference.PRIMARY) {
        return servers.filter(primaryFilter);
      }
      if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
        const result = servers.filter(primaryFilter);
        if (result.length) {
          return result;
        }
      }
      const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
      const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
      if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
        return servers.filter(primaryFilter);
      }
      return selectedServers;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var IDLE_WRITE_PERIOD = 1e4;
  var SMALLEST_MAX_STALENESS_SECONDS = 90;
  exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
  exports.writableServerSelector = writableServerSelector;
  exports.sameServerSelector = sameServerSelector;
  exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
  exports.readPreferenceServerSelector = readPreferenceServerSelector;
});

// node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MIN_SUPPORTED_QE_SERVER_VERSION = exports.MIN_SUPPORTED_QE_WIRE_VERSION = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = undefined;
  exports.MIN_SUPPORTED_SERVER_VERSION = "3.6";
  exports.MAX_SUPPORTED_SERVER_VERSION = "7.0";
  exports.MIN_SUPPORTED_WIRE_VERSION = 6;
  exports.MAX_SUPPORTED_WIRE_VERSION = 21;
  exports.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
  exports.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
  exports.OP_REPLY = 1;
  exports.OP_UPDATE = 2001;
  exports.OP_INSERT = 2002;
  exports.OP_QUERY = 2004;
  exports.OP_DELETE = 2006;
  exports.OP_COMPRESSED = 2012;
  exports.OP_MSG = 2013;
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = undefined;
  exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = undefined;
  exports.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
  exports.SYSTEM_INDEX_COLLECTION = "system.indexes";
  exports.SYSTEM_PROFILE_COLLECTION = "system.profile";
  exports.SYSTEM_USER_COLLECTION = "system.users";
  exports.SYSTEM_COMMAND_COLLECTION = "$cmd";
  exports.SYSTEM_JS_COLLECTION = "system.js";
  exports.ERROR = "error";
  exports.TIMEOUT = "timeout";
  exports.CLOSE = "close";
  exports.OPEN = "open";
  exports.CONNECT = "connect";
  exports.CLOSED = "closed";
  exports.ENDED = "ended";
  exports.MESSAGE = "message";
  exports.PINNED = "pinned";
  exports.UNPINNED = "unpinned";
  exports.DESCRIPTION_RECEIVED = "descriptionReceived";
  exports.SERVER_OPENING = "serverOpening";
  exports.SERVER_CLOSED = "serverClosed";
  exports.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
  exports.TOPOLOGY_OPENING = "topologyOpening";
  exports.TOPOLOGY_CLOSED = "topologyClosed";
  exports.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
  exports.CONNECTION_POOL_CREATED = "connectionPoolCreated";
  exports.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
  exports.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
  exports.CONNECTION_POOL_READY = "connectionPoolReady";
  exports.CONNECTION_CREATED = "connectionCreated";
  exports.CONNECTION_READY = "connectionReady";
  exports.CONNECTION_CLOSED = "connectionClosed";
  exports.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
  exports.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
  exports.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
  exports.CONNECTION_CHECKED_IN = "connectionCheckedIn";
  exports.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
  exports.COMMAND_STARTED = "commandStarted";
  exports.COMMAND_SUCCEEDED = "commandSucceeded";
  exports.COMMAND_FAILED = "commandFailed";
  exports.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
  exports.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
  exports.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
  exports.RESPONSE = "response";
  exports.MORE = "more";
  exports.INIT = "init";
  exports.CHANGE = "change";
  exports.END = "end";
  exports.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
  exports.HEARTBEAT_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED
  ]);
  exports.CMAP_EVENTS = Object.freeze([
    exports.CONNECTION_POOL_CREATED,
    exports.CONNECTION_POOL_READY,
    exports.CONNECTION_POOL_CLEARED,
    exports.CONNECTION_POOL_CLOSED,
    exports.CONNECTION_CREATED,
    exports.CONNECTION_READY,
    exports.CONNECTION_CLOSED,
    exports.CONNECTION_CHECK_OUT_STARTED,
    exports.CONNECTION_CHECK_OUT_FAILED,
    exports.CONNECTION_CHECKED_OUT,
    exports.CONNECTION_CHECKED_IN
  ]);
  exports.TOPOLOGY_EVENTS = Object.freeze([
    exports.SERVER_OPENING,
    exports.SERVER_CLOSED,
    exports.SERVER_DESCRIPTION_CHANGED,
    exports.TOPOLOGY_OPENING,
    exports.TOPOLOGY_CLOSED,
    exports.TOPOLOGY_DESCRIPTION_CHANGED,
    exports.ERROR,
    exports.TIMEOUT,
    exports.CLOSE
  ]);
  exports.APM_EVENTS = Object.freeze([
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED
  ]);
  exports.SERVER_RELAY_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED,
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED,
    ...exports.CMAP_EVENTS
  ]);
  exports.LOCAL_SERVER_EVENTS = Object.freeze([
    exports.CONNECT,
    exports.DESCRIPTION_RECEIVED,
    exports.CLOSED,
    exports.ENDED
  ]);
  exports.MONGO_CLIENT_EVENTS = Object.freeze([
    ...exports.CMAP_EVENTS,
    ...exports.APM_EVENTS,
    ...exports.TOPOLOGY_EVENTS,
    ...exports.HEARTBEAT_EVENTS
  ]);
  exports.LEGACY_HELLO_COMMAND = "ismaster";
  exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadConcern = exports.ReadConcernLevel = undefined;
  exports.ReadConcernLevel = Object.freeze({
    local: "local",
    majority: "majority",
    linearizable: "linearizable",
    available: "available",
    snapshot: "snapshot"
  });

  class ReadConcern {
    constructor(level) {
      this.level = exports.ReadConcernLevel[level] ?? level;
    }
    static fromOptions(options) {
      if (options == null) {
        return;
      }
      if (options.readConcern) {
        const { readConcern } = options;
        if (readConcern instanceof ReadConcern) {
          return readConcern;
        } else if (typeof readConcern === "string") {
          return new ReadConcern(readConcern);
        } else if ("level" in readConcern && readConcern.level) {
          return new ReadConcern(readConcern.level);
        }
      }
      if (options.level) {
        return new ReadConcern(options.level);
      }
      return;
    }
    static get MAJORITY() {
      return exports.ReadConcernLevel.majority;
    }
    static get AVAILABLE() {
      return exports.ReadConcernLevel.available;
    }
    static get LINEARIZABLE() {
      return exports.ReadConcernLevel.linearizable;
    }
    static get SNAPSHOT() {
      return exports.ReadConcernLevel.snapshot;
    }
    toJSON() {
      return { level: this.level };
    }
  }
  exports.ReadConcern = ReadConcern;
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteConcern = exports.WRITE_CONCERN_KEYS = undefined;
  exports.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];

  class WriteConcern {
    constructor(w, wtimeoutMS, journal, fsync) {
      if (w != null) {
        if (!Number.isNaN(Number(w))) {
          this.w = Number(w);
        } else {
          this.w = w;
        }
      }
      if (wtimeoutMS != null) {
        this.wtimeoutMS = this.wtimeout = wtimeoutMS;
      }
      if (journal != null) {
        this.journal = this.j = journal;
      }
      if (fsync != null) {
        this.journal = this.j = fsync ? true : false;
      }
    }
    static apply(command, writeConcern) {
      const wc = {};
      if (writeConcern.w != null)
        wc.w = writeConcern.w;
      if (writeConcern.wtimeoutMS != null)
        wc.wtimeout = writeConcern.wtimeoutMS;
      if (writeConcern.journal != null)
        wc.j = writeConcern.j;
      command.writeConcern = wc;
      return command;
    }
    static fromOptions(options, inherit) {
      if (options == null)
        return;
      inherit = inherit ?? {};
      let opts;
      if (typeof options === "string" || typeof options === "number") {
        opts = { w: options };
      } else if (options instanceof WriteConcern) {
        opts = options;
      } else {
        opts = options.writeConcern;
      }
      const parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;
      const { w = undefined, wtimeout = undefined, j = undefined, fsync = undefined, journal = undefined, wtimeoutMS = undefined } = {
        ...parentOpts,
        ...opts
      };
      if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
        return new WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
      }
      return;
    }
  }
  exports.WriteConcern = WriteConcern;
});

// node_modules/mongodb/lib/utils.js
var require_utils = __commonJS((exports) => {
  var hostMatchesWildcards = function(host, wildcards) {
    for (const wildcard of wildcards) {
      if (host === wildcard || wildcard.startsWith("*.") && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith("*/") && host?.endsWith(wildcard.substring(2, wildcard.length))) {
        return true;
      }
    }
    return false;
  };
  var normalizeHintField = function(hint) {
    let finalHint = undefined;
    if (typeof hint === "string") {
      finalHint = hint;
    } else if (Array.isArray(hint)) {
      finalHint = {};
      hint.forEach((param) => {
        finalHint[param] = 1;
      });
    } else if (hint != null && typeof hint === "object") {
      finalHint = {};
      for (const name in hint) {
        finalHint[name] = hint[name];
      }
    }
    return finalHint;
  };
  var isObject = function(arg) {
    return TO_STRING(arg) === "[object Object]";
  };
  var mergeOptions = function(target, source) {
    return { ...target, ...source };
  };
  var filterOptions = function(options, names) {
    const filterOptions2 = {};
    for (const name in options) {
      if (names.includes(name)) {
        filterOptions2[name] = options[name];
      }
    }
    return filterOptions2;
  };
  var applyRetryableWrites = function(target, db) {
    if (db && db.s.options?.retryWrites) {
      target.retryWrites = true;
    }
    return target;
  };
  var isPromiseLike = function(value14) {
    return !!value14 && typeof value14.then === "function";
  };
  var decorateWithCollation = function(command, target, options) {
    const capabilities = getTopology(target).capabilities;
    if (options.collation && typeof options.collation === "object") {
      if (capabilities && capabilities.commandsTakeCollation) {
        command.collation = options.collation;
      } else {
        throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
      }
    }
  };
  var decorateWithReadConcern = function(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
      return;
    }
    const readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
      Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
      Object.assign(command, { readConcern });
    }
  };
  var decorateWithExplain = function(command, explain) {
    if (command.explain) {
      return command;
    }
    return { explain: command, verbosity: explain.verbosity };
  };
  var getTopology = function(provider) {
    if ("topology" in provider && provider.topology) {
      return provider.topology;
    } else if ("client" in provider && provider.client.topology) {
      return provider.client.topology;
    }
    throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
  };
  var ns = function(ns2) {
    return MongoDBNamespace.fromString(ns2);
  };
  function* makeCounter(seed = 0) {
    let count = seed;
    while (true) {
      const newCount = count;
      count += 1;
      yield newCount;
    }
  }
  var maybeCallback = function(promiseFn, callback) {
    const promise4 = promiseFn();
    if (callback == null) {
      return promise4;
    }
    promise4.then((result) => callback(undefined, result), (error21) => callback(error21));
    return;
  };
  var uuidV4 = function() {
    const result = crypto2.randomBytes(16);
    result[6] = result[6] & 15 | 64;
    result[8] = result[8] & 63 | 128;
    return result;
  };
  var maxWireVersion = function(topologyOrServer) {
    if (topologyOrServer) {
      if (topologyOrServer.loadBalanced) {
        return constants_1.MAX_SUPPORTED_WIRE_VERSION;
      }
      if (topologyOrServer.hello) {
        return topologyOrServer.hello.maxWireVersion;
      }
      if ("lastHello" in topologyOrServer && typeof topologyOrServer.lastHello === "function") {
        const lastHello = topologyOrServer.lastHello();
        if (lastHello) {
          return lastHello.maxWireVersion;
        }
      }
      if (topologyOrServer.description && "maxWireVersion" in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
        return topologyOrServer.description.maxWireVersion;
      }
    }
    return 0;
  };
  var eachAsync = function(arr, eachFn, callback) {
    arr = arr || [];
    let idx = 0;
    let awaiting = 0;
    for (idx = 0;idx < arr.length; ++idx) {
      awaiting++;
      eachFn(arr[idx], eachCallback);
    }
    if (awaiting === 0) {
      callback();
      return;
    }
    function eachCallback(err) {
      awaiting--;
      if (err) {
        callback(err);
        return;
      }
      if (idx === arr.length && awaiting <= 0) {
        callback();
      }
    }
  };
  var arrayStrictEqual = function(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
      return false;
    }
    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
  };
  var errorStrictEqual = function(lhs, rhs) {
    if (lhs === rhs) {
      return true;
    }
    if (!lhs || !rhs) {
      return lhs === rhs;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
      return false;
    }
    if (lhs.message !== rhs.message) {
      return false;
    }
    return true;
  };
  var makeStateMachine = function(stateTable) {
    return function stateTransition(target, newState) {
      const legalStates = stateTable[target.s.state];
      if (legalStates && legalStates.indexOf(newState) < 0) {
        throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
      }
      target.emit("stateChanged", target.s.state, newState);
      target.s.state = newState;
    };
  };
  var now = function() {
    const hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1e6);
  };
  var calculateDurationInMs = function(started) {
    if (typeof started !== "number") {
      throw new error_1.MongoInvalidArgumentError("Numeric value required to calculate duration");
    }
    const elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
  };
  var hasAtomicOperators = function(doc) {
    if (Array.isArray(doc)) {
      for (const document of doc) {
        if (hasAtomicOperators(document)) {
          return true;
        }
      }
      return false;
    }
    const keys = Object.keys(doc);
    return keys.length > 0 && keys[0][0] === "$";
  };
  var resolveOptions = function(parent, options) {
    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
    const session = options?.session;
    if (!session?.inTransaction()) {
      const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;
      if (readConcern) {
        result.readConcern = readConcern;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;
      if (writeConcern) {
        result.writeConcern = writeConcern;
      }
    }
    const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;
    if (readPreference) {
      result.readPreference = readPreference;
    }
    return result;
  };
  var isSuperset = function(set2, subset) {
    set2 = Array.isArray(set2) ? new Set(set2) : set2;
    subset = Array.isArray(subset) ? new Set(subset) : subset;
    for (const elem of subset) {
      if (!set2.has(elem)) {
        return false;
      }
    }
    return true;
  };
  var isHello = function(doc) {
    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
  };
  var setDifference = function(setA, setB) {
    const difference = new Set(setA);
    for (const elem of setB) {
      difference.delete(elem);
    }
    return difference;
  };
  var isRecord = function(value14, requiredKeys = undefined) {
    if (!isObject(value14)) {
      return false;
    }
    const ctor = value14.constructor;
    if (ctor && ctor.prototype) {
      if (!isObject(ctor.prototype)) {
        return false;
      }
      if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
        return false;
      }
    }
    if (requiredKeys) {
      const keys = Object.keys(value14);
      return isSuperset(keys, requiredKeys);
    }
    return true;
  };
  var deepCopy = function(value14) {
    if (value14 == null) {
      return value14;
    } else if (Array.isArray(value14)) {
      return value14.map((item) => deepCopy(item));
    } else if (isRecord(value14)) {
      const res = {};
      for (const key in value14) {
        res[key] = deepCopy(value14[key]);
      }
      return res;
    }
    const ctor = value14.constructor;
    if (ctor) {
      switch (ctor.name.toLowerCase()) {
        case "date":
          return new ctor(Number(value14));
        case "map":
          return new Map(value14);
        case "set":
          return new Set(value14);
        case "buffer":
          return Buffer.from(value14);
      }
    }
    return value14;
  };
  var emitWarning = function(message) {
    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
  };
  var emitWarningOnce = function(message) {
    if (!emittedWarnings.has(message)) {
      emittedWarnings.add(message);
      return emitWarning(message);
    }
  };
  var enumToString = function(en) {
    return Object.values(en).join(", ");
  };
  var supportsRetryableWrites = function(server) {
    if (!server) {
      return false;
    }
    if (server.loadBalanced) {
      return true;
    }
    if (server.description.logicalSessionTimeoutMinutes != null) {
      if (server.description.type !== common_1.ServerType.Standalone) {
        return true;
      }
    }
    return false;
  };
  var shuffle = function(sequence, limit = 0) {
    const items = Array.from(sequence);
    if (limit > items.length) {
      throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
    }
    let remainingItemsToShuffle = items.length;
    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
    while (remainingItemsToShuffle > lowerBound) {
      const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
      remainingItemsToShuffle -= 1;
      const swapHold = items[remainingItemsToShuffle];
      items[remainingItemsToShuffle] = items[randomIndex];
      items[randomIndex] = swapHold;
    }
    return limit % items.length === 0 ? items : items.slice(lowerBound);
  };
  var commandSupportsReadConcern = function(command) {
    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
      return true;
    }
    return false;
  };
  var compareObjectId = function(oid1, oid2) {
    if (oid1 == null && oid2 == null) {
      return 0;
    }
    if (oid1 == null) {
      return -1;
    }
    if (oid2 == null) {
      return 1;
    }
    return exports.ByteUtils.compare(oid1.id, oid2.id);
  };
  var parseInteger = function(value14) {
    if (typeof value14 === "number")
      return Math.trunc(value14);
    const parsedValue = Number.parseInt(String(value14), 10);
    return Number.isNaN(parsedValue) ? null : parsedValue;
  };
  var parseUnsignedInteger = function(value14) {
    const parsedInt = parseInteger(value14);
    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
  };
  var matchesParentDomain = function(address, srvHost) {
    const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
    const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
    const allCharacterBeforeFirstDot = /^.*?\./;
    const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
    const srvHostDomain = `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
    return addressDomain.endsWith(srvHostDomain);
  };
  async function request(uri, options = {}) {
    return new Promise((resolve, reject) => {
      const requestOptions = {
        method: "GET",
        timeout: 1e4,
        json: true,
        ...url.parse(uri),
        ...options
      };
      const req = http.request(requestOptions, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d2) => {
          data += d2;
        });
        res.once("end", () => {
          if (options.json === false) {
            resolve(data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            resolve(parsed);
          } catch {
            reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.once("timeout", () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri} timed out after ${options.timeout} ms`)));
      req.once("error", (error21) => reject(error21));
      req.end();
    });
  }
  var isHostMatch = function(match, host) {
    return host && match.test(host.toLowerCase()) ? true : false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DOCUMENT_DB_CHECK = exports.TimeoutController = exports.request = exports.matchesParentDomain = exports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.maybeCallback = exports.makeCounter = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.hostMatchesWildcards = exports.ByteUtils = undefined;
  exports.isHostMatch = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = undefined;
  var crypto2 = import.meta.require("crypto");
  var http = import.meta.require("http");
  var timers_1 = import.meta.require("timers");
  var url = import.meta.require("url");
  var url_1 = import.meta.require("url");
  var bson_1 = require_bson2();
  var constants_1 = require_constants();
  var constants_2 = require_constants2();
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var write_concern_1 = require_write_concern();
  exports.ByteUtils = {
    toLocalBufferType(buffer) {
      return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    },
    equals(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
    },
    compare(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
    },
    toBase64(uint8array4) {
      return exports.ByteUtils.toLocalBufferType(uint8array4).toString("base64");
    }
  };
  exports.hostMatchesWildcards = hostMatchesWildcards;
  exports.normalizeHintField = normalizeHintField;
  var TO_STRING = (object12) => Object.prototype.toString.call(object12);
  exports.isObject = isObject;
  exports.mergeOptions = mergeOptions;
  exports.filterOptions = filterOptions;
  exports.applyRetryableWrites = applyRetryableWrites;
  exports.isPromiseLike = isPromiseLike;
  exports.decorateWithCollation = decorateWithCollation;
  exports.decorateWithReadConcern = decorateWithReadConcern;
  exports.decorateWithExplain = decorateWithExplain;
  exports.getTopology = getTopology;
  exports.ns = ns;

  class MongoDBNamespace {
    constructor(db, collection) {
      this.db = db;
      this.collection = collection;
      this.collection = collection === "" ? undefined : collection;
    }
    toString() {
      return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
      return new MongoDBCollectionNamespace(this.db, collection);
    }
    static fromString(namespace) {
      if (typeof namespace !== "string" || namespace === "") {
        throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
      }
      const [db, ...collectionParts] = namespace.split(".");
      const collection = collectionParts.join(".");
      return new MongoDBNamespace(db, collection === "" ? undefined : collection);
    }
  }
  exports.MongoDBNamespace = MongoDBNamespace;

  class MongoDBCollectionNamespace extends MongoDBNamespace {
    constructor(db, collection) {
      super(db, collection);
      this.collection = collection;
    }
    static fromString(namespace) {
      return super.fromString(namespace);
    }
  }
  exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
  exports.makeCounter = makeCounter;
  exports.maybeCallback = maybeCallback;
  exports.uuidV4 = uuidV4;
  exports.maxWireVersion = maxWireVersion;
  exports.eachAsync = eachAsync;
  exports.arrayStrictEqual = arrayStrictEqual;
  exports.errorStrictEqual = errorStrictEqual;
  exports.makeStateMachine = makeStateMachine;
  exports.now = now;
  exports.calculateDurationInMs = calculateDurationInMs;
  exports.hasAtomicOperators = hasAtomicOperators;
  exports.resolveOptions = resolveOptions;
  exports.isSuperset = isSuperset;
  exports.isHello = isHello;
  exports.setDifference = setDifference;
  var HAS_OWN = (object12, prop) => Object.prototype.hasOwnProperty.call(object12, prop);
  exports.isRecord = isRecord;
  exports.deepCopy = deepCopy;

  class List {
    get length() {
      return this.count;
    }
    get [Symbol.toStringTag]() {
      return "List";
    }
    constructor() {
      this.count = 0;
      this.head = {
        next: null,
        prev: null,
        value: null
      };
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    toArray() {
      return Array.from(this);
    }
    toString() {
      return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
    }
    *[Symbol.iterator]() {
      for (const node of this.nodes()) {
        yield node.value;
      }
    }
    *nodes() {
      let ptr = this.head.next;
      while (ptr !== this.head) {
        const { next } = ptr;
        yield ptr;
        ptr = next;
      }
    }
    push(value14) {
      this.count += 1;
      const newNode = {
        next: this.head,
        prev: this.head.prev,
        value: value14
      };
      this.head.prev.next = newNode;
      this.head.prev = newNode;
    }
    pushMany(iterable) {
      for (const value14 of iterable) {
        this.push(value14);
      }
    }
    unshift(value14) {
      this.count += 1;
      const newNode = {
        next: this.head.next,
        prev: this.head,
        value: value14
      };
      this.head.next.prev = newNode;
      this.head.next = newNode;
    }
    remove(node) {
      if (node === this.head || this.length === 0) {
        return null;
      }
      this.count -= 1;
      const prevNode = node.prev;
      const nextNode = node.next;
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
      return node.value;
    }
    shift() {
      return this.remove(this.head.next);
    }
    pop() {
      return this.remove(this.head.prev);
    }
    prune(filter) {
      for (const node of this.nodes()) {
        if (filter(node.value)) {
          this.remove(node);
        }
      }
    }
    clear() {
      this.count = 0;
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    first() {
      return this.head.next.value;
    }
    last() {
      return this.head.prev.value;
    }
  }
  exports.List = List;

  class BufferPool {
    constructor() {
      this.buffers = new List;
      this.totalByteLength = 0;
    }
    get length() {
      return this.totalByteLength;
    }
    append(buffer) {
      this.buffers.push(buffer);
      this.totalByteLength += buffer.length;
    }
    getInt32() {
      if (this.totalByteLength < 4) {
        return null;
      }
      const firstBuffer = this.buffers.first();
      if (firstBuffer != null && firstBuffer.byteLength >= 4) {
        return firstBuffer.readInt32LE(0);
      }
      const top4Bytes = this.read(4);
      const value14 = top4Bytes.readInt32LE(0);
      this.totalByteLength += 4;
      this.buffers.unshift(top4Bytes);
      return value14;
    }
    read(size) {
      if (typeof size !== "number" || size < 0) {
        throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
      }
      if (size > this.totalByteLength) {
        return Buffer.alloc(0);
      }
      const result = Buffer.allocUnsafe(size);
      for (let bytesRead = 0;bytesRead < size; ) {
        const buffer = this.buffers.shift();
        if (buffer == null) {
          break;
        }
        const bytesRemaining = size - bytesRead;
        const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
        const bytes = buffer.subarray(0, bytesReadable);
        result.set(bytes, bytesRead);
        bytesRead += bytesReadable;
        this.totalByteLength -= bytesReadable;
        if (bytesReadable < buffer.byteLength) {
          this.buffers.unshift(buffer.subarray(bytesReadable));
        }
      }
      return result;
    }
  }
  exports.BufferPool = BufferPool;

  class HostAddress {
    constructor(hostString) {
      this.host = undefined;
      this.port = undefined;
      this.socketPath = undefined;
      this.isIPv6 = false;
      const escapedHost = hostString.split(" ").join("%20");
      if (escapedHost.endsWith(".sock")) {
        this.socketPath = decodeURIComponent(escapedHost);
        return;
      }
      const urlString = `iLoveJS://${escapedHost}`;
      let url2;
      try {
        url2 = new url_1.URL(urlString);
      } catch (urlError) {
        const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
        runtimeError.cause = urlError;
        throw runtimeError;
      }
      const hostname = url2.hostname;
      const port = url2.port;
      let normalized = decodeURIComponent(hostname).toLowerCase();
      if (normalized.startsWith("[") && normalized.endsWith("]")) {
        this.isIPv6 = true;
        normalized = normalized.substring(1, hostname.length - 1);
      }
      this.host = normalized.toLowerCase();
      if (typeof port === "number") {
        this.port = port;
      } else if (typeof port === "string" && port !== "") {
        this.port = Number.parseInt(port, 10);
      } else {
        this.port = 27017;
      }
      if (this.port === 0) {
        throw new error_1.MongoParseError("Invalid port (zero) with hostname");
      }
      Object.freeze(this);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new HostAddress('${this.toString()}')`;
    }
    toString() {
      if (typeof this.host === "string") {
        if (this.isIPv6) {
          return `[${this.host}]:${this.port}`;
        }
        return `${this.host}:${this.port}`;
      }
      return `${this.socketPath}`;
    }
    static fromString(s2) {
      return new HostAddress(s2);
    }
    static fromHostPort(host, port) {
      if (host.includes(":")) {
        host = `[${host}]`;
      }
      return HostAddress.fromString(`${host}:${port}`);
    }
    static fromSrvRecord({ name, port }) {
      return HostAddress.fromHostPort(name, port);
    }
    toHostPort() {
      if (this.socketPath) {
        return { host: this.socketPath, port: 0 };
      }
      const host = this.host ?? "";
      const port = this.port ?? 0;
      return { host, port };
    }
  }
  exports.HostAddress = HostAddress;
  exports.DEFAULT_PK_FACTORY = {
    createPk() {
      return new bson_1.ObjectId;
    }
  };
  exports.MONGODB_WARNING_CODE = "MONGODB DRIVER";
  exports.emitWarning = emitWarning;
  var emittedWarnings = new Set;
  exports.emitWarningOnce = emitWarningOnce;
  exports.enumToString = enumToString;
  exports.supportsRetryableWrites = supportsRetryableWrites;
  exports.shuffle = shuffle;
  exports.commandSupportsReadConcern = commandSupportsReadConcern;
  exports.compareObjectId = compareObjectId;
  exports.parseInteger = parseInteger;
  exports.parseUnsignedInteger = parseUnsignedInteger;
  exports.matchesParentDomain = matchesParentDomain;
  exports.request = request;

  class TimeoutController extends AbortController {
    constructor(timeout = 0, timeoutId = timeout > 0 ? (0, timers_1.setTimeout)(() => this.abort(), timeout) : null) {
      super();
      this.timeoutId = timeoutId;
    }
    clear() {
      if (this.timeoutId != null) {
        (0, timers_1.clearTimeout)(this.timeoutId);
      }
      this.timeoutId = null;
    }
  }
  exports.TimeoutController = TimeoutController;
  exports.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
  exports.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
  exports.DOCUMENT_DB_MSG = "You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb";
  exports.COSMOS_DB_MSG = "You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb";
  exports.isHostMatch = isHostMatch;
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS((exports) => {
  var defineAspects = function(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
      aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, "aspects", {
      value: aspects,
      writable: false
    });
    return aspects;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineAspects = exports.AbstractOperation = exports.Aspect = undefined;
  var bson_1 = require_bson2();
  var read_preference_1 = require_read_preference();
  exports.Aspect = {
    READ_OPERATION: Symbol("READ_OPERATION"),
    WRITE_OPERATION: Symbol("WRITE_OPERATION"),
    RETRYABLE: Symbol("RETRYABLE"),
    EXPLAINABLE: Symbol("EXPLAINABLE"),
    SKIP_COLLATION: Symbol("SKIP_COLLATION"),
    CURSOR_CREATING: Symbol("CURSOR_CREATING"),
    MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER")
  };
  var kSession = Symbol("session");

  class AbstractOperation {
    constructor(options = {}) {
      this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : read_preference_1.ReadPreference.fromOptions(options) ?? read_preference_1.ReadPreference.primary;
      this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
      this[kSession] = options.session != null ? options.session : undefined;
      this.options = options;
      this.bypassPinningCheck = !!options.bypassPinningCheck;
      this.trySecondaryWrite = false;
    }
    hasAspect(aspect) {
      const ctor = this.constructor;
      if (ctor.aspects == null) {
        return false;
      }
      return ctor.aspects.has(aspect);
    }
    get session() {
      return this[kSession];
    }
    clearSession() {
      this[kSession] = undefined;
    }
    get canRetryRead() {
      return true;
    }
    get canRetryWrite() {
      return true;
    }
  }
  exports.AbstractOperation = AbstractOperation;
  exports.defineAspects = defineAspects;
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS((exports) => {
  var executeOperation = function(client, operation, callback) {
    return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);
  };
  async function executeOperationAsync(client, operation) {
    if (!(operation instanceof operation_1.AbstractOperation)) {
      throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
    }
    if (client.topology == null) {
      if (client.s.hasBeenClosed) {
        throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
      }
      client.s.options[Symbol.for("@@mdb.skipPingOnConnect")] = true;
      try {
        await client.connect();
      } finally {
        delete client.s.options[Symbol.for("@@mdb.skipPingOnConnect")];
      }
    }
    const { topology } = client;
    if (topology == null) {
      throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
    }
    let session = operation.session;
    let owner;
    if (session == null) {
      owner = Symbol();
      session = client.startSession({ owner, explicit: false });
    } else if (session.hasEnded) {
      throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
      throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
    } else if (session.client !== client) {
      throw new error_1.MongoInvalidArgumentError("ClientSession must be from the same MongoClient");
    }
    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
    const inTransaction = !!session?.inTransaction();
    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {
      throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
    }
    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
      session.unpin();
    }
    let selector;
    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
      selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
    } else if (operation.trySecondaryWrite) {
      selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
    } else {
      selector = readPreference;
    }
    const server = await topology.selectServerAsync(selector, { session });
    if (session == null) {
      return operation.execute(server, undefined);
    }
    if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {
      try {
        return await operation.execute(server, session);
      } finally {
        if (session?.owner != null && session.owner === owner) {
          await session.endSession().catch(() => null);
        }
      }
    }
    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
    const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;
    if (hasWriteAspect && willRetryWrite) {
      operation.options.willRetryWrite = true;
      session.incrementTransactionNumber();
    }
    try {
      return await operation.execute(server, session);
    } catch (operationError) {
      if (willRetry && operationError instanceof error_1.MongoError) {
        return await retryOperation(operation, operationError, {
          session,
          topology,
          selector
        });
      }
      throw operationError;
    } finally {
      if (session?.owner != null && session.owner === owner) {
        await session.endSession().catch(() => null);
      }
    }
  }
  async function retryOperation(operation, originalError, { session, topology, selector }) {
    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
      throw new error_1.MongoServerError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError
      });
    }
    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {
      throw originalError;
    }
    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {
      throw originalError;
    }
    if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {
      session.unpin({ force: true, forceClear: true });
    }
    const server = await topology.selectServerAsync(selector, { session });
    if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {
      throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
    }
    try {
      return await operation.execute(server, session);
    } catch (retryError) {
      if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
        throw originalError;
      }
      throw retryError;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeOperation = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var server_selection_1 = require_server_selection();
  var utils_1 = require_utils();
  var operation_1 = require_operation();
  var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
  var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
  exports.executeOperation = executeOperation;
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Explain = exports.ExplainVerbosity = undefined;
  var error_1 = require_error();
  exports.ExplainVerbosity = Object.freeze({
    queryPlanner: "queryPlanner",
    queryPlannerExtended: "queryPlannerExtended",
    executionStats: "executionStats",
    allPlansExecution: "allPlansExecution"
  });

  class Explain {
    constructor(verbosity) {
      if (typeof verbosity === "boolean") {
        this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
      } else {
        this.verbosity = verbosity;
      }
    }
    static fromOptions(options) {
      if (options?.explain == null)
        return;
      const explain = options.explain;
      if (typeof explain === "boolean" || typeof explain === "string") {
        return new Explain(explain);
      }
      throw new error_1.MongoInvalidArgumentError('Field "explain" must be a string or a boolean');
    }
  }
  exports.Explain = Explain;
});

// node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommandOperation = undefined;
  var error_1 = require_error();
  var explain_1 = require_explain();
  var read_concern_1 = require_read_concern();
  var server_selection_1 = require_server_selection();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var operation_1 = require_operation();

  class CommandOperation extends operation_1.AbstractOperation {
    constructor(parent, options) {
      super(options);
      this.options = options ?? {};
      const dbNameOverride = options?.dbName || options?.authdb;
      if (dbNameOverride) {
        this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
      } else {
        this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        this.explain = explain_1.Explain.fromOptions(options);
      } else if (options?.explain != null) {
        throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
      }
    }
    get canRetryWrite() {
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        return this.explain == null;
      }
      return true;
    }
    async executeCommand(server, session, cmd) {
      this.server = server;
      const options = {
        ...this.options,
        ...this.bsonOptions,
        readPreference: this.readPreference,
        session
      };
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const inTransaction = this.session && this.session.inTransaction();
      if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
        Object.assign(cmd, { readConcern: this.readConcern });
      }
      if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        options.omitReadPreference = true;
      }
      if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
        write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
      }
      if (options.collation && typeof options.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
        Object.assign(cmd, { collation: options.collation });
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
        cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
      }
      return server.commandAsync(this.ns, cmd, options);
    }
  }
  exports.CommandOperation = CommandOperation;
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListDatabasesOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListDatabasesOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options ?? {};
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    async execute(server, session) {
      const cmd = { listDatabases: 1 };
      if (typeof this.options.nameOnly === "boolean") {
        cmd.nameOnly = this.options.nameOnly;
      }
      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }
      if (typeof this.options.authorizedDatabases === "boolean") {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      }
      if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      return super.executeCommand(server, session, cmd);
    }
  }
  exports.ListDatabasesOperation = ListDatabasesOperation;
  (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoveUserOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RemoveUserOperation extends command_1.CommandOperation {
    constructor(db, username, options) {
      super(db, options);
      this.options = options;
      this.username = username;
    }
    async execute(server, session) {
      await super.executeCommand(server, session, { dropUser: this.username });
      return true;
    }
  }
  exports.RemoveUserOperation = RemoveUserOperation;
  (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunAdminCommandOperation = exports.RunCommandOperation = undefined;
  var utils_1 = require_utils();
  var operation_1 = require_operation();

  class RunCommandOperation extends operation_1.AbstractOperation {
    constructor(parent, command, options) {
      super(options);
      this.command = command;
      this.options = options;
      this.ns = parent.s.namespace.withCollection("$cmd");
    }
    async execute(server, session) {
      this.server = server;
      return server.commandAsync(this.ns, this.command, {
        ...this.options,
        readPreference: this.readPreference,
        session
      });
    }
  }
  exports.RunCommandOperation = RunCommandOperation;

  class RunAdminCommandOperation extends operation_1.AbstractOperation {
    constructor(command, options) {
      super(options);
      this.command = command;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    async execute(server, session) {
      this.server = server;
      return server.commandAsync(this.ns, this.command, {
        ...this.options,
        readPreference: this.readPreference,
        session
      });
    }
  }
  exports.RunAdminCommandOperation = RunAdminCommandOperation;
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidateCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ValidateCollectionOperation extends command_1.CommandOperation {
    constructor(admin, collectionName, options) {
      const command = { validate: collectionName };
      const keys = Object.keys(options);
      for (let i2 = 0;i2 < keys.length; i2++) {
        if (Object.prototype.hasOwnProperty.call(options, keys[i2]) && keys[i2] !== "session") {
          command[keys[i2]] = options[keys[i2]];
        }
      }
      super(admin.s.db, options);
      this.options = options;
      this.command = command;
      this.collectionName = collectionName;
    }
    async execute(server, session) {
      const collectionName = this.collectionName;
      const doc = await super.executeCommand(server, session, this.command);
      if (doc.result != null && typeof doc.result !== "string")
        throw new error_1.MongoUnexpectedServerResponseError("Error with validation data");
      if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
        throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
      if (doc.valid != null && !doc.valid)
        throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
      return doc;
    }
  }
  exports.ValidateCollectionOperation = ValidateCollectionOperation;
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Admin = undefined;
  var bson_1 = require_bson2();
  var execute_operation_1 = require_execute_operation();
  var list_databases_1 = require_list_databases();
  var remove_user_1 = require_remove_user();
  var run_command_1 = require_run_command();
  var validate_collection_1 = require_validate_collection();

  class Admin {
    constructor(db) {
      this.s = { db };
    }
    async command(command, options) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunAdminCommandOperation(command, {
        ...(0, bson_1.resolveBSONOptions)(options),
        session: options?.session,
        readPreference: options?.readPreference
      }));
    }
    async buildInfo(options) {
      return this.command({ buildinfo: 1 }, options);
    }
    async serverInfo(options) {
      return this.command({ buildinfo: 1 }, options);
    }
    async serverStatus(options) {
      return this.command({ serverStatus: 1 }, options);
    }
    async ping(options) {
      return this.command({ ping: 1 }, options);
    }
    async removeUser(username, options) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: "admin", ...options }));
    }
    async validateCollection(collectionName, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options));
    }
    async listDatabases(options) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, options));
    }
    async replSetGetStatus(options) {
      return this.command({ replSetGetStatus: 1 }, options);
    }
  }
  exports.Admin = Admin;
});

// node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS((exports) => {
  var makeDeleteStatement = function(filter, options) {
    const op = {
      q: filter,
      limit: typeof options.limit === "number" ? options.limit : 0
    };
    if (options.collation) {
      op.collation = options.collation;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    return op;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeDeleteStatement = exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DeleteOperation extends command_1.CommandOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
    }
    async execute(server, session) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        delete: this.ns.collection,
        deletes: this.statements,
        ordered
      };
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o2) => o2.hint)) {
          throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
        }
      }
      return super.executeCommand(server, session, command);
    }
  }
  exports.DeleteOperation = DeleteOperation;

  class DeleteOneOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);
    }
    async execute(server, session) {
      const res = await super.execute(server, session);
      if (this.explain)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        deletedCount: res.n
      };
    }
  }
  exports.DeleteOneOperation = DeleteOneOperation;

  class DeleteManyOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);
    }
    async execute(server, session) {
      const res = await super.execute(server, session);
      if (this.explain)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        deletedCount: res.n
      };
    }
  }
  exports.DeleteManyOperation = DeleteManyOperation;
  exports.makeDeleteStatement = makeDeleteStatement;
  (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DeleteOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(DeleteManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkWriteOperation = undefined;
  var operation_1 = require_operation();

  class BulkWriteOperation extends operation_1.AbstractOperation {
    constructor(collection, operations, options) {
      super(options);
      this.options = options;
      this.collection = collection;
      this.operations = operations;
    }
    async execute(server, session) {
      const coll = this.collection;
      const operations = this.operations;
      const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
      const bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options);
      for (let i2 = 0;i2 < operations.length; i2++) {
        bulk.raw(operations[i2]);
      }
      const result = await bulk.execute({ ...options, session });
      return result;
    }
  }
  exports.BulkWriteOperation = BulkWriteOperation;
  (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS((exports) => {
  async function indexInformation(db, name, options) {
    if (options == null) {
      options = {};
    }
    const full = options.full == null ? false : options.full;
    const indexes = await db.collection(name).listIndexes(options).toArray();
    if (full)
      return indexes;
    const info = {};
    for (const index of indexes) {
      info[index.name] = Object.entries(index.key);
    }
    return info;
  }
  var prepareDocs = function(coll, docs, options) {
    const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options?.forceServerObjectId;
    if (forceServerObjectId === true) {
      return docs;
    }
    return docs.map((doc) => {
      if (doc._id == null) {
        doc._id = coll.s.pkFactory.createPk();
      }
      return doc;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareDocs = exports.indexInformation = undefined;
  exports.indexInformation = indexInformation;
  exports.prepareDocs = prepareDocs;
});

// node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = undefined;
  var error_1 = require_error();
  var write_concern_1 = require_write_concern();
  var bulk_write_1 = require_bulk_write();
  var command_1 = require_command();
  var common_functions_1 = require_common_functions();
  var operation_1 = require_operation();

  class InsertOperation extends command_1.CommandOperation {
    constructor(ns, documents, options) {
      super(undefined, options);
      this.options = { ...options, checkKeys: options.checkKeys ?? false };
      this.ns = ns;
      this.documents = documents;
    }
    async execute(server, session) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        insert: this.ns.collection,
        documents: this.documents,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      return super.executeCommand(server, session, command);
    }
  }
  exports.InsertOperation = InsertOperation;

  class InsertOneOperation extends InsertOperation {
    constructor(collection, doc, options) {
      super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);
    }
    async execute(server, session) {
      const res = await super.execute(server, session);
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors) {
        throw new error_1.MongoServerError(res.writeErrors[0]);
      }
      return {
        acknowledged: this.writeConcern?.w !== 0,
        insertedId: this.documents[0]._id
      };
    }
  }
  exports.InsertOneOperation = InsertOneOperation;

  class InsertManyOperation extends operation_1.AbstractOperation {
    constructor(collection, docs, options) {
      super(options);
      if (!Array.isArray(docs)) {
        throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
      }
      this.options = options;
      this.collection = collection;
      this.docs = docs;
    }
    async execute(server, session) {
      const coll = this.collection;
      const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map((document) => ({ insertOne: { document } })), options);
      try {
        const res = await bulkWriteOperation.execute(server, session);
        return {
          acknowledged: writeConcern?.w !== 0,
          insertedCount: res.insertedCount,
          insertedIds: res.insertedIds
        };
      } catch (err) {
        if (err && err.message === "Operation must be an object with an operation key") {
          throw new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
        }
        throw err;
      }
    }
  }
  exports.InsertManyOperation = InsertManyOperation;
  (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/update.js
var require_update = __commonJS((exports) => {
  var makeUpdateStatement = function(filter, update, options) {
    if (filter == null || typeof filter !== "object") {
      throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
    }
    if (update == null || typeof update !== "object") {
      throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
    }
    const op = { q: filter, u: update };
    if (typeof options.upsert === "boolean") {
      op.upsert = options.upsert;
    }
    if (options.multi) {
      op.multi = options.multi;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    if (options.arrayFilters) {
      op.arrayFilters = options.arrayFilters;
    }
    if (options.collation) {
      op.collation = options.collation;
    }
    return op;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeUpdateStatement = exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class UpdateOperation extends command_1.CommandOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.multi == null || op.multi === false);
    }
    async execute(server, session) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        update: this.ns.collection,
        updates: this.statements,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o2) => o2.hint)) {
          throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
        }
      }
      return super.executeCommand(server, session, command);
    }
  }
  exports.UpdateOperation = UpdateOperation;

  class UpdateOneOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: false })], options);
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    async execute(server, session) {
      const res = await super.execute(server, session);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.UpdateOneOperation = UpdateOneOperation;

  class UpdateManyOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: true })], options);
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    async execute(server, session) {
      const res = await super.execute(server, session);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.UpdateManyOperation = UpdateManyOperation;

  class ReplaceOneOperation extends UpdateOperation {
    constructor(collection, filter, replacement, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options, multi: false })], options);
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
    }
    async execute(server, session) {
      const res = await super.execute(server, session);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.ReplaceOneOperation = ReplaceOneOperation;
  exports.makeUpdateStatement = makeUpdateStatement;
  (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
  (0, operation_1.defineAspects)(UpdateOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(UpdateManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(ReplaceOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS((exports) => {
  var mergeBatchResults = function(batch, bulkResult, err, result) {
    if (err) {
      result = err;
    } else if (result && result.result) {
      result = result.result;
    }
    if (result == null) {
      return;
    }
    if (result.ok === 0 && bulkResult.ok === 1) {
      bulkResult.ok = 0;
      const writeError = {
        index: 0,
        code: result.code || 0,
        errmsg: result.message,
        errInfo: result.errInfo,
        op: batch.operations[0]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
      return;
    } else if (result.ok === 0 && bulkResult.ok === 0) {
      return;
    }
    if (isInsertBatch(batch) && result.n) {
      bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    if (isDeleteBatch(batch) && result.n) {
      bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    let nUpserted = 0;
    if (Array.isArray(result.upserted)) {
      nUpserted = result.upserted.length;
      for (let i2 = 0;i2 < result.upserted.length; i2++) {
        bulkResult.upserted.push({
          index: result.upserted[i2].index + batch.originalZeroIndex,
          _id: result.upserted[i2]._id
        });
      }
    } else if (result.upserted) {
      nUpserted = 1;
      bulkResult.upserted.push({
        index: batch.originalZeroIndex,
        _id: result.upserted
      });
    }
    if (isUpdateBatch(batch) && result.n) {
      const nModified = result.nModified;
      bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
      bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
      if (typeof nModified === "number") {
        bulkResult.nModified = bulkResult.nModified + nModified;
      } else {
        bulkResult.nModified = 0;
      }
    }
    if (Array.isArray(result.writeErrors)) {
      for (let i2 = 0;i2 < result.writeErrors.length; i2++) {
        const writeError = {
          index: batch.originalIndexes[result.writeErrors[i2].index],
          code: result.writeErrors[i2].code,
          errmsg: result.writeErrors[i2].errmsg,
          errInfo: result.writeErrors[i2].errInfo,
          op: batch.operations[result.writeErrors[i2].index]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
      }
    }
    if (result.writeConcernError) {
      bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
  };
  var executeCommands = function(bulkOperation, options, callback) {
    if (bulkOperation.s.batches.length === 0) {
      return callback(undefined, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
    }
    const batch = bulkOperation.s.batches.shift();
    function resultHandler(err, result) {
      if (err && "message" in err && !(err instanceof error_1.MongoWriteConcernError)) {
        return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered)));
      }
      if (err instanceof error_1.MongoWriteConcernError) {
        return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, bulkOperation.isOrdered, err, callback);
      }
      mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
      const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      if (bulkOperation.handleWriteError(callback, writeResult))
        return;
      executeCommands(bulkOperation, options, callback);
    }
    const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
      ...options,
      ordered: bulkOperation.isOrdered
    });
    if (finalOptions.bypassDocumentValidation !== true) {
      delete finalOptions.bypassDocumentValidation;
    }
    if (bulkOperation.operationId) {
      resultHandler.operationId = bulkOperation.operationId;
    }
    if (bulkOperation.s.bypassDocumentValidation === true) {
      finalOptions.bypassDocumentValidation = true;
    }
    if (bulkOperation.s.checkKeys === false) {
      finalOptions.checkKeys = false;
    }
    if (finalOptions.retryWrites) {
      if (isUpdateBatch(batch)) {
        finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
      }
      if (isDeleteBatch(batch)) {
        finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
      }
    }
    try {
      if (isInsertBatch(batch)) {
        (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
      } else if (isUpdateBatch(batch)) {
        (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
      } else if (isDeleteBatch(batch)) {
        (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
      }
    } catch (err) {
      err.ok = 0;
      mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);
      callback();
    }
  };
  var handleMongoWriteConcernError = function(batch, bulkResult, isOrdered, err, callback) {
    mergeBatchResults(batch, bulkResult, undefined, err.result);
    callback(new MongoBulkWriteError({
      message: err.result?.writeConcernError.errmsg,
      code: err.result?.writeConcernError.result
    }, new BulkWriteResult(bulkResult, isOrdered)));
  };
  var shouldForceServerObjectId = function(bulkOperation) {
    if (typeof bulkOperation.s.options.forceServerObjectId === "boolean") {
      return bulkOperation.s.options.forceServerObjectId;
    }
    if (typeof bulkOperation.s.collection.s.db.options?.forceServerObjectId === "boolean") {
      return bulkOperation.s.collection.s.db.options?.forceServerObjectId;
    }
    return false;
  };
  var isInsertBatch = function(batch) {
    return batch.batchType === exports.BatchType.INSERT;
  };
  var isUpdateBatch = function(batch) {
    return batch.batchType === exports.BatchType.UPDATE;
  };
  var isDeleteBatch = function(batch) {
    return batch.batchType === exports.BatchType.DELETE;
  };
  var buildCurrentOp = function(bulkOp) {
    let { currentOp } = bulkOp.s;
    bulkOp.s.currentOp = undefined;
    if (!currentOp)
      currentOp = {};
    return currentOp;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkOperationBase = exports.FindOperators = exports.MongoBulkWriteError = exports.mergeBatchResults = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = undefined;
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var delete_1 = require_delete();
  var execute_operation_1 = require_execute_operation();
  var insert_1 = require_insert();
  var operation_1 = require_operation();
  var update_1 = require_update();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var kServerError = Symbol("serverError");
  exports.BatchType = Object.freeze({
    INSERT: 1,
    UPDATE: 2,
    DELETE: 3
  });

  class Batch {
    constructor(batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    }
  }
  exports.Batch = Batch;

  class BulkWriteResult {
    static generateIdMap(ids) {
      const idMap = {};
      for (const doc of ids) {
        idMap[doc.index] = doc._id;
      }
      return idMap;
    }
    constructor(bulkResult, isOrdered) {
      this.result = bulkResult;
      this.insertedCount = this.result.nInserted ?? 0;
      this.matchedCount = this.result.nMatched ?? 0;
      this.modifiedCount = this.result.nModified ?? 0;
      this.deletedCount = this.result.nRemoved ?? 0;
      this.upsertedCount = this.result.upserted.length ?? 0;
      this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
      this.insertedIds = BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
      Object.defineProperty(this, "result", { value: this.result, enumerable: false });
    }
    get ok() {
      return this.result.ok;
    }
    getSuccessfullyInsertedIds(bulkResult, isOrdered) {
      if (bulkResult.writeErrors.length === 0)
        return bulkResult.insertedIds;
      if (isOrdered) {
        return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
      }
      return bulkResult.insertedIds.filter(({ index }) => !bulkResult.writeErrors.some((writeError) => index === writeError.index));
    }
    getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    getRawResponse() {
      return this.result;
    }
    hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    getWriteErrorAt(index) {
      return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    }
    getWriteErrors() {
      return this.result.writeErrors;
    }
    getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return;
      } else if (this.result.writeConcernErrors.length === 1) {
        return this.result.writeConcernErrors[0];
      } else {
        let errmsg = "";
        for (let i2 = 0;i2 < this.result.writeConcernErrors.length; i2++) {
          const err = this.result.writeConcernErrors[i2];
          errmsg = errmsg + err.errmsg;
          if (i2 === 0)
            errmsg = errmsg + " and ";
        }
        return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });
      }
    }
    toString() {
      return `BulkWriteResult(${this.result})`;
    }
    isOk() {
      return this.result.ok === 1;
    }
  }
  exports.BulkWriteResult = BulkWriteResult;

  class WriteConcernError {
    constructor(error21) {
      this[kServerError] = error21;
    }
    get code() {
      return this[kServerError].code;
    }
    get errmsg() {
      return this[kServerError].errmsg;
    }
    get errInfo() {
      return this[kServerError].errInfo;
    }
    toJSON() {
      return this[kServerError];
    }
    toString() {
      return `WriteConcernError(${this.errmsg})`;
    }
  }
  exports.WriteConcernError = WriteConcernError;

  class WriteError {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get index() {
      return this.err.index;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    get errInfo() {
      return this.err.errInfo;
    }
    getOperation() {
      return this.err.op;
    }
    toJSON() {
      return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
    }
    toString() {
      return `WriteError(${JSON.stringify(this.toJSON())})`;
    }
  }
  exports.WriteError = WriteError;
  exports.mergeBatchResults = mergeBatchResults;

  class MongoBulkWriteError extends error_1.MongoServerError {
    constructor(error21, result) {
      super(error21);
      this.writeErrors = [];
      if (error21 instanceof WriteConcernError)
        this.err = error21;
      else if (!(error21 instanceof Error)) {
        this.message = error21.message;
        this.code = error21.code;
        this.writeErrors = error21.writeErrors ?? [];
      }
      this.result = result;
      Object.assign(this, error21);
    }
    get name() {
      return "MongoBulkWriteError";
    }
    get insertedCount() {
      return this.result.insertedCount;
    }
    get matchedCount() {
      return this.result.matchedCount;
    }
    get modifiedCount() {
      return this.result.modifiedCount;
    }
    get deletedCount() {
      return this.result.deletedCount;
    }
    get upsertedCount() {
      return this.result.upsertedCount;
    }
    get insertedIds() {
      return this.result.insertedIds;
    }
    get upsertedIds() {
      return this.result.upsertedIds;
    }
  }
  exports.MongoBulkWriteError = MongoBulkWriteError;

  class FindOperators {
    constructor(bulkOperation) {
      this.bulkOperation = bulkOperation;
    }
    update(updateDocument) {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
        ...currentOp,
        multi: true
      }));
    }
    updateOne(updateDocument) {
      if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
    }
    replaceOne(replacement) {
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
    }
    deleteOne() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
    }
    delete() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
    }
    upsert() {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.upsert = true;
      return this;
    }
    collation(collation) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.collation = collation;
      return this;
    }
    arrayFilters(arrayFilters) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
      return this;
    }
    hint(hint) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.hint = hint;
      return this;
    }
  }
  exports.FindOperators = FindOperators;
  var executeCommandsAsync = (0, util_1.promisify)(executeCommands);

  class BulkWriteShimOperation extends operation_1.AbstractOperation {
    constructor(bulkOperation, options) {
      super(options);
      this.bulkOperation = bulkOperation;
    }
    execute(_server, session) {
      if (this.options.session == null) {
        this.options.session = session;
      }
      return executeCommandsAsync(this.bulkOperation, this.options);
    }
  }

  class BulkOperationBase {
    constructor(collection, options, isOrdered) {
      this.isOrdered = isOrdered;
      const topology = (0, utils_1.getTopology)(collection);
      options = options == null ? {} : options;
      const namespace = collection.s.namespace;
      const executed = false;
      const currentOp = undefined;
      const hello = topology.lastHello();
      const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
      const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
      const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
      const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000;
      const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
      let finalOptions = Object.assign({}, options);
      finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
      const bulkResult = {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };
      this.s = {
        bulkResult,
        currentBatch: undefined,
        currentIndex: 0,
        currentBatchSize: 0,
        currentBatchSizeBytes: 0,
        currentInsertBatch: undefined,
        currentUpdateBatch: undefined,
        currentRemoveBatch: undefined,
        batches: [],
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        maxBsonObjectSize,
        maxBatchSizeBytes,
        maxWriteBatchSize,
        maxKeySize,
        namespace,
        topology,
        options: finalOptions,
        bsonOptions: (0, bson_1.resolveBSONOptions)(options),
        currentOp,
        executed,
        collection,
        err: undefined,
        checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : false
      };
      if (options.bypassDocumentValidation === true) {
        this.s.bypassDocumentValidation = true;
      }
    }
    insert(document) {
      if (document._id == null && !shouldForceServerObjectId(this)) {
        document._id = new bson_1.ObjectId;
      }
      return this.addToOperationsList(exports.BatchType.INSERT, document);
    }
    find(selector) {
      if (!selector) {
        throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
      }
      this.s.currentOp = {
        selector
      };
      return new FindOperators(this);
    }
    raw(op) {
      if (op == null || typeof op !== "object") {
        throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
      }
      if ("insertOne" in op) {
        const forceServerObjectId = shouldForceServerObjectId(this);
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null) {
            op.insertOne._id = new bson_1.ObjectId;
          }
          return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne);
        }
        if (forceServerObjectId !== true && op.insertOne.document._id == null) {
          op.insertOne.document._id = new bson_1.ObjectId;
        }
        return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne.document);
      }
      if ("replaceOne" in op || "updateOne" in op || "updateMany" in op) {
        if ("replaceOne" in op) {
          if ("q" in op.replaceOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
          if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateOne" in op) {
          if ("q" in op.updateOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
            ...op.updateOne,
            multi: false
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateMany" in op) {
          if ("q" in op.updateMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
            ...op.updateMany,
            multi: true
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
      }
      if ("deleteOne" in op) {
        if ("q" in op.deleteOne) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
      }
      if ("deleteMany" in op) {
        if ("q" in op.deleteMany) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
      }
      throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get batches() {
      const batches = [...this.s.batches];
      if (this.isOrdered) {
        if (this.s.currentBatch)
          batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          batches.push(this.s.currentRemoveBatch);
      }
      return batches;
    }
    async execute(options = {}) {
      if (this.s.executed) {
        throw new error_1.MongoBatchReExecutionError;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        this.s.writeConcern = writeConcern;
      }
      if (this.isOrdered) {
        if (this.s.currentBatch)
          this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          this.s.batches.push(this.s.currentRemoveBatch);
      }
      if (this.s.batches.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
      }
      this.s.executed = true;
      const finalOptions = { ...this.s.options, ...options };
      const operation = new BulkWriteShimOperation(this, finalOptions);
      return (0, execute_operation_1.executeOperation)(this.s.collection.client, operation);
    }
    handleWriteError(callback, writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
        callback(new MongoBulkWriteError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }, writeResult));
        return true;
      }
      const writeConcernError = writeResult.getWriteConcernError();
      if (writeConcernError) {
        callback(new MongoBulkWriteError(writeConcernError, writeResult));
        return true;
      }
      return false;
    }
  }
  exports.BulkOperationBase = BulkOperationBase;
  Object.defineProperty(BulkOperationBase.prototype, "length", {
    enumerable: true,
    get() {
      return this.s.currentIndex;
    }
  });
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common2();

  class OrderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, true);
    }
    addToOperationsList(batchType, document) {
      const bsonSize = BSON.calculateObjectSize(document, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize)
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        this.s.currentBatchSize = 0;
        this.s.currentBatchSizeBytes = 0;
      }
      if (batchType === common_1.BatchType.INSERT) {
        this.s.bulkResult.insertedIds.push({
          index: this.s.currentIndex,
          _id: document._id
        });
      }
      if (Array.isArray(document)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentBatch.operations.push(document);
      this.s.currentBatchSize += 1;
      this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      this.s.currentIndex += 1;
      return this;
    }
  }
  exports.OrderedBulkOperation = OrderedBulkOperation;
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnorderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common2();

  class UnorderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, false);
    }
    handleWriteError(callback, writeResult) {
      if (this.s.batches.length) {
        return false;
      }
      return super.handleWriteError(callback, writeResult);
    }
    addToOperationsList(batchType, document) {
      const bsonSize = BSON.calculateObjectSize(document, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      }
      this.s.currentBatch = undefined;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentBatch = this.s.currentInsertBatch;
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentBatch = this.s.currentUpdateBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentBatch = this.s.currentRemoveBatch;
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (Array.isArray(document)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.operations.push(document);
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentIndex = this.s.currentIndex + 1;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentInsertBatch = this.s.currentBatch;
        this.s.bulkResult.insertedIds.push({
          index: this.s.bulkResult.insertedIds.length,
          _id: document._id
        });
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentUpdateBatch = this.s.currentBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentRemoveBatch = this.s.currentBatch;
      }
      this.s.currentBatch.size += 1;
      this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return this;
    }
  }
  exports.UnorderedBulkOperation = UnorderedBulkOperation;
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.DB_AGGREGATE_COLLECTION = 1;
  var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;

  class AggregateOperation extends command_1.CommandOperation {
    constructor(ns, pipeline, options) {
      super(undefined, { ...options, dbName: ns.db });
      this.options = { ...options };
      this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
      this.pipeline = pipeline;
      this.hasWriteStage = false;
      if (typeof options?.out === "string") {
        this.pipeline = this.pipeline.concat({ $out: options.out });
        this.hasWriteStage = true;
      } else if (pipeline.length > 0) {
        const finalStage = pipeline[pipeline.length - 1];
        if (finalStage.$out || finalStage.$merge) {
          this.hasWriteStage = true;
        }
      }
      if (this.hasWriteStage) {
        this.trySecondaryWrite = true;
      } else {
        delete this.options.writeConcern;
      }
      if (this.explain && this.writeConcern) {
        throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
      }
      if (options?.cursor != null && typeof options.cursor !== "object") {
        throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
      }
    }
    get canRetryRead() {
      return !this.hasWriteStage;
    }
    addToPipeline(stage) {
      this.pipeline.push(stage);
    }
    async execute(server, session) {
      const options = this.options;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const command = { aggregate: this.target, pipeline: this.pipeline };
      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = undefined;
      }
      if (this.hasWriteStage && this.writeConcern) {
        write_concern_1.WriteConcern.apply(command, this.writeConcern);
      }
      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        command.allowDiskUse = options.allowDiskUse;
      }
      if (options.hint) {
        command.hint = options.hint;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      command.cursor = options.cursor || {};
      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }
      return super.executeCommand(server, session, command);
    }
  }
  exports.AggregateOperation = AggregateOperation;
  (0, operation_1.defineAspects)(AggregateOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationToken = exports.TypedEventEmitter = undefined;
  var events_1 = import.meta.require("events");

  class TypedEventEmitter extends events_1.EventEmitter {
    emitAndLog(event, ...args) {
      this.emit(event, ...args);
      if (this.component)
        this.mongoLogger?.debug(this.component, args[0]);
    }
  }
  exports.TypedEventEmitter = TypedEventEmitter;

  class CancellationToken extends TypedEventEmitter {
  }
  exports.CancellationToken = CancellationToken;
});

// node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetMoreOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var operation_1 = require_operation();

  class GetMoreOperation extends operation_1.AbstractOperation {
    constructor(ns, cursorId, server, options) {
      super(options);
      this.options = options;
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    async execute(server, _session) {
      if (server !== this.server) {
        throw new error_1.MongoRuntimeError("Getmore must run on the same server operation began on");
      }
      if (this.cursorId == null || this.cursorId.isZero()) {
        throw new error_1.MongoRuntimeError("Unable to iterate cursor with no id");
      }
      const collection = this.ns.collection;
      if (collection == null) {
        throw new error_1.MongoRuntimeError("A collection name must be determined before getMore");
      }
      const getMoreCmd = {
        getMore: this.cursorId,
        collection
      };
      if (typeof this.options.batchSize === "number") {
        getMoreCmd.batchSize = Math.abs(this.options.batchSize);
      }
      if (typeof this.options.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
      }
      if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
        getMoreCmd.comment = this.options.comment;
      }
      const commandOptions = {
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch",
        ...this.options
      };
      return server.commandAsync(this.ns, getMoreCmd, commandOptions);
    }
  }
  exports.GetMoreOperation = GetMoreOperation;
  (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KillCursorsOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class KillCursorsOperation extends operation_1.AbstractOperation {
    constructor(cursorId, ns, server, options) {
      super(options);
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    async execute(server, session) {
      if (server !== this.server) {
        throw new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on");
      }
      const killCursors = this.ns.collection;
      if (killCursors == null) {
        throw new error_1.MongoRuntimeError("A collection name must be determined before killCursors");
      }
      const killCursorsCommand = {
        killCursors,
        cursors: [this.cursorId]
      };
      try {
        await server.commandAsync(this.ns, killCursorsCommand, { session });
      } catch {
      }
    }
  }
  exports.KillCursorsOperation = KillCursorsOperation;
  (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolMetrics = undefined;

  class ConnectionPoolMetrics {
    constructor() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
    markPinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections += 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections += 1;
      } else {
        this.otherConnections += 1;
      }
    }
    markUnpinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections -= 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections -= 1;
      } else {
        this.otherConnections -= 1;
      }
    }
    info(maxPoolSize) {
      return "Timed out while checking out a connection from connection pool: " + `maxPoolSize: ${maxPoolSize}, ` + `connections in use by cursors: ${this.cursorConnections}, ` + `connections in use by transactions: ${this.txnConnections}, ` + `connections in use by other operations: ${this.otherConnections}`;
    }
    reset() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
  }
  ConnectionPoolMetrics.TXN = "txn";
  ConnectionPoolMetrics.CURSOR = "cursor";
  ConnectionPoolMetrics.OTHER = "other";
  exports.ConnectionPoolMetrics = ConnectionPoolMetrics;
});

// node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS((exports) => {
  var parseServerType = function(hello, options) {
    if (options?.loadBalanced) {
      return common_1.ServerType.LoadBalancer;
    }
    if (!hello || !hello.ok) {
      return common_1.ServerType.Unknown;
    }
    if (hello.isreplicaset) {
      return common_1.ServerType.RSGhost;
    }
    if (hello.msg && hello.msg === "isdbgrid") {
      return common_1.ServerType.Mongos;
    }
    if (hello.setName) {
      if (hello.hidden) {
        return common_1.ServerType.RSOther;
      } else if (hello.isWritablePrimary) {
        return common_1.ServerType.RSPrimary;
      } else if (hello.secondary) {
        return common_1.ServerType.RSSecondary;
      } else if (hello.arbiterOnly) {
        return common_1.ServerType.RSArbiter;
      } else {
        return common_1.ServerType.RSOther;
      }
    }
    return common_1.ServerType.Standalone;
  };
  var tagsStrictEqual = function(tags, tags2) {
    const tagsKeys = Object.keys(tags);
    const tags2Keys = Object.keys(tags2);
    return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
  };
  var compareTopologyVersion = function(currentTv, newTv) {
    if (currentTv == null || newTv == null) {
      return -1;
    }
    if (!currentTv.processId.equals(newTv.processId)) {
      return -1;
    }
    const currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
    const newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
    return currentCounter.compare(newCounter);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var WRITABLE_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.Standalone,
    common_1.ServerType.Mongos,
    common_1.ServerType.LoadBalancer
  ]);
  var DATA_BEARING_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.RSSecondary,
    common_1.ServerType.Mongos,
    common_1.ServerType.Standalone,
    common_1.ServerType.LoadBalancer
  ]);

  class ServerDescription {
    constructor(address, hello, options = {}) {
      if (address == null || address === "") {
        throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
      }
      this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
      this.type = parseServerType(hello, options);
      this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
      this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
      this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
      this.tags = hello?.tags ?? {};
      this.minWireVersion = hello?.minWireVersion ?? 0;
      this.maxWireVersion = hello?.maxWireVersion ?? 0;
      this.roundTripTime = options?.roundTripTime ?? -1;
      this.lastUpdateTime = (0, utils_1.now)();
      this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
      this.error = options.error ?? null;
      this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
      this.setName = hello?.setName ?? null;
      this.setVersion = hello?.setVersion ?? null;
      this.electionId = hello?.electionId ?? null;
      this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
      this.primary = hello?.primary ?? null;
      this.me = hello?.me?.toLowerCase() ?? null;
      this.$clusterTime = hello?.$clusterTime ?? null;
    }
    get hostAddress() {
      return utils_1.HostAddress.fromString(this.address);
    }
    get allHosts() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    get isReadable() {
      return this.type === common_1.ServerType.RSSecondary || this.isWritable;
    }
    get isDataBearing() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    get isWritable() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
    get host() {
      const chopLength = `:${this.port}`.length;
      return this.address.slice(0, -chopLength);
    }
    get port() {
      const port = this.address.split(":").pop();
      return port ? Number.parseInt(port, 10) : 27017;
    }
    equals(other) {
      const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion || compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
      const electionIdsEqual = this.electionId != null && other?.electionId != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === other?.electionId;
      return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  }
  exports.ServerDescription = ServerDescription;
  exports.parseServerType = parseServerType;
  exports.compareTopologyVersion = compareTopologyVersion;
});

// node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS((exports) => {
  var topologyTypeForServerType = function(serverType) {
    switch (serverType) {
      case common_1.ServerType.Standalone:
        return common_1.TopologyType.Single;
      case common_1.ServerType.Mongos:
        return common_1.TopologyType.Sharded;
      case common_1.ServerType.RSPrimary:
        return common_1.TopologyType.ReplicaSetWithPrimary;
      case common_1.ServerType.RSOther:
      case common_1.ServerType.RSSecondary:
        return common_1.TopologyType.ReplicaSetNoPrimary;
      default:
        return common_1.TopologyType.Unknown;
    }
  };
  var updateRsFromPrimary = function(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    if (serverDescription.maxWireVersion >= 17) {
      const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
      const maxElectionIdIsEqual = electionIdComparison === 0;
      const maxElectionIdIsLess = electionIdComparison === -1;
      const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
      if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
        maxElectionId = serverDescription.electionId;
        maxSetVersion = serverDescription.setVersion;
      } else {
        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
    } else {
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
    }
    for (const [address, server] of serverDescriptions) {
      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));
        break;
      }
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    const currentAddresses = Array.from(serverDescriptions.keys());
    const responseAddresses = serverDescription.allHosts;
    currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
      serverDescriptions.delete(address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  };
  var updateRsWithPrimaryFromMember = function(serverDescriptions, serverDescription, setName = null) {
    if (setName == null) {
      throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
    }
    if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
  };
  var updateRsNoPrimaryFromMember = function(serverDescriptions, serverDescription, setName = null) {
    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
    setName = setName ?? serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [topologyType, setName];
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return [topologyType, setName];
  };
  var checkHasPrimary = function(serverDescriptions) {
    for (const serverDescription of serverDescriptions.values()) {
      if (serverDescription.type === common_1.ServerType.RSPrimary) {
        return common_1.TopologyType.ReplicaSetWithPrimary;
      }
    }
    return common_1.TopologyType.ReplicaSetNoPrimary;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TopologyDescription = undefined;
  var WIRE_CONSTANTS = require_constants();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var server_description_1 = require_server_description();
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
  var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
  var NON_PRIMARY_RS_MEMBERS = new Set([
    common_1.ServerType.RSSecondary,
    common_1.ServerType.RSArbiter,
    common_1.ServerType.RSOther
  ]);

  class TopologyDescription {
    constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
      options = options ?? {};
      this.type = topologyType ?? common_1.TopologyType.Unknown;
      this.servers = serverDescriptions ?? new Map;
      this.stale = false;
      this.compatible = true;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;
      this.localThresholdMS = options.localThresholdMS ?? 15;
      this.setName = setName ?? null;
      this.maxElectionId = maxElectionId ?? null;
      this.maxSetVersion = maxSetVersion ?? null;
      this.commonWireVersion = commonWireVersion ?? 0;
      for (const serverDescription of this.servers.values()) {
        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
          continue;
        }
        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        }
        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
          break;
        }
      }
      this.logicalSessionTimeoutMinutes = null;
      for (const [, server] of this.servers) {
        if (server.isReadable) {
          if (server.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = null;
            break;
          }
          if (this.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
            continue;
          }
          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
        }
      }
    }
    updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
      const incomingHostnames = ev.hostnames();
      const currentHostnames = new Set(this.servers.keys());
      const hostnamesToAdd = new Set(incomingHostnames);
      const hostnamesToRemove = new Set;
      for (const hostname of currentHostnames) {
        hostnamesToAdd.delete(hostname);
        if (!incomingHostnames.has(hostname)) {
          hostnamesToRemove.add(hostname);
        }
      }
      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
        return this;
      }
      const serverDescriptions = new Map(this.servers);
      for (const removedHost of hostnamesToRemove) {
        serverDescriptions.delete(removedHost);
      }
      if (hostnamesToAdd.size > 0) {
        if (srvMaxHosts === 0) {
          for (const hostToAdd of hostnamesToAdd) {
            serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
          }
        } else if (serverDescriptions.size < srvMaxHosts) {
          const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
          for (const selectedHostToAdd of selectedHosts) {
            serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
          }
        }
      }
      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    update(serverDescription) {
      const address = serverDescription.address;
      let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
      const serverType = serverDescription.type;
      const serverDescriptions = new Map(this.servers);
      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }
      if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
        if (topologyType === common_1.TopologyType.Single) {
          serverDescription = new server_description_1.ServerDescription(address);
        } else {
          serverDescriptions.delete(address);
        }
      }
      serverDescriptions.set(address, serverDescription);
      if (topologyType === common_1.TopologyType.Single) {
        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      if (topologyType === common_1.TopologyType.Unknown) {
        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions.delete(address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }
      if (topologyType === common_1.TopologyType.Sharded) {
        if (!MONGOS_OR_UNKNOWN.has(serverType)) {
          serverDescriptions.delete(address);
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
        }
        if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
          topologyType = result[0];
          setName = result[1];
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }
      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    get error() {
      const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }
      return null;
    }
    get hasKnownServers() {
      return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
    }
    get hasDataBearingServers() {
      return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
    }
    hasServer(address) {
      return this.servers.has(address);
    }
  }
  exports.TopologyDescription = TopologyDescription;
});

// node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS((exports) => {
  var getReadPreference = function(options) {
    let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;
    if (options?.readPreference) {
      readPreference = options.readPreference;
    }
    if (typeof readPreference === "string") {
      readPreference = read_preference_1.ReadPreference.fromString(readPreference);
    }
    if (!(readPreference instanceof read_preference_1.ReadPreference)) {
      throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
    }
    return readPreference;
  };
  var isSharded = function(topologyOrServer) {
    if (topologyOrServer == null) {
      return false;
    }
    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
      return true;
    }
    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
      const servers = Array.from(topologyOrServer.description.servers.values());
      return servers.some((server) => server.type === common_1.ServerType.Mongos);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSharded = exports.getReadPreference = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var topology_description_1 = require_topology_description();
  exports.getReadPreference = getReadPreference;
  exports.isSharded = isSharded;
});

// node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS((exports) => {
  var isTransactionCommand = function(command) {
    return !!(command.commitTransaction || command.abortTransaction);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTransactionCommand = exports.Transaction = exports.TxnState = undefined;
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var write_concern_1 = require_write_concern();
  exports.TxnState = Object.freeze({
    NO_TRANSACTION: "NO_TRANSACTION",
    STARTING_TRANSACTION: "STARTING_TRANSACTION",
    TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
    TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
    TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
    TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
  });
  var stateMachine = {
    [exports.TxnState.NO_TRANSACTION]: [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
    [exports.TxnState.STARTING_TRANSACTION]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_IN_PROGRESS]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_COMMITTED]: [
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.STARTING_TRANSACTION,
      exports.TxnState.NO_TRANSACTION
    ],
    [exports.TxnState.TRANSACTION_ABORTED]: [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
    [exports.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.NO_TRANSACTION
    ]
  };
  var ACTIVE_STATES = new Set([
    exports.TxnState.STARTING_TRANSACTION,
    exports.TxnState.TRANSACTION_IN_PROGRESS
  ]);
  var COMMITTED_STATES = new Set([
    exports.TxnState.TRANSACTION_COMMITTED,
    exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
    exports.TxnState.TRANSACTION_ABORTED
  ]);

  class Transaction {
    constructor(options) {
      options = options ?? {};
      this.state = exports.TxnState.NO_TRANSACTION;
      this.options = {};
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        if (writeConcern.w === 0) {
          throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
        }
        this.options.writeConcern = writeConcern;
      }
      if (options.readConcern) {
        this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      }
      if (options.readPreference) {
        this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
      }
      if (options.maxCommitTimeMS) {
        this.options.maxTimeMS = options.maxCommitTimeMS;
      }
      this._pinnedServer = undefined;
      this._recoveryToken = undefined;
    }
    get server() {
      return this._pinnedServer;
    }
    get recoveryToken() {
      return this._recoveryToken;
    }
    get isPinned() {
      return !!this.server;
    }
    get isStarting() {
      return this.state === exports.TxnState.STARTING_TRANSACTION;
    }
    get isActive() {
      return ACTIVE_STATES.has(this.state);
    }
    get isCommitted() {
      return COMMITTED_STATES.has(this.state);
    }
    transition(nextState) {
      const nextStates = stateMachine[this.state];
      if (nextStates && nextStates.includes(nextState)) {
        this.state = nextState;
        if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
          this.unpinServer();
        }
        return;
      }
      throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
    }
    pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    unpinServer() {
      this._pinnedServer = undefined;
    }
  }
  exports.Transaction = Transaction;
  exports.isTransactionCommand = isTransactionCommand;
});

// node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS((exports) => {
  var hasNotTimedOut = function(startTime, max) {
    return (0, utils_1.calculateDurationInMs)(startTime) < max;
  };
  var isUnknownTransactionCommitResult = function(err) {
    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
    return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
  };
  var maybeClearPinnedConnection = function(session, options) {
    const conn = session[kPinnedConnection];
    const error21 = options?.error;
    if (session.inTransaction() && error21 && error21 instanceof error_1.MongoError && error21.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
      return;
    }
    const topology = session.client.topology;
    if (conn && topology != null) {
      const servers = Array.from(topology.s.servers.values());
      const loadBalancer = servers[0];
      if (options?.error == null || options?.force) {
        loadBalancer.pool.checkIn(conn);
        conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
        if (options?.forceClear) {
          loadBalancer.pool.clear({ serviceId: conn.serviceId });
        }
      }
      session[kPinnedConnection] = undefined;
    }
  };
  var isMaxTimeMSExpiredError = function(err) {
    if (err == null || !(err instanceof error_1.MongoServerError)) {
      return false;
    }
    return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
  };
  var attemptTransactionCommit = function(session, startTime, fn, result, options) {
    return session.commitTransaction().then(() => result, (err) => {
      if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
        if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {
          return attemptTransactionCommit(session, startTime, fn, result, options);
        }
        if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          return attemptTransaction(session, startTime, fn, options);
        }
      }
      throw err;
    });
  };
  var userExplicitlyEndedTransaction = function(session) {
    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
  };
  var attemptTransaction = function(session, startTime, fn, options = {}) {
    session.startTransaction(options);
    let promise4;
    try {
      promise4 = fn(session);
    } catch (err) {
      promise4 = Promise.reject(err);
    }
    if (!(0, utils_1.isPromiseLike)(promise4)) {
      session.abortTransaction().catch(() => null);
      return Promise.reject(new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise"));
    }
    return promise4.then((result) => {
      if (userExplicitlyEndedTransaction(session)) {
        return result;
      }
      return attemptTransactionCommit(session, startTime, fn, result, options);
    }, (err) => {
      function maybeRetryOrThrow(err2) {
        if (err2 instanceof error_1.MongoError && err2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
          return attemptTransaction(session, startTime, fn, options);
        }
        if (isMaxTimeMSExpiredError(err2)) {
          err2.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
        }
        throw err2;
      }
      if (session.inTransaction()) {
        return session.abortTransaction().then(() => maybeRetryOrThrow(err));
      }
      return maybeRetryOrThrow(err);
    });
  };
  var endTransaction = function(session, commandName, callback) {
    const txnState = session.transaction.state;
    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {
      callback(new error_1.MongoTransactionError("No transaction started"));
      return;
    }
    if (commandName === "commitTransaction") {
      if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
        callback();
        return;
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
        callback(new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction"));
        return;
      }
    } else {
      if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        callback();
        return;
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
        callback(new error_1.MongoTransactionError("Cannot call abortTransaction twice"));
        return;
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        callback(new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction"));
        return;
      }
    }
    const command = { [commandName]: 1 };
    let writeConcern;
    if (session.transaction.options.writeConcern) {
      writeConcern = Object.assign({}, session.transaction.options.writeConcern);
    } else if (session.clientOptions && session.clientOptions.writeConcern) {
      writeConcern = { w: session.clientOptions.writeConcern.w };
    }
    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {
      writeConcern = Object.assign({ wtimeoutMS: 1e4 }, writeConcern, { w: "majority" });
    }
    if (writeConcern) {
      write_concern_1.WriteConcern.apply(command, writeConcern);
    }
    if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
      Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
    }
    function commandHandler(error21) {
      if (commandName !== "commitTransaction") {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        if (session.loadBalanced) {
          maybeClearPinnedConnection(session, { force: false });
        }
        return callback();
      }
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
      if (error21 instanceof error_1.MongoError) {
        if ((0, error_1.isRetryableWriteError)(error21) || error21 instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error21)) {
          if (isUnknownTransactionCommitResult(error21)) {
            error21.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
            session.unpin({ error: error21 });
          }
        } else if (error21.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          session.unpin({ error: error21 });
        }
      }
      callback(error21);
    }
    if (session.transaction.recoveryToken) {
      command.recoveryToken = session.transaction.recoveryToken;
    }
    (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {
      session,
      readPreference: read_preference_1.ReadPreference.primary,
      bypassPinningCheck: true
    }), (error21) => {
      if (command.abortTransaction) {
        session.unpin();
      }
      if (error21 instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(error21)) {
        if (command.commitTransaction) {
          session.unpin({ force: true });
          command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
            w: "majority"
          });
        }
        return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {
          session,
          readPreference: read_preference_1.ReadPreference.primary,
          bypassPinningCheck: true
        }), commandHandler);
      }
      commandHandler(error21);
    });
  };
  var applySession = function(session, command, options) {
    if (session.hasEnded) {
      return new error_1.MongoExpiredSessionError;
    }
    const serverSession = session.serverSession;
    if (serverSession == null) {
      return new error_1.MongoRuntimeError("Unable to acquire server session");
    }
    if (options.writeConcern?.w === 0) {
      if (session && session.explicit) {
        return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
      }
      return;
    }
    serverSession.lastUse = (0, utils_1.now)();
    command.lsid = serverSession.id;
    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
    const isRetryableWrite = !!options.willRetryWrite;
    if (isRetryableWrite || inTxnOrTxnCommand) {
      serverSession.txnNumber += session[kTxnNumberIncrement];
      session[kTxnNumberIncrement] = 0;
      command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTxnOrTxnCommand) {
      if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
      }
      if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      } else if (session[kSnapshotEnabled]) {
        command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
        if (session[kSnapshotTime] != null) {
          Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });
        }
      }
      return;
    }
    command.autocommit = false;
    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
      command.startTransaction = true;
      const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
      if (readConcern) {
        command.readConcern = readConcern;
      }
      if (session.supports.causalConsistency && session.operationTime) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      }
    }
    return;
  };
  var updateSessionFromResponse = function(session, document) {
    if (document.$clusterTime) {
      (0, common_1._advanceClusterTime)(session, document.$clusterTime);
    }
    if (document.operationTime && session && session.supports.causalConsistency) {
      session.advanceOperationTime(document.operationTime);
    }
    if (document.recoveryToken && session && session.inTransaction()) {
      session.transaction._recoveryToken = document.recoveryToken;
    }
    if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {
      const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;
      if (atClusterTime) {
        session[kSnapshotTime] = atClusterTime;
      }
    }
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = undefined;
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var metrics_1 = require_metrics();
  var shared_1 = require_shared();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var minWireVersionForShardedTransactions = 8;
  var kServerSession = Symbol("serverSession");
  var kSnapshotTime = Symbol("snapshotTime");
  var kSnapshotEnabled = Symbol("snapshotEnabled");
  var kPinnedConnection = Symbol("pinnedConnection");
  var kTxnNumberIncrement = Symbol("txnNumberIncrement");

  class ClientSession extends mongo_types_1.TypedEventEmitter {
    constructor(client, sessionPool, options, clientOptions) {
      super();
      this[_a] = false;
      if (client == null) {
        throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
      }
      if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
        throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
      }
      options = options ?? {};
      if (options.snapshot === true) {
        this[kSnapshotEnabled] = true;
        if (options.causalConsistency === true) {
          throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
        }
      }
      this.client = client;
      this.sessionPool = sessionPool;
      this.hasEnded = false;
      this.clientOptions = clientOptions;
      this.explicit = !!options.explicit;
      this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;
      this[kTxnNumberIncrement] = 0;
      const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
      this.supports = {
        causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue
      };
      this.clusterTime = options.initialClusterTime;
      this.operationTime = undefined;
      this.owner = options.owner;
      this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
      this.transaction = new transactions_1.Transaction;
    }
    get id() {
      return this[kServerSession]?.id;
    }
    get serverSession() {
      let serverSession = this[kServerSession];
      if (serverSession == null) {
        if (this.explicit) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
        }
        if (this.hasEnded) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
        }
        serverSession = this.sessionPool.acquire();
        this[kServerSession] = serverSession;
      }
      return serverSession;
    }
    get snapshotEnabled() {
      return this[kSnapshotEnabled];
    }
    get loadBalanced() {
      return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
    }
    get pinnedConnection() {
      return this[kPinnedConnection];
    }
    pin(conn) {
      if (this[kPinnedConnection]) {
        throw TypeError("Cannot pin multiple connections to the same session");
      }
      this[kPinnedConnection] = conn;
      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    unpin(options) {
      if (this.loadBalanced) {
        return maybeClearPinnedConnection(this, options);
      }
      this.transaction.unpinServer();
    }
    get isPinned() {
      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
    }
    async endSession(options) {
      try {
        if (this.inTransaction()) {
          await this.abortTransaction();
        }
        if (!this.hasEnded) {
          const serverSession = this[kServerSession];
          if (serverSession != null) {
            this.sessionPool.release(serverSession);
            Object.defineProperty(this, kServerSession, {
              value: ServerSession.clone(serverSession),
              writable: false
            });
          }
          this.hasEnded = true;
          this.emit("ended", this);
        }
      } catch {
      } finally {
        maybeClearPinnedConnection(this, { force: true, ...options });
      }
    }
    advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }
      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    advanceClusterTime(clusterTime) {
      if (!clusterTime || typeof clusterTime !== "object") {
        throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
      }
      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
        throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
      }
      if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== "Binary" || typeof clusterTime.signature.keyId !== "bigint" && typeof clusterTime.signature.keyId !== "number" && clusterTime.signature.keyId?._bsontype !== "Long") {
        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
      }
      (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }
      if (this.id == null || session.id == null) {
        return false;
      }
      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
    }
    incrementTransactionNumber() {
      this[kTxnNumberIncrement] += 1;
    }
    inTransaction() {
      return this.transaction.isActive;
    }
    startTransaction(options) {
      if (this[kSnapshotEnabled]) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
      }
      if (this.inTransaction()) {
        throw new error_1.MongoTransactionError("Transaction already in progress");
      }
      if (this.isPinned && this.transaction.isCommitted) {
        this.unpin();
      }
      const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
      }
      this.incrementTransactionNumber();
      this.transaction = new transactions_1.Transaction({
        readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,
        writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,
        readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,
        maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
      });
      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
    async commitTransaction() {
      return endTransactionAsync(this, "commitTransaction");
    }
    async abortTransaction() {
      return endTransactionAsync(this, "abortTransaction");
    }
    toBSON() {
      throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
    }
    async withTransaction(fn, options) {
      const startTime = (0, utils_1.now)();
      return attemptTransaction(this, startTime, fn, options);
    }
  }
  exports.ClientSession = ClientSession;
  _a = kSnapshotEnabled;
  var MAX_WITH_TRANSACTION_TIMEOUT = 120000;
  var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    "CannotSatisfyWriteConcern",
    "UnknownReplWriteConcern",
    "UnsatisfiableWriteConcern"
  ]);
  exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
  var USER_EXPLICIT_TXN_END_STATES = new Set([
    transactions_1.TxnState.NO_TRANSACTION,
    transactions_1.TxnState.TRANSACTION_COMMITTED,
    transactions_1.TxnState.TRANSACTION_ABORTED
  ]);
  var endTransactionAsync = (0, util_1.promisify)(endTransaction);

  class ServerSession {
    constructor() {
      this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
      this.lastUse = (0, utils_1.now)();
      this.txnNumber = 0;
      this.isDirty = false;
    }
    hasTimedOut(sessionTimeoutMinutes) {
      const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
    static clone(serverSession) {
      const arrayBuffer = new ArrayBuffer(16);
      const idBytes = Buffer.from(arrayBuffer);
      idBytes.set(serverSession.id.id.buffer);
      const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);
      return Object.setPrototypeOf({
        id: { id },
        lastUse: serverSession.lastUse,
        txnNumber: serverSession.txnNumber,
        isDirty: serverSession.isDirty
      }, ServerSession.prototype);
    }
  }
  exports.ServerSession = ServerSession;

  class ServerSessionPool {
    constructor(client) {
      if (client == null) {
        throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
      }
      this.client = client;
      this.sessions = new utils_1.List;
    }
    acquire() {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      let session = null;
      while (this.sessions.length > 0) {
        const potentialSession = this.sessions.shift();
        if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
          session = potentialSession;
          break;
        }
      }
      if (session == null) {
        session = new ServerSession;
      }
      return session;
    }
    release(session) {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
        this.sessions.unshift(session);
      }
      if (!sessionTimeoutMinutes) {
        return;
      }
      this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        }
        this.sessions.unshift(session);
      }
    }
  }
  exports.ServerSessionPool = ServerSessionPool;
  exports.applySession = applySession;
  exports.updateSessionFromResponse = updateSessionFromResponse;
});

// node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS((exports) => {
  async function next(cursor, { blocking, transform: transform5 }) {
    if (cursor.closed) {
      return null;
    }
    do {
      if (cursor[kId] == null) {
        await cursor[kInit]();
      }
      if (cursor[kDocuments].length !== 0) {
        const doc = cursor[kDocuments].shift();
        if (doc != null && transform5 && cursor[kTransform]) {
          try {
            return cursor[kTransform](doc);
          } catch (error21) {
            await cleanupCursor(cursor, { error: error21, needsToEmitClosed: true }).catch(() => null);
            throw error21;
          }
        }
        return doc;
      }
      if (cursor.isDead) {
        await cleanupCursor(cursor, {});
        return null;
      }
      const batchSize = cursor[kOptions].batchSize || 1000;
      try {
        const response = await cursor.getMore(batchSize);
        if (response) {
          const cursorId = typeof response.cursor.id === "number" ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === "bigint" ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;
          cursor[kDocuments].pushMany(response.cursor.nextBatch);
          cursor[kId] = cursorId;
        }
      } catch (error21) {
        await cleanupCursor(cursor, { error: error21 }).catch(() => null);
        throw error21;
      }
      if (cursor.isDead) {
        await cleanupCursor(cursor, {});
      }
      if (cursor[kDocuments].length === 0 && blocking === false) {
        return null;
      }
    } while (!cursor.isDead || cursor[kDocuments].length !== 0);
    return null;
  }
  async function cleanupCursor(cursor, options) {
    const cursorId = cursor[kId];
    const cursorNs = cursor[kNamespace];
    const server = cursor[kServer];
    const session = cursor[kSession];
    const error21 = options?.error;
    const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;
    if (error21) {
      if (cursor.loadBalanced && error21 instanceof error_1.MongoNetworkError) {
        return completeCleanup();
      }
    }
    if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {
      if (needsToEmitClosed) {
        cursor[kClosed] = true;
        cursor[kId] = bson_1.Long.ZERO;
        cursor.emit(AbstractCursor.CLOSE);
      }
      if (session) {
        if (session.owner === cursor) {
          await session.endSession({ error: error21 });
          return;
        }
        if (!session.inTransaction()) {
          (0, sessions_1.maybeClearPinnedConnection)(session, { error: error21 });
        }
      }
      return;
    }
    async function completeCleanup() {
      if (session) {
        if (session.owner === cursor) {
          try {
            await session.endSession({ error: error21 });
          } finally {
            cursor.emit(AbstractCursor.CLOSE);
          }
          return;
        }
        if (!session.inTransaction()) {
          (0, sessions_1.maybeClearPinnedConnection)(session, { error: error21 });
        }
      }
      cursor.emit(AbstractCursor.CLOSE);
      return;
    }
    cursor[kKilled] = true;
    if (session.hasEnded) {
      return completeCleanup();
    }
    try {
      await (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, { session })).catch(() => null);
    } finally {
      await completeCleanup();
    }
  }
  var assertUninitialized = function(cursor) {
    if (cursor[kInitialized]) {
      throw new error_1.MongoCursorInUseError;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = undefined;
  var stream_1 = import.meta.require("stream");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var kill_cursors_1 = require_kill_cursors();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  var kId = Symbol("id");
  var kDocuments = Symbol("documents");
  var kServer = Symbol("server");
  var kNamespace = Symbol("namespace");
  var kClient = Symbol("client");
  var kSession = Symbol("session");
  var kOptions = Symbol("options");
  var kTransform = Symbol("transform");
  var kInitialized = Symbol("initialized");
  var kClosed = Symbol("closed");
  var kKilled = Symbol("killed");
  var kInit = Symbol("kInit");
  exports.CURSOR_FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];

  class AbstractCursor extends mongo_types_1.TypedEventEmitter {
    constructor(client, namespace, options = {}) {
      super();
      if (!client.s.isMongoClient) {
        throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
      }
      this[kClient] = client;
      this[kNamespace] = namespace;
      this[kId] = null;
      this[kDocuments] = new utils_1.List;
      this[kInitialized] = false;
      this[kClosed] = false;
      this[kKilled] = false;
      this[kOptions] = {
        readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,
        ...(0, bson_1.pluckBSONSerializeOptions)(options)
      };
      const readConcern = read_concern_1.ReadConcern.fromOptions(options);
      if (readConcern) {
        this[kOptions].readConcern = readConcern;
      }
      if (typeof options.batchSize === "number") {
        this[kOptions].batchSize = options.batchSize;
      }
      if (options.comment !== undefined) {
        this[kOptions].comment = options.comment;
      }
      if (typeof options.maxTimeMS === "number") {
        this[kOptions].maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.maxAwaitTimeMS === "number") {
        this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;
      }
      if (options.session instanceof sessions_1.ClientSession) {
        this[kSession] = options.session;
      } else {
        this[kSession] = this[kClient].startSession({ owner: this, explicit: false });
      }
    }
    get id() {
      return this[kId] ?? undefined;
    }
    get isDead() {
      return (this[kId]?.isZero() ?? false) || this[kClosed] || this[kKilled];
    }
    get client() {
      return this[kClient];
    }
    get server() {
      return this[kServer];
    }
    get namespace() {
      return this[kNamespace];
    }
    get readPreference() {
      return this[kOptions].readPreference;
    }
    get readConcern() {
      return this[kOptions].readConcern;
    }
    get session() {
      return this[kSession];
    }
    set session(clientSession) {
      this[kSession] = clientSession;
    }
    get cursorOptions() {
      return this[kOptions];
    }
    get closed() {
      return this[kClosed];
    }
    get killed() {
      return this[kKilled];
    }
    get loadBalanced() {
      return !!this[kClient].topology?.loadBalanced;
    }
    bufferedCount() {
      return this[kDocuments].length;
    }
    readBufferedDocuments(number6) {
      const bufferedDocs = [];
      const documentsToRead = Math.min(number6 ?? this[kDocuments].length, this[kDocuments].length);
      for (let count = 0;count < documentsToRead; count++) {
        const document = this[kDocuments].shift();
        if (document != null) {
          bufferedDocs.push(document);
        }
      }
      return bufferedDocs;
    }
    async* [Symbol.asyncIterator]() {
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          const document = await this.next();
          if (document === null) {
            if (!this.closed) {
              const message = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
              await cleanupCursor(this, { needsToEmitClosed: true }).catch(() => null);
              throw new error_1.MongoAPIError(message);
            }
            break;
          }
          yield document;
          if (this[kId] === bson_1.Long.ZERO) {
            break;
          }
        }
      } finally {
        if (!this.closed) {
          await this.close().catch(() => null);
        }
      }
    }
    stream(options) {
      if (options?.transform) {
        const transform5 = options.transform;
        const readable = new ReadableCursorStream(this);
        return readable.pipe(new stream_1.Transform({
          objectMode: true,
          highWaterMark: 1,
          transform(chunk, _, callback) {
            try {
              const transformed = transform5(chunk);
              callback(undefined, transformed);
            } catch (err) {
              callback(err);
            }
          }
        }));
      }
      return new ReadableCursorStream(this);
    }
    async hasNext() {
      if (this[kId] === bson_1.Long.ZERO) {
        return false;
      }
      if (this[kDocuments].length !== 0) {
        return true;
      }
      const doc = await next(this, { blocking: true, transform: false });
      if (doc) {
        this[kDocuments].unshift(doc);
        return true;
      }
      return false;
    }
    async next() {
      if (this[kId] === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      return next(this, { blocking: true, transform: true });
    }
    async tryNext() {
      if (this[kId] === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      return next(this, { blocking: false, transform: true });
    }
    async forEach(iterator4) {
      if (typeof iterator4 !== "function") {
        throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
      }
      for await (const document of this) {
        const result = iterator4(document);
        if (result === false) {
          break;
        }
      }
    }
    async close() {
      const needsToEmitClosed = !this[kClosed];
      this[kClosed] = true;
      await cleanupCursor(this, { needsToEmitClosed });
    }
    async toArray() {
      const array4 = [];
      for await (const document of this) {
        array4.push(document);
      }
      return array4;
    }
    addCursorFlag(flag, value14) {
      assertUninitialized(this);
      if (!exports.CURSOR_FLAGS.includes(flag)) {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);
      }
      if (typeof value14 !== "boolean") {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
      }
      this[kOptions][flag] = value14;
      return this;
    }
    map(transform5) {
      assertUninitialized(this);
      const oldTransform = this[kTransform];
      if (oldTransform) {
        this[kTransform] = (doc) => {
          return transform5(oldTransform(doc));
        };
      } else {
        this[kTransform] = transform5;
      }
      return this;
    }
    withReadPreference(readPreference) {
      assertUninitialized(this);
      if (readPreference instanceof read_preference_1.ReadPreference) {
        this[kOptions].readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      } else {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
      }
      return this;
    }
    withReadConcern(readConcern) {
      assertUninitialized(this);
      const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
      if (resolvedReadConcern) {
        this[kOptions].readConcern = resolvedReadConcern;
      }
      return this;
    }
    maxTimeMS(value14) {
      assertUninitialized(this);
      if (typeof value14 !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this[kOptions].maxTimeMS = value14;
      return this;
    }
    batchSize(value14) {
      assertUninitialized(this);
      if (this[kOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
      }
      if (typeof value14 !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
      }
      this[kOptions].batchSize = value14;
      return this;
    }
    rewind() {
      if (!this[kInitialized]) {
        return;
      }
      this[kId] = null;
      this[kDocuments].clear();
      this[kClosed] = false;
      this[kKilled] = false;
      this[kInitialized] = false;
      const session = this[kSession];
      if (session) {
        if (session.explicit === false) {
          if (!session.hasEnded) {
            session.endSession().catch(() => null);
          }
          this[kSession] = this.client.startSession({ owner: this, explicit: false });
        }
      }
    }
    async getMore(batchSize) {
      const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], {
        ...this[kOptions],
        session: this[kSession],
        batchSize
      });
      return (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation);
    }
    async[kInit]() {
      try {
        const state = await this._initialize(this[kSession]);
        const response = state.response;
        this[kServer] = state.server;
        if (response.cursor) {
          this[kId] = typeof response.cursor.id === "number" ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === "bigint" ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;
          if (response.cursor.ns) {
            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);
          }
          this[kDocuments].pushMany(response.cursor.firstBatch);
        }
        if (this[kId] == null) {
          this[kId] = bson_1.Long.ZERO;
          this[kDocuments].push(state.response);
        }
        this[kInitialized] = true;
      } catch (error21) {
        this[kInitialized] = true;
        await cleanupCursor(this, { error: error21 });
        throw error21;
      }
      if (this.isDead) {
        await cleanupCursor(this, undefined);
      }
      return;
    }
  }
  AbstractCursor.CLOSE = "close";
  exports.AbstractCursor = AbstractCursor;
  exports.assertUninitialized = assertUninitialized;

  class ReadableCursorStream extends stream_1.Readable {
    constructor(cursor) {
      super({
        objectMode: true,
        autoDestroy: false,
        highWaterMark: 1
      });
      this._readInProgress = false;
      this._cursor = cursor;
    }
    _read(size) {
      if (!this._readInProgress) {
        this._readInProgress = true;
        this._readNext();
      }
    }
    _destroy(error21, callback) {
      this._cursor.close().then(() => callback(error21), (closeError) => callback(closeError));
    }
    _readNext() {
      next(this._cursor, { blocking: true, transform: true }).then((result) => {
        if (result == null) {
          this.push(null);
        } else if (this.destroyed) {
          this._cursor.close().catch(() => null);
        } else {
          if (this.push(result)) {
            return this._readNext();
          }
          this._readInProgress = false;
        }
      }, (err) => {
        if (err.message.match(/server is closed/)) {
          this._cursor.close().catch(() => null);
          return this.push(null);
        }
        if (err.message.match(/operation was interrupted/)) {
          return this.push(null);
        }
        return this.destroy(err);
      });
    }
  }
});

// node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregationCursor = undefined;
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();
  var kPipeline = Symbol("pipeline");
  var kOptions = Symbol("options");

  class AggregationCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, pipeline = [], options = {}) {
      super(client, namespace, options);
      this[kPipeline] = pipeline;
      this[kOptions] = options;
    }
    get pipeline() {
      return this[kPipeline];
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);
      delete clonedOptions.session;
      return new AggregationCursor(this.client, this.namespace, this[kPipeline], {
        ...clonedOptions
      });
    }
    map(transform5) {
      return super.map(transform5);
    }
    async _initialize(session) {
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {
        ...this[kOptions],
        ...this.cursorOptions,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation);
      return { server: aggregateOperation.server, session, response };
    }
    async explain(verbosity) {
      return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {
        ...this[kOptions],
        ...this.cursorOptions,
        explain: verbosity ?? true
      }));
    }
    group($group) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $group });
      return this;
    }
    limit($limit) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $limit });
      return this;
    }
    match($match) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $match });
      return this;
    }
    out($out) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $out });
      return this;
    }
    project($project) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $project });
      return this;
    }
    lookup($lookup) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $lookup });
      return this;
    }
    redact($redact) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $redact });
      return this;
    }
    skip($skip) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $skip });
      return this;
    }
    sort($sort) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $sort });
      return this;
    }
    unwind($unwind) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $unwind });
      return this;
    }
    geoNear($geoNear) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $geoNear });
      return this;
    }
  }
  exports.AggregationCursor = AggregationCursor;
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class CountOperation extends command_1.CommandOperation {
    constructor(namespace, filter, options) {
      super({ s: { namespace } }, options);
      this.options = options;
      this.collectionName = namespace.collection;
      this.query = filter;
    }
    async execute(server, session) {
      const options = this.options;
      const cmd = {
        count: this.collectionName,
        query: this.query
      };
      if (typeof options.limit === "number") {
        cmd.limit = options.limit;
      }
      if (typeof options.skip === "number") {
        cmd.skip = options.skip;
      }
      if (options.hint != null) {
        cmd.hint = options.hint;
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      const result = await super.executeCommand(server, session, cmd);
      return result ? result.n : 0;
    }
  }
  exports.CountOperation = CountOperation;
  (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/sort.js
var require_sort = __commonJS((exports) => {
  var prepareDirection = function(direction = 1) {
    const value14 = `${direction}`.toLowerCase();
    if (isMeta(direction))
      return direction;
    switch (value14) {
      case "ascending":
      case "asc":
      case "1":
        return 1;
      case "descending":
      case "desc":
      case "-1":
        return -1;
      default:
        throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
    }
  };
  var isMeta = function(t2) {
    return typeof t2 === "object" && t2 != null && "$meta" in t2 && typeof t2.$meta === "string";
  };
  var isPair = function(t2) {
    if (Array.isArray(t2) && t2.length === 2) {
      try {
        prepareDirection(t2[1]);
        return true;
      } catch (e2) {
        return false;
      }
    }
    return false;
  };
  var isDeep = function(t2) {
    return Array.isArray(t2) && Array.isArray(t2[0]);
  };
  var isMap = function(t2) {
    return t2 instanceof Map && t2.size > 0;
  };
  var pairToMap = function(v2) {
    return new Map([[`${v2[0]}`, prepareDirection([v2[1]])]]);
  };
  var deepToMap = function(t2) {
    const sortEntries = t2.map(([k, v2]) => [`${k}`, prepareDirection(v2)]);
    return new Map(sortEntries);
  };
  var stringsToMap = function(t2) {
    const sortEntries = t2.map((key) => [`${key}`, 1]);
    return new Map(sortEntries);
  };
  var objectToMap = function(t2) {
    const sortEntries = Object.entries(t2).map(([k, v2]) => [
      `${k}`,
      prepareDirection(v2)
    ]);
    return new Map(sortEntries);
  };
  var mapToMap = function(t2) {
    const sortEntries = Array.from(t2).map(([k, v2]) => [
      `${k}`,
      prepareDirection(v2)
    ]);
    return new Map(sortEntries);
  };
  var formatSort = function(sort, direction) {
    if (sort == null)
      return;
    if (typeof sort === "string")
      return new Map([[sort, prepareDirection(direction)]]);
    if (typeof sort !== "object") {
      throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
    }
    if (!Array.isArray(sort)) {
      return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;
    }
    if (!sort.length)
      return;
    if (isDeep(sort))
      return deepToMap(sort);
    if (isPair(sort))
      return pairToMap(sort);
    return stringsToMap(sort);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatSort = undefined;
  var error_1 = require_error();
  exports.formatSort = formatSort;
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS((exports) => {
  var makeFindCommand = function(ns, filter, options) {
    const findCommand = {
      find: ns.collection,
      filter
    };
    if (options.sort) {
      findCommand.sort = (0, sort_1.formatSort)(options.sort);
    }
    if (options.projection) {
      let projection = options.projection;
      if (projection && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      findCommand.projection = projection;
    }
    if (options.hint) {
      findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
    }
    if (typeof options.skip === "number") {
      findCommand.skip = options.skip;
    }
    if (typeof options.limit === "number") {
      if (options.limit < 0) {
        findCommand.limit = -options.limit;
        findCommand.singleBatch = true;
      } else {
        findCommand.limit = options.limit;
      }
    }
    if (typeof options.batchSize === "number") {
      if (options.batchSize < 0) {
        if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
          findCommand.limit = -options.batchSize;
        }
        findCommand.singleBatch = true;
      } else {
        findCommand.batchSize = options.batchSize;
      }
    }
    if (typeof options.singleBatch === "boolean") {
      findCommand.singleBatch = options.singleBatch;
    }
    if (options.comment !== undefined) {
      findCommand.comment = options.comment;
    }
    if (typeof options.maxTimeMS === "number") {
      findCommand.maxTimeMS = options.maxTimeMS;
    }
    const readConcern = read_concern_1.ReadConcern.fromOptions(options);
    if (readConcern) {
      findCommand.readConcern = readConcern.toJSON();
    }
    if (options.max) {
      findCommand.max = options.max;
    }
    if (options.min) {
      findCommand.min = options.min;
    }
    if (typeof options.returnKey === "boolean") {
      findCommand.returnKey = options.returnKey;
    }
    if (typeof options.showRecordId === "boolean") {
      findCommand.showRecordId = options.showRecordId;
    }
    if (typeof options.tailable === "boolean") {
      findCommand.tailable = options.tailable;
    }
    if (typeof options.oplogReplay === "boolean") {
      findCommand.oplogReplay = options.oplogReplay;
    }
    if (typeof options.timeout === "boolean") {
      findCommand.noCursorTimeout = !options.timeout;
    } else if (typeof options.noCursorTimeout === "boolean") {
      findCommand.noCursorTimeout = options.noCursorTimeout;
    }
    if (typeof options.awaitData === "boolean") {
      findCommand.awaitData = options.awaitData;
    }
    if (typeof options.allowPartialResults === "boolean") {
      findCommand.allowPartialResults = options.allowPartialResults;
    }
    if (options.collation) {
      findCommand.collation = options.collation;
    }
    if (typeof options.allowDiskUse === "boolean") {
      findCommand.allowDiskUse = options.allowDiskUse;
    }
    if (options.let) {
      findCommand.let = options.let;
    }
    return findCommand;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOperation = undefined;
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class FindOperation extends command_1.CommandOperation {
    constructor(collection, ns, filter = {}, options = {}) {
      super(collection, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.ns = ns;
      if (typeof filter !== "object" || Array.isArray(filter)) {
        throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
      }
      this.filter = filter != null && filter._bsontype === "ObjectId" ? { _id: filter } : filter;
    }
    async execute(server, session) {
      this.server = server;
      const options = this.options;
      let findCommand = makeFindCommand(this.ns, this.filter, options);
      if (this.explain) {
        findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);
      }
      return server.commandAsync(this.ns, findCommand, {
        ...this.options,
        ...this.bsonOptions,
        documentsReturnedIn: "firstBatch",
        session
      });
    }
  }
  exports.FindOperation = FindOperation;
  (0, operation_1.defineAspects)(FindOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindCursor = exports.FLAGS = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var count_1 = require_count();
  var execute_operation_1 = require_execute_operation();
  var find_1 = require_find();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();
  var kFilter = Symbol("filter");
  var kNumReturned = Symbol("numReturned");
  var kBuiltOptions = Symbol("builtOptions");
  exports.FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];

  class FindCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, filter = {}, options = {}) {
      super(client, namespace, options);
      this[kFilter] = filter;
      this[kBuiltOptions] = options;
      if (options.sort != null) {
        this[kBuiltOptions].sort = (0, sort_1.formatSort)(options.sort);
      }
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this[kBuiltOptions]);
      delete clonedOptions.session;
      return new FindCursor(this.client, this.namespace, this[kFilter], {
        ...clonedOptions
      });
    }
    map(transform5) {
      return super.map(transform5);
    }
    async _initialize(session) {
      const findOperation = new find_1.FindOperation(undefined, this.namespace, this[kFilter], {
        ...this[kBuiltOptions],
        ...this.cursorOptions,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation);
      this[kNumReturned] = response.cursor?.firstBatch?.length;
      return { server: findOperation.server, session, response };
    }
    async getMore(batchSize) {
      const numReturned = this[kNumReturned];
      if (numReturned) {
        const limit = this[kBuiltOptions].limit;
        batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
        if (batchSize <= 0) {
          await this.close().catch(() => null);
          return { cursor: { id: bson_1.Long.ZERO, nextBatch: [] } };
        }
      }
      const response = await super.getMore(batchSize);
      if (response) {
        this[kNumReturned] = this[kNumReturned] + response.cursor.nextBatch.length;
      }
      return response;
    }
    async count(options) {
      (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
      if (typeof options === "boolean") {
        throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
      }
      return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this[kFilter], {
        ...this[kBuiltOptions],
        ...this.cursorOptions,
        ...options
      }));
    }
    async explain(verbosity) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(undefined, this.namespace, this[kFilter], {
        ...this[kBuiltOptions],
        ...this.cursorOptions,
        explain: verbosity ?? true
      }));
    }
    filter(filter) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kFilter] = filter;
      return this;
    }
    hint(hint) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].hint = hint;
      return this;
    }
    min(min) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].min = min;
      return this;
    }
    max(max) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].max = max;
      return this;
    }
    returnKey(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].returnKey = value14;
      return this;
    }
    showRecordId(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].showRecordId = value14;
      return this;
    }
    addQueryModifier(name, value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (name[0] !== "$") {
        throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
      }
      const field = name.substr(1);
      switch (field) {
        case "comment":
          this[kBuiltOptions].comment = value14;
          break;
        case "explain":
          this[kBuiltOptions].explain = value14;
          break;
        case "hint":
          this[kBuiltOptions].hint = value14;
          break;
        case "max":
          this[kBuiltOptions].max = value14;
          break;
        case "maxTimeMS":
          this[kBuiltOptions].maxTimeMS = value14;
          break;
        case "min":
          this[kBuiltOptions].min = value14;
          break;
        case "orderby":
          this[kBuiltOptions].sort = (0, sort_1.formatSort)(value14);
          break;
        case "query":
          this[kFilter] = value14;
          break;
        case "returnKey":
          this[kBuiltOptions].returnKey = value14;
          break;
        case "showDiskLoc":
          this[kBuiltOptions].showRecordId = value14;
          break;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
      }
      return this;
    }
    comment(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].comment = value14;
      return this;
    }
    maxAwaitTimeMS(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (typeof value14 !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
      }
      this[kBuiltOptions].maxAwaitTimeMS = value14;
      return this;
    }
    maxTimeMS(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (typeof value14 !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this[kBuiltOptions].maxTimeMS = value14;
      return this;
    }
    project(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].projection = value14;
      return this;
    }
    sort(sort, direction) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
      }
      this[kBuiltOptions].sort = (0, sort_1.formatSort)(sort, direction);
      return this;
    }
    allowDiskUse(allow = true) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (!this[kBuiltOptions].sort) {
        throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
      }
      if (!allow) {
        this[kBuiltOptions].allowDiskUse = false;
        return this;
      }
      this[kBuiltOptions].allowDiskUse = true;
      return this;
    }
    collation(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].collation = value14;
      return this;
    }
    limit(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
      }
      if (typeof value14 !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
      }
      this[kBuiltOptions].limit = value14;
      return this;
    }
    skip(value14) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
      }
      if (typeof value14 !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
      }
      this[kBuiltOptions].skip = value14;
      return this;
    }
  }
  exports.FindCursor = FindCursor;
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS((exports) => {
  var isIndexDirection = function(x) {
    return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
  };
  var isSingleIndexTuple = function(t2) {
    return Array.isArray(t2) && t2.length === 2 && isIndexDirection(t2[1]);
  };
  var makeIndexSpec = function(indexSpec, options) {
    const key = new Map;
    const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
    for (const spec of indexSpecs) {
      if (typeof spec === "string") {
        key.set(spec, 1);
      } else if (Array.isArray(spec)) {
        key.set(spec[0], spec[1] ?? 1);
      } else if (spec instanceof Map) {
        for (const [property, value14] of spec) {
          key.set(property, value14);
        }
      } else if ((0, utils_1.isObject)(spec)) {
        for (const [property, value14] of Object.entries(spec)) {
          key.set(property, value14);
        }
      }
    }
    return { ...options, key };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var common_functions_1 = require_common_functions();
  var operation_1 = require_operation();
  var VALID_INDEX_OPTIONS = new Set([
    "background",
    "unique",
    "name",
    "partialFilterExpression",
    "sparse",
    "hidden",
    "expireAfterSeconds",
    "storageEngine",
    "collation",
    "version",
    "weights",
    "default_language",
    "language_override",
    "textIndexVersion",
    "2dsphereIndexVersion",
    "bits",
    "min",
    "max",
    "bucketSize",
    "wildcardProjection"
  ]);

  class IndexesOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    async execute(_server, session) {
      const coll = this.collection;
      const options = this.options;
      return (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {
        full: true,
        ...options,
        readPreference: this.readPreference,
        session
      });
    }
  }
  exports.IndexesOperation = IndexesOperation;

  class CreateIndexesOperation extends command_1.CommandOperation {
    constructor(parent, collectionName, indexes, options) {
      super(parent, options);
      this.options = options ?? {};
      this.collectionName = collectionName;
      this.indexes = indexes.map((userIndex) => {
        const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
        const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join("_");
        const validIndexOptions = Object.fromEntries(Object.entries({ ...userIndex }).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName)));
        return {
          ...validIndexOptions,
          name,
          key
        };
      });
    }
    async execute(server, session) {
      const options = this.options;
      const indexes = this.indexes;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cmd = { createIndexes: this.collectionName, indexes };
      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          throw new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4");
        }
        cmd.commitQuorum = options.commitQuorum;
      }
      this.options.collation = undefined;
      await super.executeCommand(server, session, cmd);
      const indexNames = indexes.map((index) => index.name || "");
      return indexNames;
    }
  }
  exports.CreateIndexesOperation = CreateIndexesOperation;

  class CreateIndexOperation extends CreateIndexesOperation {
    constructor(parent, collectionName, indexSpec, options) {
      super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);
    }
    async execute(server, session) {
      const indexNames = await super.execute(server, session);
      return indexNames[0];
    }
  }
  exports.CreateIndexOperation = CreateIndexOperation;

  class EnsureIndexOperation extends CreateIndexOperation {
    constructor(db, collectionName, indexSpec, options) {
      super(db, collectionName, indexSpec, options);
      this.readPreference = read_preference_1.ReadPreference.primary;
      this.db = db;
      this.collectionName = collectionName;
    }
    async execute(server, session) {
      const indexName = this.indexes[0].name;
      const indexes = await this.db.collection(this.collectionName).listIndexes({ session }).toArray().catch((error21) => {
        if (error21 instanceof error_1.MongoError && error21.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound)
          return [];
        throw error21;
      });
      if (indexName && indexes.some((index) => index.name === indexName))
        return indexName;
      return super.execute(server, session);
    }
  }
  exports.EnsureIndexOperation = EnsureIndexOperation;

  class DropIndexOperation extends command_1.CommandOperation {
    constructor(collection, indexName, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.indexName = indexName;
    }
    async execute(server, session) {
      const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
      return super.executeCommand(server, session, cmd);
    }
  }
  exports.DropIndexOperation = DropIndexOperation;

  class ListIndexesOperation extends command_1.CommandOperation {
    constructor(collection, options) {
      super(collection, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.collectionNamespace = collection.s.namespace;
    }
    async execute(server, session) {
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
      const command = { listIndexes: this.collectionNamespace.collection, cursor };
      if (serverWireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return super.executeCommand(server, session, command);
    }
  }
  exports.ListIndexesOperation = ListIndexesOperation;

  class IndexExistsOperation extends operation_1.AbstractOperation {
    constructor(collection, indexes, options) {
      super(options);
      this.options = options;
      this.collection = collection;
      this.indexes = indexes;
    }
    async execute(server, session) {
      const coll = this.collection;
      const indexes = this.indexes;
      const info = await (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {
        ...this.options,
        readPreference: this.readPreference,
        session
      });
      if (!Array.isArray(indexes))
        return info[indexes] != null;
      return indexes.every((indexName) => info[indexName] != null);
    }
  }
  exports.IndexExistsOperation = IndexExistsOperation;

  class IndexInformationOperation extends operation_1.AbstractOperation {
    constructor(db, name, options) {
      super(options);
      this.options = options ?? {};
      this.db = db;
      this.name = name;
    }
    async execute(server, session) {
      const db = this.db;
      const name = this.name;
      return (0, common_functions_1.indexInformation)(db, name, {
        ...this.options,
        readPreference: this.readPreference,
        session
      });
    }
  }
  exports.IndexInformationOperation = IndexInformationOperation;
  (0, operation_1.defineAspects)(ListIndexesOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
  (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListIndexesCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
    constructor(collection, options) {
      super(collection.client, collection.s.namespace, options);
      this.parent = collection;
      this.options = options;
    }
    clone() {
      return new ListIndexesCursor(this.parent, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const operation = new indexes_1.ListIndexesOperation(this.parent, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation);
      return { server: operation.server, session, response };
    }
  }
  exports.ListIndexesCursor = ListIndexesCursor;
});

// node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js
var require_list_search_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListSearchIndexesCursor = undefined;
  var aggregation_cursor_1 = require_aggregation_cursor();

  class ListSearchIndexesCursor extends aggregation_cursor_1.AggregationCursor {
    constructor({ fullNamespace: ns, client }, name, options = {}) {
      const pipeline = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
      super(client, ns, pipeline, options);
    }
  }
  exports.ListSearchIndexesCursor = ListSearchIndexesCursor;
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CountDocumentsOperation = undefined;
  var aggregate_1 = require_aggregate();

  class CountDocumentsOperation extends aggregate_1.AggregateOperation {
    constructor(collection, query, options) {
      const pipeline = [];
      pipeline.push({ $match: query });
      if (typeof options.skip === "number") {
        pipeline.push({ $skip: options.skip });
      }
      if (typeof options.limit === "number") {
        pipeline.push({ $limit: options.limit });
      }
      pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
      super(collection.s.namespace, pipeline, options);
    }
    async execute(server, session) {
      const result = await super.execute(server, session);
      const response = result;
      if (response.cursor == null || response.cursor.firstBatch == null) {
        return 0;
      }
      const docs = response.cursor.firstBatch;
      return docs.length ? docs[0].n : 0;
    }
  }
  exports.CountDocumentsOperation = CountDocumentsOperation;
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DistinctOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DistinctOperation extends command_1.CommandOperation {
    constructor(collection, key, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.key = key;
      this.query = query;
    }
    async execute(server, session) {
      const coll = this.collection;
      const key = this.key;
      const query = this.query;
      const options = this.options;
      const cmd = {
        distinct: coll.collectionName,
        key,
        query
      };
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.comment !== "undefined") {
        cmd.comment = options.comment;
      }
      (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
      (0, utils_1.decorateWithCollation)(cmd, coll, options);
      const result = await super.executeCommand(server, session, cmd);
      return this.explain ? result : result.values;
    }
  }
  exports.DistinctOperation = DistinctOperation;
  (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropDatabaseOperation = exports.DropCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DropCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.db = db;
      this.options = options;
      this.name = name;
    }
    async execute(server, session) {
      const db = this.db;
      const options = this.options;
      const name = this.name;
      const encryptedFieldsMap = db.client.options.autoEncryption?.encryptedFieldsMap;
      let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
      if (!encryptedFields && encryptedFieldsMap) {
        const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
      }
      if (encryptedFields) {
        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
        for (const collectionName of [escCollection, ecocCollection]) {
          const dropOp = new DropCollectionOperation(db, collectionName);
          try {
            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);
          } catch (err) {
            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
              throw err;
            }
          }
        }
      }
      return this.executeWithoutEncryptedFieldsCheck(server, session);
    }
    async executeWithoutEncryptedFieldsCheck(server, session) {
      await super.executeCommand(server, session, { drop: this.name });
      return true;
    }
  }
  exports.DropCollectionOperation = DropCollectionOperation;

  class DropDatabaseOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    async execute(server, session) {
      await super.executeCommand(server, session, { dropDatabase: 1 });
      return true;
    }
  }
  exports.DropDatabaseOperation = DropDatabaseOperation;
  (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EstimatedDocumentCountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class EstimatedDocumentCountOperation extends command_1.CommandOperation {
    constructor(collection, options = {}) {
      super(collection, options);
      this.options = options;
      this.collectionName = collection.collectionName;
    }
    async execute(server, session) {
      const cmd = { count: this.collectionName };
      if (typeof this.options.maxTimeMS === "number") {
        cmd.maxTimeMS = this.options.maxTimeMS;
      }
      if (this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      const response = await super.executeCommand(server, session, cmd);
      return response?.n || 0;
    }
  }
  exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
  (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS((exports) => {
  var configureFindAndModifyCmdBaseUpdateOpts = function(cmdBase, options) {
    cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;
    cmdBase.upsert = options.upsert === true;
    if (options.bypassDocumentValidation === true) {
      cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    return cmdBase;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.ReturnDocument = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.ReturnDocument = Object.freeze({
    BEFORE: "before",
    AFTER: "after"
  });

  class FindAndModifyOperation extends command_1.CommandOperation {
    constructor(collection, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.cmdBase = {
        remove: false,
        new: false,
        upsert: false
      };
      options.includeResultMetadata ??= false;
      const sort = (0, sort_1.formatSort)(options.sort);
      if (sort) {
        this.cmdBase.sort = sort;
      }
      if (options.projection) {
        this.cmdBase.fields = options.projection;
      }
      if (options.maxTimeMS) {
        this.cmdBase.maxTimeMS = options.maxTimeMS;
      }
      if (options.writeConcern) {
        this.cmdBase.writeConcern = options.writeConcern;
      }
      if (options.let) {
        this.cmdBase.let = options.let;
      }
      if (options.comment !== undefined) {
        this.cmdBase.comment = options.comment;
      }
      this.readPreference = read_preference_1.ReadPreference.primary;
      this.collection = collection;
      this.query = query;
    }
    async execute(server, session) {
      const coll = this.collection;
      const query = this.query;
      const options = { ...this.options, ...this.bsonOptions };
      const cmd = {
        findAndModify: coll.collectionName,
        query,
        ...this.cmdBase
      };
      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return err;
      }
      if (options.hint) {
        const unacknowledgedWrite = this.writeConcern?.w === 0;
        if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
          throw new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands");
        }
        cmd.hint = options.hint;
      }
      const result = await super.executeCommand(server, session, cmd);
      return options.includeResultMetadata ? result : result.value ?? null;
    }
  }

  class FindOneAndDeleteOperation extends FindAndModifyOperation {
    constructor(collection, filter, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      super(collection, filter, options);
      this.cmdBase.remove = true;
    }
  }
  exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;

  class FindOneAndReplaceOperation extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (replacement == null || typeof replacement !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
      }
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = replacement;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
    }
  }
  exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;

  class FindOneAndUpdateOperation extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
      }
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = update;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
      if (options.arrayFilters) {
        this.cmdBase.arrayFilters = options.arrayFilters;
      }
    }
  }
  exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
  (0, operation_1.defineAspects)(FindAndModifyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE
  ]);
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsCappedOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class IsCappedOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    async execute(server, session) {
      const coll = this.collection;
      const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
      if (collection == null || collection.options == null) {
        throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
      }
      return !!collection.options?.capped;
    }
  }
  exports.IsCappedOperation = IsCappedOperation;
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionsOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class OptionsOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    async execute(server, session) {
      const coll = this.collection;
      const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
      if (collection == null || collection.options == null) {
        throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
      }
      return collection.options;
    }
  }
  exports.OptionsOperation = OptionsOperation;
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RenameOperation = undefined;
  var collection_1 = require_collection();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RenameOperation extends command_1.CommandOperation {
    constructor(collection, newName, options) {
      super(collection, options);
      this.collection = collection;
      this.newName = newName;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    async execute(server, session) {
      const renameCollection = this.collection.namespace;
      const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
      const dropTarget = typeof this.options.dropTarget === "boolean" ? this.options.dropTarget : false;
      const command = {
        renameCollection,
        to: toCollection,
        dropTarget
      };
      await super.executeCommand(server, session, command);
      return new collection_1.Collection(this.collection.s.db, this.newName, this.collection.s.options);
    }
  }
  exports.RenameOperation = RenameOperation;
  (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/search_indexes/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateSearchIndexesOperation = undefined;
  var operation_1 = require_operation();

  class CreateSearchIndexesOperation extends operation_1.AbstractOperation {
    constructor(collection, descriptions) {
      super();
      this.collection = collection;
      this.descriptions = descriptions;
    }
    async execute(server, session) {
      const namespace = this.collection.fullNamespace;
      const command = {
        createSearchIndexes: namespace.collection,
        indexes: this.descriptions
      };
      const res = await server.commandAsync(namespace, command, { session });
      const indexesCreated = res?.indexesCreated ?? [];
      return indexesCreated.map(({ name }) => name);
    }
  }
  exports.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/drop.js
var require_drop2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropSearchIndexOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class DropSearchIndexOperation extends operation_1.AbstractOperation {
    constructor(collection, name) {
      super();
      this.collection = collection;
      this.name = name;
    }
    async execute(server, session) {
      const namespace = this.collection.fullNamespace;
      const command = {
        dropSearchIndex: namespace.collection
      };
      if (typeof this.name === "string") {
        command.name = this.name;
      }
      try {
        await server.commandAsync(namespace, command, { session });
      } catch (error21) {
        const isNamespaceNotFoundError = error21 instanceof error_1.MongoServerError && error21.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound;
        if (!isNamespaceNotFoundError) {
          throw error21;
        }
      }
    }
  }
  exports.DropSearchIndexOperation = DropSearchIndexOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/update.js
var require_update2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateSearchIndexOperation = undefined;
  var operation_1 = require_operation();

  class UpdateSearchIndexOperation extends operation_1.AbstractOperation {
    constructor(collection, name, definition) {
      super();
      this.collection = collection;
      this.name = name;
      this.definition = definition;
    }
    async execute(server, session) {
      const namespace = this.collection.fullNamespace;
      const command = {
        updateSearchIndex: namespace.collection,
        name: this.name,
        definition: this.definition
      };
      await server.commandAsync(namespace, command, { session });
      return;
    }
  }
  exports.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Collection = undefined;
  var bson_1 = require_bson2();
  var ordered_1 = require_ordered();
  var unordered_1 = require_unordered();
  var change_stream_1 = require_change_stream();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var find_cursor_1 = require_find_cursor();
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  var list_search_indexes_cursor_1 = require_list_search_indexes_cursor();
  var error_1 = require_error();
  var bulk_write_1 = require_bulk_write();
  var count_1 = require_count();
  var count_documents_1 = require_count_documents();
  var delete_1 = require_delete();
  var distinct_1 = require_distinct();
  var drop_1 = require_drop();
  var estimated_document_count_1 = require_estimated_document_count();
  var execute_operation_1 = require_execute_operation();
  var find_and_modify_1 = require_find_and_modify();
  var indexes_1 = require_indexes();
  var insert_1 = require_insert();
  var is_capped_1 = require_is_capped();
  var options_operation_1 = require_options_operation();
  var rename_1 = require_rename();
  var create_1 = require_create();
  var drop_2 = require_drop2();
  var update_1 = require_update2();
  var update_2 = require_update();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();

  class Collection {
    constructor(db, name, options) {
      this.s = {
        db,
        options,
        namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
        pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      };
      this.client = db.client;
    }
    get dbName() {
      return this.s.namespace.db;
    }
    get collectionName() {
      return this.s.namespace.collection;
    }
    get namespace() {
      return this.fullNamespace.toString();
    }
    get fullNamespace() {
      return this.s.namespace;
    }
    get readConcern() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }
      return this.s.writeConcern;
    }
    get hint() {
      return this.s.collectionHint;
    }
    set hint(v2) {
      this.s.collectionHint = (0, utils_1.normalizeHintField)(v2);
    }
    async insertOne(doc, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));
    }
    async insertMany(docs, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async bulkWrite(operations, options) {
      if (!Array.isArray(operations)) {
        throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
      }
      return (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async updateOne(filter, update, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async replaceOne(filter, replacement, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async updateMany(filter, update, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteOne(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteMany(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async rename(newName, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, {
        ...options,
        readPreference: read_preference_1.ReadPreference.PRIMARY
      }));
    }
    async drop(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));
    }
    async findOne(filter = {}, options = {}) {
      const cursor = this.find(filter, options).limit(-1).batchSize(1);
      const res = await cursor.next();
      await cursor.close();
      return res;
    }
    find(filter = {}, options = {}) {
      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async options(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async isCapped(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(indexSpec, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndexes(indexSpecs, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options, maxTimeMS: undefined })));
    }
    async dropIndex(indexName, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
        ...(0, utils_1.resolveOptions)(this, options),
        readPreference: read_preference_1.ReadPreference.primary
      }));
    }
    async dropIndexes(options) {
      try {
        await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, "*", (0, utils_1.resolveOptions)(this, options)));
        return true;
      } catch {
        return false;
      }
    }
    listIndexes(options) {
      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
    }
    async indexExists(indexes, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexInformation(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)));
    }
    async estimatedDocumentCount(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async countDocuments(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async distinct(key, filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexes(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndDelete(filter, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndReplace(filter, replacement, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndUpdate(filter, update, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    aggregate(pipeline = [], options) {
      if (!Array.isArray(pipeline)) {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
      }
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    initializeUnorderedBulkOp(options) {
      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    initializeOrderedBulkOp(options) {
      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    async count(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    listSearchIndexes(indexNameOrOptions, options) {
      options = typeof indexNameOrOptions === "object" ? indexNameOrOptions : options == null ? {} : options;
      const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === "object" ? null : indexNameOrOptions;
      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
    }
    async createSearchIndex(description) {
      const [index] = await this.createSearchIndexes([description]);
      return index;
    }
    async createSearchIndexes(descriptions) {
      return (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
    }
    async dropSearchIndex(name) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
    }
    async updateSearchIndex(name, definition) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
    }
  }
  exports.Collection = Collection;
});

// node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStreamCursor = undefined;
  var change_stream_1 = require_change_stream();
  var constants_1 = require_constants2();
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, pipeline = [], options = {}) {
      super(client, namespace, options);
      this.pipeline = pipeline;
      this.options = options;
      this._resumeToken = null;
      this.startAtOperationTime = options.startAtOperationTime;
      if (options.startAfter) {
        this.resumeToken = options.startAfter;
      } else if (options.resumeAfter) {
        this.resumeToken = options.resumeAfter;
      }
    }
    set resumeToken(token) {
      this._resumeToken = token;
      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
    }
    get resumeToken() {
      return this._resumeToken;
    }
    get resumeOptions() {
      const options = {
        ...this.options
      };
      for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
        delete options[key];
      }
      if (this.resumeToken != null) {
        if (this.options.startAfter && !this.hasReceived) {
          options.startAfter = this.resumeToken;
        } else {
          options.resumeAfter = this.resumeToken;
        }
      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
        options.startAtOperationTime = this.startAtOperationTime;
      }
      return options;
    }
    cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
        this.resumeToken = this.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }
      this.hasReceived = true;
    }
    _processBatch(response) {
      const cursor = response.cursor;
      if (cursor.postBatchResumeToken) {
        this.postBatchResumeToken = response.cursor.postBatchResumeToken;
        const batch = "firstBatch" in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;
        if (batch.length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
    clone() {
      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation);
      const server = aggregateOperation.server;
      this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {
        this.startAtOperationTime = response.operationTime;
      }
      this._processBatch(response);
      this.emit(constants_1.INIT, response);
      this.emit(constants_1.RESPONSE);
      return { server, session, response };
    }
    async getMore(batchSize) {
      const response = await super.getMore(batchSize);
      this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
      this._processBatch(response);
      this.emit(change_stream_1.ChangeStream.MORE, response);
      this.emit(change_stream_1.ChangeStream.RESPONSE);
      return response;
    }
  }
  exports.ChangeStreamCursor = ChangeStreamCursor;
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListCollectionsOperation extends command_1.CommandOperation {
    constructor(db, filter, options) {
      super(db, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.db = db;
      this.filter = filter;
      this.nameOnly = !!this.options.nameOnly;
      this.authorizedCollections = !!this.options.authorizedCollections;
      if (typeof this.options.batchSize === "number") {
        this.batchSize = this.options.batchSize;
      }
    }
    async execute(server, session) {
      return super.executeCommand(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)));
    }
    generateCommand(wireVersion) {
      const command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? { batchSize: this.batchSize } : {},
        nameOnly: this.nameOnly,
        authorizedCollections: this.authorizedCollections
      };
      if (wireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return command;
    }
  }
  exports.ListCollectionsOperation = ListCollectionsOperation;
  (0, operation_1.defineAspects)(ListCollectionsOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var list_collections_1 = require_list_collections();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
    constructor(db, filter, options) {
      super(db.client, db.s.namespace, options);
      this.parent = db;
      this.filter = filter;
      this.options = options;
    }
    clone() {
      return new ListCollectionsCursor(this.parent, this.filter, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation);
      return { server: operation.server, session, response };
    }
  }
  exports.ListCollectionsCursor = ListCollectionsCursor;
});

// node_modules/mongodb/lib/cursor/run_command_cursor.js
var require_run_command_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunCommandCursor = undefined;
  var error_1 = require_error();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var run_command_1 = require_run_command();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class RunCommandCursor extends abstract_cursor_1.AbstractCursor {
    setComment(comment) {
      this.getMoreOptions.comment = comment;
      return this;
    }
    setMaxTimeMS(maxTimeMS) {
      this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
      return this;
    }
    setBatchSize(batchSize) {
      this.getMoreOptions.batchSize = batchSize;
      return this;
    }
    clone() {
      throw new error_1.MongoAPIError("Clone not supported, create a new cursor with db.runCursorCommand");
    }
    withReadConcern(_) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support readConcern it must be attached to the command being run");
    }
    addCursorFlag(_, __) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support cursor flags, they must be attached to the command being run");
    }
    maxTimeMS(_) {
      throw new error_1.MongoAPIError("maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()");
    }
    batchSize(_) {
      throw new error_1.MongoAPIError("batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()");
    }
    constructor(db, command, options = {}) {
      super(db.client, (0, utils_1.ns)(db.namespace), options);
      this.getMoreOptions = {};
      this.db = db;
      this.command = Object.freeze({ ...command });
    }
    async _initialize(session) {
      const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
        ...this.cursorOptions,
        session,
        readPreference: this.cursorOptions.readPreference
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, operation);
      if (response.cursor == null) {
        throw new error_1.MongoUnexpectedServerResponseError("Expected server to respond with cursor");
      }
      return {
        server: operation.server,
        session,
        response
      };
    }
    async getMore(_batchSize) {
      const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
        ...this.cursorOptions,
        session: this.session,
        ...this.getMoreOptions
      });
      return (0, execute_operation_1.executeOperation)(this.client, getMoreOperation);
    }
  }
  exports.RunCommandCursor = RunCommandCursor;
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CollectionsOperation = undefined;
  var collection_1 = require_collection();
  var operation_1 = require_operation();

  class CollectionsOperation extends operation_1.AbstractOperation {
    constructor(db, options) {
      super(options);
      this.options = options;
      this.db = db;
    }
    async execute(server, session) {
      const documents = await this.db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray();
      const collections = [];
      for (const { name } of documents) {
        if (!name.includes("$")) {
          collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
        }
      }
      return collections;
    }
  }
  exports.CollectionsOperation = CollectionsOperation;
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateCollectionOperation = undefined;
  var constants_1 = require_constants();
  var collection_1 = require_collection();
  var error_1 = require_error();
  var command_1 = require_command();
  var indexes_1 = require_indexes();
  var operation_1 = require_operation();
  var ILLEGAL_COMMAND_FIELDS = new Set([
    "w",
    "wtimeout",
    "j",
    "fsync",
    "autoIndexId",
    "pkFactory",
    "raw",
    "readPreference",
    "session",
    "readConcern",
    "writeConcern",
    "raw",
    "fieldsAsRaw",
    "useBigInt64",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bsonRegExp",
    "serializeFunctions",
    "ignoreUndefined",
    "enableUtf8Validation"
  ]);
  var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";

  class CreateCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.options = options;
      this.db = db;
      this.name = name;
    }
    async execute(server, session) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const encryptedFields = options.encryptedFields ?? db.client.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
      if (encryptedFields) {
        if (!server.loadBalanced && server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
          throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
        }
        const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
        const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
        for (const collectionName of [escCollection, ecocCollection]) {
          const createOp = new CreateCollectionOperation(db, collectionName, {
            clusteredIndex: {
              key: { _id: 1 },
              unique: true
            }
          });
          await createOp.executeWithoutEncryptedFieldsCheck(server, session);
        }
        if (!options.encryptedFields) {
          this.options = { ...this.options, encryptedFields };
        }
      }
      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);
      if (encryptedFields) {
        const createIndexOp = new indexes_1.CreateIndexOperation(db, name, { __safeContent__: 1 }, {});
        await createIndexOp.execute(server, session);
      }
      return coll;
    }
    async executeWithoutEncryptedFieldsCheck(server, session) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const cmd = { create: name };
      for (const n2 in options) {
        if (options[n2] != null && typeof options[n2] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n2)) {
          cmd[n2] = options[n2];
        }
      }
      await super.executeCommand(server, session, cmd);
      return new collection_1.Collection(db, name, options);
    }
  }
  exports.CreateCollectionOperation = CreateCollectionOperation;
  (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProfilingLevelOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ProfilingLevelOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    async execute(server, session) {
      const doc = await super.executeCommand(server, session, { profile: -1 });
      if (doc.ok === 1) {
        const was = doc.was;
        if (was === 0)
          return "off";
        if (was === 1)
          return "slow_only";
        if (was === 2)
          return "all";
        throw new error_1.MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);
      } else {
        throw new error_1.MongoUnexpectedServerResponseError("Error with profile command");
      }
    }
  }
  exports.ProfilingLevelOperation = ProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetProfilingLevelOperation = exports.ProfilingLevel = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var levelValues = new Set(["off", "slow_only", "all"]);
  exports.ProfilingLevel = Object.freeze({
    off: "off",
    slowOnly: "slow_only",
    all: "all"
  });

  class SetProfilingLevelOperation extends command_1.CommandOperation {
    constructor(db, level, options) {
      super(db, options);
      this.options = options;
      switch (level) {
        case exports.ProfilingLevel.off:
          this.profile = 0;
          break;
        case exports.ProfilingLevel.slowOnly:
          this.profile = 1;
          break;
        case exports.ProfilingLevel.all:
          this.profile = 2;
          break;
        default:
          this.profile = 0;
          break;
      }
      this.level = level;
    }
    async execute(server, session) {
      const level = this.level;
      if (!levelValues.has(level)) {
        throw new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports.ProfilingLevel)}"`);
      }
      await super.executeCommand(server, session, { profile: this.profile });
      return level;
    }
  }
  exports.SetProfilingLevelOperation = SetProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DbStatsOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DbStatsOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    async execute(server, session) {
      const command = { dbStats: true };
      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }
      return super.executeCommand(server, session, command);
    }
  }
  exports.DbStatsOperation = DbStatsOperation;
  (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Db = undefined;
  var admin_1 = require_admin();
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var collection_1 = require_collection();
  var CONSTANTS = require_constants2();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var list_collections_cursor_1 = require_list_collections_cursor();
  var run_command_cursor_1 = require_run_command_cursor();
  var error_1 = require_error();
  var collections_1 = require_collections();
  var create_collection_1 = require_create_collection();
  var drop_1 = require_drop();
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var profiling_level_1 = require_profiling_level();
  var remove_user_1 = require_remove_user();
  var rename_1 = require_rename();
  var run_command_1 = require_run_command();
  var set_profiling_level_1 = require_set_profiling_level();
  var stats_1 = require_stats();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var DB_OPTIONS_ALLOW_LIST = [
    "writeConcern",
    "readPreference",
    "readPreferenceTags",
    "native_parser",
    "forceServerObjectId",
    "pkFactory",
    "serializeFunctions",
    "raw",
    "authSource",
    "ignoreUndefined",
    "readConcern",
    "retryMiliSeconds",
    "numberOfRetries",
    "useBigInt64",
    "promoteBuffers",
    "promoteLongs",
    "bsonRegExp",
    "enableUtf8Validation",
    "promoteValues",
    "compression",
    "retryWrites"
  ];

  class Db {
    constructor(client, databaseName, options) {
      options = options ?? {};
      options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
      if (typeof databaseName === "string" && databaseName.includes(".")) {
        throw new error_1.MongoInvalidArgumentError(`Database names cannot contain the character '.'`);
      }
      this.s = {
        options,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
        pkFactory: options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        namespace: new utils_1.MongoDBNamespace(databaseName)
      };
      this.client = client;
    }
    get databaseName() {
      return this.s.namespace.db;
    }
    get options() {
      return this.s.options;
    }
    get secondaryOk() {
      return this.s.readPreference?.preference !== "primary" || false;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.client.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get namespace() {
      return this.s.namespace.toString();
    }
    async createCollection(name, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async command(command, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, {
        ...(0, bson_1.resolveBSONOptions)(options),
        session: options?.session,
        readPreference: options?.readPreference
      }));
    }
    aggregate(pipeline = [], options) {
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    admin() {
      return new admin_1.Admin(this);
    }
    collection(name, options = {}) {
      if (typeof options === "function") {
        throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
      }
      return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
    }
    async stats(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    listCollections(filter = {}, options = {}) {
      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async renameCollection(fromCollection, toCollection, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, { ...options, new_collection: true, readPreference: read_preference_1.ReadPreference.primary }));
    }
    async dropCollection(name, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async dropDatabase(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async collections(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(name, indexSpec, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options)));
    }
    async removeUser(username, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)));
    }
    async setProfilingLevel(level, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)));
    }
    async profilingLevel(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexInformation(name, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    runCursorCommand(command, options) {
      return new run_command_cursor_1.RunCommandCursor(this, command, options);
    }
  }
  Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
  Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
  Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
  Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
  Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
  Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
  exports.Db = Db;
});

// node_modules/mongodb/lib/deps.js
var require_deps = __commonJS((exports) => {
  var makeErrorModule = function(error21) {
    const props = error21 ? { kModuleError: error21 } : {};
    return new Proxy(props, {
      get: (_, key) => {
        if (key === "kModuleError") {
          return error21;
        }
        throw error21;
      },
      set: () => {
        throw error21;
      }
    });
  };
  var getKerberos = function() {
    try {
      exports.Kerberos = (()=>{throw new Error(`Cannot require module "kerberos"`);})();
      return exports.Kerberos;
    } catch {
      return exports.Kerberos;
    }
  };
  var getZstdLibrary = function() {
    try {
      exports.ZStandard = (()=>{throw new Error(`Cannot require module "@mongodb-js/zstd"`);})();
      return exports.ZStandard;
    } catch {
      return exports.ZStandard;
    }
  };
  var getAwsCredentialProvider = function() {
    try {
      const credentialProvider = (()=>{throw new Error(`Cannot require module "@aws-sdk/credential-providers"`);})();
      return credentialProvider;
    } catch {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found. Please install it to enable getting aws credentials via the official sdk."));
    }
  };
  var getGcpMetadata = function() {
    try {
      const credentialProvider = (()=>{throw new Error(`Cannot require module "gcp-metadata"`);})();
      return credentialProvider;
    } catch {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `gcp-metadata` not found. Please install it to enable getting gcp credentials via the official sdk."));
    }
  };
  var getSnappy = function() {
    try {
      const value14 = (()=>{throw new Error(`Cannot require module "snappy"`);})();
      return value14;
    } catch (cause) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression", { cause });
      return { kModuleError };
    }
  };
  var getSocks = function() {
    try {
      const value14 = (()=>{throw new Error(`Cannot require module "socks"`);})();
      return value14;
    } catch (cause) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `socks` not found. Please install it to connections over a SOCKS5 proxy", { cause });
      return { kModuleError };
    }
  };
  var getMongoDBClientEncryption = function() {
    let mongodbClientEncryption = null;
    try {
      mongodbClientEncryption = (()=>{throw new Error(`Cannot require module "mongodb-client-encryption"`);})();
    } catch (cause) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `mongodb-client-encryption` not found. Please install it to use auto encryption or ClientEncryption.", { cause });
      return { kModuleError };
    }
    return mongodbClientEncryption;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getMongoDBClientEncryption = exports.aws4 = exports.getSocks = exports.getSnappy = exports.getGcpMetadata = exports.getAwsCredentialProvider = exports.getZstdLibrary = exports.ZStandard = exports.getKerberos = exports.Kerberos = undefined;
  var error_1 = require_error();
  exports.Kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication"));
  exports.getKerberos = getKerberos;
  exports.ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression"));
  exports.getZstdLibrary = getZstdLibrary;
  exports.getAwsCredentialProvider = getAwsCredentialProvider;
  exports.getGcpMetadata = getGcpMetadata;
  exports.getSnappy = getSnappy;
  exports.getSocks = getSocks;
  exports.aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication"));
  try {
    exports.aws4 = (()=>{throw new Error(`Cannot require module "aws4"`);})();
  } catch {
  }
  exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
});

// node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuthProvider = exports.AuthContext = undefined;
  var error_1 = require_error();

  class AuthContext {
    constructor(connection, credentials, options) {
      this.reauthenticating = false;
      this.connection = connection;
      this.credentials = credentials;
      this.options = options;
    }
  }
  exports.AuthContext = AuthContext;

  class AuthProvider {
    async prepare(handshakeDoc, _authContext) {
      return handshakeDoc;
    }
    async reauth(context) {
      if (context.reauthenticating) {
        throw new error_1.MongoRuntimeError("Reauthentication already in progress.");
      }
      try {
        context.reauthenticating = true;
        await this.auth(context);
      } finally {
        context.reauthenticating = false;
      }
    }
  }
  exports.AuthProvider = AuthProvider;
});

// node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS((exports) => {
  async function externalCommand(connection, command) {
    return connection.commandAsync((0, utils_1.ns)("$external.$cmd"), command, undefined);
  }
  async function makeKerberosClient(authContext) {
    const { hostAddress } = authContext.options;
    const { credentials } = authContext;
    if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
      throw new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined.");
    }
    loadKrb();
    if ("kModuleError" in krb) {
      throw krb["kModuleError"];
    }
    const { initializeClient } = krb;
    const { username, password } = credentials;
    const mechanismProperties = credentials.mechanismProperties;
    const serviceName = mechanismProperties.SERVICE_NAME ?? "mongodb";
    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
    const initOptions = {};
    if (password != null) {
      Object.assign(initOptions, { user: username, password });
    }
    const spnHost = mechanismProperties.SERVICE_HOST ?? host;
    let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
    if ("SERVICE_REALM" in mechanismProperties) {
      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
    }
    return initializeClient(spn, initOptions);
  }
  var saslStart = function(payload) {
    return {
      saslStart: 1,
      mechanism: "GSSAPI",
      payload,
      autoAuthorize: 1
    };
  };
  var saslContinue = function(payload, conversationId) {
    return {
      saslContinue: 1,
      conversationId,
      payload
    };
  };
  async function negotiate(client, retries, payload) {
    try {
      const response = await client.step(payload);
      return response || "";
    } catch (error21) {
      if (retries === 0) {
        throw error21;
      }
      return negotiate(client, retries - 1, payload);
    }
  }
  async function finalize(client, user, payload) {
    const response = await client.unwrap(payload);
    return client.wrap(response || "", { user });
  }
  async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
      return host;
    }
    if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
      const { address } = await dns.promises.lookup(host);
      try {
        const results = await dns.promises.resolvePtr(address);
        return results.length > 0 ? results[0] : host;
      } catch (error21) {
        return resolveCname(host);
      }
    } else {
      return resolveCname(host);
    }
  }
  async function resolveCname(host) {
    try {
      const results = await dns.promises.resolveCname(host);
      return results.length > 0 ? results[0] : host;
    } catch {
      return host;
    }
  }
  var loadKrb = function() {
    if (!krb) {
      krb = (0, deps_1.getKerberos)();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = undefined;
  var dns = import.meta.require("dns");
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  exports.GSSAPICanonicalizationValue = Object.freeze({
    on: true,
    off: false,
    none: "none",
    forward: "forward",
    forwardAndReverse: "forwardAndReverse"
  });
  var krb;

  class GSSAPI extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (credentials == null) {
        throw new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication");
      }
      const { username } = credentials;
      const client = await makeKerberosClient(authContext);
      const payload = await client.step("");
      const saslStartResponse = await externalCommand(connection, saslStart(payload));
      const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
      const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
      const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
      await externalCommand(connection, {
        saslContinue: 1,
        conversationId: saslContinueResponse.conversationId,
        payload: finalizePayload
      });
    }
  }
  exports.GSSAPI = GSSAPI;
  exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
  exports.resolveCname = resolveCname;
});

// node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = undefined;
  exports.AuthMechanism = Object.freeze({
    MONGODB_AWS: "MONGODB-AWS",
    MONGODB_CR: "MONGODB-CR",
    MONGODB_DEFAULT: "DEFAULT",
    MONGODB_GSSAPI: "GSSAPI",
    MONGODB_PLAIN: "PLAIN",
    MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
    MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
    MONGODB_X509: "MONGODB-X509",
    MONGODB_OIDC: "MONGODB-OIDC"
  });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([
    exports.AuthMechanism.MONGODB_GSSAPI,
    exports.AuthMechanism.MONGODB_AWS,
    exports.AuthMechanism.MONGODB_OIDC,
    exports.AuthMechanism.MONGODB_X509
  ]);
});

// node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS((exports) => {
  var getDefaultAuthMechanism = function(hello) {
    if (hello) {
      if (Array.isArray(hello.saslSupportedMechs)) {
        return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
      }
      if (hello.maxWireVersion >= 3) {
        return providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
      }
    }
    return providers_1.AuthMechanism.MONGODB_CR;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = undefined;
  var error_1 = require_error();
  var gssapi_1 = require_gssapi();
  var providers_1 = require_providers();
  var ALLOWED_PROVIDER_NAMES = ["aws", "azure"];
  var ALLOWED_HOSTS_ERROR = "Auth mechanism property ALLOWED_HOSTS must be an array of strings.";
  exports.DEFAULT_ALLOWED_HOSTS = [
    "*.mongodb.net",
    "*.mongodb-dev.net",
    "*.mongodbgov.net",
    "localhost",
    "127.0.0.1",
    "::1"
  ];
  var TOKEN_AUDIENCE_MISSING_ERROR = "TOKEN_AUDIENCE must be set in the auth mechanism properties when PROVIDER_NAME is azure.";

  class MongoCredentials {
    constructor(options) {
      this.username = options.username ?? "";
      this.password = options.password;
      this.source = options.source;
      if (!this.source && options.db) {
        this.source = options.db;
      }
      this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
      this.mechanismProperties = options.mechanismProperties || {};
      if (this.mechanism.match(/MONGODB-AWS/i)) {
        if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
          this.username = process.env.AWS_ACCESS_KEY_ID;
        }
        if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
          this.password = process.env.AWS_SECRET_ACCESS_KEY;
        }
        if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
          this.mechanismProperties = {
            ...this.mechanismProperties,
            AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
          };
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
        this.mechanismProperties = {
          ...this.mechanismProperties,
          ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
        };
      }
      Object.freeze(this.mechanismProperties);
      Object.freeze(this);
    }
    equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    resolveAuthMechanism(hello) {
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(hello),
          mechanismProperties: this.mechanismProperties
        });
      }
      return this;
    }
    validate() {
      if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_CR || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
        throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        if (this.username && this.mechanismProperties.PROVIDER_NAME) {
          throw new error_1.MongoInvalidArgumentError(`username and PROVIDER_NAME may not be used together for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.PROVIDER_NAME === "azure" && !this.mechanismProperties.TOKEN_AUDIENCE) {
          throw new error_1.MongoAzureError(TOKEN_AUDIENCE_MISSING_ERROR);
        }
        if (this.mechanismProperties.PROVIDER_NAME && !ALLOWED_PROVIDER_NAMES.includes(this.mechanismProperties.PROVIDER_NAME)) {
          throw new error_1.MongoInvalidArgumentError(`Currently only a PROVIDER_NAME in ${ALLOWED_PROVIDER_NAMES.join(",")} is supported for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.REFRESH_TOKEN_CALLBACK && !this.mechanismProperties.REQUEST_TOKEN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError(`A REQUEST_TOKEN_CALLBACK must be provided when using a REFRESH_TOKEN_CALLBACK for mechanism '${this.mechanism}'`);
        }
        if (!this.mechanismProperties.PROVIDER_NAME && !this.mechanismProperties.REQUEST_TOKEN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError(`Either a PROVIDER_NAME or a REQUEST_TOKEN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.ALLOWED_HOSTS) {
          const hosts = this.mechanismProperties.ALLOWED_HOSTS;
          if (!Array.isArray(hosts)) {
            throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
          }
          for (const host of hosts) {
            if (typeof host !== "string") {
              throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
            }
          }
        }
      }
      if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
        if (this.source != null && this.source !== "$external") {
          throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
        throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
        if (this.password === "") {
          Reflect.set(this, "password", undefined);
          return;
        }
        throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
      }
      const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
      if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
        throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
      }
    }
    static merge(creds, options) {
      return new MongoCredentials({
        username: options.username ?? creds?.username ?? "",
        password: options.password ?? creds?.password ?? "",
        mechanism: options.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
        mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},
        source: options.source ?? options.db ?? creds?.source ?? "admin"
      });
    }
  }
  exports.MongoCredentials = MongoCredentials;
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports) => {
  var makeException = function(ErrorType, message, options) {
    if (options.globals) {
      ErrorType = options.globals[ErrorType.name];
    }
    return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
  };
  var toNumber = function(value14, options) {
    if (typeof value14 === "bigint") {
      throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
    }
    if (!options.globals) {
      return Number(value14);
    }
    return options.globals.Number(value14);
  };
  var evenRound = function(x) {
    if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
      return censorNegativeZero(Math.floor(x));
    }
    return censorNegativeZero(Math.round(x));
  };
  var integerPart = function(n2) {
    return censorNegativeZero(Math.trunc(n2));
  };
  var sign = function(x) {
    return x < 0 ? -1 : 1;
  };
  var modulo = function(x, y2) {
    const signMightNotMatch = x % y2;
    if (sign(y2) !== sign(signMightNotMatch)) {
      return signMightNotMatch + y2;
    }
    return signMightNotMatch;
  };
  var censorNegativeZero = function(x) {
    return x === 0 ? 0 : x;
  };
  var createIntegerConversion = function(bitLength, { unsigned }) {
    let lowerBound, upperBound;
    if (unsigned) {
      lowerBound = 0;
      upperBound = 2 ** bitLength - 1;
    } else {
      lowerBound = -(2 ** (bitLength - 1));
      upperBound = 2 ** (bitLength - 1) - 1;
    }
    const twoToTheBitLength = 2 ** bitLength;
    const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
    return (value14, options = {}) => {
      let x = toNumber(value14, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = integerPart(x);
      if (x >= lowerBound && x <= upperBound) {
        return x;
      }
      x = modulo(x, twoToTheBitLength);
      if (!unsigned && x >= twoToOneLessThanTheBitLength) {
        return x - twoToTheBitLength;
      }
      return x;
    };
  };
  var createLongLongConversion = function(bitLength, { unsigned }) {
    const upperBound = Number.MAX_SAFE_INTEGER;
    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
    return (value14, options = {}) => {
      let x = toNumber(value14, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      let xBigInt = BigInt(integerPart(x));
      xBigInt = asBigIntN(bitLength, xBigInt);
      return Number(xBigInt);
    };
  };
  var isNonSharedArrayBuffer = function(value14) {
    try {
      abByteLengthGetter.call(value14);
      return true;
    } catch {
      return false;
    }
  };
  var isSharedArrayBuffer = function(value14) {
    try {
      sabByteLengthGetter.call(value14);
      return true;
    } catch {
      return false;
    }
  };
  var isArrayBufferDetached = function(value14) {
    try {
      new Uint8Array(value14);
      return false;
    } catch {
      return true;
    }
  };
  exports.any = (value14) => {
    return value14;
  };
  exports.undefined = () => {
    return;
  };
  exports.boolean = (value14) => {
    return Boolean(value14);
  };
  exports.byte = createIntegerConversion(8, { unsigned: false });
  exports.octet = createIntegerConversion(8, { unsigned: true });
  exports.short = createIntegerConversion(16, { unsigned: false });
  exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
  exports.long = createIntegerConversion(32, { unsigned: false });
  exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
  exports["long long"] = createLongLongConversion(64, { unsigned: false });
  exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
  exports.double = (value14, options = {}) => {
    const x = toNumber(value14, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    return x;
  };
  exports["unrestricted double"] = (value14, options = {}) => {
    const x = toNumber(value14, options);
    return x;
  };
  exports.float = (value14, options = {}) => {
    const x = toNumber(value14, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    if (Object.is(x, -0)) {
      return x;
    }
    const y2 = Math.fround(x);
    if (!Number.isFinite(y2)) {
      throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
    }
    return y2;
  };
  exports["unrestricted float"] = (value14, options = {}) => {
    const x = toNumber(value14, options);
    if (isNaN(x)) {
      return x;
    }
    if (Object.is(x, -0)) {
      return x;
    }
    return Math.fround(x);
  };
  exports.DOMString = (value14, options = {}) => {
    if (options.treatNullAsEmptyString && value14 === null) {
      return "";
    }
    if (typeof value14 === "symbol") {
      throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
    }
    const StringCtor = options.globals ? options.globals.String : String;
    return StringCtor(value14);
  };
  exports.ByteString = (value14, options = {}) => {
    const x = exports.DOMString(value14, options);
    let c2;
    for (let i2 = 0;(c2 = x.codePointAt(i2)) !== undefined; ++i2) {
      if (c2 > 255) {
        throw makeException(TypeError, "is not a valid ByteString", options);
      }
    }
    return x;
  };
  exports.USVString = (value14, options = {}) => {
    const S = exports.DOMString(value14, options);
    const n2 = S.length;
    const U = [];
    for (let i2 = 0;i2 < n2; ++i2) {
      const c2 = S.charCodeAt(i2);
      if (c2 < 55296 || c2 > 57343) {
        U.push(String.fromCodePoint(c2));
      } else if (56320 <= c2 && c2 <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else if (i2 === n2 - 1) {
        U.push(String.fromCodePoint(65533));
      } else {
        const d2 = S.charCodeAt(i2 + 1);
        if (56320 <= d2 && d2 <= 57343) {
          const a2 = c2 & 1023;
          const b2 = d2 & 1023;
          U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
          ++i2;
        } else {
          U.push(String.fromCodePoint(65533));
        }
      }
    }
    return U.join("");
  };
  exports.object = (value14, options = {}) => {
    if (value14 === null || typeof value14 !== "object" && typeof value14 !== "function") {
      throw makeException(TypeError, "is not an object", options);
    }
    return value14;
  };
  var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
  exports.ArrayBuffer = (value14, options = {}) => {
    if (!isNonSharedArrayBuffer(value14)) {
      if (options.allowShared && !isSharedArrayBuffer(value14)) {
        throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
      }
      throw makeException(TypeError, "is not an ArrayBuffer", options);
    }
    if (isArrayBufferDetached(value14)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value14;
  };
  var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
  exports.DataView = (value14, options = {}) => {
    try {
      dvByteLengthGetter.call(value14);
    } catch (e2) {
      throw makeException(TypeError, "is not a DataView", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value14.buffer)) {
      throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value14.buffer)) {
      throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
    }
    return value14;
  };
  var typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
  [
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray,
    Float32Array,
    Float64Array
  ].forEach((func) => {
    const { name } = func;
    const article = /^[AEIOU]/u.test(name) ? "an" : "a";
    exports[name] = (value14, options = {}) => {
      if (!ArrayBuffer.isView(value14) || typedArrayNameGetter.call(value14) !== name) {
        throw makeException(TypeError, `is not ${article} ${name} object`, options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value14.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value14.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value14;
    };
  });
  exports.ArrayBufferView = (value14, options = {}) => {
    if (!ArrayBuffer.isView(value14)) {
      throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value14.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value14.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
    }
    return value14;
  };
  exports.BufferSource = (value14, options = {}) => {
    if (ArrayBuffer.isView(value14)) {
      if (!options.allowShared && isSharedArrayBuffer(value14.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value14.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value14;
    }
    if (!options.allowShared && !isNonSharedArrayBuffer(value14)) {
      throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
    }
    if (options.allowShared && !isSharedArrayBuffer(value14) && !isNonSharedArrayBuffer(value14)) {
      throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
    }
    if (isArrayBufferDetached(value14)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value14;
  };
  exports.DOMTimeStamp = exports["unsigned long long"];
});

// node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var isObject = function(value14) {
    return typeof value14 === "object" && value14 !== null || typeof value14 === "function";
  };
  var define2 = function(target, source) {
    for (const key of Reflect.ownKeys(source)) {
      const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
      if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
        throw new TypeError(`Cannot redefine property: ${String(key)}`);
      }
    }
  };
  var newObjectInRealm = function(globalObject, object12) {
    const ctorRegistry = initCtorRegistry(globalObject);
    return Object.defineProperties(Object.create(ctorRegistry["%Object.prototype%"]), Object.getOwnPropertyDescriptors(object12));
  };
  var initCtorRegistry = function(globalObject) {
    if (hasOwn(globalObject, ctorRegistrySymbol)) {
      return globalObject[ctorRegistrySymbol];
    }
    const ctorRegistry = Object.create(null);
    ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
    ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));
    try {
      ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval("(async function* () {})").prototype));
    } catch {
      ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
    }
    globalObject[ctorRegistrySymbol] = ctorRegistry;
    return ctorRegistry;
  };
  var getSameObject = function(wrapper, prop, creator) {
    if (!wrapper[sameObjectCaches]) {
      wrapper[sameObjectCaches] = Object.create(null);
    }
    if (prop in wrapper[sameObjectCaches]) {
      return wrapper[sameObjectCaches][prop];
    }
    wrapper[sameObjectCaches][prop] = creator();
    return wrapper[sameObjectCaches][prop];
  };
  var wrapperForImpl = function(impl) {
    return impl ? impl[wrapperSymbol] : null;
  };
  var implForWrapper = function(wrapper) {
    return wrapper ? wrapper[implSymbol] : null;
  };
  var tryWrapperForImpl = function(impl) {
    const wrapper = wrapperForImpl(impl);
    return wrapper ? wrapper : impl;
  };
  var tryImplForWrapper = function(wrapper) {
    const impl = implForWrapper(wrapper);
    return impl ? impl : wrapper;
  };
  var isArrayIndexPropName = function(P) {
    if (typeof P !== "string") {
      return false;
    }
    const i2 = P >>> 0;
    if (i2 === 2 ** 32 - 1) {
      return false;
    }
    const s2 = `${i2}`;
    if (P !== s2) {
      return false;
    }
    return true;
  };
  var isArrayBuffer = function(value14) {
    try {
      byteLengthGetter.call(value14);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var iteratorResult = function([key, value14], kind) {
    let result;
    switch (kind) {
      case "key":
        result = key;
        break;
      case "value":
        result = value14;
        break;
      case "key+value":
        result = [key, value14];
        break;
    }
    return { value: result, done: false };
  };
  var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  var wrapperSymbol = Symbol("wrapper");
  var implSymbol = Symbol("impl");
  var sameObjectCaches = Symbol("SameObject caches");
  var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  var iterInternalSymbol = Symbol("internal");
  var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var supportsPropertyIndex = Symbol("supports property index");
  var supportedPropertyIndices = Symbol("supported property indices");
  var supportsPropertyName = Symbol("supports property name");
  var supportedPropertyNames = Symbol("supported property names");
  var indexedGet = Symbol("indexed property get");
  var indexedSetNew = Symbol("indexed property set new");
  var indexedSetExisting = Symbol("indexed property set existing");
  var namedGet = Symbol("named property get");
  var namedSetNew = Symbol("named property set new");
  var namedSetExisting = Symbol("named property set existing");
  var namedDelete = Symbol("named property delete");
  var asyncIteratorNext = Symbol("async iterator get the next iteration result");
  var asyncIteratorReturn = Symbol("async iterator return steps");
  var asyncIteratorInit = Symbol("async iterator initialization steps");
  var asyncIteratorEOI = Symbol("async iterator end of iteration");
  module.exports = exports = {
    isObject,
    hasOwn,
    define: define2,
    newObjectInRealm,
    wrapperSymbol,
    implSymbol,
    getSameObject,
    ctorRegistrySymbol,
    initCtorRegistry,
    wrapperForImpl,
    implForWrapper,
    tryWrapperForImpl,
    tryImplForWrapper,
    iterInternalSymbol,
    isArrayBuffer,
    isArrayIndexPropName,
    supportsPropertyIndex,
    supportedPropertyIndices,
    supportsPropertyName,
    supportedPropertyNames,
    indexedGet,
    indexedSetNew,
    indexedSetExisting,
    namedGet,
    namedSetNew,
    namedSetExisting,
    namedDelete,
    asyncIteratorNext,
    asyncIteratorReturn,
    asyncIteratorInit,
    asyncIteratorEOI,
    iteratorResult
  };
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports, module) => {
  var error21 = function(type73) {
    throw new RangeError(errors4[type73]);
  };
  var map3 = function(array4, callback) {
    const result = [];
    let length = array4.length;
    while (length--) {
      result[length] = callback(array4[length]);
    }
    return result;
  };
  var mapDomain = function(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map3(labels, callback).join(".");
    return result + encoded;
  };
  var ucs2decode = function(string6) {
    const output = [];
    let counter = 0;
    const length = string6.length;
    while (counter < length) {
      const value14 = string6.charCodeAt(counter++);
      if (value14 >= 55296 && value14 <= 56319 && counter < length) {
        const extra = string6.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value14 & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value14);
          counter--;
        }
      } else {
        output.push(value14);
      }
    }
    return output;
  };
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors4 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta3, numPoints, firstTime) {
    let k = 0;
    delta3 = firstTime ? floor(delta3 / damp) : delta3 >> 1;
    delta3 += floor(delta3 / numPoints);
    for (;delta3 > baseMinusTMin * tMax >> 1; k += base) {
      delta3 = floor(delta3 / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta3 / (delta3 + skew));
  };
  var decode2 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i2 = 0;
    let n2 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error21("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
      const oldi = i2;
      for (let w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error21("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error21("invalid-input");
        }
        if (digit > floor((maxInt - i2) / w)) {
          error21("overflow");
        }
        i2 += digit * w;
        const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t2) {
          break;
        }
        const baseMinusT = base - t2;
        if (w > floor(maxInt / baseMinusT)) {
          error21("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i2 - oldi, out, oldi == 0);
      if (floor(i2 / out) > maxInt - n2) {
        error21("overflow");
      }
      n2 += floor(i2 / out);
      i2 %= out;
      output.splice(i2++, 0, n2);
    }
    return String.fromCodePoint(...output);
  };
  var encode2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n2 = initialN;
    let delta3 = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m2 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n2 && currentValue < m2) {
          m2 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m2 - n2 > floor((maxInt - delta3) / handledCPCountPlusOne)) {
        error21("overflow");
      }
      delta3 += (m2 - n2) * handledCPCountPlusOne;
      n2 = m2;
      for (const currentValue of input) {
        if (currentValue < n2 && ++delta3 > maxInt) {
          error21("overflow");
        }
        if (currentValue === n2) {
          let q2 = delta3;
          for (let k = base;; k += base) {
            const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q2 < t2) {
              break;
            }
            const qMinusT = q2 - t2;
            const baseMinusT = base - t2;
            output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
            q2 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta3, handledCPCountPlusOne, handledCPCount === basicLength);
          delta3 = 0;
          ++handledCPCount;
        }
      }
      ++delta3;
      ++n2;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string6) {
      return regexPunycode.test(string6) ? decode2(string6.slice(4).toLowerCase()) : string6;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string6) {
      return regexNonASCII.test(string6) ? "xn--" + encode2(string6) : string6;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode: decode2,
    encode: encode2,
    toASCII,
    toUnicode
  };
  module.exports = punycode;
});

// node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS((exports, module) => {
  var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
  var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}]/u;
  var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u08A0-\u08A9\u08AF\u08B0\u08B3\u08B4\u08B6-\u08B8\u08BA-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0855\u0860\u0862-\u0865\u0867-\u086A\u08A0-\u08AC\u08AE-\u08B4\u08B6-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{1E900}-\u{1E943}]/u;
  var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
  var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EFD}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
  var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
  var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31F0-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
  var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  module.exports = {
    combiningMarks,
    combiningClassVirama,
    validZWNJ,
    bidiDomain,
    bidiS1LTR,
    bidiS1RTL,
    bidiS2,
    bidiS3,
    bidiS4EN,
    bidiS4AN,
    bidiS5,
    bidiS6
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], 4], [[45, 46], 2], [47, 4], [[48, 57], 2], [[58, 64], 4], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 4], [[97, 122], 2], [[123, 127], 4], [[128, 159], 3], [160, 5, " "], [[161, 167], 2], [168, 5, " \u0308"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 5, " \u0304"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 5, " \u0301"], [181, 1, "\u03BC"], [182, 2], [183, 2], [184, 5, " \u0327"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1\u20444"], [189, 1, "1\u20442"], [190, 1, "3\u20444"], [191, 2], [192, 1, "\xE0"], [193, 1, "\xE1"], [194, 1, "\xE2"], [195, 1, "\xE3"], [196, 1, "\xE4"], [197, 1, "\xE5"], [198, 1, "\xE6"], [199, 1, "\xE7"], [200, 1, "\xE8"], [201, 1, "\xE9"], [202, 1, "\xEA"], [203, 1, "\xEB"], [204, 1, "\xEC"], [205, 1, "\xED"], [206, 1, "\xEE"], [207, 1, "\xEF"], [208, 1, "\xF0"], [209, 1, "\xF1"], [210, 1, "\xF2"], [211, 1, "\xF3"], [212, 1, "\xF4"], [213, 1, "\xF5"], [214, 1, "\xF6"], [215, 2], [216, 1, "\xF8"], [217, 1, "\xF9"], [218, 1, "\xFA"], [219, 1, "\xFB"], [220, 1, "\xFC"], [221, 1, "\xFD"], [222, 1, "\xFE"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "\u0101"], [257, 2], [258, 1, "\u0103"], [259, 2], [260, 1, "\u0105"], [261, 2], [262, 1, "\u0107"], [263, 2], [264, 1, "\u0109"], [265, 2], [266, 1, "\u010B"], [267, 2], [268, 1, "\u010D"], [269, 2], [270, 1, "\u010F"], [271, 2], [272, 1, "\u0111"], [273, 2], [274, 1, "\u0113"], [275, 2], [276, 1, "\u0115"], [277, 2], [278, 1, "\u0117"], [279, 2], [280, 1, "\u0119"], [281, 2], [282, 1, "\u011B"], [283, 2], [284, 1, "\u011D"], [285, 2], [286, 1, "\u011F"], [287, 2], [288, 1, "\u0121"], [289, 2], [290, 1, "\u0123"], [291, 2], [292, 1, "\u0125"], [293, 2], [294, 1, "\u0127"], [295, 2], [296, 1, "\u0129"], [297, 2], [298, 1, "\u012B"], [299, 2], [300, 1, "\u012D"], [301, 2], [302, 1, "\u012F"], [303, 2], [304, 1, "i\u0307"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "\u0135"], [309, 2], [310, 1, "\u0137"], [[311, 312], 2], [313, 1, "\u013A"], [314, 2], [315, 1, "\u013C"], [316, 2], [317, 1, "\u013E"], [318, 2], [[319, 320], 1, "l\xB7"], [321, 1, "\u0142"], [322, 2], [323, 1, "\u0144"], [324, 2], [325, 1, "\u0146"], [326, 2], [327, 1, "\u0148"], [328, 2], [329, 1, "\u02BCn"], [330, 1, "\u014B"], [331, 2], [332, 1, "\u014D"], [333, 2], [334, 1, "\u014F"], [335, 2], [336, 1, "\u0151"], [337, 2], [338, 1, "\u0153"], [339, 2], [340, 1, "\u0155"], [341, 2], [342, 1, "\u0157"], [343, 2], [344, 1, "\u0159"], [345, 2], [346, 1, "\u015B"], [347, 2], [348, 1, "\u015D"], [349, 2], [350, 1, "\u015F"], [351, 2], [352, 1, "\u0161"], [353, 2], [354, 1, "\u0163"], [355, 2], [356, 1, "\u0165"], [357, 2], [358, 1, "\u0167"], [359, 2], [360, 1, "\u0169"], [361, 2], [362, 1, "\u016B"], [363, 2], [364, 1, "\u016D"], [365, 2], [366, 1, "\u016F"], [367, 2], [368, 1, "\u0171"], [369, 2], [370, 1, "\u0173"], [371, 2], [372, 1, "\u0175"], [373, 2], [374, 1, "\u0177"], [375, 2], [376, 1, "\xFF"], [377, 1, "\u017A"], [378, 2], [379, 1, "\u017C"], [380, 2], [381, 1, "\u017E"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "\u0253"], [386, 1, "\u0183"], [387, 2], [388, 1, "\u0185"], [389, 2], [390, 1, "\u0254"], [391, 1, "\u0188"], [392, 2], [393, 1, "\u0256"], [394, 1, "\u0257"], [395, 1, "\u018C"], [[396, 397], 2], [398, 1, "\u01DD"], [399, 1, "\u0259"], [400, 1, "\u025B"], [401, 1, "\u0192"], [402, 2], [403, 1, "\u0260"], [404, 1, "\u0263"], [405, 2], [406, 1, "\u0269"], [407, 1, "\u0268"], [408, 1, "\u0199"], [[409, 411], 2], [412, 1, "\u026F"], [413, 1, "\u0272"], [414, 2], [415, 1, "\u0275"], [416, 1, "\u01A1"], [417, 2], [418, 1, "\u01A3"], [419, 2], [420, 1, "\u01A5"], [421, 2], [422, 1, "\u0280"], [423, 1, "\u01A8"], [424, 2], [425, 1, "\u0283"], [[426, 427], 2], [428, 1, "\u01AD"], [429, 2], [430, 1, "\u0288"], [431, 1, "\u01B0"], [432, 2], [433, 1, "\u028A"], [434, 1, "\u028B"], [435, 1, "\u01B4"], [436, 2], [437, 1, "\u01B6"], [438, 2], [439, 1, "\u0292"], [440, 1, "\u01B9"], [[441, 443], 2], [444, 1, "\u01BD"], [[445, 451], 2], [[452, 454], 1, "d\u017E"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "\u01CE"], [462, 2], [463, 1, "\u01D0"], [464, 2], [465, 1, "\u01D2"], [466, 2], [467, 1, "\u01D4"], [468, 2], [469, 1, "\u01D6"], [470, 2], [471, 1, "\u01D8"], [472, 2], [473, 1, "\u01DA"], [474, 2], [475, 1, "\u01DC"], [[476, 477], 2], [478, 1, "\u01DF"], [479, 2], [480, 1, "\u01E1"], [481, 2], [482, 1, "\u01E3"], [483, 2], [484, 1, "\u01E5"], [485, 2], [486, 1, "\u01E7"], [487, 2], [488, 1, "\u01E9"], [489, 2], [490, 1, "\u01EB"], [491, 2], [492, 1, "\u01ED"], [493, 2], [494, 1, "\u01EF"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "\u01F5"], [501, 2], [502, 1, "\u0195"], [503, 1, "\u01BF"], [504, 1, "\u01F9"], [505, 2], [506, 1, "\u01FB"], [507, 2], [508, 1, "\u01FD"], [509, 2], [510, 1, "\u01FF"], [511, 2], [512, 1, "\u0201"], [513, 2], [514, 1, "\u0203"], [515, 2], [516, 1, "\u0205"], [517, 2], [518, 1, "\u0207"], [519, 2], [520, 1, "\u0209"], [521, 2], [522, 1, "\u020B"], [523, 2], [524, 1, "\u020D"], [525, 2], [526, 1, "\u020F"], [527, 2], [528, 1, "\u0211"], [529, 2], [530, 1, "\u0213"], [531, 2], [532, 1, "\u0215"], [533, 2], [534, 1, "\u0217"], [535, 2], [536, 1, "\u0219"], [537, 2], [538, 1, "\u021B"], [539, 2], [540, 1, "\u021D"], [541, 2], [542, 1, "\u021F"], [543, 2], [544, 1, "\u019E"], [545, 2], [546, 1, "\u0223"], [547, 2], [548, 1, "\u0225"], [549, 2], [550, 1, "\u0227"], [551, 2], [552, 1, "\u0229"], [553, 2], [554, 1, "\u022B"], [555, 2], [556, 1, "\u022D"], [557, 2], [558, 1, "\u022F"], [559, 2], [560, 1, "\u0231"], [561, 2], [562, 1, "\u0233"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "\u2C65"], [571, 1, "\u023C"], [572, 2], [573, 1, "\u019A"], [574, 1, "\u2C66"], [[575, 576], 2], [577, 1, "\u0242"], [578, 2], [579, 1, "\u0180"], [580, 1, "\u0289"], [581, 1, "\u028C"], [582, 1, "\u0247"], [583, 2], [584, 1, "\u0249"], [585, 2], [586, 1, "\u024B"], [587, 2], [588, 1, "\u024D"], [589, 2], [590, 1, "\u024F"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "\u0266"], [690, 1, "j"], [691, 1, "r"], [692, 1, "\u0279"], [693, 1, "\u027B"], [694, 1, "\u0281"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 5, " \u0306"], [729, 5, " \u0307"], [730, 5, " \u030A"], [731, 5, " \u0328"], [732, 5, " \u0303"], [733, 5, " \u030B"], [734, 2], [735, 2], [736, 1, "\u0263"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "\u0295"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "\u0300"], [833, 1, "\u0301"], [834, 2], [835, 1, "\u0313"], [836, 1, "\u0308\u0301"], [837, 1, "\u03B9"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "\u0371"], [881, 2], [882, 1, "\u0373"], [883, 2], [884, 1, "\u02B9"], [885, 2], [886, 1, "\u0377"], [887, 2], [[888, 889], 3], [890, 5, " \u03B9"], [[891, 893], 2], [894, 5, ";"], [895, 1, "\u03F3"], [[896, 899], 3], [900, 5, " \u0301"], [901, 5, " \u0308\u0301"], [902, 1, "\u03AC"], [903, 1, "\xB7"], [904, 1, "\u03AD"], [905, 1, "\u03AE"], [906, 1, "\u03AF"], [907, 3], [908, 1, "\u03CC"], [909, 3], [910, 1, "\u03CD"], [911, 1, "\u03CE"], [912, 2], [913, 1, "\u03B1"], [914, 1, "\u03B2"], [915, 1, "\u03B3"], [916, 1, "\u03B4"], [917, 1, "\u03B5"], [918, 1, "\u03B6"], [919, 1, "\u03B7"], [920, 1, "\u03B8"], [921, 1, "\u03B9"], [922, 1, "\u03BA"], [923, 1, "\u03BB"], [924, 1, "\u03BC"], [925, 1, "\u03BD"], [926, 1, "\u03BE"], [927, 1, "\u03BF"], [928, 1, "\u03C0"], [929, 1, "\u03C1"], [930, 3], [931, 1, "\u03C3"], [932, 1, "\u03C4"], [933, 1, "\u03C5"], [934, 1, "\u03C6"], [935, 1, "\u03C7"], [936, 1, "\u03C8"], [937, 1, "\u03C9"], [938, 1, "\u03CA"], [939, 1, "\u03CB"], [[940, 961], 2], [962, 6, "\u03C3"], [[963, 974], 2], [975, 1, "\u03D7"], [976, 1, "\u03B2"], [977, 1, "\u03B8"], [978, 1, "\u03C5"], [979, 1, "\u03CD"], [980, 1, "\u03CB"], [981, 1, "\u03C6"], [982, 1, "\u03C0"], [983, 2], [984, 1, "\u03D9"], [985, 2], [986, 1, "\u03DB"], [987, 2], [988, 1, "\u03DD"], [989, 2], [990, 1, "\u03DF"], [991, 2], [992, 1, "\u03E1"], [993, 2], [994, 1, "\u03E3"], [995, 2], [996, 1, "\u03E5"], [997, 2], [998, 1, "\u03E7"], [999, 2], [1000, 1, "\u03E9"], [1001, 2], [1002, 1, "\u03EB"], [1003, 2], [1004, 1, "\u03ED"], [1005, 2], [1006, 1, "\u03EF"], [1007, 2], [1008, 1, "\u03BA"], [1009, 1, "\u03C1"], [1010, 1, "\u03C3"], [1011, 2], [1012, 1, "\u03B8"], [1013, 1, "\u03B5"], [1014, 2], [1015, 1, "\u03F8"], [1016, 2], [1017, 1, "\u03C3"], [1018, 1, "\u03FB"], [1019, 2], [1020, 2], [1021, 1, "\u037B"], [1022, 1, "\u037C"], [1023, 1, "\u037D"], [1024, 1, "\u0450"], [1025, 1, "\u0451"], [1026, 1, "\u0452"], [1027, 1, "\u0453"], [1028, 1, "\u0454"], [1029, 1, "\u0455"], [1030, 1, "\u0456"], [1031, 1, "\u0457"], [1032, 1, "\u0458"], [1033, 1, "\u0459"], [1034, 1, "\u045A"], [1035, 1, "\u045B"], [1036, 1, "\u045C"], [1037, 1, "\u045D"], [1038, 1, "\u045E"], [1039, 1, "\u045F"], [1040, 1, "\u0430"], [1041, 1, "\u0431"], [1042, 1, "\u0432"], [1043, 1, "\u0433"], [1044, 1, "\u0434"], [1045, 1, "\u0435"], [1046, 1, "\u0436"], [1047, 1, "\u0437"], [1048, 1, "\u0438"], [1049, 1, "\u0439"], [1050, 1, "\u043A"], [1051, 1, "\u043B"], [1052, 1, "\u043C"], [1053, 1, "\u043D"], [1054, 1, "\u043E"], [1055, 1, "\u043F"], [1056, 1, "\u0440"], [1057, 1, "\u0441"], [1058, 1, "\u0442"], [1059, 1, "\u0443"], [1060, 1, "\u0444"], [1061, 1, "\u0445"], [1062, 1, "\u0446"], [1063, 1, "\u0447"], [1064, 1, "\u0448"], [1065, 1, "\u0449"], [1066, 1, "\u044A"], [1067, 1, "\u044B"], [1068, 1, "\u044C"], [1069, 1, "\u044D"], [1070, 1, "\u044E"], [1071, 1, "\u044F"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "\u0461"], [1121, 2], [1122, 1, "\u0463"], [1123, 2], [1124, 1, "\u0465"], [1125, 2], [1126, 1, "\u0467"], [1127, 2], [1128, 1, "\u0469"], [1129, 2], [1130, 1, "\u046B"], [1131, 2], [1132, 1, "\u046D"], [1133, 2], [1134, 1, "\u046F"], [1135, 2], [1136, 1, "\u0471"], [1137, 2], [1138, 1, "\u0473"], [1139, 2], [1140, 1, "\u0475"], [1141, 2], [1142, 1, "\u0477"], [1143, 2], [1144, 1, "\u0479"], [1145, 2], [1146, 1, "\u047B"], [1147, 2], [1148, 1, "\u047D"], [1149, 2], [1150, 1, "\u047F"], [1151, 2], [1152, 1, "\u0481"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "\u048B"], [1163, 2], [1164, 1, "\u048D"], [1165, 2], [1166, 1, "\u048F"], [1167, 2], [1168, 1, "\u0491"], [1169, 2], [1170, 1, "\u0493"], [1171, 2], [1172, 1, "\u0495"], [1173, 2], [1174, 1, "\u0497"], [1175, 2], [1176, 1, "\u0499"], [1177, 2], [1178, 1, "\u049B"], [1179, 2], [1180, 1, "\u049D"], [1181, 2], [1182, 1, "\u049F"], [1183, 2], [1184, 1, "\u04A1"], [1185, 2], [1186, 1, "\u04A3"], [1187, 2], [1188, 1, "\u04A5"], [1189, 2], [1190, 1, "\u04A7"], [1191, 2], [1192, 1, "\u04A9"], [1193, 2], [1194, 1, "\u04AB"], [1195, 2], [1196, 1, "\u04AD"], [1197, 2], [1198, 1, "\u04AF"], [1199, 2], [1200, 1, "\u04B1"], [1201, 2], [1202, 1, "\u04B3"], [1203, 2], [1204, 1, "\u04B5"], [1205, 2], [1206, 1, "\u04B7"], [1207, 2], [1208, 1, "\u04B9"], [1209, 2], [1210, 1, "\u04BB"], [1211, 2], [1212, 1, "\u04BD"], [1213, 2], [1214, 1, "\u04BF"], [1215, 2], [1216, 3], [1217, 1, "\u04C2"], [1218, 2], [1219, 1, "\u04C4"], [1220, 2], [1221, 1, "\u04C6"], [1222, 2], [1223, 1, "\u04C8"], [1224, 2], [1225, 1, "\u04CA"], [1226, 2], [1227, 1, "\u04CC"], [1228, 2], [1229, 1, "\u04CE"], [1230, 2], [1231, 2], [1232, 1, "\u04D1"], [1233, 2], [1234, 1, "\u04D3"], [1235, 2], [1236, 1, "\u04D5"], [1237, 2], [1238, 1, "\u04D7"], [1239, 2], [1240, 1, "\u04D9"], [1241, 2], [1242, 1, "\u04DB"], [1243, 2], [1244, 1, "\u04DD"], [1245, 2], [1246, 1, "\u04DF"], [1247, 2], [1248, 1, "\u04E1"], [1249, 2], [1250, 1, "\u04E3"], [1251, 2], [1252, 1, "\u04E5"], [1253, 2], [1254, 1, "\u04E7"], [1255, 2], [1256, 1, "\u04E9"], [1257, 2], [1258, 1, "\u04EB"], [1259, 2], [1260, 1, "\u04ED"], [1261, 2], [1262, 1, "\u04EF"], [1263, 2], [1264, 1, "\u04F1"], [1265, 2], [1266, 1, "\u04F3"], [1267, 2], [1268, 1, "\u04F5"], [1269, 2], [1270, 1, "\u04F7"], [1271, 2], [1272, 1, "\u04F9"], [1273, 2], [1274, 1, "\u04FB"], [1275, 2], [1276, 1, "\u04FD"], [1277, 2], [1278, 1, "\u04FF"], [1279, 2], [1280, 1, "\u0501"], [1281, 2], [1282, 1, "\u0503"], [1283, 2], [1284, 1, "\u0505"], [1285, 2], [1286, 1, "\u0507"], [1287, 2], [1288, 1, "\u0509"], [1289, 2], [1290, 1, "\u050B"], [1291, 2], [1292, 1, "\u050D"], [1293, 2], [1294, 1, "\u050F"], [1295, 2], [1296, 1, "\u0511"], [1297, 2], [1298, 1, "\u0513"], [1299, 2], [1300, 1, "\u0515"], [1301, 2], [1302, 1, "\u0517"], [1303, 2], [1304, 1, "\u0519"], [1305, 2], [1306, 1, "\u051B"], [1307, 2], [1308, 1, "\u051D"], [1309, 2], [1310, 1, "\u051F"], [1311, 2], [1312, 1, "\u0521"], [1313, 2], [1314, 1, "\u0523"], [1315, 2], [1316, 1, "\u0525"], [1317, 2], [1318, 1, "\u0527"], [1319, 2], [1320, 1, "\u0529"], [1321, 2], [1322, 1, "\u052B"], [1323, 2], [1324, 1, "\u052D"], [1325, 2], [1326, 1, "\u052F"], [1327, 2], [1328, 3], [1329, 1, "\u0561"], [1330, 1, "\u0562"], [1331, 1, "\u0563"], [1332, 1, "\u0564"], [1333, 1, "\u0565"], [1334, 1, "\u0566"], [1335, 1, "\u0567"], [1336, 1, "\u0568"], [1337, 1, "\u0569"], [1338, 1, "\u056A"], [1339, 1, "\u056B"], [1340, 1, "\u056C"], [1341, 1, "\u056D"], [1342, 1, "\u056E"], [1343, 1, "\u056F"], [1344, 1, "\u0570"], [1345, 1, "\u0571"], [1346, 1, "\u0572"], [1347, 1, "\u0573"], [1348, 1, "\u0574"], [1349, 1, "\u0575"], [1350, 1, "\u0576"], [1351, 1, "\u0577"], [1352, 1, "\u0578"], [1353, 1, "\u0579"], [1354, 1, "\u057A"], [1355, 1, "\u057B"], [1356, 1, "\u057C"], [1357, 1, "\u057D"], [1358, 1, "\u057E"], [1359, 1, "\u057F"], [1360, 1, "\u0580"], [1361, 1, "\u0581"], [1362, 1, "\u0582"], [1363, 1, "\u0583"], [1364, 1, "\u0584"], [1365, 1, "\u0585"], [1366, 1, "\u0586"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "\u0565\u0582"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "\u0627\u0674"], [1654, 1, "\u0648\u0674"], [1655, 1, "\u06C7\u0674"], [1656, 1, "\u064A\u0674"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2199], 3], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "\u0915\u093C"], [2393, 1, "\u0916\u093C"], [2394, 1, "\u0917\u093C"], [2395, 1, "\u091C\u093C"], [2396, 1, "\u0921\u093C"], [2397, 1, "\u0922\u093C"], [2398, 1, "\u092B\u093C"], [2399, 1, "\u092F\u093C"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "\u09A1\u09BC"], [2525, 1, "\u09A2\u09BC"], [2526, 3], [2527, 1, "\u09AF\u09BC"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "\u0A32\u0A3C"], [2612, 3], [2613, 2], [2614, 1, "\u0A38\u0A3C"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "\u0A16\u0A3C"], [2650, 1, "\u0A17\u0A3C"], [2651, 1, "\u0A1C\u0A3C"], [2652, 2], [2653, 3], [2654, 1, "\u0A2B\u0A3C"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "\u0B21\u0B3C"], [2909, 1, "\u0B22\u0B3C"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [3315, 2], [[3316, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "\u0E4D\u0E32"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "\u0ECD\u0EB2"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [3790, 2], [3791, 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "\u0EAB\u0E99"], [3805, 1, "\u0EAB\u0EA1"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "\u0F0B"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "\u0F42\u0FB7"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "\u0F4C\u0FB7"], [[3918, 3921], 2], [3922, 1, "\u0F51\u0FB7"], [[3923, 3926], 2], [3927, 1, "\u0F56\u0FB7"], [[3928, 3931], 2], [3932, 1, "\u0F5B\u0FB7"], [[3933, 3944], 2], [3945, 1, "\u0F40\u0FB5"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "\u0F71\u0F72"], [3956, 2], [3957, 1, "\u0F71\u0F74"], [3958, 1, "\u0FB2\u0F80"], [3959, 1, "\u0FB2\u0F71\u0F80"], [3960, 1, "\u0FB3\u0F80"], [3961, 1, "\u0FB3\u0F71\u0F80"], [[3962, 3968], 2], [3969, 1, "\u0F71\u0F80"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "\u0F92\u0FB7"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "\u0F9C\u0FB7"], [[3998, 4001], 2], [4002, 1, "\u0FA1\u0FB7"], [[4003, 4006], 2], [4007, 1, "\u0FA6\u0FB7"], [[4008, 4011], 2], [4012, 1, "\u0FAB\u0FB7"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "\u0F90\u0FB5"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [[4256, 4293], 3], [4294, 3], [4295, 1, "\u2D27"], [[4296, 4300], 3], [4301, 1, "\u2D2D"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "\u10DC"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 3], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "\u13F0"], [5113, 1, "\u13F1"], [5114, 1, "\u13F2"], [5115, 1, "\u13F3"], [5116, 1, "\u13F4"], [5117, 1, "\u13F5"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6000], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 3], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6149], 2], [6150, 3], [[6151, 6154], 2], [[6155, 6157], 7], [6158, 3], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [[6989, 6991], 3], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 3], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "\u0432"], [7297, 1, "\u0434"], [7298, 1, "\u043E"], [7299, 1, "\u0441"], [[7300, 7301], 1, "\u0442"], [7302, 1, "\u044A"], [7303, 1, "\u0463"], [7304, 1, "\uA64B"], [[7305, 7311], 3], [7312, 1, "\u10D0"], [7313, 1, "\u10D1"], [7314, 1, "\u10D2"], [7315, 1, "\u10D3"], [7316, 1, "\u10D4"], [7317, 1, "\u10D5"], [7318, 1, "\u10D6"], [7319, 1, "\u10D7"], [7320, 1, "\u10D8"], [7321, 1, "\u10D9"], [7322, 1, "\u10DA"], [7323, 1, "\u10DB"], [7324, 1, "\u10DC"], [7325, 1, "\u10DD"], [7326, 1, "\u10DE"], [7327, 1, "\u10DF"], [7328, 1, "\u10E0"], [7329, 1, "\u10E1"], [7330, 1, "\u10E2"], [7331, 1, "\u10E3"], [7332, 1, "\u10E4"], [7333, 1, "\u10E5"], [7334, 1, "\u10E6"], [7335, 1, "\u10E7"], [7336, 1, "\u10E8"], [7337, 1, "\u10E9"], [7338, 1, "\u10EA"], [7339, 1, "\u10EB"], [7340, 1, "\u10EC"], [7341, 1, "\u10ED"], [7342, 1, "\u10EE"], [7343, 1, "\u10EF"], [7344, 1, "\u10F0"], [7345, 1, "\u10F1"], [7346, 1, "\u10F2"], [7347, 1, "\u10F3"], [7348, 1, "\u10F4"], [7349, 1, "\u10F5"], [7350, 1, "\u10F6"], [7351, 1, "\u10F7"], [7352, 1, "\u10F8"], [7353, 1, "\u10F9"], [7354, 1, "\u10FA"], [[7355, 7356], 3], [7357, 1, "\u10FD"], [7358, 1, "\u10FE"], [7359, 1, "\u10FF"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "\xE6"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "\u01DD"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "\u0223"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "\u0250"], [7493, 1, "\u0251"], [7494, 1, "\u1D02"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "\u0259"], [7499, 1, "\u025B"], [7500, 1, "\u025C"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "\u014B"], [7506, 1, "o"], [7507, 1, "\u0254"], [7508, 1, "\u1D16"], [7509, 1, "\u1D17"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "\u1D1D"], [7514, 1, "\u026F"], [7515, 1, "v"], [7516, 1, "\u1D25"], [7517, 1, "\u03B2"], [7518, 1, "\u03B3"], [7519, 1, "\u03B4"], [7520, 1, "\u03C6"], [7521, 1, "\u03C7"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "\u03B2"], [7527, 1, "\u03B3"], [7528, 1, "\u03C1"], [7529, 1, "\u03C6"], [7530, 1, "\u03C7"], [7531, 2], [[7532, 7543], 2], [7544, 1, "\u043D"], [[7545, 7578], 2], [7579, 1, "\u0252"], [7580, 1, "c"], [7581, 1, "\u0255"], [7582, 1, "\xF0"], [7583, 1, "\u025C"], [7584, 1, "f"], [7585, 1, "\u025F"], [7586, 1, "\u0261"], [7587, 1, "\u0265"], [7588, 1, "\u0268"], [7589, 1, "\u0269"], [7590, 1, "\u026A"], [7591, 1, "\u1D7B"], [7592, 1, "\u029D"], [7593, 1, "\u026D"], [7594, 1, "\u1D85"], [7595, 1, "\u029F"], [7596, 1, "\u0271"], [7597, 1, "\u0270"], [7598, 1, "\u0272"], [7599, 1, "\u0273"], [7600, 1, "\u0274"], [7601, 1, "\u0275"], [7602, 1, "\u0278"], [7603, 1, "\u0282"], [7604, 1, "\u0283"], [7605, 1, "\u01AB"], [7606, 1, "\u0289"], [7607, 1, "\u028A"], [7608, 1, "\u1D1C"], [7609, 1, "\u028B"], [7610, 1, "\u028C"], [7611, 1, "z"], [7612, 1, "\u0290"], [7613, 1, "\u0291"], [7614, 1, "\u0292"], [7615, 1, "\u03B8"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "\u1E01"], [7681, 2], [7682, 1, "\u1E03"], [7683, 2], [7684, 1, "\u1E05"], [7685, 2], [7686, 1, "\u1E07"], [7687, 2], [7688, 1, "\u1E09"], [7689, 2], [7690, 1, "\u1E0B"], [7691, 2], [7692, 1, "\u1E0D"], [7693, 2], [7694, 1, "\u1E0F"], [7695, 2], [7696, 1, "\u1E11"], [7697, 2], [7698, 1, "\u1E13"], [7699, 2], [7700, 1, "\u1E15"], [7701, 2], [7702, 1, "\u1E17"], [7703, 2], [7704, 1, "\u1E19"], [7705, 2], [7706, 1, "\u1E1B"], [7707, 2], [7708, 1, "\u1E1D"], [7709, 2], [7710, 1, "\u1E1F"], [7711, 2], [7712, 1, "\u1E21"], [7713, 2], [7714, 1, "\u1E23"], [7715, 2], [7716, 1, "\u1E25"], [7717, 2], [7718, 1, "\u1E27"], [7719, 2], [7720, 1, "\u1E29"], [7721, 2], [7722, 1, "\u1E2B"], [7723, 2], [7724, 1, "\u1E2D"], [7725, 2], [7726, 1, "\u1E2F"], [7727, 2], [7728, 1, "\u1E31"], [7729, 2], [7730, 1, "\u1E33"], [7731, 2], [7732, 1, "\u1E35"], [7733, 2], [7734, 1, "\u1E37"], [7735, 2], [7736, 1, "\u1E39"], [7737, 2], [7738, 1, "\u1E3B"], [7739, 2], [7740, 1, "\u1E3D"], [7741, 2], [7742, 1, "\u1E3F"], [7743, 2], [7744, 1, "\u1E41"], [7745, 2], [7746, 1, "\u1E43"], [7747, 2], [7748, 1, "\u1E45"], [7749, 2], [7750, 1, "\u1E47"], [7751, 2], [7752, 1, "\u1E49"], [7753, 2], [7754, 1, "\u1E4B"], [7755, 2], [7756, 1, "\u1E4D"], [7757, 2], [7758, 1, "\u1E4F"], [7759, 2], [7760, 1, "\u1E51"], [7761, 2], [7762, 1, "\u1E53"], [7763, 2], [7764, 1, "\u1E55"], [7765, 2], [7766, 1, "\u1E57"], [7767, 2], [7768, 1, "\u1E59"], [7769, 2], [7770, 1, "\u1E5B"], [7771, 2], [7772, 1, "\u1E5D"], [7773, 2], [7774, 1, "\u1E5F"], [7775, 2], [7776, 1, "\u1E61"], [7777, 2], [7778, 1, "\u1E63"], [7779, 2], [7780, 1, "\u1E65"], [7781, 2], [7782, 1, "\u1E67"], [7783, 2], [7784, 1, "\u1E69"], [7785, 2], [7786, 1, "\u1E6B"], [7787, 2], [7788, 1, "\u1E6D"], [7789, 2], [7790, 1, "\u1E6F"], [7791, 2], [7792, 1, "\u1E71"], [7793, 2], [7794, 1, "\u1E73"], [7795, 2], [7796, 1, "\u1E75"], [7797, 2], [7798, 1, "\u1E77"], [7799, 2], [7800, 1, "\u1E79"], [7801, 2], [7802, 1, "\u1E7B"], [7803, 2], [7804, 1, "\u1E7D"], [7805, 2], [7806, 1, "\u1E7F"], [7807, 2], [7808, 1, "\u1E81"], [7809, 2], [7810, 1, "\u1E83"], [7811, 2], [7812, 1, "\u1E85"], [7813, 2], [7814, 1, "\u1E87"], [7815, 2], [7816, 1, "\u1E89"], [7817, 2], [7818, 1, "\u1E8B"], [7819, 2], [7820, 1, "\u1E8D"], [7821, 2], [7822, 1, "\u1E8F"], [7823, 2], [7824, 1, "\u1E91"], [7825, 2], [7826, 1, "\u1E93"], [7827, 2], [7828, 1, "\u1E95"], [[7829, 7833], 2], [7834, 1, "a\u02BE"], [7835, 1, "\u1E61"], [[7836, 7837], 2], [7838, 1, "ss"], [7839, 2], [7840, 1, "\u1EA1"], [7841, 2], [7842, 1, "\u1EA3"], [7843, 2], [7844, 1, "\u1EA5"], [7845, 2], [7846, 1, "\u1EA7"], [7847, 2], [7848, 1, "\u1EA9"], [7849, 2], [7850, 1, "\u1EAB"], [7851, 2], [7852, 1, "\u1EAD"], [7853, 2], [7854, 1, "\u1EAF"], [7855, 2], [7856, 1, "\u1EB1"], [7857, 2], [7858, 1, "\u1EB3"], [7859, 2], [7860, 1, "\u1EB5"], [7861, 2], [7862, 1, "\u1EB7"], [7863, 2], [7864, 1, "\u1EB9"], [7865, 2], [7866, 1, "\u1EBB"], [7867, 2], [7868, 1, "\u1EBD"], [7869, 2], [7870, 1, "\u1EBF"], [7871, 2], [7872, 1, "\u1EC1"], [7873, 2], [7874, 1, "\u1EC3"], [7875, 2], [7876, 1, "\u1EC5"], [7877, 2], [7878, 1, "\u1EC7"], [7879, 2], [7880, 1, "\u1EC9"], [7881, 2], [7882, 1, "\u1ECB"], [7883, 2], [7884, 1, "\u1ECD"], [7885, 2], [7886, 1, "\u1ECF"], [7887, 2], [7888, 1, "\u1ED1"], [7889, 2], [7890, 1, "\u1ED3"], [7891, 2], [7892, 1, "\u1ED5"], [7893, 2], [7894, 1, "\u1ED7"], [7895, 2], [7896, 1, "\u1ED9"], [7897, 2], [7898, 1, "\u1EDB"], [7899, 2], [7900, 1, "\u1EDD"], [7901, 2], [7902, 1, "\u1EDF"], [7903, 2], [7904, 1, "\u1EE1"], [7905, 2], [7906, 1, "\u1EE3"], [7907, 2], [7908, 1, "\u1EE5"], [7909, 2], [7910, 1, "\u1EE7"], [7911, 2], [7912, 1, "\u1EE9"], [7913, 2], [7914, 1, "\u1EEB"], [7915, 2], [7916, 1, "\u1EED"], [7917, 2], [7918, 1, "\u1EEF"], [7919, 2], [7920, 1, "\u1EF1"], [7921, 2], [7922, 1, "\u1EF3"], [7923, 2], [7924, 1, "\u1EF5"], [7925, 2], [7926, 1, "\u1EF7"], [7927, 2], [7928, 1, "\u1EF9"], [7929, 2], [7930, 1, "\u1EFB"], [7931, 2], [7932, 1, "\u1EFD"], [7933, 2], [7934, 1, "\u1EFF"], [7935, 2], [[7936, 7943], 2], [7944, 1, "\u1F00"], [7945, 1, "\u1F01"], [7946, 1, "\u1F02"], [7947, 1, "\u1F03"], [7948, 1, "\u1F04"], [7949, 1, "\u1F05"], [7950, 1, "\u1F06"], [7951, 1, "\u1F07"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "\u1F10"], [7961, 1, "\u1F11"], [7962, 1, "\u1F12"], [7963, 1, "\u1F13"], [7964, 1, "\u1F14"], [7965, 1, "\u1F15"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "\u1F20"], [7977, 1, "\u1F21"], [7978, 1, "\u1F22"], [7979, 1, "\u1F23"], [7980, 1, "\u1F24"], [7981, 1, "\u1F25"], [7982, 1, "\u1F26"], [7983, 1, "\u1F27"], [[7984, 7991], 2], [7992, 1, "\u1F30"], [7993, 1, "\u1F31"], [7994, 1, "\u1F32"], [7995, 1, "\u1F33"], [7996, 1, "\u1F34"], [7997, 1, "\u1F35"], [7998, 1, "\u1F36"], [7999, 1, "\u1F37"], [[8000, 8005], 2], [[8006, 8007], 3], [8008, 1, "\u1F40"], [8009, 1, "\u1F41"], [8010, 1, "\u1F42"], [8011, 1, "\u1F43"], [8012, 1, "\u1F44"], [8013, 1, "\u1F45"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "\u1F51"], [8026, 3], [8027, 1, "\u1F53"], [8028, 3], [8029, 1, "\u1F55"], [8030, 3], [8031, 1, "\u1F57"], [[8032, 8039], 2], [8040, 1, "\u1F60"], [8041, 1, "\u1F61"], [8042, 1, "\u1F62"], [8043, 1, "\u1F63"], [8044, 1, "\u1F64"], [8045, 1, "\u1F65"], [8046, 1, "\u1F66"], [8047, 1, "\u1F67"], [8048, 2], [8049, 1, "\u03AC"], [8050, 2], [8051, 1, "\u03AD"], [8052, 2], [8053, 1, "\u03AE"], [8054, 2], [8055, 1, "\u03AF"], [8056, 2], [8057, 1, "\u03CC"], [8058, 2], [8059, 1, "\u03CD"], [8060, 2], [8061, 1, "\u03CE"], [[8062, 8063], 3], [8064, 1, "\u1F00\u03B9"], [8065, 1, "\u1F01\u03B9"], [8066, 1, "\u1F02\u03B9"], [8067, 1, "\u1F03\u03B9"], [8068, 1, "\u1F04\u03B9"], [8069, 1, "\u1F05\u03B9"], [8070, 1, "\u1F06\u03B9"], [8071, 1, "\u1F07\u03B9"], [8072, 1, "\u1F00\u03B9"], [8073, 1, "\u1F01\u03B9"], [8074, 1, "\u1F02\u03B9"], [8075, 1, "\u1F03\u03B9"], [8076, 1, "\u1F04\u03B9"], [8077, 1, "\u1F05\u03B9"], [8078, 1, "\u1F06\u03B9"], [8079, 1, "\u1F07\u03B9"], [8080, 1, "\u1F20\u03B9"], [8081, 1, "\u1F21\u03B9"], [8082, 1, "\u1F22\u03B9"], [8083, 1, "\u1F23\u03B9"], [8084, 1, "\u1F24\u03B9"], [8085, 1, "\u1F25\u03B9"], [8086, 1, "\u1F26\u03B9"], [8087, 1, "\u1F27\u03B9"], [8088, 1, "\u1F20\u03B9"], [8089, 1, "\u1F21\u03B9"], [8090, 1, "\u1F22\u03B9"], [8091, 1, "\u1F23\u03B9"], [8092, 1, "\u1F24\u03B9"], [8093, 1, "\u1F25\u03B9"], [8094, 1, "\u1F26\u03B9"], [8095, 1, "\u1F27\u03B9"], [8096, 1, "\u1F60\u03B9"], [8097, 1, "\u1F61\u03B9"], [8098, 1, "\u1F62\u03B9"], [8099, 1, "\u1F63\u03B9"], [8100, 1, "\u1F64\u03B9"], [8101, 1, "\u1F65\u03B9"], [8102, 1, "\u1F66\u03B9"], [8103, 1, "\u1F67\u03B9"], [8104, 1, "\u1F60\u03B9"], [8105, 1, "\u1F61\u03B9"], [8106, 1, "\u1F62\u03B9"], [8107, 1, "\u1F63\u03B9"], [8108, 1, "\u1F64\u03B9"], [8109, 1, "\u1F65\u03B9"], [8110, 1, "\u1F66\u03B9"], [8111, 1, "\u1F67\u03B9"], [[8112, 8113], 2], [8114, 1, "\u1F70\u03B9"], [8115, 1, "\u03B1\u03B9"], [8116, 1, "\u03AC\u03B9"], [8117, 3], [8118, 2], [8119, 1, "\u1FB6\u03B9"], [8120, 1, "\u1FB0"], [8121, 1, "\u1FB1"], [8122, 1, "\u1F70"], [8123, 1, "\u03AC"], [8124, 1, "\u03B1\u03B9"], [8125, 5, " \u0313"], [8126, 1, "\u03B9"], [8127, 5, " \u0313"], [8128, 5, " \u0342"], [8129, 5, " \u0308\u0342"], [8130, 1, "\u1F74\u03B9"], [8131, 1, "\u03B7\u03B9"], [8132, 1, "\u03AE\u03B9"], [8133, 3], [8134, 2], [8135, 1, "\u1FC6\u03B9"], [8136, 1, "\u1F72"], [8137, 1, "\u03AD"], [8138, 1, "\u1F74"], [8139, 1, "\u03AE"], [8140, 1, "\u03B7\u03B9"], [8141, 5, " \u0313\u0300"], [8142, 5, " \u0313\u0301"], [8143, 5, " \u0313\u0342"], [[8144, 8146], 2], [8147, 1, "\u0390"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "\u1FD0"], [8153, 1, "\u1FD1"], [8154, 1, "\u1F76"], [8155, 1, "\u03AF"], [8156, 3], [8157, 5, " \u0314\u0300"], [8158, 5, " \u0314\u0301"], [8159, 5, " \u0314\u0342"], [[8160, 8162], 2], [8163, 1, "\u03B0"], [[8164, 8167], 2], [8168, 1, "\u1FE0"], [8169, 1, "\u1FE1"], [8170, 1, "\u1F7A"], [8171, 1, "\u03CD"], [8172, 1, "\u1FE5"], [8173, 5, " \u0308\u0300"], [8174, 5, " \u0308\u0301"], [8175, 5, "`"], [[8176, 8177], 3], [8178, 1, "\u1F7C\u03B9"], [8179, 1, "\u03C9\u03B9"], [8180, 1, "\u03CE\u03B9"], [8181, 3], [8182, 2], [8183, 1, "\u1FF6\u03B9"], [8184, 1, "\u1F78"], [8185, 1, "\u03CC"], [8186, 1, "\u1F7C"], [8187, 1, "\u03CE"], [8188, 1, "\u03C9\u03B9"], [8189, 5, " \u0301"], [8190, 5, " \u0314"], [8191, 3], [[8192, 8202], 5, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "\u2010"], [[8210, 8214], 2], [8215, 5, " \u0333"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 5, " "], [[8240, 8242], 2], [8243, 1, "\u2032\u2032"], [8244, 1, "\u2032\u2032\u2032"], [8245, 2], [8246, 1, "\u2035\u2035"], [8247, 1, "\u2035\u2035\u2035"], [[8248, 8251], 2], [8252, 5, "!!"], [8253, 2], [8254, 5, " \u0305"], [[8255, 8262], 2], [8263, 5, "??"], [8264, 5, "?!"], [8265, 5, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "\u2032\u2032\u2032\u2032"], [[8280, 8286], 2], [8287, 5, " "], [8288, 7], [[8289, 8291], 3], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 3], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 5, "+"], [8315, 1, "\u2212"], [8316, 5, "="], [8317, 5, "("], [8318, 5, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 5, "+"], [8331, 1, "\u2212"], [8332, 5, "="], [8333, 5, "("], [8334, 5, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "\u0259"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 5, "a/c"], [8449, 5, "a/s"], [8450, 1, "c"], [8451, 1, "\xB0c"], [8452, 2], [8453, 5, "c/o"], [8454, 5, "c/u"], [8455, 1, "\u025B"], [8456, 2], [8457, 1, "\xB0f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "\u0127"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "\u03C9"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "\xE5"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 3], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "\u05D0"], [8502, 1, "\u05D1"], [8503, 1, "\u05D2"], [8504, 1, "\u05D3"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "\u03C0"], [[8509, 8510], 1, "\u03B3"], [8511, 1, "\u03C0"], [8512, 1, "\u2211"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1\u20447"], [8529, 1, "1\u20449"], [8530, 1, "1\u204410"], [8531, 1, "1\u20443"], [8532, 1, "2\u20443"], [8533, 1, "1\u20445"], [8534, 1, "2\u20445"], [8535, 1, "3\u20445"], [8536, 1, "4\u20445"], [8537, 1, "1\u20446"], [8538, 1, "5\u20446"], [8539, 1, "1\u20448"], [8540, 1, "3\u20448"], [8541, 1, "5\u20448"], [8542, 1, "7\u20448"], [8543, 1, "1\u2044"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 3], [8580, 2], [[8581, 8584], 2], [8585, 1, "0\u20443"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "\u222B\u222B"], [8749, 1, "\u222B\u222B\u222B"], [8750, 2], [8751, 1, "\u222E\u222E"], [8752, 1, "\u222E\u222E\u222E"], [[8753, 8799], 2], [8800, 4], [[8801, 8813], 2], [[8814, 8815], 4], [[8816, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9000], 2], [9001, 1, "\u3008"], [9002, 1, "\u3009"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 5, "(1)"], [9333, 5, "(2)"], [9334, 5, "(3)"], [9335, 5, "(4)"], [9336, 5, "(5)"], [9337, 5, "(6)"], [9338, 5, "(7)"], [9339, 5, "(8)"], [9340, 5, "(9)"], [9341, 5, "(10)"], [9342, 5, "(11)"], [9343, 5, "(12)"], [9344, 5, "(13)"], [9345, 5, "(14)"], [9346, 5, "(15)"], [9347, 5, "(16)"], [9348, 5, "(17)"], [9349, 5, "(18)"], [9350, 5, "(19)"], [9351, 5, "(20)"], [[9352, 9371], 3], [9372, 5, "(a)"], [9373, 5, "(b)"], [9374, 5, "(c)"], [9375, 5, "(d)"], [9376, 5, "(e)"], [9377, 5, "(f)"], [9378, 5, "(g)"], [9379, 5, "(h)"], [9380, 5, "(i)"], [9381, 5, "(j)"], [9382, 5, "(k)"], [9383, 5, "(l)"], [9384, 5, "(m)"], [9385, 5, "(n)"], [9386, 5, "(o)"], [9387, 5, "(p)"], [9388, 5, "(q)"], [9389, 5, "(r)"], [9390, 5, "(s)"], [9391, 5, "(t)"], [9392, 5, "(u)"], [9393, 5, "(v)"], [9394, 5, "(w)"], [9395, 5, "(x)"], [9396, 5, "(y)"], [9397, 5, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "\u222B\u222B\u222B\u222B"], [[10765, 10867], 2], [10868, 5, "::="], [10869, 5, "=="], [10870, 5, "==="], [[10871, 10971], 2], [10972, 1, "\u2ADD\u0338"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "\u2C30"], [11265, 1, "\u2C31"], [11266, 1, "\u2C32"], [11267, 1, "\u2C33"], [11268, 1, "\u2C34"], [11269, 1, "\u2C35"], [11270, 1, "\u2C36"], [11271, 1, "\u2C37"], [11272, 1, "\u2C38"], [11273, 1, "\u2C39"], [11274, 1, "\u2C3A"], [11275, 1, "\u2C3B"], [11276, 1, "\u2C3C"], [11277, 1, "\u2C3D"], [11278, 1, "\u2C3E"], [11279, 1, "\u2C3F"], [11280, 1, "\u2C40"], [11281, 1, "\u2C41"], [11282, 1, "\u2C42"], [11283, 1, "\u2C43"], [11284, 1, "\u2C44"], [11285, 1, "\u2C45"], [11286, 1, "\u2C46"], [11287, 1, "\u2C47"], [11288, 1, "\u2C48"], [11289, 1, "\u2C49"], [11290, 1, "\u2C4A"], [11291, 1, "\u2C4B"], [11292, 1, "\u2C4C"], [11293, 1, "\u2C4D"], [11294, 1, "\u2C4E"], [11295, 1, "\u2C4F"], [11296, 1, "\u2C50"], [11297, 1, "\u2C51"], [11298, 1, "\u2C52"], [11299, 1, "\u2C53"], [11300, 1, "\u2C54"], [11301, 1, "\u2C55"], [11302, 1, "\u2C56"], [11303, 1, "\u2C57"], [11304, 1, "\u2C58"], [11305, 1, "\u2C59"], [11306, 1, "\u2C5A"], [11307, 1, "\u2C5B"], [11308, 1, "\u2C5C"], [11309, 1, "\u2C5D"], [11310, 1, "\u2C5E"], [11311, 1, "\u2C5F"], [[11312, 11358], 2], [11359, 2], [11360, 1, "\u2C61"], [11361, 2], [11362, 1, "\u026B"], [11363, 1, "\u1D7D"], [11364, 1, "\u027D"], [[11365, 11366], 2], [11367, 1, "\u2C68"], [11368, 2], [11369, 1, "\u2C6A"], [11370, 2], [11371, 1, "\u2C6C"], [11372, 2], [11373, 1, "\u0251"], [11374, 1, "\u0271"], [11375, 1, "\u0250"], [11376, 1, "\u0252"], [11377, 2], [11378, 1, "\u2C73"], [11379, 2], [11380, 2], [11381, 1, "\u2C76"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "\u023F"], [11391, 1, "\u0240"], [11392, 1, "\u2C81"], [11393, 2], [11394, 1, "\u2C83"], [11395, 2], [11396, 1, "\u2C85"], [11397, 2], [11398, 1, "\u2C87"], [11399, 2], [11400, 1, "\u2C89"], [11401, 2], [11402, 1, "\u2C8B"], [11403, 2], [11404, 1, "\u2C8D"], [11405, 2], [11406, 1, "\u2C8F"], [11407, 2], [11408, 1, "\u2C91"], [11409, 2], [11410, 1, "\u2C93"], [11411, 2], [11412, 1, "\u2C95"], [11413, 2], [11414, 1, "\u2C97"], [11415, 2], [11416, 1, "\u2C99"], [11417, 2], [11418, 1, "\u2C9B"], [11419, 2], [11420, 1, "\u2C9D"], [11421, 2], [11422, 1, "\u2C9F"], [11423, 2], [11424, 1, "\u2CA1"], [11425, 2], [11426, 1, "\u2CA3"], [11427, 2], [11428, 1, "\u2CA5"], [11429, 2], [11430, 1, "\u2CA7"], [11431, 2], [11432, 1, "\u2CA9"], [11433, 2], [11434, 1, "\u2CAB"], [11435, 2], [11436, 1, "\u2CAD"], [11437, 2], [11438, 1, "\u2CAF"], [11439, 2], [11440, 1, "\u2CB1"], [11441, 2], [11442, 1, "\u2CB3"], [11443, 2], [11444, 1, "\u2CB5"], [11445, 2], [11446, 1, "\u2CB7"], [11447, 2], [11448, 1, "\u2CB9"], [11449, 2], [11450, 1, "\u2CBB"], [11451, 2], [11452, 1, "\u2CBD"], [11453, 2], [11454, 1, "\u2CBF"], [11455, 2], [11456, 1, "\u2CC1"], [11457, 2], [11458, 1, "\u2CC3"], [11459, 2], [11460, 1, "\u2CC5"], [11461, 2], [11462, 1, "\u2CC7"], [11463, 2], [11464, 1, "\u2CC9"], [11465, 2], [11466, 1, "\u2CCB"], [11467, 2], [11468, 1, "\u2CCD"], [11469, 2], [11470, 1, "\u2CCF"], [11471, 2], [11472, 1, "\u2CD1"], [11473, 2], [11474, 1, "\u2CD3"], [11475, 2], [11476, 1, "\u2CD5"], [11477, 2], [11478, 1, "\u2CD7"], [11479, 2], [11480, 1, "\u2CD9"], [11481, 2], [11482, 1, "\u2CDB"], [11483, 2], [11484, 1, "\u2CDD"], [11485, 2], [11486, 1, "\u2CDF"], [11487, 2], [11488, 1, "\u2CE1"], [11489, 2], [11490, 1, "\u2CE3"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "\u2CEC"], [11500, 2], [11501, 1, "\u2CEE"], [[11502, 11505], 2], [11506, 1, "\u2CF3"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "\u2D61"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "\u6BCD"], [[11936, 12018], 2], [12019, 1, "\u9F9F"], [[12020, 12031], 3], [12032, 1, "\u4E00"], [12033, 1, "\u4E28"], [12034, 1, "\u4E36"], [12035, 1, "\u4E3F"], [12036, 1, "\u4E59"], [12037, 1, "\u4E85"], [12038, 1, "\u4E8C"], [12039, 1, "\u4EA0"], [12040, 1, "\u4EBA"], [12041, 1, "\u513F"], [12042, 1, "\u5165"], [12043, 1, "\u516B"], [12044, 1, "\u5182"], [12045, 1, "\u5196"], [12046, 1, "\u51AB"], [12047, 1, "\u51E0"], [12048, 1, "\u51F5"], [12049, 1, "\u5200"], [12050, 1, "\u529B"], [12051, 1, "\u52F9"], [12052, 1, "\u5315"], [12053, 1, "\u531A"], [12054, 1, "\u5338"], [12055, 1, "\u5341"], [12056, 1, "\u535C"], [12057, 1, "\u5369"], [12058, 1, "\u5382"], [12059, 1, "\u53B6"], [12060, 1, "\u53C8"], [12061, 1, "\u53E3"], [12062, 1, "\u56D7"], [12063, 1, "\u571F"], [12064, 1, "\u58EB"], [12065, 1, "\u5902"], [12066, 1, "\u590A"], [12067, 1, "\u5915"], [12068, 1, "\u5927"], [12069, 1, "\u5973"], [12070, 1, "\u5B50"], [12071, 1, "\u5B80"], [12072, 1, "\u5BF8"], [12073, 1, "\u5C0F"], [12074, 1, "\u5C22"], [12075, 1, "\u5C38"], [12076, 1, "\u5C6E"], [12077, 1, "\u5C71"], [12078, 1, "\u5DDB"], [12079, 1, "\u5DE5"], [12080, 1, "\u5DF1"], [12081, 1, "\u5DFE"], [12082, 1, "\u5E72"], [12083, 1, "\u5E7A"], [12084, 1, "\u5E7F"], [12085, 1, "\u5EF4"], [12086, 1, "\u5EFE"], [12087, 1, "\u5F0B"], [12088, 1, "\u5F13"], [12089, 1, "\u5F50"], [12090, 1, "\u5F61"], [12091, 1, "\u5F73"], [12092, 1, "\u5FC3"], [12093, 1, "\u6208"], [12094, 1, "\u6236"], [12095, 1, "\u624B"], [12096, 1, "\u652F"], [12097, 1, "\u6534"], [12098, 1, "\u6587"], [12099, 1, "\u6597"], [12100, 1, "\u65A4"], [12101, 1, "\u65B9"], [12102, 1, "\u65E0"], [12103, 1, "\u65E5"], [12104, 1, "\u66F0"], [12105, 1, "\u6708"], [12106, 1, "\u6728"], [12107, 1, "\u6B20"], [12108, 1, "\u6B62"], [12109, 1, "\u6B79"], [12110, 1, "\u6BB3"], [12111, 1, "\u6BCB"], [12112, 1, "\u6BD4"], [12113, 1, "\u6BDB"], [12114, 1, "\u6C0F"], [12115, 1, "\u6C14"], [12116, 1, "\u6C34"], [12117, 1, "\u706B"], [12118, 1, "\u722A"], [12119, 1, "\u7236"], [12120, 1, "\u723B"], [12121, 1, "\u723F"], [12122, 1, "\u7247"], [12123, 1, "\u7259"], [12124, 1, "\u725B"], [12125, 1, "\u72AC"], [12126, 1, "\u7384"], [12127, 1, "\u7389"], [12128, 1, "\u74DC"], [12129, 1, "\u74E6"], [12130, 1, "\u7518"], [12131, 1, "\u751F"], [12132, 1, "\u7528"], [12133, 1, "\u7530"], [12134, 1, "\u758B"], [12135, 1, "\u7592"], [12136, 1, "\u7676"], [12137, 1, "\u767D"], [12138, 1, "\u76AE"], [12139, 1, "\u76BF"], [12140, 1, "\u76EE"], [12141, 1, "\u77DB"], [12142, 1, "\u77E2"], [12143, 1, "\u77F3"], [12144, 1, "\u793A"], [12145, 1, "\u79B8"], [12146, 1, "\u79BE"], [12147, 1, "\u7A74"], [12148, 1, "\u7ACB"], [12149, 1, "\u7AF9"], [12150, 1, "\u7C73"], [12151, 1, "\u7CF8"], [12152, 1, "\u7F36"], [12153, 1, "\u7F51"], [12154, 1, "\u7F8A"], [12155, 1, "\u7FBD"], [12156, 1, "\u8001"], [12157, 1, "\u800C"], [12158, 1, "\u8012"], [12159, 1, "\u8033"], [12160, 1, "\u807F"], [12161, 1, "\u8089"], [12162, 1, "\u81E3"], [12163, 1, "\u81EA"], [12164, 1, "\u81F3"], [12165, 1, "\u81FC"], [12166, 1, "\u820C"], [12167, 1, "\u821B"], [12168, 1, "\u821F"], [12169, 1, "\u826E"], [12170, 1, "\u8272"], [12171, 1, "\u8278"], [12172, 1, "\u864D"], [12173, 1, "\u866B"], [12174, 1, "\u8840"], [12175, 1, "\u884C"], [12176, 1, "\u8863"], [12177, 1, "\u897E"], [12178, 1, "\u898B"], [12179, 1, "\u89D2"], [12180, 1, "\u8A00"], [12181, 1, "\u8C37"], [12182, 1, "\u8C46"], [12183, 1, "\u8C55"], [12184, 1, "\u8C78"], [12185, 1, "\u8C9D"], [12186, 1, "\u8D64"], [12187, 1, "\u8D70"], [12188, 1, "\u8DB3"], [12189, 1, "\u8EAB"], [12190, 1, "\u8ECA"], [12191, 1, "\u8F9B"], [12192, 1, "\u8FB0"], [12193, 1, "\u8FB5"], [12194, 1, "\u9091"], [12195, 1, "\u9149"], [12196, 1, "\u91C6"], [12197, 1, "\u91CC"], [12198, 1, "\u91D1"], [12199, 1, "\u9577"], [12200, 1, "\u9580"], [12201, 1, "\u961C"], [12202, 1, "\u96B6"], [12203, 1, "\u96B9"], [12204, 1, "\u96E8"], [12205, 1, "\u9751"], [12206, 1, "\u975E"], [12207, 1, "\u9762"], [12208, 1, "\u9769"], [12209, 1, "\u97CB"], [12210, 1, "\u97ED"], [12211, 1, "\u97F3"], [12212, 1, "\u9801"], [12213, 1, "\u98A8"], [12214, 1, "\u98DB"], [12215, 1, "\u98DF"], [12216, 1, "\u9996"], [12217, 1, "\u9999"], [12218, 1, "\u99AC"], [12219, 1, "\u9AA8"], [12220, 1, "\u9AD8"], [12221, 1, "\u9ADF"], [12222, 1, "\u9B25"], [12223, 1, "\u9B2F"], [12224, 1, "\u9B32"], [12225, 1, "\u9B3C"], [12226, 1, "\u9B5A"], [12227, 1, "\u9CE5"], [12228, 1, "\u9E75"], [12229, 1, "\u9E7F"], [12230, 1, "\u9EA5"], [12231, 1, "\u9EBB"], [12232, 1, "\u9EC3"], [12233, 1, "\u9ECD"], [12234, 1, "\u9ED1"], [12235, 1, "\u9EF9"], [12236, 1, "\u9EFD"], [12237, 1, "\u9F0E"], [12238, 1, "\u9F13"], [12239, 1, "\u9F20"], [12240, 1, "\u9F3B"], [12241, 1, "\u9F4A"], [12242, 1, "\u9F52"], [12243, 1, "\u9F8D"], [12244, 1, "\u9F9C"], [12245, 1, "\u9FA0"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 5, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "\u3012"], [12343, 2], [12344, 1, "\u5341"], [12345, 1, "\u5344"], [12346, 1, "\u5345"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 5, " \u3099"], [12444, 5, " \u309A"], [[12445, 12446], 2], [12447, 1, "\u3088\u308A"], [12448, 2], [[12449, 12542], 2], [12543, 1, "\u30B3\u30C8"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "\u1100"], [12594, 1, "\u1101"], [12595, 1, "\u11AA"], [12596, 1, "\u1102"], [12597, 1, "\u11AC"], [12598, 1, "\u11AD"], [12599, 1, "\u1103"], [12600, 1, "\u1104"], [12601, 1, "\u1105"], [12602, 1, "\u11B0"], [12603, 1, "\u11B1"], [12604, 1, "\u11B2"], [12605, 1, "\u11B3"], [12606, 1, "\u11B4"], [12607, 1, "\u11B5"], [12608, 1, "\u111A"], [12609, 1, "\u1106"], [12610, 1, "\u1107"], [12611, 1, "\u1108"], [12612, 1, "\u1121"], [12613, 1, "\u1109"], [12614, 1, "\u110A"], [12615, 1, "\u110B"], [12616, 1, "\u110C"], [12617, 1, "\u110D"], [12618, 1, "\u110E"], [12619, 1, "\u110F"], [12620, 1, "\u1110"], [12621, 1, "\u1111"], [12622, 1, "\u1112"], [12623, 1, "\u1161"], [12624, 1, "\u1162"], [12625, 1, "\u1163"], [12626, 1, "\u1164"], [12627, 1, "\u1165"], [12628, 1, "\u1166"], [12629, 1, "\u1167"], [12630, 1, "\u1168"], [12631, 1, "\u1169"], [12632, 1, "\u116A"], [12633, 1, "\u116B"], [12634, 1, "\u116C"], [12635, 1, "\u116D"], [12636, 1, "\u116E"], [12637, 1, "\u116F"], [12638, 1, "\u1170"], [12639, 1, "\u1171"], [12640, 1, "\u1172"], [12641, 1, "\u1173"], [12642, 1, "\u1174"], [12643, 1, "\u1175"], [12644, 3], [12645, 1, "\u1114"], [12646, 1, "\u1115"], [12647, 1, "\u11C7"], [12648, 1, "\u11C8"], [12649, 1, "\u11CC"], [12650, 1, "\u11CE"], [12651, 1, "\u11D3"], [12652, 1, "\u11D7"], [12653, 1, "\u11D9"], [12654, 1, "\u111C"], [12655, 1, "\u11DD"], [12656, 1, "\u11DF"], [12657, 1, "\u111D"], [12658, 1, "\u111E"], [12659, 1, "\u1120"], [12660, 1, "\u1122"], [12661, 1, "\u1123"], [12662, 1, "\u1127"], [12663, 1, "\u1129"], [12664, 1, "\u112B"], [12665, 1, "\u112C"], [12666, 1, "\u112D"], [12667, 1, "\u112E"], [12668, 1, "\u112F"], [12669, 1, "\u1132"], [12670, 1, "\u1136"], [12671, 1, "\u1140"], [12672, 1, "\u1147"], [12673, 1, "\u114C"], [12674, 1, "\u11F1"], [12675, 1, "\u11F2"], [12676, 1, "\u1157"], [12677, 1, "\u1158"], [12678, 1, "\u1159"], [12679, 1, "\u1184"], [12680, 1, "\u1185"], [12681, 1, "\u1188"], [12682, 1, "\u1191"], [12683, 1, "\u1192"], [12684, 1, "\u1194"], [12685, 1, "\u119E"], [12686, 1, "\u11A1"], [12687, 3], [[12688, 12689], 2], [12690, 1, "\u4E00"], [12691, 1, "\u4E8C"], [12692, 1, "\u4E09"], [12693, 1, "\u56DB"], [12694, 1, "\u4E0A"], [12695, 1, "\u4E2D"], [12696, 1, "\u4E0B"], [12697, 1, "\u7532"], [12698, 1, "\u4E59"], [12699, 1, "\u4E19"], [12700, 1, "\u4E01"], [12701, 1, "\u5929"], [12702, 1, "\u5730"], [12703, 1, "\u4EBA"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12783], 3], [[12784, 12799], 2], [12800, 5, "(\u1100)"], [12801, 5, "(\u1102)"], [12802, 5, "(\u1103)"], [12803, 5, "(\u1105)"], [12804, 5, "(\u1106)"], [12805, 5, "(\u1107)"], [12806, 5, "(\u1109)"], [12807, 5, "(\u110B)"], [12808, 5, "(\u110C)"], [12809, 5, "(\u110E)"], [12810, 5, "(\u110F)"], [12811, 5, "(\u1110)"], [12812, 5, "(\u1111)"], [12813, 5, "(\u1112)"], [12814, 5, "(\uAC00)"], [12815, 5, "(\uB098)"], [12816, 5, "(\uB2E4)"], [12817, 5, "(\uB77C)"], [12818, 5, "(\uB9C8)"], [12819, 5, "(\uBC14)"], [12820, 5, "(\uC0AC)"], [12821, 5, "(\uC544)"], [12822, 5, "(\uC790)"], [12823, 5, "(\uCC28)"], [12824, 5, "(\uCE74)"], [12825, 5, "(\uD0C0)"], [12826, 5, "(\uD30C)"], [12827, 5, "(\uD558)"], [12828, 5, "(\uC8FC)"], [12829, 5, "(\uC624\uC804)"], [12830, 5, "(\uC624\uD6C4)"], [12831, 3], [12832, 5, "(\u4E00)"], [12833, 5, "(\u4E8C)"], [12834, 5, "(\u4E09)"], [12835, 5, "(\u56DB)"], [12836, 5, "(\u4E94)"], [12837, 5, "(\u516D)"], [12838, 5, "(\u4E03)"], [12839, 5, "(\u516B)"], [12840, 5, "(\u4E5D)"], [12841, 5, "(\u5341)"], [12842, 5, "(\u6708)"], [12843, 5, "(\u706B)"], [12844, 5, "(\u6C34)"], [12845, 5, "(\u6728)"], [12846, 5, "(\u91D1)"], [12847, 5, "(\u571F)"], [12848, 5, "(\u65E5)"], [12849, 5, "(\u682A)"], [12850, 5, "(\u6709)"], [12851, 5, "(\u793E)"], [12852, 5, "(\u540D)"], [12853, 5, "(\u7279)"], [12854, 5, "(\u8CA1)"], [12855, 5, "(\u795D)"], [12856, 5, "(\u52B4)"], [12857, 5, "(\u4EE3)"], [12858, 5, "(\u547C)"], [12859, 5, "(\u5B66)"], [12860, 5, "(\u76E3)"], [12861, 5, "(\u4F01)"], [12862, 5, "(\u8CC7)"], [12863, 5, "(\u5354)"], [12864, 5, "(\u796D)"], [12865, 5, "(\u4F11)"], [12866, 5, "(\u81EA)"], [12867, 5, "(\u81F3)"], [12868, 1, "\u554F"], [12869, 1, "\u5E7C"], [12870, 1, "\u6587"], [12871, 1, "\u7B8F"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "\u1100"], [12897, 1, "\u1102"], [12898, 1, "\u1103"], [12899, 1, "\u1105"], [12900, 1, "\u1106"], [12901, 1, "\u1107"], [12902, 1, "\u1109"], [12903, 1, "\u110B"], [12904, 1, "\u110C"], [12905, 1, "\u110E"], [12906, 1, "\u110F"], [12907, 1, "\u1110"], [12908, 1, "\u1111"], [12909, 1, "\u1112"], [12910, 1, "\uAC00"], [12911, 1, "\uB098"], [12912, 1, "\uB2E4"], [12913, 1, "\uB77C"], [12914, 1, "\uB9C8"], [12915, 1, "\uBC14"], [12916, 1, "\uC0AC"], [12917, 1, "\uC544"], [12918, 1, "\uC790"], [12919, 1, "\uCC28"], [12920, 1, "\uCE74"], [12921, 1, "\uD0C0"], [12922, 1, "\uD30C"], [12923, 1, "\uD558"], [12924, 1, "\uCC38\uACE0"], [12925, 1, "\uC8FC\uC758"], [12926, 1, "\uC6B0"], [12927, 2], [12928, 1, "\u4E00"], [12929, 1, "\u4E8C"], [12930, 1, "\u4E09"], [12931, 1, "\u56DB"], [12932, 1, "\u4E94"], [12933, 1, "\u516D"], [12934, 1, "\u4E03"], [12935, 1, "\u516B"], [12936, 1, "\u4E5D"], [12937, 1, "\u5341"], [12938, 1, "\u6708"], [12939, 1, "\u706B"], [12940, 1, "\u6C34"], [12941, 1, "\u6728"], [12942, 1, "\u91D1"], [12943, 1, "\u571F"], [12944, 1, "\u65E5"], [12945, 1, "\u682A"], [12946, 1, "\u6709"], [12947, 1, "\u793E"], [12948, 1, "\u540D"], [12949, 1, "\u7279"], [12950, 1, "\u8CA1"], [12951, 1, "\u795D"], [12952, 1, "\u52B4"], [12953, 1, "\u79D8"], [12954, 1, "\u7537"], [12955, 1, "\u5973"], [12956, 1, "\u9069"], [12957, 1, "\u512A"], [12958, 1, "\u5370"], [12959, 1, "\u6CE8"], [12960, 1, "\u9805"], [12961, 1, "\u4F11"], [12962, 1, "\u5199"], [12963, 1, "\u6B63"], [12964, 1, "\u4E0A"], [12965, 1, "\u4E2D"], [12966, 1, "\u4E0B"], [12967, 1, "\u5DE6"], [12968, 1, "\u53F3"], [12969, 1, "\u533B"], [12970, 1, "\u5B97"], [12971, 1, "\u5B66"], [12972, 1, "\u76E3"], [12973, 1, "\u4F01"], [12974, 1, "\u8CC7"], [12975, 1, "\u5354"], [12976, 1, "\u591C"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1\u6708"], [12993, 1, "2\u6708"], [12994, 1, "3\u6708"], [12995, 1, "4\u6708"], [12996, 1, "5\u6708"], [12997, 1, "6\u6708"], [12998, 1, "7\u6708"], [12999, 1, "8\u6708"], [13000, 1, "9\u6708"], [13001, 1, "10\u6708"], [13002, 1, "11\u6708"], [13003, 1, "12\u6708"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "\u30A2"], [13009, 1, "\u30A4"], [13010, 1, "\u30A6"], [13011, 1, "\u30A8"], [13012, 1, "\u30AA"], [13013, 1, "\u30AB"], [13014, 1, "\u30AD"], [13015, 1, "\u30AF"], [13016, 1, "\u30B1"], [13017, 1, "\u30B3"], [13018, 1, "\u30B5"], [13019, 1, "\u30B7"], [13020, 1, "\u30B9"], [13021, 1, "\u30BB"], [13022, 1, "\u30BD"], [13023, 1, "\u30BF"], [13024, 1, "\u30C1"], [13025, 1, "\u30C4"], [13026, 1, "\u30C6"], [13027, 1, "\u30C8"], [13028, 1, "\u30CA"], [13029, 1, "\u30CB"], [13030, 1, "\u30CC"], [13031, 1, "\u30CD"], [13032, 1, "\u30CE"], [13033, 1, "\u30CF"], [13034, 1, "\u30D2"], [13035, 1, "\u30D5"], [13036, 1, "\u30D8"], [13037, 1, "\u30DB"], [13038, 1, "\u30DE"], [13039, 1, "\u30DF"], [13040, 1, "\u30E0"], [13041, 1, "\u30E1"], [13042, 1, "\u30E2"], [13043, 1, "\u30E4"], [13044, 1, "\u30E6"], [13045, 1, "\u30E8"], [13046, 1, "\u30E9"], [13047, 1, "\u30EA"], [13048, 1, "\u30EB"], [13049, 1, "\u30EC"], [13050, 1, "\u30ED"], [13051, 1, "\u30EF"], [13052, 1, "\u30F0"], [13053, 1, "\u30F1"], [13054, 1, "\u30F2"], [13055, 1, "\u4EE4\u548C"], [13056, 1, "\u30A2\u30D1\u30FC\u30C8"], [13057, 1, "\u30A2\u30EB\u30D5\u30A1"], [13058, 1, "\u30A2\u30F3\u30DA\u30A2"], [13059, 1, "\u30A2\u30FC\u30EB"], [13060, 1, "\u30A4\u30CB\u30F3\u30B0"], [13061, 1, "\u30A4\u30F3\u30C1"], [13062, 1, "\u30A6\u30A9\u30F3"], [13063, 1, "\u30A8\u30B9\u30AF\u30FC\u30C9"], [13064, 1, "\u30A8\u30FC\u30AB\u30FC"], [13065, 1, "\u30AA\u30F3\u30B9"], [13066, 1, "\u30AA\u30FC\u30E0"], [13067, 1, "\u30AB\u30A4\u30EA"], [13068, 1, "\u30AB\u30E9\u30C3\u30C8"], [13069, 1, "\u30AB\u30ED\u30EA\u30FC"], [13070, 1, "\u30AC\u30ED\u30F3"], [13071, 1, "\u30AC\u30F3\u30DE"], [13072, 1, "\u30AE\u30AC"], [13073, 1, "\u30AE\u30CB\u30FC"], [13074, 1, "\u30AD\u30E5\u30EA\u30FC"], [13075, 1, "\u30AE\u30EB\u30C0\u30FC"], [13076, 1, "\u30AD\u30ED"], [13077, 1, "\u30AD\u30ED\u30B0\u30E9\u30E0"], [13078, 1, "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [13079, 1, "\u30AD\u30ED\u30EF\u30C3\u30C8"], [13080, 1, "\u30B0\u30E9\u30E0"], [13081, 1, "\u30B0\u30E9\u30E0\u30C8\u30F3"], [13082, 1, "\u30AF\u30EB\u30BC\u30A4\u30ED"], [13083, 1, "\u30AF\u30ED\u30FC\u30CD"], [13084, 1, "\u30B1\u30FC\u30B9"], [13085, 1, "\u30B3\u30EB\u30CA"], [13086, 1, "\u30B3\u30FC\u30DD"], [13087, 1, "\u30B5\u30A4\u30AF\u30EB"], [13088, 1, "\u30B5\u30F3\u30C1\u30FC\u30E0"], [13089, 1, "\u30B7\u30EA\u30F3\u30B0"], [13090, 1, "\u30BB\u30F3\u30C1"], [13091, 1, "\u30BB\u30F3\u30C8"], [13092, 1, "\u30C0\u30FC\u30B9"], [13093, 1, "\u30C7\u30B7"], [13094, 1, "\u30C9\u30EB"], [13095, 1, "\u30C8\u30F3"], [13096, 1, "\u30CA\u30CE"], [13097, 1, "\u30CE\u30C3\u30C8"], [13098, 1, "\u30CF\u30A4\u30C4"], [13099, 1, "\u30D1\u30FC\u30BB\u30F3\u30C8"], [13100, 1, "\u30D1\u30FC\u30C4"], [13101, 1, "\u30D0\u30FC\u30EC\u30EB"], [13102, 1, "\u30D4\u30A2\u30B9\u30C8\u30EB"], [13103, 1, "\u30D4\u30AF\u30EB"], [13104, 1, "\u30D4\u30B3"], [13105, 1, "\u30D3\u30EB"], [13106, 1, "\u30D5\u30A1\u30E9\u30C3\u30C9"], [13107, 1, "\u30D5\u30A3\u30FC\u30C8"], [13108, 1, "\u30D6\u30C3\u30B7\u30A7\u30EB"], [13109, 1, "\u30D5\u30E9\u30F3"], [13110, 1, "\u30D8\u30AF\u30BF\u30FC\u30EB"], [13111, 1, "\u30DA\u30BD"], [13112, 1, "\u30DA\u30CB\u30D2"], [13113, 1, "\u30D8\u30EB\u30C4"], [13114, 1, "\u30DA\u30F3\u30B9"], [13115, 1, "\u30DA\u30FC\u30B8"], [13116, 1, "\u30D9\u30FC\u30BF"], [13117, 1, "\u30DD\u30A4\u30F3\u30C8"], [13118, 1, "\u30DC\u30EB\u30C8"], [13119, 1, "\u30DB\u30F3"], [13120, 1, "\u30DD\u30F3\u30C9"], [13121, 1, "\u30DB\u30FC\u30EB"], [13122, 1, "\u30DB\u30FC\u30F3"], [13123, 1, "\u30DE\u30A4\u30AF\u30ED"], [13124, 1, "\u30DE\u30A4\u30EB"], [13125, 1, "\u30DE\u30C3\u30CF"], [13126, 1, "\u30DE\u30EB\u30AF"], [13127, 1, "\u30DE\u30F3\u30B7\u30E7\u30F3"], [13128, 1, "\u30DF\u30AF\u30ED\u30F3"], [13129, 1, "\u30DF\u30EA"], [13130, 1, "\u30DF\u30EA\u30D0\u30FC\u30EB"], [13131, 1, "\u30E1\u30AC"], [13132, 1, "\u30E1\u30AC\u30C8\u30F3"], [13133, 1, "\u30E1\u30FC\u30C8\u30EB"], [13134, 1, "\u30E4\u30FC\u30C9"], [13135, 1, "\u30E4\u30FC\u30EB"], [13136, 1, "\u30E6\u30A2\u30F3"], [13137, 1, "\u30EA\u30C3\u30C8\u30EB"], [13138, 1, "\u30EA\u30E9"], [13139, 1, "\u30EB\u30D4\u30FC"], [13140, 1, "\u30EB\u30FC\u30D6\u30EB"], [13141, 1, "\u30EC\u30E0"], [13142, 1, "\u30EC\u30F3\u30C8\u30B2\u30F3"], [13143, 1, "\u30EF\u30C3\u30C8"], [13144, 1, "0\u70B9"], [13145, 1, "1\u70B9"], [13146, 1, "2\u70B9"], [13147, 1, "3\u70B9"], [13148, 1, "4\u70B9"], [13149, 1, "5\u70B9"], [13150, 1, "6\u70B9"], [13151, 1, "7\u70B9"], [13152, 1, "8\u70B9"], [13153, 1, "9\u70B9"], [13154, 1, "10\u70B9"], [13155, 1, "11\u70B9"], [13156, 1, "12\u70B9"], [13157, 1, "13\u70B9"], [13158, 1, "14\u70B9"], [13159, 1, "15\u70B9"], [13160, 1, "16\u70B9"], [13161, 1, "17\u70B9"], [13162, 1, "18\u70B9"], [13163, 1, "19\u70B9"], [13164, 1, "20\u70B9"], [13165, 1, "21\u70B9"], [13166, 1, "22\u70B9"], [13167, 1, "23\u70B9"], [13168, 1, "24\u70B9"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "\u5E73\u6210"], [13180, 1, "\u662D\u548C"], [13181, 1, "\u5927\u6B63"], [13182, 1, "\u660E\u6CBB"], [13183, 1, "\u682A\u5F0F\u4F1A\u793E"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "\u03BCa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "\u03BCf"], [13197, 1, "\u03BCg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "\u03BCl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "\u03BCm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m\u2215s"], [13224, 1, "m\u2215s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad\u2215s"], [13231, 1, "rad\u2215s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "\u03BCs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "\u03BCv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "\u03BCw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k\u03C9"], [13249, 1, "m\u03C9"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c\u2215kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v\u2215m"], [13279, 1, "a\u2215m"], [13280, 1, "1\u65E5"], [13281, 1, "2\u65E5"], [13282, 1, "3\u65E5"], [13283, 1, "4\u65E5"], [13284, 1, "5\u65E5"], [13285, 1, "6\u65E5"], [13286, 1, "7\u65E5"], [13287, 1, "8\u65E5"], [13288, 1, "9\u65E5"], [13289, 1, "10\u65E5"], [13290, 1, "11\u65E5"], [13291, 1, "12\u65E5"], [13292, 1, "13\u65E5"], [13293, 1, "14\u65E5"], [13294, 1, "15\u65E5"], [13295, 1, "16\u65E5"], [13296, 1, "17\u65E5"], [13297, 1, "18\u65E5"], [13298, 1, "19\u65E5"], [13299, 1, "20\u65E5"], [13300, 1, "21\u65E5"], [13301, 1, "22\u65E5"], [13302, 1, "23\u65E5"], [13303, 1, "24\u65E5"], [13304, 1, "25\u65E5"], [13305, 1, "26\u65E5"], [13306, 1, "27\u65E5"], [13307, 1, "28\u65E5"], [13308, 1, "29\u65E5"], [13309, 1, "30\u65E5"], [13310, 1, "31\u65E5"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "\uA641"], [42561, 2], [42562, 1, "\uA643"], [42563, 2], [42564, 1, "\uA645"], [42565, 2], [42566, 1, "\uA647"], [42567, 2], [42568, 1, "\uA649"], [42569, 2], [42570, 1, "\uA64B"], [42571, 2], [42572, 1, "\uA64D"], [42573, 2], [42574, 1, "\uA64F"], [42575, 2], [42576, 1, "\uA651"], [42577, 2], [42578, 1, "\uA653"], [42579, 2], [42580, 1, "\uA655"], [42581, 2], [42582, 1, "\uA657"], [42583, 2], [42584, 1, "\uA659"], [42585, 2], [42586, 1, "\uA65B"], [42587, 2], [42588, 1, "\uA65D"], [42589, 2], [42590, 1, "\uA65F"], [42591, 2], [42592, 1, "\uA661"], [42593, 2], [42594, 1, "\uA663"], [42595, 2], [42596, 1, "\uA665"], [42597, 2], [42598, 1, "\uA667"], [42599, 2], [42600, 1, "\uA669"], [42601, 2], [42602, 1, "\uA66B"], [42603, 2], [42604, 1, "\uA66D"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "\uA681"], [42625, 2], [42626, 1, "\uA683"], [42627, 2], [42628, 1, "\uA685"], [42629, 2], [42630, 1, "\uA687"], [42631, 2], [42632, 1, "\uA689"], [42633, 2], [42634, 1, "\uA68B"], [42635, 2], [42636, 1, "\uA68D"], [42637, 2], [42638, 1, "\uA68F"], [42639, 2], [42640, 1, "\uA691"], [42641, 2], [42642, 1, "\uA693"], [42643, 2], [42644, 1, "\uA695"], [42645, 2], [42646, 1, "\uA697"], [42647, 2], [42648, 1, "\uA699"], [42649, 2], [42650, 1, "\uA69B"], [42651, 2], [42652, 1, "\u044A"], [42653, 1, "\u044C"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "\uA723"], [42787, 2], [42788, 1, "\uA725"], [42789, 2], [42790, 1, "\uA727"], [42791, 2], [42792, 1, "\uA729"], [42793, 2], [42794, 1, "\uA72B"], [42795, 2], [42796, 1, "\uA72D"], [42797, 2], [42798, 1, "\uA72F"], [[42799, 42801], 2], [42802, 1, "\uA733"], [42803, 2], [42804, 1, "\uA735"], [42805, 2], [42806, 1, "\uA737"], [42807, 2], [42808, 1, "\uA739"], [42809, 2], [42810, 1, "\uA73B"], [42811, 2], [42812, 1, "\uA73D"], [42813, 2], [42814, 1, "\uA73F"], [42815, 2], [42816, 1, "\uA741"], [42817, 2], [42818, 1, "\uA743"], [42819, 2], [42820, 1, "\uA745"], [42821, 2], [42822, 1, "\uA747"], [42823, 2], [42824, 1, "\uA749"], [42825, 2], [42826, 1, "\uA74B"], [42827, 2], [42828, 1, "\uA74D"], [42829, 2], [42830, 1, "\uA74F"], [42831, 2], [42832, 1, "\uA751"], [42833, 2], [42834, 1, "\uA753"], [42835, 2], [42836, 1, "\uA755"], [42837, 2], [42838, 1, "\uA757"], [42839, 2], [42840, 1, "\uA759"], [42841, 2], [42842, 1, "\uA75B"], [42843, 2], [42844, 1, "\uA75D"], [42845, 2], [42846, 1, "\uA75F"], [42847, 2], [42848, 1, "\uA761"], [42849, 2], [42850, 1, "\uA763"], [42851, 2], [42852, 1, "\uA765"], [42853, 2], [42854, 1, "\uA767"], [42855, 2], [42856, 1, "\uA769"], [42857, 2], [42858, 1, "\uA76B"], [42859, 2], [42860, 1, "\uA76D"], [42861, 2], [42862, 1, "\uA76F"], [42863, 2], [42864, 1, "\uA76F"], [[42865, 42872], 2], [42873, 1, "\uA77A"], [42874, 2], [42875, 1, "\uA77C"], [42876, 2], [42877, 1, "\u1D79"], [42878, 1, "\uA77F"], [42879, 2], [42880, 1, "\uA781"], [42881, 2], [42882, 1, "\uA783"], [42883, 2], [42884, 1, "\uA785"], [42885, 2], [42886, 1, "\uA787"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "\uA78C"], [42892, 2], [42893, 1, "\u0265"], [42894, 2], [42895, 2], [42896, 1, "\uA791"], [42897, 2], [42898, 1, "\uA793"], [42899, 2], [[42900, 42901], 2], [42902, 1, "\uA797"], [42903, 2], [42904, 1, "\uA799"], [42905, 2], [42906, 1, "\uA79B"], [42907, 2], [42908, 1, "\uA79D"], [42909, 2], [42910, 1, "\uA79F"], [42911, 2], [42912, 1, "\uA7A1"], [42913, 2], [42914, 1, "\uA7A3"], [42915, 2], [42916, 1, "\uA7A5"], [42917, 2], [42918, 1, "\uA7A7"], [42919, 2], [42920, 1, "\uA7A9"], [42921, 2], [42922, 1, "\u0266"], [42923, 1, "\u025C"], [42924, 1, "\u0261"], [42925, 1, "\u026C"], [42926, 1, "\u026A"], [42927, 2], [42928, 1, "\u029E"], [42929, 1, "\u0287"], [42930, 1, "\u029D"], [42931, 1, "\uAB53"], [42932, 1, "\uA7B5"], [42933, 2], [42934, 1, "\uA7B7"], [42935, 2], [42936, 1, "\uA7B9"], [42937, 2], [42938, 1, "\uA7BB"], [42939, 2], [42940, 1, "\uA7BD"], [42941, 2], [42942, 1, "\uA7BF"], [42943, 2], [42944, 1, "\uA7C1"], [42945, 2], [42946, 1, "\uA7C3"], [42947, 2], [42948, 1, "\uA794"], [42949, 1, "\u0282"], [42950, 1, "\u1D8E"], [42951, 1, "\uA7C8"], [42952, 2], [42953, 1, "\uA7CA"], [42954, 2], [[42955, 42959], 3], [42960, 1, "\uA7D1"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "\uA7D7"], [42967, 2], [42968, 1, "\uA7D9"], [42969, 2], [[42970, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "\uA7F6"], [42998, 2], [42999, 2], [43000, 1, "\u0127"], [43001, 1, "\u0153"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "\uA727"], [43869, 1, "\uAB37"], [43870, 1, "\u026B"], [43871, 1, "\uAB52"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "\u028D"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "\u13A0"], [43889, 1, "\u13A1"], [43890, 1, "\u13A2"], [43891, 1, "\u13A3"], [43892, 1, "\u13A4"], [43893, 1, "\u13A5"], [43894, 1, "\u13A6"], [43895, 1, "\u13A7"], [43896, 1, "\u13A8"], [43897, 1, "\u13A9"], [43898, 1, "\u13AA"], [43899, 1, "\u13AB"], [43900, 1, "\u13AC"], [43901, 1, "\u13AD"], [43902, 1, "\u13AE"], [43903, 1, "\u13AF"], [43904, 1, "\u13B0"], [43905, 1, "\u13B1"], [43906, 1, "\u13B2"], [43907, 1, "\u13B3"], [43908, 1, "\u13B4"], [43909, 1, "\u13B5"], [43910, 1, "\u13B6"], [43911, 1, "\u13B7"], [43912, 1, "\u13B8"], [43913, 1, "\u13B9"], [43914, 1, "\u13BA"], [43915, 1, "\u13BB"], [43916, 1, "\u13BC"], [43917, 1, "\u13BD"], [43918, 1, "\u13BE"], [43919, 1, "\u13BF"], [43920, 1, "\u13C0"], [43921, 1, "\u13C1"], [43922, 1, "\u13C2"], [43923, 1, "\u13C3"], [43924, 1, "\u13C4"], [43925, 1, "\u13C5"], [43926, 1, "\u13C6"], [43927, 1, "\u13C7"], [43928, 1, "\u13C8"], [43929, 1, "\u13C9"], [43930, 1, "\u13CA"], [43931, 1, "\u13CB"], [43932, 1, "\u13CC"], [43933, 1, "\u13CD"], [43934, 1, "\u13CE"], [43935, 1, "\u13CF"], [43936, 1, "\u13D0"], [43937, 1, "\u13D1"], [43938, 1, "\u13D2"], [43939, 1, "\u13D3"], [43940, 1, "\u13D4"], [43941, 1, "\u13D5"], [43942, 1, "\u13D6"], [43943, 1, "\u13D7"], [43944, 1, "\u13D8"], [43945, 1, "\u13D9"], [43946, 1, "\u13DA"], [43947, 1, "\u13DB"], [43948, 1, "\u13DC"], [43949, 1, "\u13DD"], [43950, 1, "\u13DE"], [43951, 1, "\u13DF"], [43952, 1, "\u13E0"], [43953, 1, "\u13E1"], [43954, 1, "\u13E2"], [43955, 1, "\u13E3"], [43956, 1, "\u13E4"], [43957, 1, "\u13E5"], [43958, 1, "\u13E6"], [43959, 1, "\u13E7"], [43960, 1, "\u13E8"], [43961, 1, "\u13E9"], [43962, 1, "\u13EA"], [43963, 1, "\u13EB"], [43964, 1, "\u13EC"], [43965, 1, "\u13ED"], [43966, 1, "\u13EE"], [43967, 1, "\u13EF"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "\u8C48"], [63745, 1, "\u66F4"], [63746, 1, "\u8ECA"], [63747, 1, "\u8CC8"], [63748, 1, "\u6ED1"], [63749, 1, "\u4E32"], [63750, 1, "\u53E5"], [[63751, 63752], 1, "\u9F9C"], [63753, 1, "\u5951"], [63754, 1, "\u91D1"], [63755, 1, "\u5587"], [63756, 1, "\u5948"], [63757, 1, "\u61F6"], [63758, 1, "\u7669"], [63759, 1, "\u7F85"], [63760, 1, "\u863F"], [63761, 1, "\u87BA"], [63762, 1, "\u88F8"], [63763, 1, "\u908F"], [63764, 1, "\u6A02"], [63765, 1, "\u6D1B"], [63766, 1, "\u70D9"], [63767, 1, "\u73DE"], [63768, 1, "\u843D"], [63769, 1, "\u916A"], [63770, 1, "\u99F1"], [63771, 1, "\u4E82"], [63772, 1, "\u5375"], [63773, 1, "\u6B04"], [63774, 1, "\u721B"], [63775, 1, "\u862D"], [63776, 1, "\u9E1E"], [63777, 1, "\u5D50"], [63778, 1, "\u6FEB"], [63779, 1, "\u85CD"], [63780, 1, "\u8964"], [63781, 1, "\u62C9"], [63782, 1, "\u81D8"], [63783, 1, "\u881F"], [63784, 1, "\u5ECA"], [63785, 1, "\u6717"], [63786, 1, "\u6D6A"], [63787, 1, "\u72FC"], [63788, 1, "\u90CE"], [63789, 1, "\u4F86"], [63790, 1, "\u51B7"], [63791, 1, "\u52DE"], [63792, 1, "\u64C4"], [63793, 1, "\u6AD3"], [63794, 1, "\u7210"], [63795, 1, "\u76E7"], [63796, 1, "\u8001"], [63797, 1, "\u8606"], [63798, 1, "\u865C"], [63799, 1, "\u8DEF"], [63800, 1, "\u9732"], [63801, 1, "\u9B6F"], [63802, 1, "\u9DFA"], [63803, 1, "\u788C"], [63804, 1, "\u797F"], [63805, 1, "\u7DA0"], [63806, 1, "\u83C9"], [63807, 1, "\u9304"], [63808, 1, "\u9E7F"], [63809, 1, "\u8AD6"], [63810, 1, "\u58DF"], [63811, 1, "\u5F04"], [63812, 1, "\u7C60"], [63813, 1, "\u807E"], [63814, 1, "\u7262"], [63815, 1, "\u78CA"], [63816, 1, "\u8CC2"], [63817, 1, "\u96F7"], [63818, 1, "\u58D8"], [63819, 1, "\u5C62"], [63820, 1, "\u6A13"], [63821, 1, "\u6DDA"], [63822, 1, "\u6F0F"], [63823, 1, "\u7D2F"], [63824, 1, "\u7E37"], [63825, 1, "\u964B"], [63826, 1, "\u52D2"], [63827, 1, "\u808B"], [63828, 1, "\u51DC"], [63829, 1, "\u51CC"], [63830, 1, "\u7A1C"], [63831, 1, "\u7DBE"], [63832, 1, "\u83F1"], [63833, 1, "\u9675"], [63834, 1, "\u8B80"], [63835, 1, "\u62CF"], [63836, 1, "\u6A02"], [63837, 1, "\u8AFE"], [63838, 1, "\u4E39"], [63839, 1, "\u5BE7"], [63840, 1, "\u6012"], [63841, 1, "\u7387"], [63842, 1, "\u7570"], [63843, 1, "\u5317"], [63844, 1, "\u78FB"], [63845, 1, "\u4FBF"], [63846, 1, "\u5FA9"], [63847, 1, "\u4E0D"], [63848, 1, "\u6CCC"], [63849, 1, "\u6578"], [63850, 1, "\u7D22"], [63851, 1, "\u53C3"], [63852, 1, "\u585E"], [63853, 1, "\u7701"], [63854, 1, "\u8449"], [63855, 1, "\u8AAA"], [63856, 1, "\u6BBA"], [63857, 1, "\u8FB0"], [63858, 1, "\u6C88"], [63859, 1, "\u62FE"], [63860, 1, "\u82E5"], [63861, 1, "\u63A0"], [63862, 1, "\u7565"], [63863, 1, "\u4EAE"], [63864, 1, "\u5169"], [63865, 1, "\u51C9"], [63866, 1, "\u6881"], [63867, 1, "\u7CE7"], [63868, 1, "\u826F"], [63869, 1, "\u8AD2"], [63870, 1, "\u91CF"], [63871, 1, "\u52F5"], [63872, 1, "\u5442"], [63873, 1, "\u5973"], [63874, 1, "\u5EEC"], [63875, 1, "\u65C5"], [63876, 1, "\u6FFE"], [63877, 1, "\u792A"], [63878, 1, "\u95AD"], [63879, 1, "\u9A6A"], [63880, 1, "\u9E97"], [63881, 1, "\u9ECE"], [63882, 1, "\u529B"], [63883, 1, "\u66C6"], [63884, 1, "\u6B77"], [63885, 1, "\u8F62"], [63886, 1, "\u5E74"], [63887, 1, "\u6190"], [63888, 1, "\u6200"], [63889, 1, "\u649A"], [63890, 1, "\u6F23"], [63891, 1, "\u7149"], [63892, 1, "\u7489"], [63893, 1, "\u79CA"], [63894, 1, "\u7DF4"], [63895, 1, "\u806F"], [63896, 1, "\u8F26"], [63897, 1, "\u84EE"], [63898, 1, "\u9023"], [63899, 1, "\u934A"], [63900, 1, "\u5217"], [63901, 1, "\u52A3"], [63902, 1, "\u54BD"], [63903, 1, "\u70C8"], [63904, 1, "\u88C2"], [63905, 1, "\u8AAA"], [63906, 1, "\u5EC9"], [63907, 1, "\u5FF5"], [63908, 1, "\u637B"], [63909, 1, "\u6BAE"], [63910, 1, "\u7C3E"], [63911, 1, "\u7375"], [63912, 1, "\u4EE4"], [63913, 1, "\u56F9"], [63914, 1, "\u5BE7"], [63915, 1, "\u5DBA"], [63916, 1, "\u601C"], [63917, 1, "\u73B2"], [63918, 1, "\u7469"], [63919, 1, "\u7F9A"], [63920, 1, "\u8046"], [63921, 1, "\u9234"], [63922, 1, "\u96F6"], [63923, 1, "\u9748"], [63924, 1, "\u9818"], [63925, 1, "\u4F8B"], [63926, 1, "\u79AE"], [63927, 1, "\u91B4"], [63928, 1, "\u96B8"], [63929, 1, "\u60E1"], [63930, 1, "\u4E86"], [63931, 1, "\u50DA"], [63932, 1, "\u5BEE"], [63933, 1, "\u5C3F"], [63934, 1, "\u6599"], [63935, 1, "\u6A02"], [63936, 1, "\u71CE"], [63937, 1, "\u7642"], [63938, 1, "\u84FC"], [63939, 1, "\u907C"], [63940, 1, "\u9F8D"], [63941, 1, "\u6688"], [63942, 1, "\u962E"], [63943, 1, "\u5289"], [63944, 1, "\u677B"], [63945, 1, "\u67F3"], [63946, 1, "\u6D41"], [63947, 1, "\u6E9C"], [63948, 1, "\u7409"], [63949, 1, "\u7559"], [63950, 1, "\u786B"], [63951, 1, "\u7D10"], [63952, 1, "\u985E"], [63953, 1, "\u516D"], [63954, 1, "\u622E"], [63955, 1, "\u9678"], [63956, 1, "\u502B"], [63957, 1, "\u5D19"], [63958, 1, "\u6DEA"], [63959, 1, "\u8F2A"], [63960, 1, "\u5F8B"], [63961, 1, "\u6144"], [63962, 1, "\u6817"], [63963, 1, "\u7387"], [63964, 1, "\u9686"], [63965, 1, "\u5229"], [63966, 1, "\u540F"], [63967, 1, "\u5C65"], [63968, 1, "\u6613"], [63969, 1, "\u674E"], [63970, 1, "\u68A8"], [63971, 1, "\u6CE5"], [63972, 1, "\u7406"], [63973, 1, "\u75E2"], [63974, 1, "\u7F79"], [63975, 1, "\u88CF"], [63976, 1, "\u88E1"], [63977, 1, "\u91CC"], [63978, 1, "\u96E2"], [63979, 1, "\u533F"], [63980, 1, "\u6EBA"], [63981, 1, "\u541D"], [63982, 1, "\u71D0"], [63983, 1, "\u7498"], [63984, 1, "\u85FA"], [63985, 1, "\u96A3"], [63986, 1, "\u9C57"], [63987, 1, "\u9E9F"], [63988, 1, "\u6797"], [63989, 1, "\u6DCB"], [63990, 1, "\u81E8"], [63991, 1, "\u7ACB"], [63992, 1, "\u7B20"], [63993, 1, "\u7C92"], [63994, 1, "\u72C0"], [63995, 1, "\u7099"], [63996, 1, "\u8B58"], [63997, 1, "\u4EC0"], [63998, 1, "\u8336"], [63999, 1, "\u523A"], [64000, 1, "\u5207"], [64001, 1, "\u5EA6"], [64002, 1, "\u62D3"], [64003, 1, "\u7CD6"], [64004, 1, "\u5B85"], [64005, 1, "\u6D1E"], [64006, 1, "\u66B4"], [64007, 1, "\u8F3B"], [64008, 1, "\u884C"], [64009, 1, "\u964D"], [64010, 1, "\u898B"], [64011, 1, "\u5ED3"], [64012, 1, "\u5140"], [64013, 1, "\u55C0"], [[64014, 64015], 2], [64016, 1, "\u585A"], [64017, 2], [64018, 1, "\u6674"], [[64019, 64020], 2], [64021, 1, "\u51DE"], [64022, 1, "\u732A"], [64023, 1, "\u76CA"], [64024, 1, "\u793C"], [64025, 1, "\u795E"], [64026, 1, "\u7965"], [64027, 1, "\u798F"], [64028, 1, "\u9756"], [64029, 1, "\u7CBE"], [64030, 1, "\u7FBD"], [64031, 2], [64032, 1, "\u8612"], [64033, 2], [64034, 1, "\u8AF8"], [[64035, 64036], 2], [64037, 1, "\u9038"], [64038, 1, "\u90FD"], [[64039, 64041], 2], [64042, 1, "\u98EF"], [64043, 1, "\u98FC"], [64044, 1, "\u9928"], [64045, 1, "\u9DB4"], [64046, 1, "\u90DE"], [64047, 1, "\u96B7"], [64048, 1, "\u4FAE"], [64049, 1, "\u50E7"], [64050, 1, "\u514D"], [64051, 1, "\u52C9"], [64052, 1, "\u52E4"], [64053, 1, "\u5351"], [64054, 1, "\u559D"], [64055, 1, "\u5606"], [64056, 1, "\u5668"], [64057, 1, "\u5840"], [64058, 1, "\u58A8"], [64059, 1, "\u5C64"], [64060, 1, "\u5C6E"], [64061, 1, "\u6094"], [64062, 1, "\u6168"], [64063, 1, "\u618E"], [64064, 1, "\u61F2"], [64065, 1, "\u654F"], [64066, 1, "\u65E2"], [64067, 1, "\u6691"], [64068, 1, "\u6885"], [64069, 1, "\u6D77"], [64070, 1, "\u6E1A"], [64071, 1, "\u6F22"], [64072, 1, "\u716E"], [64073, 1, "\u722B"], [64074, 1, "\u7422"], [64075, 1, "\u7891"], [64076, 1, "\u793E"], [64077, 1, "\u7949"], [64078, 1, "\u7948"], [64079, 1, "\u7950"], [64080, 1, "\u7956"], [64081, 1, "\u795D"], [64082, 1, "\u798D"], [64083, 1, "\u798E"], [64084, 1, "\u7A40"], [64085, 1, "\u7A81"], [64086, 1, "\u7BC0"], [64087, 1, "\u7DF4"], [64088, 1, "\u7E09"], [64089, 1, "\u7E41"], [64090, 1, "\u7F72"], [64091, 1, "\u8005"], [64092, 1, "\u81ED"], [[64093, 64094], 1, "\u8279"], [64095, 1, "\u8457"], [64096, 1, "\u8910"], [64097, 1, "\u8996"], [64098, 1, "\u8B01"], [64099, 1, "\u8B39"], [64100, 1, "\u8CD3"], [64101, 1, "\u8D08"], [64102, 1, "\u8FB6"], [64103, 1, "\u9038"], [64104, 1, "\u96E3"], [64105, 1, "\u97FF"], [64106, 1, "\u983B"], [64107, 1, "\u6075"], [64108, 1, "\uD850\uDEEE"], [64109, 1, "\u8218"], [[64110, 64111], 3], [64112, 1, "\u4E26"], [64113, 1, "\u51B5"], [64114, 1, "\u5168"], [64115, 1, "\u4F80"], [64116, 1, "\u5145"], [64117, 1, "\u5180"], [64118, 1, "\u52C7"], [64119, 1, "\u52FA"], [64120, 1, "\u559D"], [64121, 1, "\u5555"], [64122, 1, "\u5599"], [64123, 1, "\u55E2"], [64124, 1, "\u585A"], [64125, 1, "\u58B3"], [64126, 1, "\u5944"], [64127, 1, "\u5954"], [64128, 1, "\u5A62"], [64129, 1, "\u5B28"], [64130, 1, "\u5ED2"], [64131, 1, "\u5ED9"], [64132, 1, "\u5F69"], [64133, 1, "\u5FAD"], [64134, 1, "\u60D8"], [64135, 1, "\u614E"], [64136, 1, "\u6108"], [64137, 1, "\u618E"], [64138, 1, "\u6160"], [64139, 1, "\u61F2"], [64140, 1, "\u6234"], [64141, 1, "\u63C4"], [64142, 1, "\u641C"], [64143, 1, "\u6452"], [64144, 1, "\u6556"], [64145, 1, "\u6674"], [64146, 1, "\u6717"], [64147, 1, "\u671B"], [64148, 1, "\u6756"], [64149, 1, "\u6B79"], [64150, 1, "\u6BBA"], [64151, 1, "\u6D41"], [64152, 1, "\u6EDB"], [64153, 1, "\u6ECB"], [64154, 1, "\u6F22"], [64155, 1, "\u701E"], [64156, 1, "\u716E"], [64157, 1, "\u77A7"], [64158, 1, "\u7235"], [64159, 1, "\u72AF"], [64160, 1, "\u732A"], [64161, 1, "\u7471"], [64162, 1, "\u7506"], [64163, 1, "\u753B"], [64164, 1, "\u761D"], [64165, 1, "\u761F"], [64166, 1, "\u76CA"], [64167, 1, "\u76DB"], [64168, 1, "\u76F4"], [64169, 1, "\u774A"], [64170, 1, "\u7740"], [64171, 1, "\u78CC"], [64172, 1, "\u7AB1"], [64173, 1, "\u7BC0"], [64174, 1, "\u7C7B"], [64175, 1, "\u7D5B"], [64176, 1, "\u7DF4"], [64177, 1, "\u7F3E"], [64178, 1, "\u8005"], [64179, 1, "\u8352"], [64180, 1, "\u83EF"], [64181, 1, "\u8779"], [64182, 1, "\u8941"], [64183, 1, "\u8986"], [64184, 1, "\u8996"], [64185, 1, "\u8ABF"], [64186, 1, "\u8AF8"], [64187, 1, "\u8ACB"], [64188, 1, "\u8B01"], [64189, 1, "\u8AFE"], [64190, 1, "\u8AED"], [64191, 1, "\u8B39"], [64192, 1, "\u8B8A"], [64193, 1, "\u8D08"], [64194, 1, "\u8F38"], [64195, 1, "\u9072"], [64196, 1, "\u9199"], [64197, 1, "\u9276"], [64198, 1, "\u967C"], [64199, 1, "\u96E3"], [64200, 1, "\u9756"], [64201, 1, "\u97DB"], [64202, 1, "\u97FF"], [64203, 1, "\u980B"], [64204, 1, "\u983B"], [64205, 1, "\u9B12"], [64206, 1, "\u9F9C"], [64207, 1, "\uD84A\uDC4A"], [64208, 1, "\uD84A\uDC44"], [64209, 1, "\uD84C\uDFD5"], [64210, 1, "\u3B9D"], [64211, 1, "\u4018"], [64212, 1, "\u4039"], [64213, 1, "\uD854\uDE49"], [64214, 1, "\uD857\uDCD0"], [64215, 1, "\uD85F\uDED3"], [64216, 1, "\u9F43"], [64217, 1, "\u9F8E"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "\u0574\u0576"], [64276, 1, "\u0574\u0565"], [64277, 1, "\u0574\u056B"], [64278, 1, "\u057E\u0576"], [64279, 1, "\u0574\u056D"], [[64280, 64284], 3], [64285, 1, "\u05D9\u05B4"], [64286, 2], [64287, 1, "\u05F2\u05B7"], [64288, 1, "\u05E2"], [64289, 1, "\u05D0"], [64290, 1, "\u05D3"], [64291, 1, "\u05D4"], [64292, 1, "\u05DB"], [64293, 1, "\u05DC"], [64294, 1, "\u05DD"], [64295, 1, "\u05E8"], [64296, 1, "\u05EA"], [64297, 5, "+"], [64298, 1, "\u05E9\u05C1"], [64299, 1, "\u05E9\u05C2"], [64300, 1, "\u05E9\u05BC\u05C1"], [64301, 1, "\u05E9\u05BC\u05C2"], [64302, 1, "\u05D0\u05B7"], [64303, 1, "\u05D0\u05B8"], [64304, 1, "\u05D0\u05BC"], [64305, 1, "\u05D1\u05BC"], [64306, 1, "\u05D2\u05BC"], [64307, 1, "\u05D3\u05BC"], [64308, 1, "\u05D4\u05BC"], [64309, 1, "\u05D5\u05BC"], [64310, 1, "\u05D6\u05BC"], [64311, 3], [64312, 1, "\u05D8\u05BC"], [64313, 1, "\u05D9\u05BC"], [64314, 1, "\u05DA\u05BC"], [64315, 1, "\u05DB\u05BC"], [64316, 1, "\u05DC\u05BC"], [64317, 3], [64318, 1, "\u05DE\u05BC"], [64319, 3], [64320, 1, "\u05E0\u05BC"], [64321, 1, "\u05E1\u05BC"], [64322, 3], [64323, 1, "\u05E3\u05BC"], [64324, 1, "\u05E4\u05BC"], [64325, 3], [64326, 1, "\u05E6\u05BC"], [64327, 1, "\u05E7\u05BC"], [64328, 1, "\u05E8\u05BC"], [64329, 1, "\u05E9\u05BC"], [64330, 1, "\u05EA\u05BC"], [64331, 1, "\u05D5\u05B9"], [64332, 1, "\u05D1\u05BF"], [64333, 1, "\u05DB\u05BF"], [64334, 1, "\u05E4\u05BF"], [64335, 1, "\u05D0\u05DC"], [[64336, 64337], 1, "\u0671"], [[64338, 64341], 1, "\u067B"], [[64342, 64345], 1, "\u067E"], [[64346, 64349], 1, "\u0680"], [[64350, 64353], 1, "\u067A"], [[64354, 64357], 1, "\u067F"], [[64358, 64361], 1, "\u0679"], [[64362, 64365], 1, "\u06A4"], [[64366, 64369], 1, "\u06A6"], [[64370, 64373], 1, "\u0684"], [[64374, 64377], 1, "\u0683"], [[64378, 64381], 1, "\u0686"], [[64382, 64385], 1, "\u0687"], [[64386, 64387], 1, "\u068D"], [[64388, 64389], 1, "\u068C"], [[64390, 64391], 1, "\u068E"], [[64392, 64393], 1, "\u0688"], [[64394, 64395], 1, "\u0698"], [[64396, 64397], 1, "\u0691"], [[64398, 64401], 1, "\u06A9"], [[64402, 64405], 1, "\u06AF"], [[64406, 64409], 1, "\u06B3"], [[64410, 64413], 1, "\u06B1"], [[64414, 64415], 1, "\u06BA"], [[64416, 64419], 1, "\u06BB"], [[64420, 64421], 1, "\u06C0"], [[64422, 64425], 1, "\u06C1"], [[64426, 64429], 1, "\u06BE"], [[64430, 64431], 1, "\u06D2"], [[64432, 64433], 1, "\u06D3"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "\u06AD"], [[64471, 64472], 1, "\u06C7"], [[64473, 64474], 1, "\u06C6"], [[64475, 64476], 1, "\u06C8"], [64477, 1, "\u06C7\u0674"], [[64478, 64479], 1, "\u06CB"], [[64480, 64481], 1, "\u06C5"], [[64482, 64483], 1, "\u06C9"], [[64484, 64487], 1, "\u06D0"], [[64488, 64489], 1, "\u0649"], [[64490, 64491], 1, "\u0626\u0627"], [[64492, 64493], 1, "\u0626\u06D5"], [[64494, 64495], 1, "\u0626\u0648"], [[64496, 64497], 1, "\u0626\u06C7"], [[64498, 64499], 1, "\u0626\u06C6"], [[64500, 64501], 1, "\u0626\u06C8"], [[64502, 64504], 1, "\u0626\u06D0"], [[64505, 64507], 1, "\u0626\u0649"], [[64508, 64511], 1, "\u06CC"], [64512, 1, "\u0626\u062C"], [64513, 1, "\u0626\u062D"], [64514, 1, "\u0626\u0645"], [64515, 1, "\u0626\u0649"], [64516, 1, "\u0626\u064A"], [64517, 1, "\u0628\u062C"], [64518, 1, "\u0628\u062D"], [64519, 1, "\u0628\u062E"], [64520, 1, "\u0628\u0645"], [64521, 1, "\u0628\u0649"], [64522, 1, "\u0628\u064A"], [64523, 1, "\u062A\u062C"], [64524, 1, "\u062A\u062D"], [64525, 1, "\u062A\u062E"], [64526, 1, "\u062A\u0645"], [64527, 1, "\u062A\u0649"], [64528, 1, "\u062A\u064A"], [64529, 1, "\u062B\u062C"], [64530, 1, "\u062B\u0645"], [64531, 1, "\u062B\u0649"], [64532, 1, "\u062B\u064A"], [64533, 1, "\u062C\u062D"], [64534, 1, "\u062C\u0645"], [64535, 1, "\u062D\u062C"], [64536, 1, "\u062D\u0645"], [64537, 1, "\u062E\u062C"], [64538, 1, "\u062E\u062D"], [64539, 1, "\u062E\u0645"], [64540, 1, "\u0633\u062C"], [64541, 1, "\u0633\u062D"], [64542, 1, "\u0633\u062E"], [64543, 1, "\u0633\u0645"], [64544, 1, "\u0635\u062D"], [64545, 1, "\u0635\u0645"], [64546, 1, "\u0636\u062C"], [64547, 1, "\u0636\u062D"], [64548, 1, "\u0636\u062E"], [64549, 1, "\u0636\u0645"], [64550, 1, "\u0637\u062D"], [64551, 1, "\u0637\u0645"], [64552, 1, "\u0638\u0645"], [64553, 1, "\u0639\u062C"], [64554, 1, "\u0639\u0645"], [64555, 1, "\u063A\u062C"], [64556, 1, "\u063A\u0645"], [64557, 1, "\u0641\u062C"], [64558, 1, "\u0641\u062D"], [64559, 1, "\u0641\u062E"], [64560, 1, "\u0641\u0645"], [64561, 1, "\u0641\u0649"], [64562, 1, "\u0641\u064A"], [64563, 1, "\u0642\u062D"], [64564, 1, "\u0642\u0645"], [64565, 1, "\u0642\u0649"], [64566, 1, "\u0642\u064A"], [64567, 1, "\u0643\u0627"], [64568, 1, "\u0643\u062C"], [64569, 1, "\u0643\u062D"], [64570, 1, "\u0643\u062E"], [64571, 1, "\u0643\u0644"], [64572, 1, "\u0643\u0645"], [64573, 1, "\u0643\u0649"], [64574, 1, "\u0643\u064A"], [64575, 1, "\u0644\u062C"], [64576, 1, "\u0644\u062D"], [64577, 1, "\u0644\u062E"], [64578, 1, "\u0644\u0645"], [64579, 1, "\u0644\u0649"], [64580, 1, "\u0644\u064A"], [64581, 1, "\u0645\u062C"], [64582, 1, "\u0645\u062D"], [64583, 1, "\u0645\u062E"], [64584, 1, "\u0645\u0645"], [64585, 1, "\u0645\u0649"], [64586, 1, "\u0645\u064A"], [64587, 1, "\u0646\u062C"], [64588, 1, "\u0646\u062D"], [64589, 1, "\u0646\u062E"], [64590, 1, "\u0646\u0645"], [64591, 1, "\u0646\u0649"], [64592, 1, "\u0646\u064A"], [64593, 1, "\u0647\u062C"], [64594, 1, "\u0647\u0645"], [64595, 1, "\u0647\u0649"], [64596, 1, "\u0647\u064A"], [64597, 1, "\u064A\u062C"], [64598, 1, "\u064A\u062D"], [64599, 1, "\u064A\u062E"], [64600, 1, "\u064A\u0645"], [64601, 1, "\u064A\u0649"], [64602, 1, "\u064A\u064A"], [64603, 1, "\u0630\u0670"], [64604, 1, "\u0631\u0670"], [64605, 1, "\u0649\u0670"], [64606, 5, " \u064C\u0651"], [64607, 5, " \u064D\u0651"], [64608, 5, " \u064E\u0651"], [64609, 5, " \u064F\u0651"], [64610, 5, " \u0650\u0651"], [64611, 5, " \u0651\u0670"], [64612, 1, "\u0626\u0631"], [64613, 1, "\u0626\u0632"], [64614, 1, "\u0626\u0645"], [64615, 1, "\u0626\u0646"], [64616, 1, "\u0626\u0649"], [64617, 1, "\u0626\u064A"], [64618, 1, "\u0628\u0631"], [64619, 1, "\u0628\u0632"], [64620, 1, "\u0628\u0645"], [64621, 1, "\u0628\u0646"], [64622, 1, "\u0628\u0649"], [64623, 1, "\u0628\u064A"], [64624, 1, "\u062A\u0631"], [64625, 1, "\u062A\u0632"], [64626, 1, "\u062A\u0645"], [64627, 1, "\u062A\u0646"], [64628, 1, "\u062A\u0649"], [64629, 1, "\u062A\u064A"], [64630, 1, "\u062B\u0631"], [64631, 1, "\u062B\u0632"], [64632, 1, "\u062B\u0645"], [64633, 1, "\u062B\u0646"], [64634, 1, "\u062B\u0649"], [64635, 1, "\u062B\u064A"], [64636, 1, "\u0641\u0649"], [64637, 1, "\u0641\u064A"], [64638, 1, "\u0642\u0649"], [64639, 1, "\u0642\u064A"], [64640, 1, "\u0643\u0627"], [64641, 1, "\u0643\u0644"], [64642, 1, "\u0643\u0645"], [64643, 1, "\u0643\u0649"], [64644, 1, "\u0643\u064A"], [64645, 1, "\u0644\u0645"], [64646, 1, "\u0644\u0649"], [64647, 1, "\u0644\u064A"], [64648, 1, "\u0645\u0627"], [64649, 1, "\u0645\u0645"], [64650, 1, "\u0646\u0631"], [64651, 1, "\u0646\u0632"], [64652, 1, "\u0646\u0645"], [64653, 1, "\u0646\u0646"], [64654, 1, "\u0646\u0649"], [64655, 1, "\u0646\u064A"], [64656, 1, "\u0649\u0670"], [64657, 1, "\u064A\u0631"], [64658, 1, "\u064A\u0632"], [64659, 1, "\u064A\u0645"], [64660, 1, "\u064A\u0646"], [64661, 1, "\u064A\u0649"], [64662, 1, "\u064A\u064A"], [64663, 1, "\u0626\u062C"], [64664, 1, "\u0626\u062D"], [64665, 1, "\u0626\u062E"], [64666, 1, "\u0626\u0645"], [64667, 1, "\u0626\u0647"], [64668, 1, "\u0628\u062C"], [64669, 1, "\u0628\u062D"], [64670, 1, "\u0628\u062E"], [64671, 1, "\u0628\u0645"], [64672, 1, "\u0628\u0647"], [64673, 1, "\u062A\u062C"], [64674, 1, "\u062A\u062D"], [64675, 1, "\u062A\u062E"], [64676, 1, "\u062A\u0645"], [64677, 1, "\u062A\u0647"], [64678, 1, "\u062B\u0645"], [64679, 1, "\u062C\u062D"], [64680, 1, "\u062C\u0645"], [64681, 1, "\u062D\u062C"], [64682, 1, "\u062D\u0645"], [64683, 1, "\u062E\u062C"], [64684, 1, "\u062E\u0645"], [64685, 1, "\u0633\u062C"], [64686, 1, "\u0633\u062D"], [64687, 1, "\u0633\u062E"], [64688, 1, "\u0633\u0645"], [64689, 1, "\u0635\u062D"], [64690, 1, "\u0635\u062E"], [64691, 1, "\u0635\u0645"], [64692, 1, "\u0636\u062C"], [64693, 1, "\u0636\u062D"], [64694, 1, "\u0636\u062E"], [64695, 1, "\u0636\u0645"], [64696, 1, "\u0637\u062D"], [64697, 1, "\u0638\u0645"], [64698, 1, "\u0639\u062C"], [64699, 1, "\u0639\u0645"], [64700, 1, "\u063A\u062C"], [64701, 1, "\u063A\u0645"], [64702, 1, "\u0641\u062C"], [64703, 1, "\u0641\u062D"], [64704, 1, "\u0641\u062E"], [64705, 1, "\u0641\u0645"], [64706, 1, "\u0642\u062D"], [64707, 1, "\u0642\u0645"], [64708, 1, "\u0643\u062C"], [64709, 1, "\u0643\u062D"], [64710, 1, "\u0643\u062E"], [64711, 1, "\u0643\u0644"], [64712, 1, "\u0643\u0645"], [64713, 1, "\u0644\u062C"], [64714, 1, "\u0644\u062D"], [64715, 1, "\u0644\u062E"], [64716, 1, "\u0644\u0645"], [64717, 1, "\u0644\u0647"], [64718, 1, "\u0645\u062C"], [64719, 1, "\u0645\u062D"], [64720, 1, "\u0645\u062E"], [64721, 1, "\u0645\u0645"], [64722, 1, "\u0646\u062C"], [64723, 1, "\u0646\u062D"], [64724, 1, "\u0646\u062E"], [64725, 1, "\u0646\u0645"], [64726, 1, "\u0646\u0647"], [64727, 1, "\u0647\u062C"], [64728, 1, "\u0647\u0645"], [64729, 1, "\u0647\u0670"], [64730, 1, "\u064A\u062C"], [64731, 1, "\u064A\u062D"], [64732, 1, "\u064A\u062E"], [64733, 1, "\u064A\u0645"], [64734, 1, "\u064A\u0647"], [64735, 1, "\u0626\u0645"], [64736, 1, "\u0626\u0647"], [64737, 1, "\u0628\u0645"], [64738, 1, "\u0628\u0647"], [64739, 1, "\u062A\u0645"], [64740, 1, "\u062A\u0647"], [64741, 1, "\u062B\u0645"], [64742, 1, "\u062B\u0647"], [64743, 1, "\u0633\u0645"], [64744, 1, "\u0633\u0647"], [64745, 1, "\u0634\u0645"], [64746, 1, "\u0634\u0647"], [64747, 1, "\u0643\u0644"], [64748, 1, "\u0643\u0645"], [64749, 1, "\u0644\u0645"], [64750, 1, "\u0646\u0645"], [64751, 1, "\u0646\u0647"], [64752, 1, "\u064A\u0645"], [64753, 1, "\u064A\u0647"], [64754, 1, "\u0640\u064E\u0651"], [64755, 1, "\u0640\u064F\u0651"], [64756, 1, "\u0640\u0650\u0651"], [64757, 1, "\u0637\u0649"], [64758, 1, "\u0637\u064A"], [64759, 1, "\u0639\u0649"], [64760, 1, "\u0639\u064A"], [64761, 1, "\u063A\u0649"], [64762, 1, "\u063A\u064A"], [64763, 1, "\u0633\u0649"], [64764, 1, "\u0633\u064A"], [64765, 1, "\u0634\u0649"], [64766, 1, "\u0634\u064A"], [64767, 1, "\u062D\u0649"], [64768, 1, "\u062D\u064A"], [64769, 1, "\u062C\u0649"], [64770, 1, "\u062C\u064A"], [64771, 1, "\u062E\u0649"], [64772, 1, "\u062E\u064A"], [64773, 1, "\u0635\u0649"], [64774, 1, "\u0635\u064A"], [64775, 1, "\u0636\u0649"], [64776, 1, "\u0636\u064A"], [64777, 1, "\u0634\u062C"], [64778, 1, "\u0634\u062D"], [64779, 1, "\u0634\u062E"], [64780, 1, "\u0634\u0645"], [64781, 1, "\u0634\u0631"], [64782, 1, "\u0633\u0631"], [64783, 1, "\u0635\u0631"], [64784, 1, "\u0636\u0631"], [64785, 1, "\u0637\u0649"], [64786, 1, "\u0637\u064A"], [64787, 1, "\u0639\u0649"], [64788, 1, "\u0639\u064A"], [64789, 1, "\u063A\u0649"], [64790, 1, "\u063A\u064A"], [64791, 1, "\u0633\u0649"], [64792, 1, "\u0633\u064A"], [64793, 1, "\u0634\u0649"], [64794, 1, "\u0634\u064A"], [64795, 1, "\u062D\u0649"], [64796, 1, "\u062D\u064A"], [64797, 1, "\u062C\u0649"], [64798, 1, "\u062C\u064A"], [64799, 1, "\u062E\u0649"], [64800, 1, "\u062E\u064A"], [64801, 1, "\u0635\u0649"], [64802, 1, "\u0635\u064A"], [64803, 1, "\u0636\u0649"], [64804, 1, "\u0636\u064A"], [64805, 1, "\u0634\u062C"], [64806, 1, "\u0634\u062D"], [64807, 1, "\u0634\u062E"], [64808, 1, "\u0634\u0645"], [64809, 1, "\u0634\u0631"], [64810, 1, "\u0633\u0631"], [64811, 1, "\u0635\u0631"], [64812, 1, "\u0636\u0631"], [64813, 1, "\u0634\u062C"], [64814, 1, "\u0634\u062D"], [64815, 1, "\u0634\u062E"], [64816, 1, "\u0634\u0645"], [64817, 1, "\u0633\u0647"], [64818, 1, "\u0634\u0647"], [64819, 1, "\u0637\u0645"], [64820, 1, "\u0633\u062C"], [64821, 1, "\u0633\u062D"], [64822, 1, "\u0633\u062E"], [64823, 1, "\u0634\u062C"], [64824, 1, "\u0634\u062D"], [64825, 1, "\u0634\u062E"], [64826, 1, "\u0637\u0645"], [64827, 1, "\u0638\u0645"], [[64828, 64829], 1, "\u0627\u064B"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "\u062A\u062C\u0645"], [[64849, 64850], 1, "\u062A\u062D\u062C"], [64851, 1, "\u062A\u062D\u0645"], [64852, 1, "\u062A\u062E\u0645"], [64853, 1, "\u062A\u0645\u062C"], [64854, 1, "\u062A\u0645\u062D"], [64855, 1, "\u062A\u0645\u062E"], [[64856, 64857], 1, "\u062C\u0645\u062D"], [64858, 1, "\u062D\u0645\u064A"], [64859, 1, "\u062D\u0645\u0649"], [64860, 1, "\u0633\u062D\u062C"], [64861, 1, "\u0633\u062C\u062D"], [64862, 1, "\u0633\u062C\u0649"], [[64863, 64864], 1, "\u0633\u0645\u062D"], [64865, 1, "\u0633\u0645\u062C"], [[64866, 64867], 1, "\u0633\u0645\u0645"], [[64868, 64869], 1, "\u0635\u062D\u062D"], [64870, 1, "\u0635\u0645\u0645"], [[64871, 64872], 1, "\u0634\u062D\u0645"], [64873, 1, "\u0634\u062C\u064A"], [[64874, 64875], 1, "\u0634\u0645\u062E"], [[64876, 64877], 1, "\u0634\u0645\u0645"], [64878, 1, "\u0636\u062D\u0649"], [[64879, 64880], 1, "\u0636\u062E\u0645"], [[64881, 64882], 1, "\u0637\u0645\u062D"], [64883, 1, "\u0637\u0645\u0645"], [64884, 1, "\u0637\u0645\u064A"], [64885, 1, "\u0639\u062C\u0645"], [[64886, 64887], 1, "\u0639\u0645\u0645"], [64888, 1, "\u0639\u0645\u0649"], [64889, 1, "\u063A\u0645\u0645"], [64890, 1, "\u063A\u0645\u064A"], [64891, 1, "\u063A\u0645\u0649"], [[64892, 64893], 1, "\u0641\u062E\u0645"], [64894, 1, "\u0642\u0645\u062D"], [64895, 1, "\u0642\u0645\u0645"], [64896, 1, "\u0644\u062D\u0645"], [64897, 1, "\u0644\u062D\u064A"], [64898, 1, "\u0644\u062D\u0649"], [[64899, 64900], 1, "\u0644\u062C\u062C"], [[64901, 64902], 1, "\u0644\u062E\u0645"], [[64903, 64904], 1, "\u0644\u0645\u062D"], [64905, 1, "\u0645\u062D\u062C"], [64906, 1, "\u0645\u062D\u0645"], [64907, 1, "\u0645\u062D\u064A"], [64908, 1, "\u0645\u062C\u062D"], [64909, 1, "\u0645\u062C\u0645"], [64910, 1, "\u0645\u062E\u062C"], [64911, 1, "\u0645\u062E\u0645"], [[64912, 64913], 3], [64914, 1, "\u0645\u062C\u062E"], [64915, 1, "\u0647\u0645\u062C"], [64916, 1, "\u0647\u0645\u0645"], [64917, 1, "\u0646\u062D\u0645"], [64918, 1, "\u0646\u062D\u0649"], [[64919, 64920], 1, "\u0646\u062C\u0645"], [64921, 1, "\u0646\u062C\u0649"], [64922, 1, "\u0646\u0645\u064A"], [64923, 1, "\u0646\u0645\u0649"], [[64924, 64925], 1, "\u064A\u0645\u0645"], [64926, 1, "\u0628\u062E\u064A"], [64927, 1, "\u062A\u062C\u064A"], [64928, 1, "\u062A\u062C\u0649"], [64929, 1, "\u062A\u062E\u064A"], [64930, 1, "\u062A\u062E\u0649"], [64931, 1, "\u062A\u0645\u064A"], [64932, 1, "\u062A\u0645\u0649"], [64933, 1, "\u062C\u0645\u064A"], [64934, 1, "\u062C\u062D\u0649"], [64935, 1, "\u062C\u0645\u0649"], [64936, 1, "\u0633\u062E\u0649"], [64937, 1, "\u0635\u062D\u064A"], [64938, 1, "\u0634\u062D\u064A"], [64939, 1, "\u0636\u062D\u064A"], [64940, 1, "\u0644\u062C\u064A"], [64941, 1, "\u0644\u0645\u064A"], [64942, 1, "\u064A\u062D\u064A"], [64943, 1, "\u064A\u062C\u064A"], [64944, 1, "\u064A\u0645\u064A"], [64945, 1, "\u0645\u0645\u064A"], [64946, 1, "\u0642\u0645\u064A"], [64947, 1, "\u0646\u062D\u064A"], [64948, 1, "\u0642\u0645\u062D"], [64949, 1, "\u0644\u062D\u0645"], [64950, 1, "\u0639\u0645\u064A"], [64951, 1, "\u0643\u0645\u064A"], [64952, 1, "\u0646\u062C\u062D"], [64953, 1, "\u0645\u062E\u064A"], [64954, 1, "\u0644\u062C\u0645"], [64955, 1, "\u0643\u0645\u0645"], [64956, 1, "\u0644\u062C\u0645"], [64957, 1, "\u0646\u062C\u062D"], [64958, 1, "\u062C\u062D\u064A"], [64959, 1, "\u062D\u062C\u064A"], [64960, 1, "\u0645\u062C\u064A"], [64961, 1, "\u0641\u0645\u064A"], [64962, 1, "\u0628\u062D\u064A"], [64963, 1, "\u0643\u0645\u0645"], [64964, 1, "\u0639\u062C\u0645"], [64965, 1, "\u0635\u0645\u0645"], [64966, 1, "\u0633\u062E\u064A"], [64967, 1, "\u0646\u062C\u064A"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "\u0635\u0644\u06D2"], [65009, 1, "\u0642\u0644\u06D2"], [65010, 1, "\u0627\u0644\u0644\u0647"], [65011, 1, "\u0627\u0643\u0628\u0631"], [65012, 1, "\u0645\u062D\u0645\u062F"], [65013, 1, "\u0635\u0644\u0639\u0645"], [65014, 1, "\u0631\u0633\u0648\u0644"], [65015, 1, "\u0639\u0644\u064A\u0647"], [65016, 1, "\u0648\u0633\u0644\u0645"], [65017, 1, "\u0635\u0644\u0649"], [65018, 5, "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [65019, 5, "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [65020, 1, "\u0631\u06CC\u0627\u0644"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 5, ","], [65041, 1, "\u3001"], [65042, 3], [65043, 5, ":"], [65044, 5, ";"], [65045, 5, "!"], [65046, 5, "?"], [65047, 1, "\u3016"], [65048, 1, "\u3017"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "\u2014"], [65074, 1, "\u2013"], [[65075, 65076], 5, "_"], [65077, 5, "("], [65078, 5, ")"], [65079, 5, "{"], [65080, 5, "}"], [65081, 1, "\u3014"], [65082, 1, "\u3015"], [65083, 1, "\u3010"], [65084, 1, "\u3011"], [65085, 1, "\u300A"], [65086, 1, "\u300B"], [65087, 1, "\u3008"], [65088, 1, "\u3009"], [65089, 1, "\u300C"], [65090, 1, "\u300D"], [65091, 1, "\u300E"], [65092, 1, "\u300F"], [[65093, 65094], 2], [65095, 5, "["], [65096, 5, "]"], [[65097, 65100], 5, " \u0305"], [[65101, 65103], 5, "_"], [65104, 5, ","], [65105, 1, "\u3001"], [65106, 3], [65107, 3], [65108, 5, ";"], [65109, 5, ":"], [65110, 5, "?"], [65111, 5, "!"], [65112, 1, "\u2014"], [65113, 5, "("], [65114, 5, ")"], [65115, 5, "{"], [65116, 5, "}"], [65117, 1, "\u3014"], [65118, 1, "\u3015"], [65119, 5, "#"], [65120, 5, "&"], [65121, 5, "*"], [65122, 5, "+"], [65123, 1, "-"], [65124, 5, "<"], [65125, 5, ">"], [65126, 5, "="], [65127, 3], [65128, 5, "\\"], [65129, 5, "$"], [65130, 5, "%"], [65131, 5, "@"], [[65132, 65135], 3], [65136, 5, " \u064B"], [65137, 1, "\u0640\u064B"], [65138, 5, " \u064C"], [65139, 2], [65140, 5, " \u064D"], [65141, 3], [65142, 5, " \u064E"], [65143, 1, "\u0640\u064E"], [65144, 5, " \u064F"], [65145, 1, "\u0640\u064F"], [65146, 5, " \u0650"], [65147, 1, "\u0640\u0650"], [65148, 5, " \u0651"], [65149, 1, "\u0640\u0651"], [65150, 5, " \u0652"], [65151, 1, "\u0640\u0652"], [65152, 1, "\u0621"], [[65153, 65154], 1, "\u0622"], [[65155, 65156], 1, "\u0623"], [[65157, 65158], 1, "\u0624"], [[65159, 65160], 1, "\u0625"], [[65161, 65164], 1, "\u0626"], [[65165, 65166], 1, "\u0627"], [[65167, 65170], 1, "\u0628"], [[65171, 65172], 1, "\u0629"], [[65173, 65176], 1, "\u062A"], [[65177, 65180], 1, "\u062B"], [[65181, 65184], 1, "\u062C"], [[65185, 65188], 1, "\u062D"], [[65189, 65192], 1, "\u062E"], [[65193, 65194], 1, "\u062F"], [[65195, 65196], 1, "\u0630"], [[65197, 65198], 1, "\u0631"], [[65199, 65200], 1, "\u0632"], [[65201, 65204], 1, "\u0633"], [[65205, 65208], 1, "\u0634"], [[65209, 65212], 1, "\u0635"], [[65213, 65216], 1, "\u0636"], [[65217, 65220], 1, "\u0637"], [[65221, 65224], 1, "\u0638"], [[65225, 65228], 1, "\u0639"], [[65229, 65232], 1, "\u063A"], [[65233, 65236], 1, "\u0641"], [[65237, 65240], 1, "\u0642"], [[65241, 65244], 1, "\u0643"], [[65245, 65248], 1, "\u0644"], [[65249, 65252], 1, "\u0645"], [[65253, 65256], 1, "\u0646"], [[65257, 65260], 1, "\u0647"], [[65261, 65262], 1, "\u0648"], [[65263, 65264], 1, "\u0649"], [[65265, 65268], 1, "\u064A"], [[65269, 65270], 1, "\u0644\u0622"], [[65271, 65272], 1, "\u0644\u0623"], [[65273, 65274], 1, "\u0644\u0625"], [[65275, 65276], 1, "\u0644\u0627"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 5, "!"], [65282, 5, "\""], [65283, 5, "#"], [65284, 5, "$"], [65285, 5, "%"], [65286, 5, "&"], [65287, 5, "'"], [65288, 5, "("], [65289, 5, ")"], [65290, 5, "*"], [65291, 5, "+"], [65292, 5, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 5, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 5, ":"], [65307, 5, ";"], [65308, 5, "<"], [65309, 5, "="], [65310, 5, ">"], [65311, 5, "?"], [65312, 5, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 5, "["], [65340, 5, "\\"], [65341, 5, "]"], [65342, 5, "^"], [65343, 5, "_"], [65344, 5, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 5, "{"], [65372, 5, "|"], [65373, 5, "}"], [65374, 5, "~"], [65375, 1, "\u2985"], [65376, 1, "\u2986"], [65377, 1, "."], [65378, 1, "\u300C"], [65379, 1, "\u300D"], [65380, 1, "\u3001"], [65381, 1, "\u30FB"], [65382, 1, "\u30F2"], [65383, 1, "\u30A1"], [65384, 1, "\u30A3"], [65385, 1, "\u30A5"], [65386, 1, "\u30A7"], [65387, 1, "\u30A9"], [65388, 1, "\u30E3"], [65389, 1, "\u30E5"], [65390, 1, "\u30E7"], [65391, 1, "\u30C3"], [65392, 1, "\u30FC"], [65393, 1, "\u30A2"], [65394, 1, "\u30A4"], [65395, 1, "\u30A6"], [65396, 1, "\u30A8"], [65397, 1, "\u30AA"], [65398, 1, "\u30AB"], [65399, 1, "\u30AD"], [65400, 1, "\u30AF"], [65401, 1, "\u30B1"], [65402, 1, "\u30B3"], [65403, 1, "\u30B5"], [65404, 1, "\u30B7"], [65405, 1, "\u30B9"], [65406, 1, "\u30BB"], [65407, 1, "\u30BD"], [65408, 1, "\u30BF"], [65409, 1, "\u30C1"], [65410, 1, "\u30C4"], [65411, 1, "\u30C6"], [65412, 1, "\u30C8"], [65413, 1, "\u30CA"], [65414, 1, "\u30CB"], [65415, 1, "\u30CC"], [65416, 1, "\u30CD"], [65417, 1, "\u30CE"], [65418, 1, "\u30CF"], [65419, 1, "\u30D2"], [65420, 1, "\u30D5"], [65421, 1, "\u30D8"], [65422, 1, "\u30DB"], [65423, 1, "\u30DE"], [65424, 1, "\u30DF"], [65425, 1, "\u30E0"], [65426, 1, "\u30E1"], [65427, 1, "\u30E2"], [65428, 1, "\u30E4"], [65429, 1, "\u30E6"], [65430, 1, "\u30E8"], [65431, 1, "\u30E9"], [65432, 1, "\u30EA"], [65433, 1, "\u30EB"], [65434, 1, "\u30EC"], [65435, 1, "\u30ED"], [65436, 1, "\u30EF"], [65437, 1, "\u30F3"], [65438, 1, "\u3099"], [65439, 1, "\u309A"], [65440, 3], [65441, 1, "\u1100"], [65442, 1, "\u1101"], [65443, 1, "\u11AA"], [65444, 1, "\u1102"], [65445, 1, "\u11AC"], [65446, 1, "\u11AD"], [65447, 1, "\u1103"], [65448, 1, "\u1104"], [65449, 1, "\u1105"], [65450, 1, "\u11B0"], [65451, 1, "\u11B1"], [65452, 1, "\u11B2"], [65453, 1, "\u11B3"], [65454, 1, "\u11B4"], [65455, 1, "\u11B5"], [65456, 1, "\u111A"], [65457, 1, "\u1106"], [65458, 1, "\u1107"], [65459, 1, "\u1108"], [65460, 1, "\u1121"], [65461, 1, "\u1109"], [65462, 1, "\u110A"], [65463, 1, "\u110B"], [65464, 1, "\u110C"], [65465, 1, "\u110D"], [65466, 1, "\u110E"], [65467, 1, "\u110F"], [65468, 1, "\u1110"], [65469, 1, "\u1111"], [65470, 1, "\u1112"], [[65471, 65473], 3], [65474, 1, "\u1161"], [65475, 1, "\u1162"], [65476, 1, "\u1163"], [65477, 1, "\u1164"], [65478, 1, "\u1165"], [65479, 1, "\u1166"], [[65480, 65481], 3], [65482, 1, "\u1167"], [65483, 1, "\u1168"], [65484, 1, "\u1169"], [65485, 1, "\u116A"], [65486, 1, "\u116B"], [65487, 1, "\u116C"], [[65488, 65489], 3], [65490, 1, "\u116D"], [65491, 1, "\u116E"], [65492, 1, "\u116F"], [65493, 1, "\u1170"], [65494, 1, "\u1171"], [65495, 1, "\u1172"], [[65496, 65497], 3], [65498, 1, "\u1173"], [65499, 1, "\u1174"], [65500, 1, "\u1175"], [[65501, 65503], 3], [65504, 1, "\xA2"], [65505, 1, "\xA3"], [65506, 1, "\xAC"], [65507, 5, " \u0304"], [65508, 1, "\xA6"], [65509, 1, "\xA5"], [65510, 1, "\u20A9"], [65511, 3], [65512, 1, "\u2502"], [65513, 1, "\u2190"], [65514, 1, "\u2191"], [65515, 1, "\u2192"], [65516, 1, "\u2193"], [65517, 1, "\u25A0"], [65518, 1, "\u25CB"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66000, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\uD801\uDC28"], [66561, 1, "\uD801\uDC29"], [66562, 1, "\uD801\uDC2A"], [66563, 1, "\uD801\uDC2B"], [66564, 1, "\uD801\uDC2C"], [66565, 1, "\uD801\uDC2D"], [66566, 1, "\uD801\uDC2E"], [66567, 1, "\uD801\uDC2F"], [66568, 1, "\uD801\uDC30"], [66569, 1, "\uD801\uDC31"], [66570, 1, "\uD801\uDC32"], [66571, 1, "\uD801\uDC33"], [66572, 1, "\uD801\uDC34"], [66573, 1, "\uD801\uDC35"], [66574, 1, "\uD801\uDC36"], [66575, 1, "\uD801\uDC37"], [66576, 1, "\uD801\uDC38"], [66577, 1, "\uD801\uDC39"], [66578, 1, "\uD801\uDC3A"], [66579, 1, "\uD801\uDC3B"], [66580, 1, "\uD801\uDC3C"], [66581, 1, "\uD801\uDC3D"], [66582, 1, "\uD801\uDC3E"], [66583, 1, "\uD801\uDC3F"], [66584, 1, "\uD801\uDC40"], [66585, 1, "\uD801\uDC41"], [66586, 1, "\uD801\uDC42"], [66587, 1, "\uD801\uDC43"], [66588, 1, "\uD801\uDC44"], [66589, 1, "\uD801\uDC45"], [66590, 1, "\uD801\uDC46"], [66591, 1, "\uD801\uDC47"], [66592, 1, "\uD801\uDC48"], [66593, 1, "\uD801\uDC49"], [66594, 1, "\uD801\uDC4A"], [66595, 1, "\uD801\uDC4B"], [66596, 1, "\uD801\uDC4C"], [66597, 1, "\uD801\uDC4D"], [66598, 1, "\uD801\uDC4E"], [66599, 1, "\uD801\uDC4F"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\uD801\uDCD8"], [66737, 1, "\uD801\uDCD9"], [66738, 1, "\uD801\uDCDA"], [66739, 1, "\uD801\uDCDB"], [66740, 1, "\uD801\uDCDC"], [66741, 1, "\uD801\uDCDD"], [66742, 1, "\uD801\uDCDE"], [66743, 1, "\uD801\uDCDF"], [66744, 1, "\uD801\uDCE0"], [66745, 1, "\uD801\uDCE1"], [66746, 1, "\uD801\uDCE2"], [66747, 1, "\uD801\uDCE3"], [66748, 1, "\uD801\uDCE4"], [66749, 1, "\uD801\uDCE5"], [66750, 1, "\uD801\uDCE6"], [66751, 1, "\uD801\uDCE7"], [66752, 1, "\uD801\uDCE8"], [66753, 1, "\uD801\uDCE9"], [66754, 1, "\uD801\uDCEA"], [66755, 1, "\uD801\uDCEB"], [66756, 1, "\uD801\uDCEC"], [66757, 1, "\uD801\uDCED"], [66758, 1, "\uD801\uDCEE"], [66759, 1, "\uD801\uDCEF"], [66760, 1, "\uD801\uDCF0"], [66761, 1, "\uD801\uDCF1"], [66762, 1, "\uD801\uDCF2"], [66763, 1, "\uD801\uDCF3"], [66764, 1, "\uD801\uDCF4"], [66765, 1, "\uD801\uDCF5"], [66766, 1, "\uD801\uDCF6"], [66767, 1, "\uD801\uDCF7"], [66768, 1, "\uD801\uDCF8"], [66769, 1, "\uD801\uDCF9"], [66770, 1, "\uD801\uDCFA"], [66771, 1, "\uD801\uDCFB"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\uD801\uDD97"], [66929, 1, "\uD801\uDD98"], [66930, 1, "\uD801\uDD99"], [66931, 1, "\uD801\uDD9A"], [66932, 1, "\uD801\uDD9B"], [66933, 1, "\uD801\uDD9C"], [66934, 1, "\uD801\uDD9D"], [66935, 1, "\uD801\uDD9E"], [66936, 1, "\uD801\uDD9F"], [66937, 1, "\uD801\uDDA0"], [66938, 1, "\uD801\uDDA1"], [66939, 3], [66940, 1, "\uD801\uDDA3"], [66941, 1, "\uD801\uDDA4"], [66942, 1, "\uD801\uDDA5"], [66943, 1, "\uD801\uDDA6"], [66944, 1, "\uD801\uDDA7"], [66945, 1, "\uD801\uDDA8"], [66946, 1, "\uD801\uDDA9"], [66947, 1, "\uD801\uDDAA"], [66948, 1, "\uD801\uDDAB"], [66949, 1, "\uD801\uDDAC"], [66950, 1, "\uD801\uDDAD"], [66951, 1, "\uD801\uDDAE"], [66952, 1, "\uD801\uDDAF"], [66953, 1, "\uD801\uDDB0"], [66954, 1, "\uD801\uDDB1"], [66955, 3], [66956, 1, "\uD801\uDDB3"], [66957, 1, "\uD801\uDDB4"], [66958, 1, "\uD801\uDDB5"], [66959, 1, "\uD801\uDDB6"], [66960, 1, "\uD801\uDDB7"], [66961, 1, "\uD801\uDDB8"], [66962, 1, "\uD801\uDDB9"], [66963, 3], [66964, 1, "\uD801\uDDBB"], [66965, 1, "\uD801\uDDBC"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "\u02D0"], [67458, 1, "\u02D1"], [67459, 1, "\xE6"], [67460, 1, "\u0299"], [67461, 1, "\u0253"], [67462, 3], [67463, 1, "\u02A3"], [67464, 1, "\uAB66"], [67465, 1, "\u02A5"], [67466, 1, "\u02A4"], [67467, 1, "\u0256"], [67468, 1, "\u0257"], [67469, 1, "\u1D91"], [67470, 1, "\u0258"], [67471, 1, "\u025E"], [67472, 1, "\u02A9"], [67473, 1, "\u0264"], [67474, 1, "\u0262"], [67475, 1, "\u0260"], [67476, 1, "\u029B"], [67477, 1, "\u0127"], [67478, 1, "\u029C"], [67479, 1, "\u0267"], [67480, 1, "\u0284"], [67481, 1, "\u02AA"], [67482, 1, "\u02AB"], [67483, 1, "\u026C"], [67484, 1, "\uD837\uDF04"], [67485, 1, "\uA78E"], [67486, 1, "\u026E"], [67487, 1, "\uD837\uDF05"], [67488, 1, "\u028E"], [67489, 1, "\uD837\uDF06"], [67490, 1, "\xF8"], [67491, 1, "\u0276"], [67492, 1, "\u0277"], [67493, 1, "q"], [67494, 1, "\u027A"], [67495, 1, "\uD837\uDF08"], [67496, 1, "\u027D"], [67497, 1, "\u027E"], [67498, 1, "\u0280"], [67499, 1, "\u02A8"], [67500, 1, "\u02A6"], [67501, 1, "\uAB67"], [67502, 1, "\u02A7"], [67503, 1, "\u0288"], [67504, 1, "\u2C71"], [67505, 3], [67506, 1, "\u028F"], [67507, 1, "\u02A1"], [67508, 1, "\u02A2"], [67509, 1, "\u0298"], [67510, 1, "\u01C0"], [67511, 1, "\u01C1"], [67512, 1, "\u01C2"], [67513, 1, "\uD837\uDF0A"], [67514, 1, "\uD837\uDF1E"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\uD803\uDCC0"], [68737, 1, "\uD803\uDCC1"], [68738, 1, "\uD803\uDCC2"], [68739, 1, "\uD803\uDCC3"], [68740, 1, "\uD803\uDCC4"], [68741, 1, "\uD803\uDCC5"], [68742, 1, "\uD803\uDCC6"], [68743, 1, "\uD803\uDCC7"], [68744, 1, "\uD803\uDCC8"], [68745, 1, "\uD803\uDCC9"], [68746, 1, "\uD803\uDCCA"], [68747, 1, "\uD803\uDCCB"], [68748, 1, "\uD803\uDCCC"], [68749, 1, "\uD803\uDCCD"], [68750, 1, "\uD803\uDCCE"], [68751, 1, "\uD803\uDCCF"], [68752, 1, "\uD803\uDCD0"], [68753, 1, "\uD803\uDCD1"], [68754, 1, "\uD803\uDCD2"], [68755, 1, "\uD803\uDCD3"], [68756, 1, "\uD803\uDCD4"], [68757, 1, "\uD803\uDCD5"], [68758, 1, "\uD803\uDCD6"], [68759, 1, "\uD803\uDCD7"], [68760, 1, "\uD803\uDCD8"], [68761, 1, "\uD803\uDCD9"], [68762, 1, "\uD803\uDCDA"], [68763, 1, "\uD803\uDCDB"], [68764, 1, "\uD803\uDCDC"], [68765, 1, "\uD803\uDCDD"], [68766, 1, "\uD803\uDCDE"], [68767, 1, "\uD803\uDCDF"], [68768, 1, "\uD803\uDCE0"], [68769, 1, "\uD803\uDCE1"], [68770, 1, "\uD803\uDCE2"], [68771, 1, "\uD803\uDCE3"], [68772, 1, "\uD803\uDCE4"], [68773, 1, "\uD803\uDCE5"], [68774, 1, "\uD803\uDCE6"], [68775, 1, "\uD803\uDCE7"], [68776, 1, "\uD803\uDCE8"], [68777, 1, "\uD803\uDCE9"], [68778, 1, "\uD803\uDCEA"], [68779, 1, "\uD803\uDCEB"], [68780, 1, "\uD803\uDCEC"], [68781, 1, "\uD803\uDCED"], [68782, 1, "\uD803\uDCEE"], [68783, 1, "\uD803\uDCEF"], [68784, 1, "\uD803\uDCF0"], [68785, 1, "\uD803\uDCF1"], [68786, 1, "\uD803\uDCF2"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69372], 3], [[69373, 69375], 2], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70209], 2], [[70210, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\uD806\uDCC0"], [71841, 1, "\uD806\uDCC1"], [71842, 1, "\uD806\uDCC2"], [71843, 1, "\uD806\uDCC3"], [71844, 1, "\uD806\uDCC4"], [71845, 1, "\uD806\uDCC5"], [71846, 1, "\uD806\uDCC6"], [71847, 1, "\uD806\uDCC7"], [71848, 1, "\uD806\uDCC8"], [71849, 1, "\uD806\uDCC9"], [71850, 1, "\uD806\uDCCA"], [71851, 1, "\uD806\uDCCB"], [71852, 1, "\uD806\uDCCC"], [71853, 1, "\uD806\uDCCD"], [71854, 1, "\uD806\uDCCE"], [71855, 1, "\uD806\uDCCF"], [71856, 1, "\uD806\uDCD0"], [71857, 1, "\uD806\uDCD1"], [71858, 1, "\uD806\uDCD2"], [71859, 1, "\uD806\uDCD3"], [71860, 1, "\uD806\uDCD4"], [71861, 1, "\uD806\uDCD5"], [71862, 1, "\uD806\uDCD6"], [71863, 1, "\uD806\uDCD7"], [71864, 1, "\uD806\uDCD8"], [71865, 1, "\uD806\uDCD9"], [71866, 1, "\uD806\uDCDA"], [71867, 1, "\uD806\uDCDB"], [71868, 1, "\uD806\uDCDC"], [71869, 1, "\uD806\uDCDD"], [71870, 1, "\uD806\uDCDE"], [71871, 1, "\uD806\uDCDF"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72447], 3], [[72448, 72457], 2], [[72458, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73471], 3], [[73472, 73488], 2], [73489, 3], [[73490, 73530], 2], [[73531, 73533], 3], [[73534, 73538], 2], [[73539, 73551], 2], [[73552, 73561], 2], [[73562, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 2], [[78896, 78904], 3], [[78905, 78911], 3], [[78912, 78933], 2], [[78934, 82943], 3], [[82944, 83526], 2], [[83527, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93759], 3], [93760, 1, "\uD81B\uDE60"], [93761, 1, "\uD81B\uDE61"], [93762, 1, "\uD81B\uDE62"], [93763, 1, "\uD81B\uDE63"], [93764, 1, "\uD81B\uDE64"], [93765, 1, "\uD81B\uDE65"], [93766, 1, "\uD81B\uDE66"], [93767, 1, "\uD81B\uDE67"], [93768, 1, "\uD81B\uDE68"], [93769, 1, "\uD81B\uDE69"], [93770, 1, "\uD81B\uDE6A"], [93771, 1, "\uD81B\uDE6B"], [93772, 1, "\uD81B\uDE6C"], [93773, 1, "\uD81B\uDE6D"], [93774, 1, "\uD81B\uDE6E"], [93775, 1, "\uD81B\uDE6F"], [93776, 1, "\uD81B\uDE70"], [93777, 1, "\uD81B\uDE71"], [93778, 1, "\uD81B\uDE72"], [93779, 1, "\uD81B\uDE73"], [93780, 1, "\uD81B\uDE74"], [93781, 1, "\uD81B\uDE75"], [93782, 1, "\uD81B\uDE76"], [93783, 1, "\uD81B\uDE77"], [93784, 1, "\uD81B\uDE78"], [93785, 1, "\uD81B\uDE79"], [93786, 1, "\uD81B\uDE7A"], [93787, 1, "\uD81B\uDE7B"], [93788, 1, "\uD81B\uDE7C"], [93789, 1, "\uD81B\uDE7D"], [93790, 1, "\uD81B\uDE7E"], [93791, 1, "\uD81B\uDE7F"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101631], 3], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110897], 3], [110898, 2], [[110899, 110927], 3], [[110928, 110930], 2], [[110931, 110932], 3], [110933, 2], [[110934, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\uD834\uDD57\uD834\uDD65"], [119135, 1, "\uD834\uDD58\uD834\uDD65"], [119136, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD6E"], [119137, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD6F"], [119138, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD70"], [119139, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD71"], [119140, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD72"], [[119141, 119154], 2], [[119155, 119162], 3], [[119163, 119226], 2], [119227, 1, "\uD834\uDDB9\uD834\uDD65"], [119228, 1, "\uD834\uDDBA\uD834\uDD65"], [119229, 1, "\uD834\uDDB9\uD834\uDD65\uD834\uDD6E"], [119230, 1, "\uD834\uDDBA\uD834\uDD65\uD834\uDD6E"], [119231, 1, "\uD834\uDDB9\uD834\uDD65\uD834\uDD6F"], [119232, 1, "\uD834\uDDBA\uD834\uDD65\uD834\uDD6F"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119487], 3], [[119488, 119507], 2], [[119508, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [120000, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "\u0131"], [120485, 1, "\u0237"], [[120486, 120487], 3], [120488, 1, "\u03B1"], [120489, 1, "\u03B2"], [120490, 1, "\u03B3"], [120491, 1, "\u03B4"], [120492, 1, "\u03B5"], [120493, 1, "\u03B6"], [120494, 1, "\u03B7"], [120495, 1, "\u03B8"], [120496, 1, "\u03B9"], [120497, 1, "\u03BA"], [120498, 1, "\u03BB"], [120499, 1, "\u03BC"], [120500, 1, "\u03BD"], [120501, 1, "\u03BE"], [120502, 1, "\u03BF"], [120503, 1, "\u03C0"], [120504, 1, "\u03C1"], [120505, 1, "\u03B8"], [120506, 1, "\u03C3"], [120507, 1, "\u03C4"], [120508, 1, "\u03C5"], [120509, 1, "\u03C6"], [120510, 1, "\u03C7"], [120511, 1, "\u03C8"], [120512, 1, "\u03C9"], [120513, 1, "\u2207"], [120514, 1, "\u03B1"], [120515, 1, "\u03B2"], [120516, 1, "\u03B3"], [120517, 1, "\u03B4"], [120518, 1, "\u03B5"], [120519, 1, "\u03B6"], [120520, 1, "\u03B7"], [120521, 1, "\u03B8"], [120522, 1, "\u03B9"], [120523, 1, "\u03BA"], [120524, 1, "\u03BB"], [120525, 1, "\u03BC"], [120526, 1, "\u03BD"], [120527, 1, "\u03BE"], [120528, 1, "\u03BF"], [120529, 1, "\u03C0"], [120530, 1, "\u03C1"], [[120531, 120532], 1, "\u03C3"], [120533, 1, "\u03C4"], [120534, 1, "\u03C5"], [120535, 1, "\u03C6"], [120536, 1, "\u03C7"], [120537, 1, "\u03C8"], [120538, 1, "\u03C9"], [120539, 1, "\u2202"], [120540, 1, "\u03B5"], [120541, 1, "\u03B8"], [120542, 1, "\u03BA"], [120543, 1, "\u03C6"], [120544, 1, "\u03C1"], [120545, 1, "\u03C0"], [120546, 1, "\u03B1"], [120547, 1, "\u03B2"], [120548, 1, "\u03B3"], [120549, 1, "\u03B4"], [120550, 1, "\u03B5"], [120551, 1, "\u03B6"], [120552, 1, "\u03B7"], [120553, 1, "\u03B8"], [120554, 1, "\u03B9"], [120555, 1, "\u03BA"], [120556, 1, "\u03BB"], [120557, 1, "\u03BC"], [120558, 1, "\u03BD"], [120559, 1, "\u03BE"], [120560, 1, "\u03BF"], [120561, 1, "\u03C0"], [120562, 1, "\u03C1"], [120563, 1, "\u03B8"], [120564, 1, "\u03C3"], [120565, 1, "\u03C4"], [120566, 1, "\u03C5"], [120567, 1, "\u03C6"], [120568, 1, "\u03C7"], [120569, 1, "\u03C8"], [120570, 1, "\u03C9"], [120571, 1, "\u2207"], [120572, 1, "\u03B1"], [120573, 1, "\u03B2"], [120574, 1, "\u03B3"], [120575, 1, "\u03B4"], [120576, 1, "\u03B5"], [120577, 1, "\u03B6"], [120578, 1, "\u03B7"], [120579, 1, "\u03B8"], [120580, 1, "\u03B9"], [120581, 1, "\u03BA"], [120582, 1, "\u03BB"], [120583, 1, "\u03BC"], [120584, 1, "\u03BD"], [120585, 1, "\u03BE"], [120586, 1, "\u03BF"], [120587, 1, "\u03C0"], [120588, 1, "\u03C1"], [[120589, 120590], 1, "\u03C3"], [120591, 1, "\u03C4"], [120592, 1, "\u03C5"], [120593, 1, "\u03C6"], [120594, 1, "\u03C7"], [120595, 1, "\u03C8"], [120596, 1, "\u03C9"], [120597, 1, "\u2202"], [120598, 1, "\u03B5"], [120599, 1, "\u03B8"], [120600, 1, "\u03BA"], [120601, 1, "\u03C6"], [120602, 1, "\u03C1"], [120603, 1, "\u03C0"], [120604, 1, "\u03B1"], [120605, 1, "\u03B2"], [120606, 1, "\u03B3"], [120607, 1, "\u03B4"], [120608, 1, "\u03B5"], [120609, 1, "\u03B6"], [120610, 1, "\u03B7"], [120611, 1, "\u03B8"], [120612, 1, "\u03B9"], [120613, 1, "\u03BA"], [120614, 1, "\u03BB"], [120615, 1, "\u03BC"], [120616, 1, "\u03BD"], [120617, 1, "\u03BE"], [120618, 1, "\u03BF"], [120619, 1, "\u03C0"], [120620, 1, "\u03C1"], [120621, 1, "\u03B8"], [120622, 1, "\u03C3"], [120623, 1, "\u03C4"], [120624, 1, "\u03C5"], [120625, 1, "\u03C6"], [120626, 1, "\u03C7"], [120627, 1, "\u03C8"], [120628, 1, "\u03C9"], [120629, 1, "\u2207"], [120630, 1, "\u03B1"], [120631, 1, "\u03B2"], [120632, 1, "\u03B3"], [120633, 1, "\u03B4"], [120634, 1, "\u03B5"], [120635, 1, "\u03B6"], [120636, 1, "\u03B7"], [120637, 1, "\u03B8"], [120638, 1, "\u03B9"], [120639, 1, "\u03BA"], [120640, 1, "\u03BB"], [120641, 1, "\u03BC"], [120642, 1, "\u03BD"], [120643, 1, "\u03BE"], [120644, 1, "\u03BF"], [120645, 1, "\u03C0"], [120646, 1, "\u03C1"], [[120647, 120648], 1, "\u03C3"], [120649, 1, "\u03C4"], [120650, 1, "\u03C5"], [120651, 1, "\u03C6"], [120652, 1, "\u03C7"], [120653, 1, "\u03C8"], [120654, 1, "\u03C9"], [120655, 1, "\u2202"], [120656, 1, "\u03B5"], [120657, 1, "\u03B8"], [120658, 1, "\u03BA"], [120659, 1, "\u03C6"], [120660, 1, "\u03C1"], [120661, 1, "\u03C0"], [120662, 1, "\u03B1"], [120663, 1, "\u03B2"], [120664, 1, "\u03B3"], [120665, 1, "\u03B4"], [120666, 1, "\u03B5"], [120667, 1, "\u03B6"], [120668, 1, "\u03B7"], [120669, 1, "\u03B8"], [120670, 1, "\u03B9"], [120671, 1, "\u03BA"], [120672, 1, "\u03BB"], [120673, 1, "\u03BC"], [120674, 1, "\u03BD"], [120675, 1, "\u03BE"], [120676, 1, "\u03BF"], [120677, 1, "\u03C0"], [120678, 1, "\u03C1"], [120679, 1, "\u03B8"], [120680, 1, "\u03C3"], [120681, 1, "\u03C4"], [120682, 1, "\u03C5"], [120683, 1, "\u03C6"], [120684, 1, "\u03C7"], [120685, 1, "\u03C8"], [120686, 1, "\u03C9"], [120687, 1, "\u2207"], [120688, 1, "\u03B1"], [120689, 1, "\u03B2"], [120690, 1, "\u03B3"], [120691, 1, "\u03B4"], [120692, 1, "\u03B5"], [120693, 1, "\u03B6"], [120694, 1, "\u03B7"], [120695, 1, "\u03B8"], [120696, 1, "\u03B9"], [120697, 1, "\u03BA"], [120698, 1, "\u03BB"], [120699, 1, "\u03BC"], [120700, 1, "\u03BD"], [120701, 1, "\u03BE"], [120702, 1, "\u03BF"], [120703, 1, "\u03C0"], [120704, 1, "\u03C1"], [[120705, 120706], 1, "\u03C3"], [120707, 1, "\u03C4"], [120708, 1, "\u03C5"], [120709, 1, "\u03C6"], [120710, 1, "\u03C7"], [120711, 1, "\u03C8"], [120712, 1, "\u03C9"], [120713, 1, "\u2202"], [120714, 1, "\u03B5"], [120715, 1, "\u03B8"], [120716, 1, "\u03BA"], [120717, 1, "\u03C6"], [120718, 1, "\u03C1"], [120719, 1, "\u03C0"], [120720, 1, "\u03B1"], [120721, 1, "\u03B2"], [120722, 1, "\u03B3"], [120723, 1, "\u03B4"], [120724, 1, "\u03B5"], [120725, 1, "\u03B6"], [120726, 1, "\u03B7"], [120727, 1, "\u03B8"], [120728, 1, "\u03B9"], [120729, 1, "\u03BA"], [120730, 1, "\u03BB"], [120731, 1, "\u03BC"], [120732, 1, "\u03BD"], [120733, 1, "\u03BE"], [120734, 1, "\u03BF"], [120735, 1, "\u03C0"], [120736, 1, "\u03C1"], [120737, 1, "\u03B8"], [120738, 1, "\u03C3"], [120739, 1, "\u03C4"], [120740, 1, "\u03C5"], [120741, 1, "\u03C6"], [120742, 1, "\u03C7"], [120743, 1, "\u03C8"], [120744, 1, "\u03C9"], [120745, 1, "\u2207"], [120746, 1, "\u03B1"], [120747, 1, "\u03B2"], [120748, 1, "\u03B3"], [120749, 1, "\u03B4"], [120750, 1, "\u03B5"], [120751, 1, "\u03B6"], [120752, 1, "\u03B7"], [120753, 1, "\u03B8"], [120754, 1, "\u03B9"], [120755, 1, "\u03BA"], [120756, 1, "\u03BB"], [120757, 1, "\u03BC"], [120758, 1, "\u03BD"], [120759, 1, "\u03BE"], [120760, 1, "\u03BF"], [120761, 1, "\u03C0"], [120762, 1, "\u03C1"], [[120763, 120764], 1, "\u03C3"], [120765, 1, "\u03C4"], [120766, 1, "\u03C5"], [120767, 1, "\u03C6"], [120768, 1, "\u03C7"], [120769, 1, "\u03C8"], [120770, 1, "\u03C9"], [120771, 1, "\u2202"], [120772, 1, "\u03B5"], [120773, 1, "\u03B8"], [120774, 1, "\u03BA"], [120775, 1, "\u03C6"], [120776, 1, "\u03C1"], [120777, 1, "\u03C0"], [[120778, 120779], 1, "\u03DD"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122660], 3], [[122661, 122666], 2], [[122667, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 122927], 3], [122928, 1, "\u0430"], [122929, 1, "\u0431"], [122930, 1, "\u0432"], [122931, 1, "\u0433"], [122932, 1, "\u0434"], [122933, 1, "\u0435"], [122934, 1, "\u0436"], [122935, 1, "\u0437"], [122936, 1, "\u0438"], [122937, 1, "\u043A"], [122938, 1, "\u043B"], [122939, 1, "\u043C"], [122940, 1, "\u043E"], [122941, 1, "\u043F"], [122942, 1, "\u0440"], [122943, 1, "\u0441"], [122944, 1, "\u0442"], [122945, 1, "\u0443"], [122946, 1, "\u0444"], [122947, 1, "\u0445"], [122948, 1, "\u0446"], [122949, 1, "\u0447"], [122950, 1, "\u0448"], [122951, 1, "\u044B"], [122952, 1, "\u044D"], [122953, 1, "\u044E"], [122954, 1, "\uA689"], [122955, 1, "\u04D9"], [122956, 1, "\u0456"], [122957, 1, "\u0458"], [122958, 1, "\u04E9"], [122959, 1, "\u04AF"], [122960, 1, "\u04CF"], [122961, 1, "\u0430"], [122962, 1, "\u0431"], [122963, 1, "\u0432"], [122964, 1, "\u0433"], [122965, 1, "\u0434"], [122966, 1, "\u0435"], [122967, 1, "\u0436"], [122968, 1, "\u0437"], [122969, 1, "\u0438"], [122970, 1, "\u043A"], [122971, 1, "\u043B"], [122972, 1, "\u043E"], [122973, 1, "\u043F"], [122974, 1, "\u0441"], [122975, 1, "\u0443"], [122976, 1, "\u0444"], [122977, 1, "\u0445"], [122978, 1, "\u0446"], [122979, 1, "\u0447"], [122980, 1, "\u0448"], [122981, 1, "\u044A"], [122982, 1, "\u044B"], [122983, 1, "\u0491"], [122984, 1, "\u0456"], [122985, 1, "\u0455"], [122986, 1, "\u045F"], [122987, 1, "\u04AB"], [122988, 1, "\uA651"], [122989, 1, "\u04B1"], [[122990, 123022], 3], [123023, 2], [[123024, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124111], 3], [[124112, 124153], 2], [[124154, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\uD83A\uDD22"], [125185, 1, "\uD83A\uDD23"], [125186, 1, "\uD83A\uDD24"], [125187, 1, "\uD83A\uDD25"], [125188, 1, "\uD83A\uDD26"], [125189, 1, "\uD83A\uDD27"], [125190, 1, "\uD83A\uDD28"], [125191, 1, "\uD83A\uDD29"], [125192, 1, "\uD83A\uDD2A"], [125193, 1, "\uD83A\uDD2B"], [125194, 1, "\uD83A\uDD2C"], [125195, 1, "\uD83A\uDD2D"], [125196, 1, "\uD83A\uDD2E"], [125197, 1, "\uD83A\uDD2F"], [125198, 1, "\uD83A\uDD30"], [125199, 1, "\uD83A\uDD31"], [125200, 1, "\uD83A\uDD32"], [125201, 1, "\uD83A\uDD33"], [125202, 1, "\uD83A\uDD34"], [125203, 1, "\uD83A\uDD35"], [125204, 1, "\uD83A\uDD36"], [125205, 1, "\uD83A\uDD37"], [125206, 1, "\uD83A\uDD38"], [125207, 1, "\uD83A\uDD39"], [125208, 1, "\uD83A\uDD3A"], [125209, 1, "\uD83A\uDD3B"], [125210, 1, "\uD83A\uDD3C"], [125211, 1, "\uD83A\uDD3D"], [125212, 1, "\uD83A\uDD3E"], [125213, 1, "\uD83A\uDD3F"], [125214, 1, "\uD83A\uDD40"], [125215, 1, "\uD83A\uDD41"], [125216, 1, "\uD83A\uDD42"], [125217, 1, "\uD83A\uDD43"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "\u0627"], [126465, 1, "\u0628"], [126466, 1, "\u062C"], [126467, 1, "\u062F"], [126468, 3], [126469, 1, "\u0648"], [126470, 1, "\u0632"], [126471, 1, "\u062D"], [126472, 1, "\u0637"], [126473, 1, "\u064A"], [126474, 1, "\u0643"], [126475, 1, "\u0644"], [126476, 1, "\u0645"], [126477, 1, "\u0646"], [126478, 1, "\u0633"], [126479, 1, "\u0639"], [126480, 1, "\u0641"], [126481, 1, "\u0635"], [126482, 1, "\u0642"], [126483, 1, "\u0631"], [126484, 1, "\u0634"], [126485, 1, "\u062A"], [126486, 1, "\u062B"], [126487, 1, "\u062E"], [126488, 1, "\u0630"], [126489, 1, "\u0636"], [126490, 1, "\u0638"], [126491, 1, "\u063A"], [126492, 1, "\u066E"], [126493, 1, "\u06BA"], [126494, 1, "\u06A1"], [126495, 1, "\u066F"], [126496, 3], [126497, 1, "\u0628"], [126498, 1, "\u062C"], [126499, 3], [126500, 1, "\u0647"], [[126501, 126502], 3], [126503, 1, "\u062D"], [126504, 3], [126505, 1, "\u064A"], [126506, 1, "\u0643"], [126507, 1, "\u0644"], [126508, 1, "\u0645"], [126509, 1, "\u0646"], [126510, 1, "\u0633"], [126511, 1, "\u0639"], [126512, 1, "\u0641"], [126513, 1, "\u0635"], [126514, 1, "\u0642"], [126515, 3], [126516, 1, "\u0634"], [126517, 1, "\u062A"], [126518, 1, "\u062B"], [126519, 1, "\u062E"], [126520, 3], [126521, 1, "\u0636"], [126522, 3], [126523, 1, "\u063A"], [[126524, 126529], 3], [126530, 1, "\u062C"], [[126531, 126534], 3], [126535, 1, "\u062D"], [126536, 3], [126537, 1, "\u064A"], [126538, 3], [126539, 1, "\u0644"], [126540, 3], [126541, 1, "\u0646"], [126542, 1, "\u0633"], [126543, 1, "\u0639"], [126544, 3], [126545, 1, "\u0635"], [126546, 1, "\u0642"], [126547, 3], [126548, 1, "\u0634"], [[126549, 126550], 3], [126551, 1, "\u062E"], [126552, 3], [126553, 1, "\u0636"], [126554, 3], [126555, 1, "\u063A"], [126556, 3], [126557, 1, "\u06BA"], [126558, 3], [126559, 1, "\u066F"], [126560, 3], [126561, 1, "\u0628"], [126562, 1, "\u062C"], [126563, 3], [126564, 1, "\u0647"], [[126565, 126566], 3], [126567, 1, "\u062D"], [126568, 1, "\u0637"], [126569, 1, "\u064A"], [126570, 1, "\u0643"], [126571, 3], [126572, 1, "\u0645"], [126573, 1, "\u0646"], [126574, 1, "\u0633"], [126575, 1, "\u0639"], [126576, 1, "\u0641"], [126577, 1, "\u0635"], [126578, 1, "\u0642"], [126579, 3], [126580, 1, "\u0634"], [126581, 1, "\u062A"], [126582, 1, "\u062B"], [126583, 1, "\u062E"], [126584, 3], [126585, 1, "\u0636"], [126586, 1, "\u0638"], [126587, 1, "\u063A"], [126588, 1, "\u066E"], [126589, 3], [126590, 1, "\u06A1"], [126591, 3], [126592, 1, "\u0627"], [126593, 1, "\u0628"], [126594, 1, "\u062C"], [126595, 1, "\u062F"], [126596, 1, "\u0647"], [126597, 1, "\u0648"], [126598, 1, "\u0632"], [126599, 1, "\u062D"], [126600, 1, "\u0637"], [126601, 1, "\u064A"], [126602, 3], [126603, 1, "\u0644"], [126604, 1, "\u0645"], [126605, 1, "\u0646"], [126606, 1, "\u0633"], [126607, 1, "\u0639"], [126608, 1, "\u0641"], [126609, 1, "\u0635"], [126610, 1, "\u0642"], [126611, 1, "\u0631"], [126612, 1, "\u0634"], [126613, 1, "\u062A"], [126614, 1, "\u062B"], [126615, 1, "\u062E"], [126616, 1, "\u0630"], [126617, 1, "\u0636"], [126618, 1, "\u0638"], [126619, 1, "\u063A"], [[126620, 126624], 3], [126625, 1, "\u0628"], [126626, 1, "\u062C"], [126627, 1, "\u062F"], [126628, 3], [126629, 1, "\u0648"], [126630, 1, "\u0632"], [126631, 1, "\u062D"], [126632, 1, "\u0637"], [126633, 1, "\u064A"], [126634, 3], [126635, 1, "\u0644"], [126636, 1, "\u0645"], [126637, 1, "\u0646"], [126638, 1, "\u0633"], [126639, 1, "\u0639"], [126640, 1, "\u0641"], [126641, 1, "\u0635"], [126642, 1, "\u0642"], [126643, 1, "\u0631"], [126644, 1, "\u0634"], [126645, 1, "\u062A"], [126646, 1, "\u062B"], [126647, 1, "\u062E"], [126648, 1, "\u0630"], [126649, 1, "\u0636"], [126650, 1, "\u0638"], [126651, 1, "\u063A"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 5, "0,"], [127234, 5, "1,"], [127235, 5, "2,"], [127236, 5, "3,"], [127237, 5, "4,"], [127238, 5, "5,"], [127239, 5, "6,"], [127240, 5, "7,"], [127241, 5, "8,"], [127242, 5, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 5, "(a)"], [127249, 5, "(b)"], [127250, 5, "(c)"], [127251, 5, "(d)"], [127252, 5, "(e)"], [127253, 5, "(f)"], [127254, 5, "(g)"], [127255, 5, "(h)"], [127256, 5, "(i)"], [127257, 5, "(j)"], [127258, 5, "(k)"], [127259, 5, "(l)"], [127260, 5, "(m)"], [127261, 5, "(n)"], [127262, 5, "(o)"], [127263, 5, "(p)"], [127264, 5, "(q)"], [127265, 5, "(r)"], [127266, 5, "(s)"], [127267, 5, "(t)"], [127268, 5, "(u)"], [127269, 5, "(v)"], [127270, 5, "(w)"], [127271, 5, "(x)"], [127272, 5, "(y)"], [127273, 5, "(z)"], [127274, 1, "\u3014s\u3015"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "\u307B\u304B"], [127489, 1, "\u30B3\u30B3"], [127490, 1, "\u30B5"], [[127491, 127503], 3], [127504, 1, "\u624B"], [127505, 1, "\u5B57"], [127506, 1, "\u53CC"], [127507, 1, "\u30C7"], [127508, 1, "\u4E8C"], [127509, 1, "\u591A"], [127510, 1, "\u89E3"], [127511, 1, "\u5929"], [127512, 1, "\u4EA4"], [127513, 1, "\u6620"], [127514, 1, "\u7121"], [127515, 1, "\u6599"], [127516, 1, "\u524D"], [127517, 1, "\u5F8C"], [127518, 1, "\u518D"], [127519, 1, "\u65B0"], [127520, 1, "\u521D"], [127521, 1, "\u7D42"], [127522, 1, "\u751F"], [127523, 1, "\u8CA9"], [127524, 1, "\u58F0"], [127525, 1, "\u5439"], [127526, 1, "\u6F14"], [127527, 1, "\u6295"], [127528, 1, "\u6355"], [127529, 1, "\u4E00"], [127530, 1, "\u4E09"], [127531, 1, "\u904A"], [127532, 1, "\u5DE6"], [127533, 1, "\u4E2D"], [127534, 1, "\u53F3"], [127535, 1, "\u6307"], [127536, 1, "\u8D70"], [127537, 1, "\u6253"], [127538, 1, "\u7981"], [127539, 1, "\u7A7A"], [127540, 1, "\u5408"], [127541, 1, "\u6E80"], [127542, 1, "\u6709"], [127543, 1, "\u6708"], [127544, 1, "\u7533"], [127545, 1, "\u5272"], [127546, 1, "\u55B6"], [127547, 1, "\u914D"], [[127548, 127551], 3], [127552, 1, "\u3014\u672C\u3015"], [127553, 1, "\u3014\u4E09\u3015"], [127554, 1, "\u3014\u4E8C\u3015"], [127555, 1, "\u3014\u5B89\u3015"], [127556, 1, "\u3014\u70B9\u3015"], [127557, 1, "\u3014\u6253\u3015"], [127558, 1, "\u3014\u76D7\u3015"], [127559, 1, "\u3014\u52DD\u3015"], [127560, 1, "\u3014\u6557\u3015"], [[127561, 127567], 3], [127568, 1, "\u5F97"], [127569, 1, "\u53EF"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128000, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128731], 3], [128732, 2], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128886], 2], [[128887, 128890], 3], [[128891, 128895], 2], [[128896, 128980], 2], [[128981, 128984], 2], [128985, 2], [[128986, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 2], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129672], 2], [[129673, 129679], 3], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 2], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129725], 2], [129726, 3], [129727, 2], [[129728, 129730], 2], [[129731, 129733], 2], [[129734, 129741], 3], [[129742, 129743], 2], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129755], 2], [[129756, 129759], 3], [[129760, 129767], 2], [129768, 2], [[129769, 129775], 3], [[129776, 129782], 2], [[129783, 129784], 2], [[129785, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 3], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [177977, 2], [[177978, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 194559], 3], [194560, 1, "\u4E3D"], [194561, 1, "\u4E38"], [194562, 1, "\u4E41"], [194563, 1, "\uD840\uDD22"], [194564, 1, "\u4F60"], [194565, 1, "\u4FAE"], [194566, 1, "\u4FBB"], [194567, 1, "\u5002"], [194568, 1, "\u507A"], [194569, 1, "\u5099"], [194570, 1, "\u50E7"], [194571, 1, "\u50CF"], [194572, 1, "\u349E"], [194573, 1, "\uD841\uDE3A"], [194574, 1, "\u514D"], [194575, 1, "\u5154"], [194576, 1, "\u5164"], [194577, 1, "\u5177"], [194578, 1, "\uD841\uDD1C"], [194579, 1, "\u34B9"], [194580, 1, "\u5167"], [194581, 1, "\u518D"], [194582, 1, "\uD841\uDD4B"], [194583, 1, "\u5197"], [194584, 1, "\u51A4"], [194585, 1, "\u4ECC"], [194586, 1, "\u51AC"], [194587, 1, "\u51B5"], [194588, 1, "\uD864\uDDDF"], [194589, 1, "\u51F5"], [194590, 1, "\u5203"], [194591, 1, "\u34DF"], [194592, 1, "\u523B"], [194593, 1, "\u5246"], [194594, 1, "\u5272"], [194595, 1, "\u5277"], [194596, 1, "\u3515"], [194597, 1, "\u52C7"], [194598, 1, "\u52C9"], [194599, 1, "\u52E4"], [194600, 1, "\u52FA"], [194601, 1, "\u5305"], [194602, 1, "\u5306"], [194603, 1, "\u5317"], [194604, 1, "\u5349"], [194605, 1, "\u5351"], [194606, 1, "\u535A"], [194607, 1, "\u5373"], [194608, 1, "\u537D"], [[194609, 194611], 1, "\u537F"], [194612, 1, "\uD842\uDE2C"], [194613, 1, "\u7070"], [194614, 1, "\u53CA"], [194615, 1, "\u53DF"], [194616, 1, "\uD842\uDF63"], [194617, 1, "\u53EB"], [194618, 1, "\u53F1"], [194619, 1, "\u5406"], [194620, 1, "\u549E"], [194621, 1, "\u5438"], [194622, 1, "\u5448"], [194623, 1, "\u5468"], [194624, 1, "\u54A2"], [194625, 1, "\u54F6"], [194626, 1, "\u5510"], [194627, 1, "\u5553"], [194628, 1, "\u5563"], [[194629, 194630], 1, "\u5584"], [194631, 1, "\u5599"], [194632, 1, "\u55AB"], [194633, 1, "\u55B3"], [194634, 1, "\u55C2"], [194635, 1, "\u5716"], [194636, 1, "\u5606"], [194637, 1, "\u5717"], [194638, 1, "\u5651"], [194639, 1, "\u5674"], [194640, 1, "\u5207"], [194641, 1, "\u58EE"], [194642, 1, "\u57CE"], [194643, 1, "\u57F4"], [194644, 1, "\u580D"], [194645, 1, "\u578B"], [194646, 1, "\u5832"], [194647, 1, "\u5831"], [194648, 1, "\u58AC"], [194649, 1, "\uD845\uDCE4"], [194650, 1, "\u58F2"], [194651, 1, "\u58F7"], [194652, 1, "\u5906"], [194653, 1, "\u591A"], [194654, 1, "\u5922"], [194655, 1, "\u5962"], [194656, 1, "\uD845\uDEA8"], [194657, 1, "\uD845\uDEEA"], [194658, 1, "\u59EC"], [194659, 1, "\u5A1B"], [194660, 1, "\u5A27"], [194661, 1, "\u59D8"], [194662, 1, "\u5A66"], [194663, 1, "\u36EE"], [194664, 3], [194665, 1, "\u5B08"], [[194666, 194667], 1, "\u5B3E"], [194668, 1, "\uD846\uDDC8"], [194669, 1, "\u5BC3"], [194670, 1, "\u5BD8"], [194671, 1, "\u5BE7"], [194672, 1, "\u5BF3"], [194673, 1, "\uD846\uDF18"], [194674, 1, "\u5BFF"], [194675, 1, "\u5C06"], [194676, 3], [194677, 1, "\u5C22"], [194678, 1, "\u3781"], [194679, 1, "\u5C60"], [194680, 1, "\u5C6E"], [194681, 1, "\u5CC0"], [194682, 1, "\u5C8D"], [194683, 1, "\uD847\uDDE4"], [194684, 1, "\u5D43"], [194685, 1, "\uD847\uDDE6"], [194686, 1, "\u5D6E"], [194687, 1, "\u5D6B"], [194688, 1, "\u5D7C"], [194689, 1, "\u5DE1"], [194690, 1, "\u5DE2"], [194691, 1, "\u382F"], [194692, 1, "\u5DFD"], [194693, 1, "\u5E28"], [194694, 1, "\u5E3D"], [194695, 1, "\u5E69"], [194696, 1, "\u3862"], [194697, 1, "\uD848\uDD83"], [194698, 1, "\u387C"], [194699, 1, "\u5EB0"], [194700, 1, "\u5EB3"], [194701, 1, "\u5EB6"], [194702, 1, "\u5ECA"], [194703, 1, "\uD868\uDF92"], [194704, 1, "\u5EFE"], [[194705, 194706], 1, "\uD848\uDF31"], [194707, 1, "\u8201"], [[194708, 194709], 1, "\u5F22"], [194710, 1, "\u38C7"], [194711, 1, "\uD84C\uDEB8"], [194712, 1, "\uD858\uDDDA"], [194713, 1, "\u5F62"], [194714, 1, "\u5F6B"], [194715, 1, "\u38E3"], [194716, 1, "\u5F9A"], [194717, 1, "\u5FCD"], [194718, 1, "\u5FD7"], [194719, 1, "\u5FF9"], [194720, 1, "\u6081"], [194721, 1, "\u393A"], [194722, 1, "\u391C"], [194723, 1, "\u6094"], [194724, 1, "\uD849\uDED4"], [194725, 1, "\u60C7"], [194726, 1, "\u6148"], [194727, 1, "\u614C"], [194728, 1, "\u614E"], [194729, 1, "\u614C"], [194730, 1, "\u617A"], [194731, 1, "\u618E"], [194732, 1, "\u61B2"], [194733, 1, "\u61A4"], [194734, 1, "\u61AF"], [194735, 1, "\u61DE"], [194736, 1, "\u61F2"], [194737, 1, "\u61F6"], [194738, 1, "\u6210"], [194739, 1, "\u621B"], [194740, 1, "\u625D"], [194741, 1, "\u62B1"], [194742, 1, "\u62D4"], [194743, 1, "\u6350"], [194744, 1, "\uD84A\uDF0C"], [194745, 1, "\u633D"], [194746, 1, "\u62FC"], [194747, 1, "\u6368"], [194748, 1, "\u6383"], [194749, 1, "\u63E4"], [194750, 1, "\uD84A\uDFF1"], [194751, 1, "\u6422"], [194752, 1, "\u63C5"], [194753, 1, "\u63A9"], [194754, 1, "\u3A2E"], [194755, 1, "\u6469"], [194756, 1, "\u647E"], [194757, 1, "\u649D"], [194758, 1, "\u6477"], [194759, 1, "\u3A6C"], [194760, 1, "\u654F"], [194761, 1, "\u656C"], [194762, 1, "\uD84C\uDC0A"], [194763, 1, "\u65E3"], [194764, 1, "\u66F8"], [194765, 1, "\u6649"], [194766, 1, "\u3B19"], [194767, 1, "\u6691"], [194768, 1, "\u3B08"], [194769, 1, "\u3AE4"], [194770, 1, "\u5192"], [194771, 1, "\u5195"], [194772, 1, "\u6700"], [194773, 1, "\u669C"], [194774, 1, "\u80AD"], [194775, 1, "\u43D9"], [194776, 1, "\u6717"], [194777, 1, "\u671B"], [194778, 1, "\u6721"], [194779, 1, "\u675E"], [194780, 1, "\u6753"], [194781, 1, "\uD84C\uDFC3"], [194782, 1, "\u3B49"], [194783, 1, "\u67FA"], [194784, 1, "\u6785"], [194785, 1, "\u6852"], [194786, 1, "\u6885"], [194787, 1, "\uD84D\uDC6D"], [194788, 1, "\u688E"], [194789, 1, "\u681F"], [194790, 1, "\u6914"], [194791, 1, "\u3B9D"], [194792, 1, "\u6942"], [194793, 1, "\u69A3"], [194794, 1, "\u69EA"], [194795, 1, "\u6AA8"], [194796, 1, "\uD84D\uDEA3"], [194797, 1, "\u6ADB"], [194798, 1, "\u3C18"], [194799, 1, "\u6B21"], [194800, 1, "\uD84E\uDCA7"], [194801, 1, "\u6B54"], [194802, 1, "\u3C4E"], [194803, 1, "\u6B72"], [194804, 1, "\u6B9F"], [194805, 1, "\u6BBA"], [194806, 1, "\u6BBB"], [194807, 1, "\uD84E\uDE8D"], [194808, 1, "\uD847\uDD0B"], [194809, 1, "\uD84E\uDEFA"], [194810, 1, "\u6C4E"], [194811, 1, "\uD84F\uDCBC"], [194812, 1, "\u6CBF"], [194813, 1, "\u6CCD"], [194814, 1, "\u6C67"], [194815, 1, "\u6D16"], [194816, 1, "\u6D3E"], [194817, 1, "\u6D77"], [194818, 1, "\u6D41"], [194819, 1, "\u6D69"], [194820, 1, "\u6D78"], [194821, 1, "\u6D85"], [194822, 1, "\uD84F\uDD1E"], [194823, 1, "\u6D34"], [194824, 1, "\u6E2F"], [194825, 1, "\u6E6E"], [194826, 1, "\u3D33"], [194827, 1, "\u6ECB"], [194828, 1, "\u6EC7"], [194829, 1, "\uD84F\uDED1"], [194830, 1, "\u6DF9"], [194831, 1, "\u6F6E"], [194832, 1, "\uD84F\uDF5E"], [194833, 1, "\uD84F\uDF8E"], [194834, 1, "\u6FC6"], [194835, 1, "\u7039"], [194836, 1, "\u701E"], [194837, 1, "\u701B"], [194838, 1, "\u3D96"], [194839, 1, "\u704A"], [194840, 1, "\u707D"], [194841, 1, "\u7077"], [194842, 1, "\u70AD"], [194843, 1, "\uD841\uDD25"], [194844, 1, "\u7145"], [194845, 1, "\uD850\uDE63"], [194846, 1, "\u719C"], [194847, 3], [194848, 1, "\u7228"], [194849, 1, "\u7235"], [194850, 1, "\u7250"], [194851, 1, "\uD851\uDE08"], [194852, 1, "\u7280"], [194853, 1, "\u7295"], [194854, 1, "\uD851\uDF35"], [194855, 1, "\uD852\uDC14"], [194856, 1, "\u737A"], [194857, 1, "\u738B"], [194858, 1, "\u3EAC"], [194859, 1, "\u73A5"], [[194860, 194861], 1, "\u3EB8"], [194862, 1, "\u7447"], [194863, 1, "\u745C"], [194864, 1, "\u7471"], [194865, 1, "\u7485"], [194866, 1, "\u74CA"], [194867, 1, "\u3F1B"], [194868, 1, "\u7524"], [194869, 1, "\uD853\uDC36"], [194870, 1, "\u753E"], [194871, 1, "\uD853\uDC92"], [194872, 1, "\u7570"], [194873, 1, "\uD848\uDD9F"], [194874, 1, "\u7610"], [194875, 1, "\uD853\uDFA1"], [194876, 1, "\uD853\uDFB8"], [194877, 1, "\uD854\uDC44"], [194878, 1, "\u3FFC"], [194879, 1, "\u4008"], [194880, 1, "\u76F4"], [194881, 1, "\uD854\uDCF3"], [194882, 1, "\uD854\uDCF2"], [194883, 1, "\uD854\uDD19"], [194884, 1, "\uD854\uDD33"], [194885, 1, "\u771E"], [[194886, 194887], 1, "\u771F"], [194888, 1, "\u774A"], [194889, 1, "\u4039"], [194890, 1, "\u778B"], [194891, 1, "\u4046"], [194892, 1, "\u4096"], [194893, 1, "\uD855\uDC1D"], [194894, 1, "\u784E"], [194895, 1, "\u788C"], [194896, 1, "\u78CC"], [194897, 1, "\u40E3"], [194898, 1, "\uD855\uDE26"], [194899, 1, "\u7956"], [194900, 1, "\uD855\uDE9A"], [194901, 1, "\uD855\uDEC5"], [194902, 1, "\u798F"], [194903, 1, "\u79EB"], [194904, 1, "\u412F"], [194905, 1, "\u7A40"], [194906, 1, "\u7A4A"], [194907, 1, "\u7A4F"], [194908, 1, "\uD856\uDD7C"], [[194909, 194910], 1, "\uD856\uDEA7"], [194911, 3], [194912, 1, "\u4202"], [194913, 1, "\uD856\uDFAB"], [194914, 1, "\u7BC6"], [194915, 1, "\u7BC9"], [194916, 1, "\u4227"], [194917, 1, "\uD857\uDC80"], [194918, 1, "\u7CD2"], [194919, 1, "\u42A0"], [194920, 1, "\u7CE8"], [194921, 1, "\u7CE3"], [194922, 1, "\u7D00"], [194923, 1, "\uD857\uDF86"], [194924, 1, "\u7D63"], [194925, 1, "\u4301"], [194926, 1, "\u7DC7"], [194927, 1, "\u7E02"], [194928, 1, "\u7E45"], [194929, 1, "\u4334"], [194930, 1, "\uD858\uDE28"], [194931, 1, "\uD858\uDE47"], [194932, 1, "\u4359"], [194933, 1, "\uD858\uDED9"], [194934, 1, "\u7F7A"], [194935, 1, "\uD858\uDF3E"], [194936, 1, "\u7F95"], [194937, 1, "\u7FFA"], [194938, 1, "\u8005"], [194939, 1, "\uD859\uDCDA"], [194940, 1, "\uD859\uDD23"], [194941, 1, "\u8060"], [194942, 1, "\uD859\uDDA8"], [194943, 1, "\u8070"], [194944, 1, "\uD84C\uDF5F"], [194945, 1, "\u43D5"], [194946, 1, "\u80B2"], [194947, 1, "\u8103"], [194948, 1, "\u440B"], [194949, 1, "\u813E"], [194950, 1, "\u5AB5"], [194951, 1, "\uD859\uDFA7"], [194952, 1, "\uD859\uDFB5"], [194953, 1, "\uD84C\uDF93"], [194954, 1, "\uD84C\uDF9C"], [194955, 1, "\u8201"], [194956, 1, "\u8204"], [194957, 1, "\u8F9E"], [194958, 1, "\u446B"], [194959, 1, "\u8291"], [194960, 1, "\u828B"], [194961, 1, "\u829D"], [194962, 1, "\u52B3"], [194963, 1, "\u82B1"], [194964, 1, "\u82B3"], [194965, 1, "\u82BD"], [194966, 1, "\u82E6"], [194967, 1, "\uD85A\uDF3C"], [194968, 1, "\u82E5"], [194969, 1, "\u831D"], [194970, 1, "\u8363"], [194971, 1, "\u83AD"], [194972, 1, "\u8323"], [194973, 1, "\u83BD"], [194974, 1, "\u83E7"], [194975, 1, "\u8457"], [194976, 1, "\u8353"], [194977, 1, "\u83CA"], [194978, 1, "\u83CC"], [194979, 1, "\u83DC"], [194980, 1, "\uD85B\uDC36"], [194981, 1, "\uD85B\uDD6B"], [194982, 1, "\uD85B\uDCD5"], [194983, 1, "\u452B"], [194984, 1, "\u84F1"], [194985, 1, "\u84F3"], [194986, 1, "\u8516"], [194987, 1, "\uD85C\uDFCA"], [194988, 1, "\u8564"], [194989, 1, "\uD85B\uDF2C"], [194990, 1, "\u455D"], [194991, 1, "\u4561"], [194992, 1, "\uD85B\uDFB1"], [194993, 1, "\uD85C\uDCD2"], [194994, 1, "\u456B"], [194995, 1, "\u8650"], [194996, 1, "\u865C"], [194997, 1, "\u8667"], [194998, 1, "\u8669"], [194999, 1, "\u86A9"], [195000, 1, "\u8688"], [195001, 1, "\u870E"], [195002, 1, "\u86E2"], [195003, 1, "\u8779"], [195004, 1, "\u8728"], [195005, 1, "\u876B"], [195006, 1, "\u8786"], [195007, 3], [195008, 1, "\u87E1"], [195009, 1, "\u8801"], [195010, 1, "\u45F9"], [195011, 1, "\u8860"], [195012, 1, "\u8863"], [195013, 1, "\uD85D\uDE67"], [195014, 1, "\u88D7"], [195015, 1, "\u88DE"], [195016, 1, "\u4635"], [195017, 1, "\u88FA"], [195018, 1, "\u34BB"], [195019, 1, "\uD85E\uDCAE"], [195020, 1, "\uD85E\uDD66"], [195021, 1, "\u46BE"], [195022, 1, "\u46C7"], [195023, 1, "\u8AA0"], [195024, 1, "\u8AED"], [195025, 1, "\u8B8A"], [195026, 1, "\u8C55"], [195027, 1, "\uD85F\uDCA8"], [195028, 1, "\u8CAB"], [195029, 1, "\u8CC1"], [195030, 1, "\u8D1B"], [195031, 1, "\u8D77"], [195032, 1, "\uD85F\uDF2F"], [195033, 1, "\uD842\uDC04"], [195034, 1, "\u8DCB"], [195035, 1, "\u8DBC"], [195036, 1, "\u8DF0"], [195037, 1, "\uD842\uDCDE"], [195038, 1, "\u8ED4"], [195039, 1, "\u8F38"], [195040, 1, "\uD861\uDDD2"], [195041, 1, "\uD861\uDDED"], [195042, 1, "\u9094"], [195043, 1, "\u90F1"], [195044, 1, "\u9111"], [195045, 1, "\uD861\uDF2E"], [195046, 1, "\u911B"], [195047, 1, "\u9238"], [195048, 1, "\u92D7"], [195049, 1, "\u92D8"], [195050, 1, "\u927C"], [195051, 1, "\u93F9"], [195052, 1, "\u9415"], [195053, 1, "\uD862\uDFFA"], [195054, 1, "\u958B"], [195055, 1, "\u4995"], [195056, 1, "\u95B7"], [195057, 1, "\uD863\uDD77"], [195058, 1, "\u49E6"], [195059, 1, "\u96C3"], [195060, 1, "\u5DB2"], [195061, 1, "\u9723"], [195062, 1, "\uD864\uDD45"], [195063, 1, "\uD864\uDE1A"], [195064, 1, "\u4A6E"], [195065, 1, "\u4A76"], [195066, 1, "\u97E0"], [195067, 1, "\uD865\uDC0A"], [195068, 1, "\u4AB2"], [195069, 1, "\uD865\uDC96"], [[195070, 195071], 1, "\u980B"], [195072, 1, "\u9829"], [195073, 1, "\uD865\uDDB6"], [195074, 1, "\u98E2"], [195075, 1, "\u4B33"], [195076, 1, "\u9929"], [195077, 1, "\u99A7"], [195078, 1, "\u99C2"], [195079, 1, "\u99FE"], [195080, 1, "\u4BCE"], [195081, 1, "\uD866\uDF30"], [195082, 1, "\u9B12"], [195083, 1, "\u9C40"], [195084, 1, "\u9CFD"], [195085, 1, "\u4CCE"], [195086, 1, "\u4CED"], [195087, 1, "\u9D67"], [195088, 1, "\uD868\uDCCE"], [195089, 1, "\u4CF8"], [195090, 1, "\uD868\uDD05"], [195091, 1, "\uD868\uDE0E"], [195092, 1, "\uD868\uDE91"], [195093, 1, "\u9EBB"], [195094, 1, "\u4D56"], [195095, 1, "\u9EF9"], [195096, 1, "\u9EFE"], [195097, 1, "\u9F05"], [195098, 1, "\u9F0F"], [195099, 1, "\u9F16"], [195100, 1, "\u9F3B"], [195101, 1, "\uD869\uDE00"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 201551], 3], [[201552, 205743], 2], [[205744, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918000, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
});

// node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS((exports, module) => {
  exports.STATUS_MAPPING = {
    mapped: 1,
    valid: 2,
    disallowed: 3,
    disallowed_STD3_valid: 4,
    disallowed_STD3_mapped: 5,
    deviation: 6,
    ignored: 7
  };
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var containsNonASCII = function(str) {
    return /[^\x00-\x7F]/u.test(str);
  };
  var findStatus = function(val, { useSTD3ASCIIRules }) {
    let start = 0;
    let end = mappingTable.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const target = mappingTable[mid];
      const min = Array.isArray(target[0]) ? target[0][0] : target[0];
      const max = Array.isArray(target[0]) ? target[0][1] : target[0];
      if (min <= val && max >= val) {
        if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
          return [STATUS_MAPPING.disallowed, ...target.slice(2)];
        } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
          return [STATUS_MAPPING.valid, ...target.slice(2)];
        } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
          return [STATUS_MAPPING.mapped, ...target.slice(2)];
        }
        return target.slice(1);
      } else if (min > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  };
  var mapChars = function(domainName, { useSTD3ASCIIRules, processingOption }) {
    let hasError = false;
    let processed = "";
    for (const ch of domainName) {
      const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
      switch (status) {
        case STATUS_MAPPING.disallowed:
          hasError = true;
          processed += ch;
          break;
        case STATUS_MAPPING.ignored:
          break;
        case STATUS_MAPPING.mapped:
          processed += mapping;
          break;
        case STATUS_MAPPING.deviation:
          if (processingOption === "transitional") {
            processed += mapping;
          } else {
            processed += ch;
          }
          break;
        case STATUS_MAPPING.valid:
          processed += ch;
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  };
  var validateLabel = function(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {
    if (label.normalize("NFC") !== label) {
      return false;
    }
    const codePoints = Array.from(label);
    if (checkHyphens) {
      if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
        return false;
      }
    }
    if (label.includes(".") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {
      return false;
    }
    for (const ch of codePoints) {
      const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
      if (processingOption === "transitional" && status !== STATUS_MAPPING.valid || processingOption === "nontransitional" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
        return false;
      }
    }
    if (checkJoiners) {
      let last = 0;
      for (const [i2, ch] of codePoints.entries()) {
        if (ch === "\u200C" || ch === "\u200D") {
          if (i2 > 0) {
            if (regexes.combiningClassVirama.test(codePoints[i2 - 1])) {
              continue;
            }
            if (ch === "\u200C") {
              const next = codePoints.indexOf("\u200C", i2 + 1);
              const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
              if (regexes.validZWNJ.test(test.join(""))) {
                last = i2 + 1;
                continue;
              }
            }
          }
          return false;
        }
      }
    }
    if (checkBidi && codePoints.length > 0) {
      let rtl;
      if (regexes.bidiS1LTR.test(codePoints[0])) {
        rtl = false;
      } else if (regexes.bidiS1RTL.test(codePoints[0])) {
        rtl = true;
      } else {
        return false;
      }
      if (rtl) {
        if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
          return false;
        }
      } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
        return false;
      }
    }
    return true;
  };
  var isBidiDomain = function(labels) {
    const domain = labels.map((label) => {
      if (label.startsWith("xn--")) {
        try {
          return punycode.decode(label.substring(4));
        } catch (err) {
          return "";
        }
      }
      return label;
    }).join(".");
    return regexes.bidiDomain.test(domain);
  };
  var processing = function(domainName, options) {
    const { processingOption } = options;
    let { string: string6, error: error21 } = mapChars(domainName, options);
    string6 = string6.normalize("NFC");
    const labels = string6.split(".");
    const isBidi = isBidiDomain(labels);
    for (const [i2, origLabel] of labels.entries()) {
      let label = origLabel;
      let curProcessing = processingOption;
      if (label.startsWith("xn--")) {
        try {
          label = punycode.decode(label.substring(4));
          labels[i2] = label;
        } catch (err) {
          error21 = true;
          continue;
        }
        curProcessing = "nontransitional";
      }
      if (error21) {
        continue;
      }
      const validation = validateLabel(label, {
        ...options,
        processingOption: curProcessing,
        checkBidi: options.checkBidi && isBidi
      });
      if (!validation) {
        error21 = true;
      }
    }
    return {
      string: labels.join("."),
      error: error21
    };
  };
  var toASCII = function(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    processingOption = "nontransitional",
    verifyDNSLength = false
  } = {}) {
    if (processingOption !== "transitional" && processingOption !== "nontransitional") {
      throw new RangeError("processingOption must be either transitional or nontransitional");
    }
    const result = processing(domainName, {
      processingOption,
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules
    });
    let labels = result.string.split(".");
    labels = labels.map((l) => {
      if (containsNonASCII(l)) {
        try {
          return `xn--${punycode.encode(l)}`;
        } catch (e2) {
          result.error = true;
        }
      }
      return l;
    });
    if (verifyDNSLength) {
      const total = labels.join(".").length;
      if (total > 253 || total === 0) {
        result.error = true;
      }
      for (let i2 = 0;i2 < labels.length; ++i2) {
        if (labels[i2].length > 63 || labels[i2].length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error) {
      return null;
    }
    return labels.join(".");
  };
  var toUnicode = function(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    processingOption = "nontransitional"
  } = {}) {
    const result = processing(domainName, {
      processingOption,
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules
    });
    return {
      domain: result.string,
      error: result.error
    };
  };
  var punycode = require_punycode();
  var regexes = require_regexes();
  var mappingTable = require_mappingTable();
  var { STATUS_MAPPING } = require_statusMapping();
  module.exports = {
    toASCII,
    toUnicode
  };
});

// node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS((exports, module) => {
  var isASCIIDigit = function(c2) {
    return c2 >= 48 && c2 <= 57;
  };
  var isASCIIAlpha = function(c2) {
    return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
  };
  var isASCIIAlphanumeric = function(c2) {
    return isASCIIAlpha(c2) || isASCIIDigit(c2);
  };
  var isASCIIHex = function(c2) {
    return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
  };
  module.exports = {
    isASCIIDigit,
    isASCIIAlpha,
    isASCIIAlphanumeric,
    isASCIIHex
  };
});

// node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  var utf8Encode = function(string6) {
    return utf8Encoder.encode(string6);
  };
  var utf8DecodeWithoutBOM = function(bytes) {
    return utf8Decoder.decode(bytes);
  };
  var utf8Encoder = new TextEncoder;
  var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
  module.exports = {
    utf8Encode,
    utf8DecodeWithoutBOM
  };
});

// node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS((exports, module) => {
  var p2 = function(char) {
    return char.codePointAt(0);
  };
  var percentEncode = function(c2) {
    let hex = c2.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    return `%${hex}`;
  };
  var percentDecodeBytes = function(input) {
    const output = new Uint8Array(input.byteLength);
    let outputIndex = 0;
    for (let i2 = 0;i2 < input.byteLength; ++i2) {
      const byte = input[i2];
      if (byte !== 37) {
        output[outputIndex++] = byte;
      } else if (byte === 37 && (!isASCIIHex(input[i2 + 1]) || !isASCIIHex(input[i2 + 2]))) {
        output[outputIndex++] = byte;
      } else {
        const bytePoint = parseInt(String.fromCodePoint(input[i2 + 1], input[i2 + 2]), 16);
        output[outputIndex++] = bytePoint;
        i2 += 2;
      }
    }
    return output.slice(0, outputIndex);
  };
  var percentDecodeString = function(input) {
    const bytes = utf8Encode(input);
    return percentDecodeBytes(bytes);
  };
  var isC0ControlPercentEncode = function(c2) {
    return c2 <= 31 || c2 > 126;
  };
  var isFragmentPercentEncode = function(c2) {
    return isC0ControlPercentEncode(c2) || extraFragmentPercentEncodeSet.has(c2);
  };
  var isQueryPercentEncode = function(c2) {
    return isC0ControlPercentEncode(c2) || extraQueryPercentEncodeSet.has(c2);
  };
  var isSpecialQueryPercentEncode = function(c2) {
    return isQueryPercentEncode(c2) || c2 === p2("'");
  };
  var isPathPercentEncode = function(c2) {
    return isQueryPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
  };
  var isUserinfoPercentEncode = function(c2) {
    return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
  };
  var isComponentPercentEncode = function(c2) {
    return isUserinfoPercentEncode(c2) || extraComponentPercentEncodeSet.has(c2);
  };
  var isURLEncodedPercentEncode = function(c2) {
    return isComponentPercentEncode(c2) || extraURLEncodedPercentEncodeSet.has(c2);
  };
  var utf8PercentEncodeCodePointInternal = function(codePoint, percentEncodePredicate) {
    const bytes = utf8Encode(codePoint);
    let output = "";
    for (const byte of bytes) {
      if (!percentEncodePredicate(byte)) {
        output += String.fromCharCode(byte);
      } else {
        output += percentEncode(byte);
      }
    }
    return output;
  };
  var utf8PercentEncodeCodePoint = function(codePoint, percentEncodePredicate) {
    return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
  };
  var utf8PercentEncodeString = function(input, percentEncodePredicate, spaceAsPlus = false) {
    let output = "";
    for (const codePoint of input) {
      if (spaceAsPlus && codePoint === " ") {
        output += "+";
      } else {
        output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
      }
    }
    return output;
  };
  var { isASCIIHex } = require_infra();
  var { utf8Encode } = require_encoding();
  var extraFragmentPercentEncodeSet = new Set([p2(" "), p2("\""), p2("<"), p2(">"), p2("`")]);
  var extraQueryPercentEncodeSet = new Set([p2(" "), p2("\""), p2("#"), p2("<"), p2(">")]);
  var extraPathPercentEncodeSet = new Set([p2("?"), p2("`"), p2("{"), p2("}")]);
  var extraUserinfoPercentEncodeSet = new Set([p2("/"), p2(":"), p2(";"), p2("="), p2("@"), p2("["), p2("\\"), p2("]"), p2("^"), p2("|")]);
  var extraComponentPercentEncodeSet = new Set([p2("$"), p2("%"), p2("&"), p2("+"), p2(",")]);
  var extraURLEncodedPercentEncodeSet = new Set([p2("!"), p2("'"), p2("("), p2(")"), p2("~")]);
  module.exports = {
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode,
    isURLEncodedPercentEncode,
    percentDecodeString,
    percentDecodeBytes,
    utf8PercentEncodeString,
    utf8PercentEncodeCodePoint
  };
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var p2 = function(char) {
    return char.codePointAt(0);
  };
  var countSymbols = function(str) {
    return [...str].length;
  };
  var at = function(input, idx) {
    const c2 = input[idx];
    return isNaN(c2) ? undefined : String.fromCodePoint(c2);
  };
  var isSingleDot = function(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  };
  var isDoubleDot = function(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  };
  var isWindowsDriveLetterCodePoints = function(cp1, cp2) {
    return infra.isASCIIAlpha(cp1) && (cp2 === p2(":") || cp2 === p2("|"));
  };
  var isWindowsDriveLetterString = function(string6) {
    return string6.length === 2 && infra.isASCIIAlpha(string6.codePointAt(0)) && (string6[1] === ":" || string6[1] === "|");
  };
  var isNormalizedWindowsDriveLetterString = function(string6) {
    return string6.length === 2 && infra.isASCIIAlpha(string6.codePointAt(0)) && string6[1] === ":";
  };
  var containsForbiddenHostCodePoint = function(string6) {
    return string6.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
  };
  var containsForbiddenDomainCodePoint = function(string6) {
    return containsForbiddenHostCodePoint(string6) || string6.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
  };
  var isSpecialScheme = function(scheme) {
    return specialSchemes[scheme] !== undefined;
  };
  var isSpecial = function(url) {
    return isSpecialScheme(url.scheme);
  };
  var isNotSpecial = function(url) {
    return !isSpecialScheme(url.scheme);
  };
  var defaultPort = function(scheme) {
    return specialSchemes[scheme];
  };
  var parseIPv4Number = function(input) {
    if (input === "") {
      return failure;
    }
    let R2 = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R2 = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R2 = 8;
    }
    if (input === "") {
      return 0;
    }
    let regex = /[^0-7]/u;
    if (R2 === 10) {
      regex = /[^0-9]/u;
    }
    if (R2 === 16) {
      regex = /[^0-9A-Fa-f]/u;
    }
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R2);
  };
  var parseIPv4 = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return failure;
    }
    const numbers = [];
    for (const part of parts) {
      const n2 = parseIPv4Number(part);
      if (n2 === failure) {
        return failure;
      }
      numbers.push(n2);
    }
    for (let i2 = 0;i2 < numbers.length - 1; ++i2) {
      if (numbers[i2] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n2 of numbers) {
      ipv4 += n2 * 256 ** (3 - counter);
      ++counter;
    }
    return ipv4;
  };
  var serializeIPv4 = function(address) {
    let output = "";
    let n2 = address;
    for (let i2 = 1;i2 <= 4; ++i2) {
      output = String(n2 % 256) + output;
      if (i2 !== 4) {
        output = `.${output}`;
      }
      n2 = Math.floor(n2 / 256);
    }
    return output;
  };
  var parseIPv6 = function(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer3 = 0;
    input = Array.from(input, (c2) => c2.codePointAt(0));
    if (input[pointer3] === p2(":")) {
      if (input[pointer3 + 1] !== p2(":")) {
        return failure;
      }
      pointer3 += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer3 < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer3] === p2(":")) {
        if (compress !== null) {
          return failure;
        }
        ++pointer3;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value14 = 0;
      let length = 0;
      while (length < 4 && infra.isASCIIHex(input[pointer3])) {
        value14 = value14 * 16 + parseInt(at(input, pointer3), 16);
        ++pointer3;
        ++length;
      }
      if (input[pointer3] === p2(".")) {
        if (length === 0) {
          return failure;
        }
        pointer3 -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer3] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer3] === p2(".") && numbersSeen < 4) {
              ++pointer3;
            } else {
              return failure;
            }
          }
          if (!infra.isASCIIDigit(input[pointer3])) {
            return failure;
          }
          while (infra.isASCIIDigit(input[pointer3])) {
            const number6 = parseInt(at(input, pointer3));
            if (ipv4Piece === null) {
              ipv4Piece = number6;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number6;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer3;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer3] === p2(":")) {
        ++pointer3;
        if (input[pointer3] === undefined) {
          return failure;
        }
      } else if (input[pointer3] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value14;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  };
  var serializeIPv6 = function(address) {
    let output = "";
    const compress = findLongestZeroSequence(address);
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  };
  var parseHost = function(input, isNotSpecialArg = false) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (isNotSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === failure) {
      return failure;
    }
    if (containsForbiddenDomainCodePoint(asciiDomain)) {
      return failure;
    }
    if (endsInANumber(asciiDomain)) {
      return parseIPv4(asciiDomain);
    }
    return asciiDomain;
  };
  var endsInANumber = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length === 1) {
        return false;
      }
      parts.pop();
    }
    const last = parts[parts.length - 1];
    if (parseIPv4Number(last) !== failure) {
      return true;
    }
    if (/^[0-9]+$/u.test(last)) {
      return true;
    }
    return false;
  };
  var parseOpaqueHost = function(input) {
    if (containsForbiddenHostCodePoint(input)) {
      return failure;
    }
    return utf8PercentEncodeString(input, isC0ControlPercentEncode);
  };
  var findLongestZeroSequence = function(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i2 = 0;i2 < arr.length; ++i2) {
      if (arr[i2] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i2;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      return currStart;
    }
    return maxIdx;
  };
  var serializeHost = function(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return `[${serializeIPv6(host)}]`;
    }
    return host;
  };
  var domainToASCII = function(domain, beStrict = false) {
    const result = tr46.toASCII(domain, {
      checkBidi: true,
      checkHyphens: false,
      checkJoiners: true,
      useSTD3ASCIIRules: beStrict,
      verifyDNSLength: beStrict
    });
    if (result === null || result === "") {
      return failure;
    }
    return result;
  };
  var trimControlChars = function(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/ug, "");
  };
  var trimTabAndNewline = function(url) {
    return url.replace(/\u0009|\u000A|\u000D/ug, "");
  };
  var shortenPath = function(url) {
    const { path } = url;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  };
  var includesCredentials = function(url) {
    return url.username !== "" || url.password !== "";
  };
  var cannotHaveAUsernamePasswordPort = function(url) {
    return url.host === null || url.host === "" || url.scheme === "file";
  };
  var hasAnOpaquePath = function(url) {
    return typeof url.path === "string";
  };
  var isNormalizedWindowsDriveLetter = function(string6) {
    return /^[A-Za-z]:$/u.test(string6);
  };
  var URLStateMachine = function(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(this.input, (c2) => c2.codePointAt(0));
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c2 = this.input[this.pointer];
      const cStr = isNaN(c2) ? undefined : String.fromCodePoint(c2);
      const ret = this[`parse ${this.state}`](c2, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  };
  var startsWithWindowsDriveLetter = function(input, pointer3) {
    const length = input.length - pointer3;
    return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer3], input[pointer3 + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer3 + 2]));
  };
  var serializeURL = function(url, excludeFragment) {
    let output = `${url.scheme}:`;
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += `:${url.password}`;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += `:${url.port}`;
      }
    }
    if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
      output += "/.";
    }
    output += serializePath(url);
    if (url.query !== null) {
      output += `?${url.query}`;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += `#${url.fragment}`;
    }
    return output;
  };
  var serializeOrigin = function(tuple7) {
    let result = `${tuple7.scheme}://`;
    result += serializeHost(tuple7.host);
    if (tuple7.port !== null) {
      result += `:${tuple7.port}`;
    }
    return result;
  };
  var serializePath = function(url) {
    if (hasAnOpaquePath(url)) {
      return url.path;
    }
    let output = "";
    for (const segment of url.path) {
      output += `/${segment}`;
    }
    return output;
  };
  var tr46 = require_tr46();
  var infra = require_infra();
  var { utf8DecodeWithoutBOM } = require_encoding();
  var {
    percentDecodeString,
    utf8PercentEncodeCodePoint,
    utf8PercentEncodeString,
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode
  } = require_percent_encoding();
  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
    if (infra.isASCIIAlpha(c2)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
    if (infra.isASCIIAlphanumeric(c2) || c2 === p2("+") || c2 === p2("-") || c2 === p2(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c2 === p2(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p2("/") || this.input[this.pointer + 2] !== p2("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p2("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = "";
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
    if (this.base === null || hasAnOpaquePath(this.base) && c2 !== p2("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c2 === p2("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
    if (c2 === p2("/") && this.input[this.pointer + 1] === p2("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
    if (c2 === p2("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
    this.url.scheme = this.base.scheme;
    if (c2 === p2("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c2 === p2("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c2 === p2("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c2)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
    if (isSpecial(this.url) && (c2 === p2("/") || c2 === p2("\\"))) {
      if (c2 === p2("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c2 === p2("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
    if (c2 === p2("/") && this.input[this.pointer + 1] === p2("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
    if (c2 !== p2("/") && c2 !== p2("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
    if (c2 === p2("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = `%40${this.buffer}`;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer3 = 0;pointer3 < len; ++pointer3) {
        const codePoint = this.buffer.codePointAt(pointer3);
        if (codePoint === p2(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c2) || c2 === p2("/") || c2 === p2("?") || c2 === p2("#") || isSpecial(this.url) && c2 === p2("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c2 === p2(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c2) || c2 === p2("/") || c2 === p2("?") || c2 === p2("#") || isSpecial(this.url) && c2 === p2("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c2 === p2("[")) {
        this.arrFlag = true;
      } else if (c2 === p2("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
    if (infra.isASCIIDigit(c2)) {
      this.buffer += cStr;
    } else if (isNaN(c2) || c2 === p2("/") || c2 === p2("?") || c2 === p2("#") || isSpecial(this.url) && c2 === p2("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > 2 ** 16 - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([p2("/"), p2("\\"), p2("?"), p2("#")]);
  URLStateMachine.prototype["parse file"] = function parseFile(c2) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c2 === p2("/") || c2 === p2("\\")) {
      if (c2 === p2("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c2 === p2("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c2)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
    if (c2 === p2("/") || c2 === p2("\\")) {
      if (c2 === p2("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
    if (isNaN(c2) || c2 === p2("/") || c2 === p2("\\") || c2 === p2("?") || c2 === p2("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
    if (isSpecial(this.url)) {
      if (c2 === p2("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c2 !== p2("/") && c2 !== p2("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c2 === p2("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c2 === p2("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c2 !== undefined) {
      this.state = "path";
      if (c2 !== p2("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c2) {
    if (isNaN(c2) || c2 === p2("/") || isSpecial(this.url) && c2 === p2("\\") || !this.stateOverride && (c2 === p2("?") || c2 === p2("#"))) {
      if (isSpecial(this.url) && c2 === p2("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c2 !== p2("/") && !(isSpecial(this.url) && c2 === p2("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c2 !== p2("/") && !(isSpecial(this.url) && c2 === p2("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = `${this.buffer[0]}:`;
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c2 === p2("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c2 === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c2 === p2("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint(c2, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c2) {
    if (c2 === p2("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c2 === p2("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c2) && c2 !== p2("%")) {
        this.parseError = true;
      }
      if (c2 === p2("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c2)) {
        this.url.path += utf8PercentEncodeCodePoint(c2, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c2 === p2("#") || isNaN(c2)) {
      const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
      this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c2 === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c2)) {
      if (c2 === p2("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
    if (!isNaN(c2)) {
      if (c2 === p2("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint(c2, isFragmentPercentEncode);
    }
    return true;
  };
  exports.serializeURL = serializeURL;
  exports.serializePath = serializePath;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob": {
        const pathURL = exports.parseURL(serializePath(url));
        if (pathURL === null) {
          return "null";
        }
        if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
          return "null";
        }
        return exports.serializeURLOrigin(pathURL);
      }
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "null";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return null;
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
  };
  exports.setThePassword = function(url, password) {
    url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = hasAnOpaquePath;
  exports.serializeInteger = function(integer3) {
    return String(integer3);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var p2 = function(char) {
    return char.codePointAt(0);
  };
  var parseUrlencoded = function(input) {
    const sequences = strictlySplitByteSequence(input, p2("&"));
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0) {
        continue;
      }
      let name, value14;
      const indexOfEqual = bytes.indexOf(p2("="));
      if (indexOfEqual >= 0) {
        name = bytes.slice(0, indexOfEqual);
        value14 = bytes.slice(indexOfEqual + 1);
      } else {
        name = bytes;
        value14 = new Uint8Array(0);
      }
      name = replaceByteInByteSequence(name, 43, 32);
      value14 = replaceByteInByteSequence(value14, 43, 32);
      const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
      const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value14));
      output.push([nameString, valueString]);
    }
    return output;
  };
  var parseUrlencodedString = function(input) {
    return parseUrlencoded(utf8Encode(input));
  };
  var serializeUrlencoded = function(tuples, encodingOverride = undefined) {
    let encoding = "utf-8";
    if (encodingOverride !== undefined) {
      encoding = encodingOverride;
    }
    let output = "";
    for (const [i2, tuple7] of tuples.entries()) {
      const name = utf8PercentEncodeString(tuple7[0], isURLEncodedPercentEncode, true);
      let value14 = tuple7[1];
      if (tuple7.length > 2 && tuple7[2] !== undefined) {
        if (tuple7[2] === "hidden" && name === "_charset_") {
          value14 = encoding;
        } else if (tuple7[2] === "file") {
          value14 = value14.name;
        }
      }
      value14 = utf8PercentEncodeString(value14, isURLEncodedPercentEncode, true);
      if (i2 !== 0) {
        output += "&";
      }
      output += `${name}=${value14}`;
    }
    return output;
  };
  var strictlySplitByteSequence = function(buf, cp) {
    const list = [];
    let last = 0;
    let i2 = buf.indexOf(cp);
    while (i2 >= 0) {
      list.push(buf.slice(last, i2));
      last = i2 + 1;
      i2 = buf.indexOf(cp, last);
    }
    if (last !== buf.length) {
      list.push(buf.slice(last));
    }
    return list;
  };
  var replaceByteInByteSequence = function(buf, from, to) {
    let i2 = buf.indexOf(from);
    while (i2 >= 0) {
      buf[i2] = to;
      i2 = buf.indexOf(from, i2 + 1);
    }
    return buf;
  };
  var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
  var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
  module.exports = {
    parseUrlencodedString,
    serializeUrlencoded
  };
});

// node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS((exports) => {
  var conversions = require_lib();
  var utils = require_utils2();
  exports.convert = (globalObject, value14, { context = "The provided value" } = {}) => {
    if (typeof value14 !== "function") {
      throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(...args) {
      const thisArg = utils.tryWrapperForImpl(this);
      let callResult;
      for (let i2 = 0;i2 < args.length; i2++) {
        args[i2] = utils.tryWrapperForImpl(args[i2]);
      }
      callResult = Reflect.apply(value14, thisArg, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    }
    invokeTheCallbackFunction.construct = (...args) => {
      for (let i2 = 0;i2 < args.length; i2++) {
        args[i2] = utils.tryWrapperForImpl(args[i2]);
      }
      let callResult = Reflect.construct(value14, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value14;
    invokeTheCallbackFunction.objectReference = value14;
    return invokeTheCallbackFunction;
  };
});

// node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS((exports) => {
  var urlencoded = require_urlencoded();
  exports.implementation = class URLSearchParamsImpl {
    constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
      let init = constructorArgs[0];
      this._list = [];
      this._url = null;
      if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
        init = init.slice(1);
      }
      if (Array.isArray(init)) {
        for (const pair of init) {
          if (pair.length !== 2) {
            throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
          }
          this._list.push([pair[0], pair[1]]);
        }
      } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
        for (const name of Object.keys(init)) {
          const value14 = init[name];
          this._list.push([name, value14]);
        }
      } else {
        this._list = urlencoded.parseUrlencodedString(init);
      }
    }
    _updateSteps() {
      if (this._url !== null) {
        let serializedQuery = urlencoded.serializeUrlencoded(this._list);
        if (serializedQuery === "") {
          serializedQuery = null;
        }
        this._url._url.query = serializedQuery;
        if (serializedQuery === null) {
          this._url._potentiallyStripTrailingSpacesFromAnOpaquePath();
        }
      }
    }
    get size() {
      return this._list.length;
    }
    append(name, value14) {
      this._list.push([name, value14]);
      this._updateSteps();
    }
    delete(name, value14) {
      let i2 = 0;
      while (i2 < this._list.length) {
        if (this._list[i2][0] === name && (value14 === undefined || this._list[i2][1] === value14)) {
          this._list.splice(i2, 1);
        } else {
          i2++;
        }
      }
      this._updateSteps();
    }
    get(name) {
      for (const tuple7 of this._list) {
        if (tuple7[0] === name) {
          return tuple7[1];
        }
      }
      return null;
    }
    getAll(name) {
      const output = [];
      for (const tuple7 of this._list) {
        if (tuple7[0] === name) {
          output.push(tuple7[1]);
        }
      }
      return output;
    }
    has(name, value14) {
      for (const tuple7 of this._list) {
        if (tuple7[0] === name && (value14 === undefined || tuple7[1] === value14)) {
          return true;
        }
      }
      return false;
    }
    set(name, value14) {
      let found = false;
      let i2 = 0;
      while (i2 < this._list.length) {
        if (this._list[i2][0] === name) {
          if (found) {
            this._list.splice(i2, 1);
          } else {
            found = true;
            this._list[i2][1] = value14;
            i2++;
          }
        } else {
          i2++;
        }
      }
      if (!found) {
        this._list.push([name, value14]);
      }
      this._updateSteps();
    }
    sort() {
      this._list.sort((a2, b2) => {
        if (a2[0] < b2[0]) {
          return -1;
        }
        if (a2[0] > b2[0]) {
          return 1;
        }
        return 0;
      });
      this._updateSteps();
    }
    [Symbol.iterator]() {
      return this._list[Symbol.iterator]();
    }
    toString() {
      return urlencoded.serializeUrlencoded(this._list);
    }
  };
});

// node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var makeWrapper = function(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
    }
    return Object.create(proto);
  };
  var conversions = require_lib();
  var utils = require_utils2();
  var Function3 = require_Function();
  var newObjectInRealm = utils.newObjectInRealm;
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URLSearchParams";
  exports.is = (value14) => {
    return utils.isObject(value14) && utils.hasOwn(value14, implSymbol) && value14[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value14) => {
    return utils.isObject(value14) && value14 instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value14, { context = "The provided value" } = {}) => {
    if (exports.is(value14)) {
      return utils.implForWrapper(value14);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
  };
  exports.createDefaultIterator = (globalObject, target, kind) => {
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
    const iterator4 = Object.create(iteratorPrototype);
    Object.defineProperty(iterator4, utils.iterInternalSymbol, {
      value: { target, kind, index: 0 },
      configurable: true
    });
    return iterator4;
  };
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URLSearchParams {
      constructor() {
        const args = [];
        {
          let curArg = arguments[0];
          if (curArg !== undefined) {
            if (utils.isObject(curArg)) {
              if (curArg[Symbol.iterator] !== undefined) {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object.");
                } else {
                  const V = [];
                  const tmp = curArg;
                  for (let nextItem of tmp) {
                    if (!utils.isObject(nextItem)) {
                      throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object.");
                    } else {
                      const V2 = [];
                      const tmp2 = nextItem;
                      for (let nextItem2 of tmp2) {
                        nextItem2 = conversions["USVString"](nextItem2, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                          globals: globalObject
                        });
                        V2.push(nextItem2);
                      }
                      nextItem = V2;
                    }
                    V.push(nextItem);
                  }
                  curArg = V;
                }
              } else {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1 record is not an object.");
                } else {
                  const result = Object.create(null);
                  for (const key of Reflect.ownKeys(curArg)) {
                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                    if (desc && desc.enumerable) {
                      let typedKey = key;
                      typedKey = conversions["USVString"](typedKey, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                        globals: globalObject
                      });
                      let typedValue = curArg[key];
                      typedValue = conversions["USVString"](typedValue, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                        globals: globalObject
                      });
                      result[typedKey] = typedValue;
                    }
                  }
                  curArg = result;
                }
              }
            } else {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URLSearchParams': parameter 1",
                globals: globalObject
              });
            }
          } else {
            curArg = "";
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      append(name, value14) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'append' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
      }
      delete(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'delete' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
      }
      get(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return esValue[implSymbol].get(...args);
      }
      getAll(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'getAll' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
      }
      has(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return esValue[implSymbol].has(...args);
      }
      set(name, value14) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
      }
      sort() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].sort());
      }
      toString() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol].toString();
      }
      keys() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key");
      }
      values() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'values' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "value");
      }
      entries() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'entries' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key+value");
      }
      forEach(callback) {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'forEach' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
        }
        callback = Function3.convert(globalObject, callback, {
          context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
        });
        const thisArg = arguments[1];
        let pairs = Array.from(this[implSymbol]);
        let i2 = 0;
        while (i2 < pairs.length) {
          const [key, value14] = pairs[i2].map(utils.tryWrapperForImpl);
          callback.call(thisArg, value14, key, this);
          pairs = Array.from(this[implSymbol]);
          i2++;
        }
      }
      get size() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol]["size"];
      }
    }
    Object.defineProperties(URLSearchParams.prototype, {
      append: { enumerable: true },
      delete: { enumerable: true },
      get: { enumerable: true },
      getAll: { enumerable: true },
      has: { enumerable: true },
      set: { enumerable: true },
      sort: { enumerable: true },
      toString: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
      forEach: { enumerable: true },
      size: { enumerable: true },
      [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
      [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
    });
    ctorRegistry[interfaceName] = URLSearchParams;
    ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
      [Symbol.toStringTag]: {
        configurable: true,
        value: "URLSearchParams Iterator"
      }
    });
    utils.define(ctorRegistry["URLSearchParams Iterator"], {
      next() {
        const internal = this && this[utils.iterInternalSymbol];
        if (!internal) {
          throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
        }
        const { target, kind, index } = internal;
        const values = Array.from(target[implSymbol]);
        const len = values.length;
        if (index >= len) {
          return newObjectInRealm(globalObject, { value: undefined, done: true });
        }
        const pair = values[index];
        internal.index = index + 1;
        return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
      }
    });
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URLSearchParams
    });
  };
  var Impl = require_URLSearchParams_impl();
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  var urlencoded = require_urlencoded();
  var URLSearchParams = require_URLSearchParams();
  exports.implementation = class URLImpl {
    constructor(globalObject, constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          throw new TypeError(`Invalid base URL: ${base}`);
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      const query = parsedURL.query !== null ? parsedURL.query : "";
      this._url = parsedURL;
      this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
      this._query._url = this;
    }
    static canParse(url, base) {
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          return false;
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        return false;
      }
      return true;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v2) {
      const parsedURL = usm.basicURLParse(v2);
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${v2}`);
      }
      this._url = parsedURL;
      this._query._list.splice(0);
      const { query } = parsedURL;
      if (query !== null) {
        this._query._list = urlencoded.parseUrlencodedString(query);
      }
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return `${this._url.scheme}:`;
    }
    set protocol(v2) {
      usm.basicURLParse(`${v2}:`, { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v2);
    }
    get password() {
      return this._url.password;
    }
    set password(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v2);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
    }
    set host(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v2 === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      return usm.serializePath(this._url);
    }
    set pathname(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return `?${this._url.query}`;
    }
    set search(v2) {
      const url = this._url;
      if (v2 === "") {
        url.query = null;
        this._query._list = [];
        this._potentiallyStripTrailingSpacesFromAnOpaquePath();
        return;
      }
      const input = v2[0] === "?" ? v2.substring(1) : v2;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
      this._query._list = urlencoded.parseUrlencodedString(input);
    }
    get searchParams() {
      return this._query;
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return `#${this._url.fragment}`;
    }
    set hash(v2) {
      if (v2 === "") {
        this._url.fragment = null;
        this._potentiallyStripTrailingSpacesFromAnOpaquePath();
        return;
      }
      const input = v2[0] === "#" ? v2.substring(1) : v2;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
    _potentiallyStripTrailingSpacesFromAnOpaquePath() {
      if (!usm.hasAnOpaquePath(this._url)) {
        return;
      }
      if (this._url.fragment !== null) {
        return;
      }
      if (this._url.query !== null) {
        return;
      }
      this._url.path = this._url.path.replace(/\u0020+$/u, "");
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports) => {
  var makeWrapper = function(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
    }
    return Object.create(proto);
  };
  var conversions = require_lib();
  var utils = require_utils2();
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URL";
  exports.is = (value14) => {
    return utils.isObject(value14) && utils.hasOwn(value14, implSymbol) && value14[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value14) => {
    return utils.isObject(value14) && value14 instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value14, { context = "The provided value" } = {}) => {
    if (exports.is(value14)) {
      return utils.implForWrapper(value14);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
  };
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URL2 {
      constructor(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to construct 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      toJSON() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol].toJSON();
      }
      get href() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      set href(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'href' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["href"] = V;
      }
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      get origin() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["origin"];
      }
      get protocol() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["protocol"];
      }
      set protocol(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'protocol' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["protocol"] = V;
      }
      get username() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["username"];
      }
      set username(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'username' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["username"] = V;
      }
      get password() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["password"];
      }
      set password(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'password' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["password"] = V;
      }
      get host() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["host"];
      }
      set host(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'host' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["host"] = V;
      }
      get hostname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hostname"];
      }
      set hostname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hostname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hostname"] = V;
      }
      get port() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["port"];
      }
      set port(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'port' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["port"] = V;
      }
      get pathname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["pathname"];
      }
      set pathname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'pathname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["pathname"] = V;
      }
      get search() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["search"];
      }
      set search(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'search' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["search"] = V;
      }
      get searchParams() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
        }
        return utils.getSameObject(this, "searchParams", () => {
          return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
        });
      }
      get hash() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hash"];
      }
      set hash(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hash' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hash"] = V;
      }
      static canParse(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'canParse' on 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return Impl.implementation.canParse(...args);
      }
    }
    Object.defineProperties(URL2.prototype, {
      toJSON: { enumerable: true },
      href: { enumerable: true },
      toString: { enumerable: true },
      origin: { enumerable: true },
      protocol: { enumerable: true },
      username: { enumerable: true },
      password: { enumerable: true },
      host: { enumerable: true },
      hostname: { enumerable: true },
      port: { enumerable: true },
      pathname: { enumerable: true },
      search: { enumerable: true },
      searchParams: { enumerable: true },
      hash: { enumerable: true },
      [Symbol.toStringTag]: { value: "URL", configurable: true }
    });
    Object.defineProperties(URL2, { canParse: { enumerable: true } });
    ctorRegistry[interfaceName] = URL2;
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URL2
    });
    if (globalNames.includes("Window")) {
      Object.defineProperty(globalObject, "webkitURL", {
        configurable: true,
        writable: true,
        value: URL2
      });
    }
  };
  var Impl = require_URL_impl();
});

// node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS((exports) => {
  var URL2 = require_URL();
  var URLSearchParams = require_URLSearchParams();
  exports.URL = URL2;
  exports.URLSearchParams = URLSearchParams;
});

// node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS((exports) => {
  var { URL: URL2, URLSearchParams } = require_webidl2js_wrapper();
  var urlStateMachine = require_url_state_machine();
  var percentEncoding = require_percent_encoding();
  var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
  URL2.install(sharedGlobalObject, ["Window"]);
  URLSearchParams.install(sharedGlobalObject, ["Window"]);
  exports.URL = sharedGlobalObject.URL;
  exports.URLSearchParams = sharedGlobalObject.URLSearchParams;
  exports.parseURL = urlStateMachine.parseURL;
  exports.basicURLParse = urlStateMachine.basicURLParse;
  exports.serializeURL = urlStateMachine.serializeURL;
  exports.serializePath = urlStateMachine.serializePath;
  exports.serializeHost = urlStateMachine.serializeHost;
  exports.serializeInteger = urlStateMachine.serializeInteger;
  exports.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
  exports.setTheUsername = urlStateMachine.setTheUsername;
  exports.setThePassword = urlStateMachine.setThePassword;
  exports.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
  exports.percentDecodeString = percentEncoding.percentDecodeString;
  exports.percentDecodeBytes = percentEncoding.percentDecodeBytes;
});

// node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS((exports) => {
  var redactValidConnectionString = function(inputUrl, options) {
    var _a, _b;
    const url = inputUrl.clone();
    const replacementString = (_a = options === null || options === undefined ? undefined : options.replacementString) !== null && _a !== undefined ? _a : "_credentials_";
    const redactUsernames = (_b = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b !== undefined ? _b : true;
    if ((url.username || url.password) && redactUsernames) {
      url.username = replacementString;
      url.password = "";
    } else if (url.password) {
      url.password = replacementString;
    }
    if (url.searchParams.has("authMechanismProperties")) {
      const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get("authMechanismProperties"));
      if (props.get("AWS_SESSION_TOKEN")) {
        props.set("AWS_SESSION_TOKEN", replacementString);
        url.searchParams.set("authMechanismProperties", props.toString());
      }
    }
    if (url.searchParams.has("tlsCertificateKeyFilePassword")) {
      url.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
    }
    if (url.searchParams.has("proxyUsername") && redactUsernames) {
      url.searchParams.set("proxyUsername", replacementString);
    }
    if (url.searchParams.has("proxyPassword")) {
      url.searchParams.set("proxyPassword", replacementString);
    }
    return url;
  };
  var redactConnectionString = function(uri, options) {
    var _a, _b;
    const replacementString = (_a = options === null || options === undefined ? undefined : options.replacementString) !== null && _a !== undefined ? _a : "<credentials>";
    const redactUsernames = (_b = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b !== undefined ? _b : true;
    let parsed;
    try {
      parsed = new index_1.default(uri);
    } catch (_c) {
    }
    if (parsed) {
      options = { ...options, replacementString: "___credentials___" };
      return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
    }
    const R2 = replacementString;
    const replacements = [
      (uri2) => uri2.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `\$1${R2}\$3`),
      (uri2) => uri2.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `\$1${R2}`),
      (uri2) => uri2.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `\$1${R2}`),
      (uri2) => redactUsernames ? uri2.replace(/(proxyUsername=)([^&]+)/gi, `\$1${R2}`) : uri2,
      (uri2) => uri2.replace(/(proxyPassword=)([^&]+)/gi, `\$1${R2}`)
    ];
    for (const replacer of replacements) {
      uri = replacer(uri);
    }
    return uri;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redactConnectionString = exports.redactValidConnectionString = undefined;
  var index_1 = __importStar(require_lib2());
  exports.redactValidConnectionString = redactValidConnectionString;
  exports.redactConnectionString = redactConnectionString;
});

// node_modules/mongodb-connection-string-url/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var connectionStringHasValidScheme = function(connectionString) {
    return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
  };
  var caseInsenstiveURLSearchParams = function(Ctor) {
    return class CaseInsenstiveURLSearchParams extends Ctor {
      append(name, value14) {
        return super.append(this._normalizeKey(name), value14);
      }
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      getAll(name) {
        return super.getAll(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value14) {
        return super.set(this._normalizeKey(name), value14);
      }
      keys() {
        return super.keys();
      }
      values() {
        return super.values();
      }
      entries() {
        return super.entries();
      }
      [Symbol.iterator]() {
        return super[Symbol.iterator]();
      }
      _normalizeKey(name) {
        return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = undefined;
  var whatwg_url_1 = require_whatwg_url();
  var redact_1 = require_redact();
  Object.defineProperty(exports, "redactConnectionString", { enumerable: true, get: function() {
    return redact_1.redactConnectionString;
  } });
  var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
  var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;

  class CaseInsensitiveMap extends Map {
    delete(name) {
      return super.delete(this._normalizeKey(name));
    }
    get(name) {
      return super.get(this._normalizeKey(name));
    }
    has(name) {
      return super.has(this._normalizeKey(name));
    }
    set(name, value14) {
      return super.set(this._normalizeKey(name), value14);
    }
    _normalizeKey(name) {
      name = `${name}`;
      for (const key of this.keys()) {
        if (key.toLowerCase() === name.toLowerCase()) {
          name = key;
          break;
        }
      }
      return name;
    }
  }

  class URLWithoutHost extends whatwg_url_1.URL {
  }

  class MongoParseError extends Error {
    get name() {
      return "MongoParseError";
    }
  }

  class ConnectionString extends URLWithoutHost {
    constructor(uri, options = {}) {
      var _a;
      const { looseValidation } = options;
      if (!looseValidation && !connectionStringHasValidScheme(uri)) {
        throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
      }
      const match = uri.match(HOSTS_REGEX);
      if (!match) {
        throw new MongoParseError(`Invalid connection string "${uri}"`);
      }
      const { protocol, username, password, hosts, rest: rest3 } = (_a = match.groups) !== null && _a !== undefined ? _a : {};
      if (!looseValidation) {
        if (!protocol || !hosts) {
          throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
        }
        try {
          decodeURIComponent(username !== null && username !== undefined ? username : "");
          decodeURIComponent(password !== null && password !== undefined ? password : "");
        } catch (err) {
          throw new MongoParseError(err.message);
        }
        const illegalCharacters = /[:/?#[\]@]/gi;
        if (username === null || username === undefined ? undefined : username.match(illegalCharacters)) {
          throw new MongoParseError(`Username contains unescaped characters ${username}`);
        }
        if (!username || !password) {
          const uriWithoutProtocol = uri.replace(`${protocol}://`, "");
          if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
            throw new MongoParseError("URI contained empty userinfo section");
          }
        }
        if (password === null || password === undefined ? undefined : password.match(illegalCharacters)) {
          throw new MongoParseError("Password contains unescaped characters");
        }
      }
      let authString = "";
      if (typeof username === "string")
        authString += username;
      if (typeof password === "string")
        authString += `:${password}`;
      if (authString)
        authString += "@";
      try {
        super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest3}`);
      } catch (err) {
        if (looseValidation) {
          new ConnectionString(uri, {
            ...options,
            looseValidation: false
          });
        }
        if (typeof err.message === "string") {
          err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
        }
        throw err;
      }
      this._hosts = hosts.split(",");
      if (!looseValidation) {
        if (this.isSRV && this.hosts.length !== 1) {
          throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
        }
        if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
          throw new MongoParseError("mongodb+srv URI cannot have port number");
        }
      }
      if (!this.pathname) {
        this.pathname = "/";
      }
      Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
    }
    get host() {
      return DUMMY_HOSTNAME;
    }
    set host(_ignored) {
      throw new Error("No single host for connection string");
    }
    get hostname() {
      return DUMMY_HOSTNAME;
    }
    set hostname(_ignored) {
      throw new Error("No single host for connection string");
    }
    get port() {
      return "";
    }
    set port(_ignored) {
      throw new Error("No single host for connection string");
    }
    get href() {
      return this.toString();
    }
    set href(_ignored) {
      throw new Error("Cannot set href for connection strings");
    }
    get isSRV() {
      return this.protocol.includes("srv");
    }
    get hosts() {
      return this._hosts;
    }
    set hosts(list) {
      this._hosts = list;
    }
    toString() {
      return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
    }
    clone() {
      return new ConnectionString(this.toString(), {
        looseValidation: true
      });
    }
    redact(options) {
      return (0, redact_1.redactValidConnectionString)(this, options);
    }
    typedSearchParams() {
      const sametype = false;
      return this.searchParams;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash: hash6 } = this;
      return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash: hash6 };
    }
  }
  exports.ConnectionString = ConnectionString;

  class CommaAndColonSeparatedRecord extends CaseInsensitiveMap {
    constructor(from) {
      super();
      for (const entry of (from !== null && from !== undefined ? from : "").split(",")) {
        if (!entry)
          continue;
        const colonIndex = entry.indexOf(":");
        if (colonIndex === -1) {
          this.set(entry, "");
        } else {
          this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
        }
      }
    }
    toString() {
      return [...this].map((entry) => entry.join(":")).join(",");
    }
  }
  exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
  exports.default = ConnectionString;
});

// node_modules/mongodb/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "mongodb",
    version: "6.3.0",
    description: "The official MongoDB driver for Node.js",
    main: "lib/index.js",
    files: [
      "lib",
      "src",
      "etc/prepare.js",
      "mongodb.d.ts",
      "tsconfig.json"
    ],
    types: "mongodb.d.ts",
    repository: {
      type: "git",
      url: "git@github.com:mongodb/node-mongodb-native.git"
    },
    keywords: [
      "mongodb",
      "driver",
      "official"
    ],
    author: {
      name: "The MongoDB NodeJS Team",
      email: "dbx-node@mongodb.com"
    },
    dependencies: {
      "@mongodb-js/saslprep": "^1.1.0",
      bson: "^6.2.0",
      "mongodb-connection-string-url": "^3.0.0"
    },
    peerDependencies: {
      "@aws-sdk/credential-providers": "^3.188.0",
      "@mongodb-js/zstd": "^1.1.0",
      "gcp-metadata": "^5.2.0",
      kerberos: "^2.0.1",
      "mongodb-client-encryption": ">=6.0.0 <7",
      snappy: "^7.2.2",
      socks: "^2.7.1"
    },
    peerDependenciesMeta: {
      "@aws-sdk/credential-providers": {
        optional: true
      },
      "@mongodb-js/zstd": {
        optional: true
      },
      kerberos: {
        optional: true
      },
      snappy: {
        optional: true
      },
      "mongodb-client-encryption": {
        optional: true
      },
      "gcp-metadata": {
        optional: true
      },
      socks: {
        optional: true
      }
    },
    devDependencies: {
      "@iarna/toml": "^2.2.5",
      "@istanbuljs/nyc-config-typescript": "^1.0.2",
      "@microsoft/api-extractor": "^7.36.4",
      "@microsoft/tsdoc-config": "^0.16.2",
      "@mongodb-js/zstd": "^1.1.0",
      "@octokit/core": "^4.2.4",
      "@types/chai": "^4.3.5",
      "@types/chai-subset": "^1.3.3",
      "@types/express": "^4.17.17",
      "@types/kerberos": "^1.1.2",
      "@types/mocha": "^10.0.1",
      "@types/node": "^20.5.9",
      "@types/saslprep": "^1.0.1",
      "@types/semver": "^7.5.0",
      "@types/sinon": "^10.0.16",
      "@types/sinon-chai": "^3.2.9",
      "@types/whatwg-url": "^11.0.0",
      "@typescript-eslint/eslint-plugin": "^5.62.0",
      "@typescript-eslint/parser": "^5.62.0",
      chai: "^4.3.7",
      "chai-subset": "^1.6.0",
      chalk: "^4.1.2",
      eslint: "^8.48.0",
      "eslint-config-prettier": "^8.10.0",
      "eslint-plugin-import": "^2.28.1",
      "eslint-plugin-prettier": "^4.2.1",
      "eslint-plugin-simple-import-sort": "^10.0.0",
      "eslint-plugin-tsdoc": "^0.2.17",
      "eslint-plugin-unused-imports": "^2.0.0",
      express: "^4.18.2",
      "gcp-metadata": "^5.2.0",
      "js-yaml": "^4.1.0",
      mocha: "^10.2.0",
      "mocha-sinon": "^2.1.2",
      "mongodb-client-encryption": "^6.0.0",
      "mongodb-legacy": "^6.0.0",
      nyc: "^15.1.0",
      prettier: "^2.8.8",
      semver: "^7.5.4",
      sinon: "^15.2.0",
      "sinon-chai": "^3.7.0",
      snappy: "^7.2.2",
      socks: "^2.7.1",
      "source-map-support": "^0.5.21",
      "ts-node": "^10.9.1",
      tsd: "^0.28.1",
      typescript: "^5.0.4",
      "typescript-cached-transpile": "^0.0.6",
      "v8-heapsnapshot": "^1.3.1",
      yargs: "^17.7.2"
    },
    license: "Apache-2.0",
    engines: {
      node: ">=16.20.1"
    },
    bugs: {
      url: "https://jira.mongodb.org/projects/NODE/issues/"
    },
    homepage: "https://github.com/mongodb/node-mongodb-native",
    scripts: {
      "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
      "build:ts": "node ./node_modules/typescript/bin/tsc",
      "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs && eslint mongodb.d.ts --fix",
      "build:docs": "./etc/docs/build.ts",
      "build:typedoc": "typedoc",
      "build:nightly": "node ./.github/scripts/nightly.mjs",
      "check:bench": "node test/benchmarks/driverBench",
      "check:coverage": "nyc npm run test:all",
      "check:integration-coverage": "nyc npm run check:test",
      "check:lambda": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/handler.test.js",
      "check:lambda:aws": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/aws_handler.test.js",
      "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
      "check:eslint": "eslint -v && eslint --max-warnings=0 --ext '.js,.ts' src test",
      "check:tsd": "tsd --version && tsd",
      "check:dependencies": "mocha test/action/dependency.test.ts",
      "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
      "check:search-indexes": "nyc mocha --config test/mocha_mongodb.json test/manual/search-index-management.prose.test.ts",
      "check:test": "mocha --config test/mocha_mongodb.json test/integration",
      "check:unit": "mocha test/unit",
      "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
      "check:atlas": "mocha --config test/manual/mocharc.json test/manual/atlas_connectivity.test.js",
      "check:drivers-atlas-testing": "mocha --config test/mocha_mongodb.json test/atlas/drivers_atlas_testing.test.ts",
      "check:adl": "mocha --config test/mocha_mongodb.json test/manual/atlas-data-lake-testing",
      "check:aws": "nyc mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_aws.test.ts",
      "check:oidc": "mocha --config test/mocha_mongodb.json test/manual/mongodb_oidc.prose.test.ts",
      "check:oidc-azure": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_azure.prose.test.ts",
      "check:ocsp": "mocha --config test/manual/mocharc.json test/manual/ocsp_support.test.js",
      "check:kerberos": "nyc mocha --config test/manual/mocharc.json test/manual/kerberos.test.ts",
      "check:tls": "mocha --config test/manual/mocharc.json test/manual/tls_support.test.ts",
      "check:ldap": "nyc mocha --config test/manual/mocharc.json test/manual/ldap.test.js",
      "check:socks5": "mocha --config test/manual/mocharc.json test/manual/socks5.test.ts",
      "check:csfle": "mocha --config test/mocha_mongodb.json test/integration/client-side-encryption",
      "check:snappy": "mocha test/unit/assorted/snappy.test.js",
      "fix:eslint": "npm run check:eslint -- --fix",
      prepare: "node etc/prepare.js",
      "preview:docs": "ts-node etc/docs/preview.ts",
      test: "npm run check:lint && npm run test:all",
      "test:all": "npm run check:unit && npm run check:test",
      "update:docs": "npm run build:docs -- --yes"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        strict: true,
        target: "esnext",
        module: "commonjs",
        moduleResolution: "node"
      }
    }
  };
});

// node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS((exports) => {
  var makeClientMetadata = function(options) {
    const metadataDocument = new LimitedSizeDocument(512);
    const { appName = "" } = options;
    if (appName.length > 0) {
      const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
      metadataDocument.ifItFitsItSits("application", { name: name2 });
    }
    const { name = "", version = "", platform = "" } = options.driverInfo;
    const driverInfo = {
      name: name.length > 0 ? `nodejs|${name}` : "nodejs",
      version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
    };
    if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
    }
    let runtimeInfo = getRuntimeInfo();
    if (platform.length > 0) {
      runtimeInfo = `${runtimeInfo}|${platform}`;
    }
    if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
    }
    const osInfo = new Map().set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
    if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
      for (const key of osInfo.keys()) {
        osInfo.delete(key);
        if (osInfo.size === 0)
          break;
        if (metadataDocument.ifItFitsItSits("os", osInfo))
          break;
      }
    }
    const faasEnv = getFAASEnv();
    if (faasEnv != null) {
      if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
        for (const key of faasEnv.keys()) {
          faasEnv.delete(key);
          if (faasEnv.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("env", faasEnv))
            break;
        }
      }
    }
    return metadataDocument.toObject();
  };
  var getFAASEnv = function() {
    const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
    const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
    const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
    const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
    const isVercelFaaS = VERCEL.length > 0;
    const faasEnv = new Map;
    if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
      if (VERCEL_REGION.length > 0) {
        faasEnv.set("region", VERCEL_REGION);
      }
      faasEnv.set("name", "vercel");
      return faasEnv;
    }
    if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
      if (AWS_REGION.length > 0) {
        faasEnv.set("region", AWS_REGION);
      }
      if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
        faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
      }
      faasEnv.set("name", "aws.lambda");
      return faasEnv;
    }
    if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
      faasEnv.set("name", "azure.func");
      return faasEnv;
    }
    if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
      if (FUNCTION_REGION.length > 0) {
        faasEnv.set("region", FUNCTION_REGION);
      }
      if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
        faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
      }
      if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
        faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
      }
      faasEnv.set("name", "gcp.func");
      return faasEnv;
    }
    return null;
  };
  var getRuntimeInfo = function() {
    if ("Deno" in globalThis) {
      const version = typeof Deno?.version?.deno === "string" ? Deno?.version?.deno : "0.0.0-unknown";
      return `Deno v${version}, ${os.endianness()}`;
    }
    if ("Bun" in globalThis) {
      const version = typeof Bun?.version === "string" ? Bun?.version : "0.0.0-unknown";
      return `Bun v${version}, ${os.endianness()}`;
    }
    return `Node.js ${process2.version}, ${os.endianness()}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFAASEnv = exports.makeClientMetadata = exports.LimitedSizeDocument = undefined;
  var os = import.meta.require("os");
  var process2 = import.meta.require("process");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var NODE_DRIVER_VERSION = require_package().version;

  class LimitedSizeDocument {
    constructor(maxSize) {
      this.maxSize = maxSize;
      this.document = new Map;
      this.documentSize = 5;
    }
    ifItFitsItSits(key, value14) {
      const newElementSize = bson_1.BSON.serialize(new Map().set(key, value14)).byteLength - 5;
      if (newElementSize + this.documentSize > this.maxSize) {
        return false;
      }
      this.documentSize += newElementSize;
      this.document.set(key, value14);
      return true;
    }
    toObject() {
      return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
        promoteLongs: false,
        promoteBuffers: false,
        promoteValues: false,
        useBigInt64: false
      });
    }
  }
  exports.LimitedSizeDocument = LimitedSizeDocument;
  exports.makeClientMetadata = makeClientMetadata;
  exports.getFAASEnv = getFAASEnv;
});

// node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OpCompressedRequest = exports.OpMsgResponse = exports.OpMsgRequest = exports.OpQueryResponse = exports.OpQueryRequest = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var compression_1 = require_compression();
  var constants_1 = require_constants();
  var _requestId = 0;
  var OPTS_TAILABLE_CURSOR = 2;
  var OPTS_SECONDARY = 4;
  var OPTS_OPLOG_REPLAY = 8;
  var OPTS_NO_CURSOR_TIMEOUT = 16;
  var OPTS_AWAIT_DATA = 32;
  var OPTS_EXHAUST = 64;
  var OPTS_PARTIAL = 128;
  var CURSOR_NOT_FOUND = 1;
  var QUERY_FAILURE = 2;
  var SHARD_CONFIG_STALE = 4;
  var AWAIT_CAPABLE = 8;

  class OpQueryRequest {
    constructor(databaseName, query, options) {
      this.databaseName = databaseName;
      this.query = query;
      const ns = `${databaseName}.\$cmd`;
      if (typeof databaseName !== "string") {
        throw new error_1.MongoRuntimeError("Database name must be a string for a query");
      }
      if (query == null)
        throw new error_1.MongoRuntimeError("A query document must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
      }
      this.ns = ns;
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || undefined;
      this.requestId = options.requestId ?? OpQueryRequest.getRequestId();
      this.pre32Limit = options.pre32Limit;
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.batchSize = this.numberToReturn;
      this.tailable = false;
      this.secondaryOk = typeof options.secondaryOk === "boolean" ? options.secondaryOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    }
    incRequestId() {
      this.requestId = _requestId++;
    }
    nextRequestId() {
      return _requestId + 1;
    }
    static getRequestId() {
      return ++_requestId;
    }
    toBin() {
      const buffers = [];
      let projection = null;
      let flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.secondaryOk) {
        flags |= OPTS_SECONDARY;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (this.batchSize !== this.numberToReturn)
        this.numberToReturn = this.batchSize;
      const header = Buffer.alloc(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1 + 4 + 4);
      buffers.push(header);
      const query = BSON.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
        projection = BSON.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      const totalLength = header.length + query.length + (projection ? projection.length : 0);
      let index = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index + 3] = this.requestId >> 24 & 255;
      header[index + 2] = this.requestId >> 16 & 255;
      header[index + 1] = this.requestId >> 8 & 255;
      header[index] = this.requestId & 255;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 255;
      header[index + 2] = 0 >> 16 & 255;
      header[index + 1] = 0 >> 8 & 255;
      header[index] = 0 & 255;
      index = index + 4;
      header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
      header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
      header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
      header[index] = constants_1.OP_QUERY & 255;
      index = index + 4;
      header[index + 3] = flags >> 24 & 255;
      header[index + 2] = flags >> 16 & 255;
      header[index + 1] = flags >> 8 & 255;
      header[index] = flags & 255;
      index = index + 4;
      index = index + header.write(this.ns, index, "utf8") + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 255;
      header[index + 2] = this.numberToSkip >> 16 & 255;
      header[index + 1] = this.numberToSkip >> 8 & 255;
      header[index] = this.numberToSkip & 255;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 255;
      header[index + 2] = this.numberToReturn >> 16 & 255;
      header[index + 1] = this.numberToReturn >> 8 & 255;
      header[index] = this.numberToReturn & 255;
      index = index + 4;
      return buffers;
    }
  }
  exports.OpQueryRequest = OpQueryRequest;

  class OpQueryResponse {
    constructor(message, msgHeader, msgBody, opts) {
      this.documents = new Array(0);
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
    }
    isParsed() {
      return this.parsed;
    }
    parse(options) {
      if (this.parsed)
        return;
      options = options ?? {};
      const raw = options.raw || false;
      const documentsReturnedIn = options.documentsReturnedIn || null;
      const useBigInt64 = options.useBigInt64 ?? this.opts.useBigInt64;
      const promoteLongs = options.promoteLongs ?? this.opts.promoteLongs;
      const promoteValues = options.promoteValues ?? this.opts.promoteValues;
      const promoteBuffers = options.promoteBuffers ?? this.opts.promoteBuffers;
      const bsonRegExp = options.bsonRegExp ?? this.opts.bsonRegExp;
      let bsonSize;
      const _options = {
        useBigInt64,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp
      };
      this.index = 20;
      this.responseFlags = this.data.readInt32LE(0);
      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
      this.startingFrom = this.data.readInt32LE(12);
      this.numberReturned = this.data.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      for (let i2 = 0;i2 < this.numberReturned; i2++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i2] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i2] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = BSON.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    }
  }
  exports.OpQueryResponse = OpQueryResponse;
  var OPTS_CHECKSUM_PRESENT = 1;
  var OPTS_MORE_TO_COME = 2;
  var OPTS_EXHAUST_ALLOWED = 1 << 16;

  class OpMsgRequest {
    constructor(databaseName, command, options) {
      this.databaseName = databaseName;
      this.command = command;
      this.options = options;
      if (command == null)
        throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
      this.command.$db = databaseName;
      if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {
        this.command.$readPreference = options.readPreference.toJSON();
      }
      this.options = options ?? {};
      this.requestId = options.requestId ? options.requestId : OpMsgRequest.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checksumPresent = false;
      this.moreToCome = options.moreToCome || false;
      this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
    }
    toBin() {
      const buffers = [];
      let flags = 0;
      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }
      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }
      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }
      const header = Buffer.alloc(4 * 4 + 4);
      buffers.push(header);
      let totalLength = header.length;
      const command = this.command;
      totalLength += this.makeDocumentSegment(buffers, command);
      header.writeInt32LE(totalLength, 0);
      header.writeInt32LE(this.requestId, 4);
      header.writeInt32LE(0, 8);
      header.writeInt32LE(constants_1.OP_MSG, 12);
      header.writeUInt32LE(flags, 16);
      return buffers;
    }
    makeDocumentSegment(buffers, document) {
      const payloadTypeBuffer = Buffer.alloc(1);
      payloadTypeBuffer[0] = 0;
      const documentBuffer = this.serializeBson(document);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      return payloadTypeBuffer.length + documentBuffer.length;
    }
    serializeBson(document) {
      return BSON.serialize(document, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
    static getRequestId() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    }
  }
  exports.OpMsgRequest = OpMsgRequest;

  class OpMsgResponse {
    constructor(message, msgHeader, msgBody, opts) {
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
      this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
      this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      this.documents = [];
    }
    isParsed() {
      return this.parsed;
    }
    parse(options) {
      if (this.parsed)
        return;
      options = options ?? {};
      this.index = 4;
      const raw = options.raw || false;
      const documentsReturnedIn = options.documentsReturnedIn || null;
      const useBigInt64 = options.useBigInt64 ?? this.opts.useBigInt64;
      const promoteLongs = options.promoteLongs ?? this.opts.promoteLongs;
      const promoteValues = options.promoteValues ?? this.opts.promoteValues;
      const promoteBuffers = options.promoteBuffers ?? this.opts.promoteBuffers;
      const bsonRegExp = options.bsonRegExp ?? this.opts.bsonRegExp;
      const validation = this.parseBsonSerializationOptions(options);
      const bsonOptions = {
        useBigInt64,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp,
        validation
      };
      while (this.index < this.data.length) {
        const payloadType = this.data.readUInt8(this.index++);
        if (payloadType === 0) {
          const bsonSize = this.data.readUInt32LE(this.index);
          const bin = this.data.slice(this.index, this.index + bsonSize);
          this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));
          this.index += bsonSize;
        } else if (payloadType === 1) {
          throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
        }
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        bsonOptions.fieldsAsRaw = fieldsAsRaw;
        const doc = BSON.deserialize(this.documents[0], bsonOptions);
        this.documents = [doc];
      }
      this.parsed = true;
    }
    parseBsonSerializationOptions({ enableUtf8Validation }) {
      if (enableUtf8Validation === false) {
        return { utf8: false };
      }
      return { utf8: { writeErrors: false } };
    }
  }
  exports.OpMsgResponse = OpMsgResponse;
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;

  class OpCompressedRequest {
    constructor(command, options) {
      this.command = command;
      this.options = options;
    }
    static canCompress(command) {
      const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !compression_1.uncompressibleCommands.has(commandName);
    }
    async toBin() {
      const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
      msgHeader.writeInt32LE(this.command.requestId, 4);
      msgHeader.writeInt32LE(0, 8);
      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
      compressionDetails.writeInt32LE(originalCommandOpCode, 0);
      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
      compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8);
      return [msgHeader, compressionDetails, compressedMessage];
    }
  }
  exports.OpCompressedRequest = OpCompressedRequest;
});

// node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS((exports) => {
  var loadSnappy = function() {
    if (Snappy == null) {
      const snappyImport = (0, deps_1.getSnappy)();
      if ("kModuleError" in snappyImport) {
        throw snappyImport.kModuleError;
      }
      Snappy = snappyImport;
    }
    return Snappy;
  };
  async function compress(options, dataToBeCompressed) {
    const zlibOptions = {};
    switch (options.agreedCompressor) {
      case "snappy": {
        Snappy ??= loadSnappy();
        return Snappy.compress(dataToBeCompressed);
      }
      case "zstd": {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
      }
      case "zlib": {
        if (options.zlibCompressionLevel) {
          zlibOptions.level = options.zlibCompressionLevel;
        }
        return zlibDeflate(dataToBeCompressed, zlibOptions);
      }
      default: {
        throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);
      }
    }
  }
  async function decompress(compressorID, compressedData) {
    if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {
      throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
    }
    switch (compressorID) {
      case exports.Compressor.snappy: {
        Snappy ??= loadSnappy();
        return Snappy.uncompress(compressedData, { asBuffer: true });
      }
      case exports.Compressor.zstd: {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return zstd.decompress(compressedData);
      }
      case exports.Compressor.zlib: {
        return zlibInflate(compressedData);
      }
      default: {
        return compressedData;
      }
    }
  }
  var loadZstd = function() {
    if (!zstd) {
      zstd = (0, deps_1.getZstdLibrary)();
    }
  };
  async function compressCommand(command, description) {
    const finalCommand = description.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
      agreedCompressor: description.agreedCompressor ?? "none",
      zlibCompressionLevel: description.zlibCompressionLevel ?? 0
    });
    const data = await finalCommand.toBin();
    return Buffer.concat(data);
  }
  async function decompressResponse(message) {
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
      const ResponseType2 = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpQueryResponse;
      const messageBody2 = message.subarray(MESSAGE_HEADER_SIZE);
      return new ResponseType2(message, messageHeader, messageBody2);
    }
    const header = {
      ...messageHeader,
      fromCompressed: true,
      opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
      length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
    };
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpQueryResponse;
    const messageBody = await decompress(compressorID, compressedBuffer);
    if (messageBody.length !== header.length) {
      throw new error_1.MongoDecompressionError("Message body and message header must be the same length");
    }
    return new ResponseType(message, header, messageBody);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponse = exports.compressCommand = exports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = undefined;
  var util_1 = import.meta.require("util");
  var zlib = import.meta.require("zlib");
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var commands_1 = require_commands();
  var constants_2 = require_constants();
  exports.Compressor = Object.freeze({
    none: 0,
    snappy: 1,
    zlib: 2,
    zstd: 3
  });
  exports.uncompressibleCommands = new Set([
    constants_1.LEGACY_HELLO_COMMAND,
    "saslStart",
    "saslContinue",
    "getnonce",
    "authenticate",
    "createUser",
    "updateUser",
    "copydbSaslStart",
    "copydbgetnonce",
    "copydb"
  ]);
  var ZSTD_COMPRESSION_LEVEL = 3;
  var zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));
  var zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));
  var zstd;
  var Snappy = null;
  exports.compress = compress;
  exports.decompress = decompress;
  var MESSAGE_HEADER_SIZE = 16;
  exports.compressCommand = compressCommand;
  exports.decompressResponse = decompressResponse;
});

// node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js
var require_crypto_callbacks = __commonJS((exports) => {
  var makeAES256Hook = function(method, mode) {
    return function(key, iv, input, output) {
      let result;
      try {
        const cipher = crypto2[method](mode, key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
        const final = cipher.final();
        if (final.length > 0) {
          result = Buffer.concat([result, final]);
        }
      } catch (e2) {
        return e2;
      }
      result.copy(output);
      return result.length;
    };
  };
  var randomHook = function(buffer, count) {
    try {
      crypto2.randomFillSync(buffer, 0, count);
    } catch (e2) {
      return e2;
    }
    return count;
  };
  var sha256Hook = function(input, output) {
    let result;
    try {
      result = crypto2.createHash("sha256").update(input).digest();
    } catch (e2) {
      return e2;
    }
    result.copy(output);
    return result.length;
  };
  var makeHmacHook = function(algorithm) {
    return (key, input, output) => {
      let result;
      try {
        result = crypto2.createHmac(algorithm, key).update(input).digest();
      } catch (e2) {
        return e2;
      }
      result.copy(output);
      return result.length;
    };
  };
  var signRsaSha256Hook = function(key, input, output) {
    let result;
    try {
      const signer = crypto2.createSign("sha256WithRSAEncryption");
      const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----\n${key.toString("base64")}\n-----END PRIVATE KEY-----\n`);
      result = signer.update(input).end().sign(privateKey);
    } catch (e2) {
      return e2;
    }
    result.copy(output);
    return result.length;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmacSha256Hook = exports.hmacSha512Hook = exports.aes256CtrDecryptHook = exports.aes256CtrEncryptHook = exports.aes256CbcDecryptHook = exports.aes256CbcEncryptHook = exports.signRsaSha256Hook = exports.makeHmacHook = exports.sha256Hook = exports.randomHook = exports.makeAES256Hook = undefined;
  var crypto2 = import.meta.require("crypto");
  exports.makeAES256Hook = makeAES256Hook;
  exports.randomHook = randomHook;
  exports.sha256Hook = sha256Hook;
  exports.makeHmacHook = makeHmacHook;
  exports.signRsaSha256Hook = signRsaSha256Hook;
  exports.aes256CbcEncryptHook = makeAES256Hook("createCipheriv", "aes-256-cbc");
  exports.aes256CbcDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-cbc");
  exports.aes256CtrEncryptHook = makeAES256Hook("createCipheriv", "aes-256-ctr");
  exports.aes256CtrDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-ctr");
  exports.hmacSha512Hook = makeHmacHook("sha512");
  exports.hmacSha256Hook = makeHmacHook("sha256");
});

// node_modules/mongodb/lib/client-side-encryption/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptAzureKMSRequestError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = undefined;
  var error_1 = require_error();

  class MongoCryptError extends error_1.MongoError {
    constructor(message, options = {}) {
      super(message, options);
    }
    get name() {
      return "MongoCryptError";
    }
  }
  exports.MongoCryptError = MongoCryptError;

  class MongoCryptInvalidArgumentError extends MongoCryptError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCryptInvalidArgumentError";
    }
  }
  exports.MongoCryptInvalidArgumentError = MongoCryptInvalidArgumentError;

  class MongoCryptCreateDataKeyError extends MongoCryptError {
    constructor(encryptedFields, { cause }) {
      super(`Unable to complete creating data keys: ${cause.message}`, { cause });
      this.encryptedFields = encryptedFields;
    }
    get name() {
      return "MongoCryptCreateDataKeyError";
    }
  }
  exports.MongoCryptCreateDataKeyError = MongoCryptCreateDataKeyError;

  class MongoCryptCreateEncryptedCollectionError extends MongoCryptError {
    constructor(encryptedFields, { cause }) {
      super(`Unable to create collection: ${cause.message}`, { cause });
      this.encryptedFields = encryptedFields;
    }
    get name() {
      return "MongoCryptCreateEncryptedCollectionError";
    }
  }
  exports.MongoCryptCreateEncryptedCollectionError = MongoCryptCreateEncryptedCollectionError;

  class MongoCryptAzureKMSRequestError extends MongoCryptError {
    constructor(message, body) {
      super(message);
      this.body = body;
    }
    get name() {
      return "MongoCryptAzureKMSRequestError";
    }
  }
  exports.MongoCryptAzureKMSRequestError = MongoCryptAzureKMSRequestError;

  class MongoCryptKMSRequestNetworkTimeoutError extends MongoCryptError {
    get name() {
      return "MongoCryptKMSRequestNetworkTimeoutError";
    }
  }
  exports.MongoCryptKMSRequestNetworkTimeoutError = MongoCryptKMSRequestNetworkTimeoutError;
});

// node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js
var require_mongocryptd_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongocryptdManager = undefined;
  var error_1 = require_error();

  class MongocryptdManager {
    constructor(extraOptions = {}) {
      this.uri = typeof extraOptions.mongocryptdURI === "string" && extraOptions.mongocryptdURI.length > 0 ? extraOptions.mongocryptdURI : MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
      this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
      this.spawnPath = extraOptions.mongocryptdSpawnPath || "";
      this.spawnArgs = [];
      if (Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
        this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
      }
      if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
        this.spawnArgs.push("--idleShutdownTimeoutSecs", "60");
      }
    }
    async spawn() {
      const cmdName = this.spawnPath || "mongocryptd";
      const { spawn } = import.meta.require("child_process");
      this._child = spawn(cmdName, this.spawnArgs, {
        stdio: "ignore",
        detached: true
      });
      this._child.on("error", () => {
      });
      this._child.unref();
    }
    async withRespawn(fn) {
      try {
        const result2 = await fn();
        return result2;
      } catch (err) {
        const shouldSpawn = err instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;
        if (!shouldSpawn) {
          throw err;
        }
      }
      await this.spawn();
      const result = await fn();
      return result;
    }
  }
  MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = "mongodb://localhost:27020";
  exports.MongocryptdManager = MongocryptdManager;
});

// node_modules/mongodb/lib/client-side-encryption/providers/aws.js
var require_aws = __commonJS((exports) => {
  async function loadAWSCredentials(kmsProviders) {
    const credentialProvider = (0, deps_1.getAwsCredentialProvider)();
    if ("kModuleError" in credentialProvider) {
      return kmsProviders;
    }
    const { fromNodeProviderChain } = credentialProvider;
    const provider = fromNodeProviderChain();
    const aws = await provider();
    return { ...kmsProviders, aws };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadAWSCredentials = undefined;
  var deps_1 = require_deps();
  exports.loadAWSCredentials = loadAWSCredentials;
});

// node_modules/mongodb/lib/client-side-encryption/providers/utils.js
var require_utils3 = __commonJS((exports) => {
  var get = function(url, options = {}) {
    return new Promise((resolve, reject) => {
      let timeoutId;
      const request = http.get(url, options, (response) => {
        response.setEncoding("utf8");
        let body = "";
        response.on("data", (chunk) => body += chunk);
        response.on("end", () => {
          (0, timers_1.clearTimeout)(timeoutId);
          resolve({ status: response.statusCode, body });
        });
      }).on("error", (error21) => {
        (0, timers_1.clearTimeout)(timeoutId);
        reject(error21);
      }).end();
      timeoutId = (0, timers_1.setTimeout)(() => {
        request.destroy(new errors_1.MongoCryptKMSRequestNetworkTimeoutError(`request timed out after 10 seconds`));
      }, 1e4);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.get = undefined;
  var http = import.meta.require("http");
  var timers_1 = import.meta.require("timers");
  var errors_1 = require_errors();
  exports.get = get;
});

// node_modules/mongodb/lib/client-side-encryption/providers/azure.js
var require_azure = __commonJS((exports) => {
  async function parseResponse(response) {
    const { status, body: rawBody } = response;
    const body = (() => {
      try {
        return JSON.parse(rawBody);
      } catch {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed JSON body in GET request.");
      }
    })();
    if (status !== 200) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Unable to complete request.", body);
    }
    if (!body.access_token) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `access_token`.");
    }
    if (!body.expires_in) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `expires_in`.");
    }
    const expiresInMS = Number(body.expires_in) * 1000;
    if (Number.isNaN(expiresInMS)) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - unable to parse int from `expires_in` field.");
    }
    return {
      accessToken: body.access_token,
      expiresOnTimestamp: Date.now() + expiresInMS
    };
  }
  var prepareRequest = function(options) {
    const url = new URL(options.url?.toString() ?? "http://169.254.169.254/metadata/identity/oauth2/token");
    url.searchParams.append("api-version", "2018-02-01");
    url.searchParams.append("resource", "https://vault.azure.net");
    const headers = { ...options.headers, "Content-Type": "application/json", Metadata: true };
    return { headers, url };
  };
  async function fetchAzureKMSToken(options = {}) {
    const { headers, url } = prepareRequest(options);
    const response = await (0, utils_1.get)(url, { headers }).catch((error21) => {
      if (error21 instanceof errors_1.MongoCryptKMSRequestNetworkTimeoutError) {
        throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error21.message}`);
      }
      throw error21;
    });
    return parseResponse(response);
  }
  async function loadAzureCredentials(kmsProviders) {
    const azure = await exports.tokenCache.getToken();
    return { ...kmsProviders, azure };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadAzureCredentials = exports.fetchAzureKMSToken = exports.prepareRequest = exports.tokenCache = exports.AzureCredentialCache = undefined;
  var errors_1 = require_errors();
  var utils_1 = require_utils3();
  var MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;

  class AzureCredentialCache {
    constructor() {
      this.cachedToken = null;
    }
    async getToken() {
      if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {
        this.cachedToken = await this._getToken();
      }
      return { accessToken: this.cachedToken.accessToken };
    }
    needsRefresh(token) {
      const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();
      return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;
    }
    resetCache() {
      this.cachedToken = null;
    }
    _getToken() {
      return fetchAzureKMSToken();
    }
  }
  exports.AzureCredentialCache = AzureCredentialCache;
  exports.tokenCache = new AzureCredentialCache;
  exports.prepareRequest = prepareRequest;
  exports.fetchAzureKMSToken = fetchAzureKMSToken;
  exports.loadAzureCredentials = loadAzureCredentials;
});

// node_modules/mongodb/lib/client-side-encryption/providers/gcp.js
var require_gcp = __commonJS((exports) => {
  async function loadGCPCredentials(kmsProviders) {
    const gcpMetadata = (0, deps_1.getGcpMetadata)();
    if ("kModuleError" in gcpMetadata) {
      return kmsProviders;
    }
    const { access_token: accessToken } = await gcpMetadata.instance({
      property: "service-accounts/default/token"
    });
    return { ...kmsProviders, gcp: { accessToken } };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadGCPCredentials = undefined;
  var deps_1 = require_deps();
  exports.loadGCPCredentials = loadGCPCredentials;
});

// node_modules/mongodb/lib/client-side-encryption/providers/index.js
var require_providers2 = __commonJS((exports) => {
  var isEmptyCredentials = function(providerName, kmsProviders) {
    const provider = kmsProviders[providerName];
    if (provider == null) {
      return false;
    }
    return typeof provider === "object" && Object.keys(provider).length === 0;
  };
  async function refreshKMSCredentials(kmsProviders) {
    let finalKMSProviders = kmsProviders;
    if (isEmptyCredentials("aws", kmsProviders)) {
      finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders);
    }
    if (isEmptyCredentials("gcp", kmsProviders)) {
      finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);
    }
    if (isEmptyCredentials("azure", kmsProviders)) {
      finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);
    }
    return finalKMSProviders;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.refreshKMSCredentials = exports.isEmptyCredentials = undefined;
  var aws_1 = require_aws();
  var azure_1 = require_azure();
  var gcp_1 = require_gcp();
  exports.isEmptyCredentials = isEmptyCredentials;
  exports.refreshKMSCredentials = refreshKMSCredentials;
});

// node_modules/mongodb/lib/client-side-encryption/state_machine.js
var require_state_machine = __commonJS((exports) => {
  var loadSocks = function() {
    if (socks == null) {
      const socksImport = (0, deps_1.getSocks)();
      if ("kModuleError" in socksImport) {
        throw socksImport.kModuleError;
      }
      socks = socksImport;
    }
    return socks;
  };
  var debug = function(msg) {
    if (process.env.MONGODB_CRYPT_DEBUG) {
      console.error(msg);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StateMachine = undefined;
  var fs = import.meta.require("fs/promises");
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var bson_1 = require_bson2();
  var deps_1 = require_deps();
  var utils_1 = require_utils();
  var errors_1 = require_errors();
  var socks = null;
  var MONGOCRYPT_CTX_ERROR = 0;
  var MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
  var MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
  var MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
  var MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
  var MONGOCRYPT_CTX_NEED_KMS = 4;
  var MONGOCRYPT_CTX_READY = 5;
  var MONGOCRYPT_CTX_DONE = 6;
  var HTTPS_PORT = 443;
  var stateToString = new Map([
    [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
    [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
    [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
    [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
    [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, "MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS"],
    [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
    [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
    [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
  ]);
  var INSECURE_TLS_OPTIONS = [
    "tlsInsecure",
    "tlsAllowInvalidCertificates",
    "tlsAllowInvalidHostnames",
    "tlsDisableOCSPEndpointCheck",
    "tlsDisableCertificateRevocationCheck"
  ];

  class StateMachine {
    constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {
      this.options = options;
      this.bsonOptions = bsonOptions;
    }
    async execute(executor, context) {
      const keyVaultNamespace = executor._keyVaultNamespace;
      const keyVaultClient = executor._keyVaultClient;
      const metaDataClient = executor._metaDataClient;
      const mongocryptdClient = executor._mongocryptdClient;
      const mongocryptdManager = executor._mongocryptdManager;
      let result = null;
      while (context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR) {
        debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
        switch (context.state) {
          case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
            const filter = (0, bson_1.deserialize)(context.nextMongoOperation());
            if (!metaDataClient) {
              throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined");
            }
            const collInfo = await this.fetchCollectionInfo(metaDataClient, context.ns, filter);
            if (collInfo) {
              context.addMongoOperationResponse(collInfo);
            }
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
            const command = context.nextMongoOperation();
            if (!mongocryptdClient) {
              throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined");
            }
            const markedCommand = mongocryptdManager ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command)) : await this.markCommand(mongocryptdClient, context.ns, command);
            context.addMongoOperationResponse(markedCommand);
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
            const filter = context.nextMongoOperation();
            const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter);
            if (keys.length === 0) {
              result = { v: [] };
            }
            for await (const key of keys) {
              context.addMongoOperationResponse((0, bson_1.serialize)(key));
            }
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
            const kmsProviders = await executor.askForKMSCredentials();
            context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));
            break;
          }
          case MONGOCRYPT_CTX_NEED_KMS: {
            const requests = Array.from(this.requests(context));
            await Promise.all(requests);
            context.finishKMSRequests();
            break;
          }
          case MONGOCRYPT_CTX_READY: {
            const finalizedContext = context.finalize();
            if (context.state === MONGOCRYPT_CTX_ERROR) {
              const message = context.status.message || "Finalization error";
              throw new errors_1.MongoCryptError(message);
            }
            result = (0, bson_1.deserialize)(finalizedContext, this.options);
            break;
          }
          default:
            throw new errors_1.MongoCryptError(`Unknown state: ${context.state}`);
        }
      }
      if (context.state === MONGOCRYPT_CTX_ERROR || result == null) {
        const message = context.status.message;
        if (!message) {
          debug(`unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`);
        }
        throw new errors_1.MongoCryptError(message ?? "unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.");
      }
      return result;
    }
    kmsRequest(request) {
      const parsedUrl = request.endpoint.split(":");
      const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
      const options = {
        host: parsedUrl[0],
        servername: parsedUrl[0],
        port
      };
      const message = request.message;
      return new Promise(async (resolve, reject) => {
        const buffer = new utils_1.BufferPool;
        let socket;
        let rawSocket;
        function destroySockets() {
          for (const sock of [socket, rawSocket]) {
            if (sock) {
              sock.removeAllListeners();
              sock.destroy();
            }
          }
        }
        function ontimeout() {
          destroySockets();
          reject(new errors_1.MongoCryptError("KMS request timed out"));
        }
        function onerror(err) {
          destroySockets();
          const mcError = new errors_1.MongoCryptError("KMS request failed", { cause: err });
          reject(mcError);
        }
        if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {
          rawSocket = net.connect({
            host: this.options.proxyOptions.proxyHost,
            port: this.options.proxyOptions.proxyPort || 1080
          });
          rawSocket.on("timeout", ontimeout);
          rawSocket.on("error", onerror);
          try {
            const events = import.meta.require("events");
            await events.once(rawSocket, "connect");
            socks ??= loadSocks();
            options.socket = (await socks.SocksClient.createConnection({
              existing_socket: rawSocket,
              command: "connect",
              destination: { host: options.host, port: options.port },
              proxy: {
                host: "iLoveJavaScript",
                port: 0,
                type: 5,
                userId: this.options.proxyOptions.proxyUsername,
                password: this.options.proxyOptions.proxyPassword
              }
            })).socket;
          } catch (err) {
            return onerror(err);
          }
        }
        const tlsOptions = this.options.tlsOptions;
        if (tlsOptions) {
          const kmsProvider = request.kmsProvider;
          const providerTlsOptions = tlsOptions[kmsProvider];
          if (providerTlsOptions) {
            const error21 = this.validateTlsOptions(kmsProvider, providerTlsOptions);
            if (error21)
              reject(error21);
            try {
              await this.setTlsOptions(providerTlsOptions, options);
            } catch (error22) {
              return onerror(error22);
            }
          }
        }
        socket = tls.connect(options, () => {
          socket.write(message);
        });
        socket.once("timeout", ontimeout);
        socket.once("error", onerror);
        socket.on("data", (data) => {
          buffer.append(data);
          while (request.bytesNeeded > 0 && buffer.length) {
            const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
            request.addResponse(buffer.read(bytesNeeded));
          }
          if (request.bytesNeeded <= 0) {
            destroySockets();
            resolve();
          }
        });
      });
    }
    *requests(context) {
      for (let request = context.nextKMSRequest();request != null; request = context.nextKMSRequest()) {
        yield this.kmsRequest(request);
      }
    }
    validateTlsOptions(kmsProvider, tlsOptions) {
      const tlsOptionNames = Object.keys(tlsOptions);
      for (const option of INSECURE_TLS_OPTIONS) {
        if (tlsOptionNames.includes(option)) {
          return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
        }
      }
    }
    async setTlsOptions(tlsOptions, options) {
      if (tlsOptions.tlsCertificateKeyFile) {
        const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);
        options.cert = options.key = cert;
      }
      if (tlsOptions.tlsCAFile) {
        options.ca = await fs.readFile(tlsOptions.tlsCAFile);
      }
      if (tlsOptions.tlsCertificateKeyFilePassword) {
        options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
      }
    }
    async fetchCollectionInfo(client, ns, filter) {
      const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
      const collections = await client.db(db).listCollections(filter, {
        promoteLongs: false,
        promoteValues: false
      }).toArray();
      const info = collections.length > 0 ? (0, bson_1.serialize)(collections[0]) : null;
      return info;
    }
    async markCommand(client, ns, command) {
      const options = { promoteLongs: false, promoteValues: false };
      const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
      const rawCommand = (0, bson_1.deserialize)(command, options);
      const response = await client.db(db).command(rawCommand, options);
      return (0, bson_1.serialize)(response, this.bsonOptions);
    }
    fetchKeys(client, keyVaultNamespace, filter) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);
      return client.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find((0, bson_1.deserialize)(filter)).toArray();
    }
  }
  exports.StateMachine = StateMachine;
});

// node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js
var require_auto_encrypter = __commonJS((exports) => {
  var decorateDecryptionResult = function(decrypted, original, isTopLevelDecorateCall = true) {
    if (isTopLevelDecorateCall) {
      if (Buffer.isBuffer(original)) {
        original = (0, bson_1.deserialize)(original);
      }
      if (Buffer.isBuffer(decrypted)) {
        throw new error_1.MongoRuntimeError("Expected result of decryption to be deserialized BSON object");
      }
    }
    if (!decrypted || typeof decrypted !== "object")
      return;
    for (const k of Object.keys(decrypted)) {
      const originalValue = original[k];
      if (originalValue && originalValue._bsontype === "Binary" && originalValue.sub_type === 6) {
        if (!decrypted[kDecoratedKeys]) {
          Object.defineProperty(decrypted, kDecoratedKeys, {
            value: [],
            configurable: true,
            enumerable: false,
            writable: false
          });
        }
        decrypted[kDecoratedKeys].push(k);
        continue;
      }
      decorateDecryptionResult(decrypted[k], originalValue, false);
    }
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = undefined;
  var bson_1 = require_bson2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var utils_1 = require_utils();
  var cryptoCallbacks = require_crypto_callbacks();
  var errors_1 = require_errors();
  var mongocryptd_manager_1 = require_mongocryptd_manager();
  var providers_1 = require_providers2();
  var state_machine_1 = require_state_machine();
  exports.AutoEncryptionLoggerLevel = Object.freeze({
    FatalError: 0,
    Error: 1,
    Warning: 2,
    Info: 3,
    Trace: 4
  });
  var kDecorateResult = Symbol.for("@@mdb.decorateDecryptionResult");
  var kDecoratedKeys = Symbol.for("@@mdb.decryptedKeys");

  class AutoEncrypter {
    static getMongoCrypt() {
      const encryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in encryption) {
        throw encryption.kModuleError;
      }
      return encryption.MongoCrypt;
    }
    constructor(client, options) {
      this[_a] = false;
      this._client = client;
      this._bypassEncryption = options.bypassAutoEncryption === true;
      this._keyVaultNamespace = options.keyVaultNamespace || "admin.datakeys";
      this._keyVaultClient = options.keyVaultClient || client;
      this._metaDataClient = options.metadataClient || client;
      this._proxyOptions = options.proxyOptions || {};
      this._tlsOptions = options.tlsOptions || {};
      this._kmsProviders = options.kmsProviders || {};
      const mongoCryptOptions = {
        cryptoCallbacks
      };
      if (options.schemaMap) {
        mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);
      }
      if (options.encryptedFieldsMap) {
        mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);
      }
      mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;
      if (options.options?.logger) {
        mongoCryptOptions.logger = options.options.logger;
      }
      if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {
        mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;
      }
      if (options.bypassQueryAnalysis) {
        mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;
      }
      this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;
      if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {
        mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;
      } else if (!this._bypassMongocryptdAndCryptShared) {
        mongoCryptOptions.cryptSharedLibSearchPaths = ["$SYSTEM"];
      }
      const MongoCrypt = AutoEncrypter.getMongoCrypt();
      this._mongocrypt = new MongoCrypt(mongoCryptOptions);
      this._contextCounter = 0;
      if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {
        throw new errors_1.MongoCryptInvalidArgumentError("`cryptSharedLibRequired` set but no crypt_shared library loaded");
      }
      if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
        this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);
        const clientOptions = {
          serverSelectionTimeoutMS: 1e4
        };
        if (options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== "string") {
          clientOptions.family = 4;
        }
        this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
      }
    }
    async init() {
      if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
        return;
      }
      if (!this._mongocryptdManager) {
        throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.");
      }
      if (!this._mongocryptdClient) {
        throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.");
      }
      if (!this._mongocryptdManager.bypassSpawn) {
        await this._mongocryptdManager.spawn();
      }
      try {
        const client = await this._mongocryptdClient.connect();
        return client;
      } catch (error21) {
        const { message } = error21;
        if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {
          throw new error_1.MongoRuntimeError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn", { cause: error21 });
        }
        throw error21;
      }
    }
    async teardown(force) {
      await this._mongocryptdClient?.close(force);
    }
    async encrypt(ns, cmd, options = {}) {
      if (this._bypassEncryption) {
        return cmd;
      }
      const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);
      const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
      context.id = this._contextCounter++;
      context.ns = ns;
      context.document = cmd;
      const stateMachine = new state_machine_1.StateMachine({
        promoteValues: false,
        promoteLongs: false,
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions
      });
      return stateMachine.execute(this, context);
    }
    async decrypt(response, options = {}) {
      const buffer = Buffer.isBuffer(response) ? response : (0, bson_1.serialize)(response, options);
      const context = this._mongocrypt.makeDecryptionContext(buffer);
      context.id = this._contextCounter++;
      const stateMachine = new state_machine_1.StateMachine({
        ...options,
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions
      });
      const decorateResult = this[kDecorateResult];
      const result = await stateMachine.execute(this, context);
      if (decorateResult) {
        decorateDecryptionResult(result, response);
      }
      return result;
    }
    async askForKMSCredentials() {
      return (0, providers_1.refreshKMSCredentials)(this._kmsProviders);
    }
    get cryptSharedLibVersionInfo() {
      return this._mongocrypt.cryptSharedLibVersionInfo;
    }
    static get libmongocryptVersion() {
      return AutoEncrypter.getMongoCrypt().libmongocryptVersion;
    }
  }
  exports.AutoEncrypter = AutoEncrypter;
  _a = kDecorateResult;
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Encrypter = undefined;
  var util_1 = import.meta.require("util");
  var auto_encrypter_1 = require_auto_encrypter();
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var kInternalClient = Symbol("internalClient");

  class Encrypter {
    constructor(client, uri, options) {
      if (typeof options.autoEncryption !== "object") {
        throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
      }
      this[kInternalClient] = null;
      this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
      this.needsConnecting = false;
      if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = client;
      } else if (options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
      }
      if (this.bypassAutoEncryption) {
        options.autoEncryption.metadataClient = undefined;
      } else if (options.maxPoolSize === 0) {
        options.autoEncryption.metadataClient = client;
      } else {
        options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
      }
      if (options.proxyHost) {
        options.autoEncryption.proxyOptions = {
          proxyHost: options.proxyHost,
          proxyPort: options.proxyPort,
          proxyUsername: options.proxyUsername,
          proxyPassword: options.proxyPassword
        };
      }
      this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options.autoEncryption);
    }
    getInternalClient(client, uri, options) {
      let internalClient = this[kInternalClient];
      if (internalClient == null) {
        const clonedOptions = {};
        for (const key of [
          ...Object.getOwnPropertyNames(options),
          ...Object.getOwnPropertySymbols(options)
        ]) {
          if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
            continue;
          Reflect.set(clonedOptions, key, Reflect.get(options, key));
        }
        clonedOptions.minPoolSize = 0;
        internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
        this[kInternalClient] = internalClient;
        for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
          for (const listener of client.listeners(eventName)) {
            internalClient.on(eventName, listener);
          }
        }
        client.on("newListener", (eventName, listener) => {
          internalClient?.on(eventName, listener);
        });
        this.needsConnecting = true;
      }
      return internalClient;
    }
    async connectInternalClient() {
      const internalClient = this[kInternalClient];
      if (this.needsConnecting && internalClient != null) {
        this.needsConnecting = false;
        await internalClient.connect();
      }
    }
    closeCallback(client, force, callback) {
      (0, util_1.callbackify)(this.close.bind(this))(client, force, callback);
    }
    async close(client, force) {
      const maybeError = await this.autoEncrypter.teardown(!!force).catch((e2) => e2);
      const internalClient = this[kInternalClient];
      if (internalClient != null && client !== internalClient) {
        return internalClient.close(force);
      }
      if (maybeError) {
        throw maybeError;
      }
    }
    static checkForMongoCrypt() {
      const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in mongodbClientEncryption) {
        throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
      }
    }
  }
  exports.Encrypter = Encrypter;
});

// node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS((exports) => {
  var parseSeverityFromString = function(s2) {
    const validSeverities = Object.values(exports.SeverityLevel);
    const lowerSeverity = s2?.toLowerCase();
    if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
      return lowerSeverity;
    }
    return null;
  };
  var createStdioLogger = function(stream) {
    return {
      write: (log) => {
        stream.write((0, util_1.inspect)(log, { compact: true, breakLength: Infinity }), "utf-8");
        return;
      }
    };
  };
  var resolveLogPath = function({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
    if (typeof mongodbLogPath === "string" && /^stderr$/i.test(mongodbLogPath)) {
      return createStdioLogger(process.stderr);
    }
    if (typeof mongodbLogPath === "string" && /^stdout$/i.test(mongodbLogPath)) {
      return createStdioLogger(process.stdout);
    }
    if (typeof mongodbLogPath === "object" && typeof mongodbLogPath?.write === "function") {
      return mongodbLogPath;
    }
    if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
      return createStdioLogger(process.stderr);
    }
    if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
      return createStdioLogger(process.stdout);
    }
    return createStdioLogger(process.stderr);
  };
  var resolveSeverityConfiguration = function(clientOption, environmentOption, defaultSeverity) {
    return parseSeverityFromString(clientOption) ?? parseSeverityFromString(environmentOption) ?? defaultSeverity;
  };
  var compareSeverity = function(s02, s1) {
    const s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s02);
    const s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
    return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
  };
  var stringifyWithMaxLen = function(value14, maxDocumentLength) {
    const ejson = bson_1.EJSON.stringify(value14);
    return maxDocumentLength !== 0 && ejson.length > maxDocumentLength ? `${ejson.slice(0, maxDocumentLength)}...` : ejson;
  };
  var isLogConvertible = function(obj) {
    const objAsLogConvertible = obj;
    return objAsLogConvertible.toLog !== undefined && typeof objAsLogConvertible.toLog === "function";
  };
  var attachCommandFields = function(log, commandEvent) {
    log.commandName = commandEvent.commandName;
    log.requestId = commandEvent.requestId;
    log.driverConnectionId = commandEvent?.connectionId;
    const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    if (commandEvent?.serviceId) {
      log.serviceId = commandEvent.serviceId.toHexString();
    }
    return log;
  };
  var attachConnectionFields = function(log, connectionPoolEvent) {
    const { host, port } = utils_1.HostAddress.fromString(connectionPoolEvent.address).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    return log;
  };
  var defaultLogTransform = function(logObject, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
    let log = Object.create(null);
    switch (logObject.name) {
      case constants_1.COMMAND_STARTED:
        log = attachCommandFields(log, logObject);
        log.message = "Command started";
        log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength);
        log.databaseName = logObject.databaseName;
        return log;
      case constants_1.COMMAND_SUCCEEDED:
        log = attachCommandFields(log, logObject);
        log.message = "Command succeeded";
        log.durationMS = logObject.duration;
        log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength);
        return log;
      case constants_1.COMMAND_FAILED:
        log = attachCommandFields(log, logObject);
        log.message = "Command failed";
        log.durationMS = logObject.duration;
        log.failure = logObject.failure;
        return log;
      case constants_1.CONNECTION_POOL_CREATED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool created";
        if (logObject.options) {
          const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
          log = {
            ...log,
            maxIdleTimeMS,
            minPoolSize,
            maxPoolSize,
            maxConnecting,
            waitQueueTimeoutMS
          };
        }
        return log;
      case constants_1.CONNECTION_POOL_READY:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool ready";
        return log;
      case constants_1.CONNECTION_POOL_CLEARED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool cleared";
        if (logObject.serviceId?._bsontype === "ObjectId") {
          log.serviceId = logObject.serviceId.toHexString();
        }
        return log;
      case constants_1.CONNECTION_POOL_CLOSED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool closed";
        return log;
      case constants_1.CONNECTION_CREATED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection created";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_READY:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection ready";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_CLOSED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection closed";
        log.driverConnectionId = logObject.connectionId;
        switch (logObject.reason) {
          case "stale":
            log.reason = "Connection became stale because the pool was cleared";
            break;
          case "idle":
            log.reason = "Connection has been available but unused for longer than the configured max idle time";
            break;
          case "error":
            log.reason = "An error occurred while using the connection";
            if (logObject.error) {
              log.error = logObject.error;
            }
            break;
          case "poolClosed":
            log.reason = "Connection pool was closed";
            break;
          default:
            log.reason = `Unknown close reason: ${logObject.reason}`;
        }
        return log;
      case constants_1.CONNECTION_CHECK_OUT_STARTED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checkout started";
        return log;
      case constants_1.CONNECTION_CHECK_OUT_FAILED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checkout failed";
        switch (logObject.reason) {
          case "poolClosed":
            log.reason = "Connection pool was closed";
            break;
          case "timeout":
            log.reason = "Wait queue timeout elapsed without a connection becoming available";
            break;
          case "connectionError":
            log.reason = "An error occurred while trying to establish a new connection";
            if (logObject.error) {
              log.error = logObject.error;
            }
            break;
          default:
            log.reason = `Unknown close reason: ${logObject.reason}`;
        }
        return log;
      case constants_1.CONNECTION_CHECKED_OUT:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checked out";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_CHECKED_IN:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checked in";
        log.driverConnectionId = logObject.connectionId;
        return log;
      default:
        for (const [key, value14] of Object.entries(logObject)) {
          if (value14 != null)
            log[key] = value14;
        }
    }
    return log;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoLogger = exports.stringifyWithMaxLen = exports.createStdioLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = undefined;
  var bson_1 = require_bson();
  var util_1 = import.meta.require("util");
  var constants_1 = require_constants2();
  var utils_1 = require_utils();
  exports.SeverityLevel = Object.freeze({
    EMERGENCY: "emergency",
    ALERT: "alert",
    CRITICAL: "critical",
    ERROR: "error",
    WARNING: "warn",
    NOTICE: "notice",
    INFORMATIONAL: "info",
    DEBUG: "debug",
    TRACE: "trace",
    OFF: "off"
  });
  exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1000;

  class SeverityLevelMap extends Map {
    constructor(entries) {
      const newEntries = [];
      for (const [level, value14] of entries) {
        newEntries.push([value14, level]);
      }
      newEntries.push(...entries);
      super(newEntries);
    }
    getNumericSeverityLevel(severity) {
      return this.get(severity);
    }
    getSeverityLevelName(level) {
      return this.get(level);
    }
  }
  exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
    [exports.SeverityLevel.OFF, (-Infinity)],
    [exports.SeverityLevel.EMERGENCY, 0],
    [exports.SeverityLevel.ALERT, 1],
    [exports.SeverityLevel.CRITICAL, 2],
    [exports.SeverityLevel.ERROR, 3],
    [exports.SeverityLevel.WARNING, 4],
    [exports.SeverityLevel.NOTICE, 5],
    [exports.SeverityLevel.INFORMATIONAL, 6],
    [exports.SeverityLevel.DEBUG, 7],
    [exports.SeverityLevel.TRACE, 8]
  ]);
  exports.MongoLoggableComponent = Object.freeze({
    COMMAND: "command",
    TOPOLOGY: "topology",
    SERVER_SELECTION: "serverSelection",
    CONNECTION: "connection",
    CLIENT: "client"
  });
  exports.createStdioLogger = createStdioLogger;
  exports.stringifyWithMaxLen = stringifyWithMaxLen;

  class MongoLogger {
    constructor(options) {
      this.error = this.log.bind(this, "error");
      this.warn = this.log.bind(this, "warn");
      this.info = this.log.bind(this, "info");
      this.debug = this.log.bind(this, "debug");
      this.trace = this.log.bind(this, "trace");
      this.componentSeverities = options.componentSeverities;
      this.maxDocumentLength = options.maxDocumentLength;
      this.logDestination = options.logDestination;
    }
    log(severity, component, message) {
      if (compareSeverity(severity, this.componentSeverities[component]) > 0)
        return;
      let logMessage = { t: new Date, c: component, s: severity };
      if (typeof message === "string") {
        logMessage.message = message;
      } else if (typeof message === "object") {
        if (isLogConvertible(message)) {
          logMessage = { ...logMessage, ...message.toLog() };
        } else {
          logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
        }
      }
      this.logDestination.write(logMessage);
    }
    static resolveOptions(envOptions, clientOptions) {
      const combinedOptions = {
        ...envOptions,
        ...clientOptions,
        mongodbLogPath: resolveLogPath(envOptions, clientOptions)
      };
      const defaultSeverity = resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.default, combinedOptions.MONGODB_LOG_ALL, exports.SeverityLevel.OFF);
      return {
        componentSeverities: {
          command: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.command, combinedOptions.MONGODB_LOG_COMMAND, defaultSeverity),
          topology: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.topology, combinedOptions.MONGODB_LOG_TOPOLOGY, defaultSeverity),
          serverSelection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.serverSelection, combinedOptions.MONGODB_LOG_SERVER_SELECTION, defaultSeverity),
          connection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.connection, combinedOptions.MONGODB_LOG_CONNECTION, defaultSeverity),
          client: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.client, combinedOptions.MONGODB_LOG_CLIENT, defaultSeverity),
          default: defaultSeverity
        },
        maxDocumentLength: combinedOptions.mongodbLogMaxDocumentLength ?? (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ?? 1000,
        logDestination: combinedOptions.mongodbLogPath
      };
    }
  }
  exports.MongoLogger = MongoLogger;
});

// node_modules/mongodb/lib/cmap/auth/mongocr.js
var require_mongocr = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCR = undefined;
  var crypto2 = import.meta.require("crypto");
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class MongoCR extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const { username, password, source } = credentials;
      const { nonce } = await connection.commandAsync((0, utils_1.ns)(`${source}.\$cmd`), { getnonce: 1 }, undefined);
      const hashPassword = crypto2.createHash("md5").update(`${username}:mongo:${password}`, "utf8").digest("hex");
      const key = crypto2.createHash("md5").update(`${nonce}${username}${hashPassword}`, "utf8").digest("hex");
      const authenticateCommand = {
        authenticate: 1,
        user: username,
        nonce,
        key
      };
      await connection.commandAsync((0, utils_1.ns)(`${source}.\$cmd`), authenticateCommand, undefined);
    }
  }
  exports.MongoCR = MongoCR;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS((exports) => {
  async function makeTempCredentials(credentials) {
    function makeMongoCredentialsFromAWSTemp(creds) {
      if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {
        throw new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials");
      }
      return new mongo_credentials_1.MongoCredentials({
        username: creds.AccessKeyId,
        password: creds.SecretAccessKey,
        source: credentials.source,
        mechanism: providers_1.AuthMechanism.MONGODB_AWS,
        mechanismProperties: {
          AWS_SESSION_TOKEN: creds.Token
        }
      });
    }
    MongoDBAWS.credentialProvider ??= (0, deps_1.getAwsCredentialProvider)();
    if ("kModuleError" in MongoDBAWS.credentialProvider) {
      if (process2.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        return makeMongoCredentialsFromAWSTemp(await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process2.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`));
      }
      const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
        method: "PUT",
        json: false,
        headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 }
      });
      const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
        json: false,
        headers: { "X-aws-ec2-metadata-token": token }
      });
      const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
        headers: { "X-aws-ec2-metadata-token": token }
      });
      return makeMongoCredentialsFromAWSTemp(creds);
    } else {
      let { AWS_STS_REGIONAL_ENDPOINTS = "", AWS_REGION = "" } = process2.env;
      AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();
      AWS_REGION = AWS_REGION.toLowerCase();
      const awsRegionSettingsExist = AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;
      const useRegionalSts = AWS_STS_REGIONAL_ENDPOINTS === "regional" || AWS_STS_REGIONAL_ENDPOINTS === "legacy" && !LEGACY_REGIONS.has(AWS_REGION);
      const provider = awsRegionSettingsExist && useRegionalSts ? MongoDBAWS.credentialProvider.fromNodeProviderChain({
        clientConfig: { region: AWS_REGION }
      }) : MongoDBAWS.credentialProvider.fromNodeProviderChain();
      try {
        const creds = await provider();
        return makeMongoCredentialsFromAWSTemp({
          AccessKeyId: creds.accessKeyId,
          SecretAccessKey: creds.secretAccessKey,
          Token: creds.sessionToken,
          Expiration: creds.expiration
        });
      } catch (error21) {
        throw new error_1.MongoAWSError(error21.message);
      }
    }
  }
  var deriveRegion = function(host) {
    const parts = host.split(".");
    if (parts.length === 1 || parts[1] === "amazonaws") {
      return "us-east-1";
    }
    return parts[1];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBAWS = undefined;
  var crypto2 = import.meta.require("crypto");
  var process2 = import.meta.require("process");
  var util_1 = import.meta.require("util");
  var BSON = require_bson2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var LEGACY_REGIONS = new Set([
    "ap-northeast-1",
    "ap-south-1",
    "ap-southeast-1",
    "ap-southeast-2",
    "aws-global",
    "ca-central-1",
    "eu-central-1",
    "eu-north-1",
    "eu-west-1",
    "eu-west-2",
    "eu-west-3",
    "sa-east-1",
    "us-east-1",
    "us-east-2",
    "us-west-1",
    "us-west-2"
  ]);
  var ASCII_N = 110;
  var AWS_RELATIVE_URI = "http://169.254.170.2";
  var AWS_EC2_URI = "http://169.254.169.254";
  var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
  var bsonOptions = {
    useBigInt64: false,
    promoteLongs: true,
    promoteValues: true,
    promoteBuffers: false,
    bsonRegExp: false
  };

  class MongoDBAWS extends auth_provider_1.AuthProvider {
    constructor() {
      super();
      this.randomBytesAsync = (0, util_1.promisify)(crypto2.randomBytes);
    }
    async auth(authContext) {
      const { connection } = authContext;
      if (!authContext.credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if ("kModuleError" in deps_1.aws4) {
        throw deps_1.aws4["kModuleError"];
      }
      const { sign } = deps_1.aws4;
      if ((0, utils_1.maxWireVersion)(connection) < 9) {
        throw new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later");
      }
      if (!authContext.credentials.username) {
        authContext.credentials = await makeTempCredentials(authContext.credentials);
      }
      const { credentials } = authContext;
      const accessKeyId = credentials.username;
      const secretAccessKey = credentials.password;
      const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : undefined;
      const db = credentials.source;
      const nonce = await this.randomBytesAsync(32);
      const saslStart = {
        saslStart: 1,
        mechanism: "MONGODB-AWS",
        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
      };
      const saslStartResponse = await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslStart, undefined);
      const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
      const host = serverResponse.h;
      const serverNonce = serverResponse.s.buffer;
      if (serverNonce.length !== 64) {
        throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
      }
      if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
        throw new error_1.MongoRuntimeError("Server nonce does not begin with client nonce");
      }
      if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
      }
      const body = "Action=GetCallerIdentity&Version=2011-06-15";
      const options = sign({
        method: "POST",
        host,
        region: deriveRegion(serverResponse.h),
        service: "sts",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Content-Length": body.length,
          "X-MongoDB-Server-Nonce": utils_1.ByteUtils.toBase64(serverNonce),
          "X-MongoDB-GS2-CB-Flag": "n"
        },
        path: "/",
        body
      }, awsCredentials);
      const payload = {
        a: options.headers.Authorization,
        d: options.headers["X-Amz-Date"]
      };
      if (sessionToken) {
        payload.t = sessionToken;
      }
      const saslContinue = {
        saslContinue: 1,
        conversationId: 1,
        payload: BSON.serialize(payload, bsonOptions)
      };
      await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslContinue, undefined);
    }
  }
  MongoDBAWS.credentialProvider = null;
  exports.MongoDBAWS = MongoDBAWS;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/service_workflow.js
var require_service_workflow = __commonJS((exports) => {
  var commandDocument = function(token) {
    return {
      saslStart: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: bson_1.BSON.serialize({ jwt: token })
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commandDocument = exports.ServiceWorkflow = undefined;
  var bson_1 = require_bson();
  var utils_1 = require_utils();
  var providers_1 = require_providers();

  class ServiceWorkflow {
    async execute(connection, credentials) {
      const token = await this.getToken(credentials);
      const command = commandDocument(token);
      return connection.commandAsync((0, utils_1.ns)(credentials.source), command, undefined);
    }
    async speculativeAuth(credentials) {
      const token = await this.getToken(credentials);
      const document = commandDocument(token);
      document.db = credentials.source;
      return { speculativeAuthenticate: document };
    }
  }
  exports.ServiceWorkflow = ServiceWorkflow;
  exports.commandDocument = commandDocument;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/aws_service_workflow.js
var require_aws_service_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsServiceWorkflow = undefined;
  var fs = import.meta.require("fs");
  var error_1 = require_error();
  var service_workflow_1 = require_service_workflow();
  var TOKEN_MISSING_ERROR = "AWS_WEB_IDENTITY_TOKEN_FILE must be set in the environment.";

  class AwsServiceWorkflow extends service_workflow_1.ServiceWorkflow {
    constructor() {
      super();
    }
    async getToken() {
      const tokenFile = process.env.AWS_WEB_IDENTITY_TOKEN_FILE;
      if (!tokenFile) {
        throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
      }
      return fs.promises.readFile(tokenFile, "utf8");
    }
  }
  exports.AwsServiceWorkflow = AwsServiceWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cache = exports.ExpiringCacheEntry = undefined;
  var EXPIRATION_BUFFER_MS = 300000;

  class ExpiringCacheEntry {
    constructor(expiration) {
      this.expiration = this.expirationTime(expiration);
    }
    isValid() {
      return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;
    }
    expirationTime(expiresInSeconds) {
      return Date.now() + expiresInSeconds * 1000;
    }
  }
  exports.ExpiringCacheEntry = ExpiringCacheEntry;

  class Cache {
    constructor() {
      this.entries = new Map;
    }
    clear() {
      this.entries.clear();
    }
    hashedCacheKey(address, username, callbackHash) {
      return JSON.stringify([address, username, callbackHash]);
    }
  }
  exports.Cache = Cache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_token_cache.js
var require_azure_token_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureTokenCache = exports.AzureTokenEntry = undefined;
  var cache_1 = require_cache();

  class AzureTokenEntry extends cache_1.ExpiringCacheEntry {
    constructor(token, expiration) {
      super(expiration);
      this.token = token;
    }
  }
  exports.AzureTokenEntry = AzureTokenEntry;

  class AzureTokenCache extends cache_1.Cache {
    addEntry(tokenAudience, token) {
      const entry = new AzureTokenEntry(token.access_token, token.expires_in);
      this.entries.set(tokenAudience, entry);
      return entry;
    }
    cacheKey(tokenAudience) {
      return tokenAudience;
    }
    deleteEntry(tokenAudience) {
      this.entries.delete(tokenAudience);
    }
    getEntry(tokenAudience) {
      return this.entries.get(tokenAudience);
    }
  }
  exports.AzureTokenCache = AzureTokenCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_service_workflow.js
var require_azure_service_workflow = __commonJS((exports) => {
  async function getAzureTokenData(tokenAudience) {
    const url = `${AZURE_BASE_URL}&resource=${tokenAudience}`;
    const data = await (0, utils_1.request)(url, {
      json: true,
      headers: AZURE_HEADERS
    });
    return data;
  }
  var isEndpointResultValid = function(token) {
    if (token == null || typeof token !== "object")
      return false;
    return "access_token" in token && "expires_in" in token;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureServiceWorkflow = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var azure_token_cache_1 = require_azure_token_cache();
  var service_workflow_1 = require_service_workflow();
  var AZURE_BASE_URL = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01";
  var AZURE_HEADERS = Object.freeze({ Metadata: "true", Accept: "application/json" });
  var ENDPOINT_RESULT_ERROR = "Azure endpoint did not return a value with only access_token and expires_in properties";
  var TOKEN_AUDIENCE_MISSING_ERROR = "TOKEN_AUDIENCE must be set in the auth mechanism properties when PROVIDER_NAME is azure.";

  class AzureServiceWorkflow extends service_workflow_1.ServiceWorkflow {
    constructor() {
      super(...arguments);
      this.cache = new azure_token_cache_1.AzureTokenCache;
    }
    async getToken(credentials) {
      const tokenAudience = credentials?.mechanismProperties.TOKEN_AUDIENCE;
      if (!tokenAudience) {
        throw new error_1.MongoAzureError(TOKEN_AUDIENCE_MISSING_ERROR);
      }
      let token;
      const entry = this.cache.getEntry(tokenAudience);
      if (entry?.isValid()) {
        token = entry.token;
      } else {
        this.cache.deleteEntry(tokenAudience);
        const response = await getAzureTokenData(tokenAudience);
        if (!isEndpointResultValid(response)) {
          throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
        }
        this.cache.addEntry(tokenAudience, response);
        token = response.access_token;
      }
      return token;
    }
  }
  exports.AzureServiceWorkflow = AzureServiceWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_lock_cache.js
var require_callback_lock_cache = __commonJS((exports) => {
  var withLock = function(callback) {
    let lock = Promise.resolve();
    return async (info, context) => {
      await lock;
      lock = lock.then(() => callback(info, context));
      return lock;
    };
  };
  var hashFunctions = function(requestFn, refreshFn) {
    let requestHash = FN_HASHES.get(requestFn);
    let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);
    if (requestHash == null) {
      FN_HASH_COUNTER++;
      requestHash = FN_HASH_COUNTER;
      FN_HASHES.set(requestFn, FN_HASH_COUNTER);
    }
    if (refreshHash == null && refreshFn) {
      FN_HASH_COUNTER++;
      refreshHash = FN_HASH_COUNTER;
      FN_HASHES.set(refreshFn, FN_HASH_COUNTER);
    }
    return `${requestHash}-${refreshHash}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallbackLockCache = undefined;
  var error_1 = require_error();
  var cache_1 = require_cache();
  var REQUEST_CALLBACK_REQUIRED_ERROR = "Auth mechanism property REQUEST_TOKEN_CALLBACK is required.";
  var FN_HASH_COUNTER = 0;
  var NO_FUNCTION = async () => ({ accessToken: "test" });
  var FN_HASHES = new WeakMap;
  FN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);

  class CallbackLockCache extends cache_1.Cache {
    getEntry(connection, credentials) {
      const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
      const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;
      if (!requestCallback) {
        throw new error_1.MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);
      }
      const callbackHash = hashFunctions(requestCallback, refreshCallback);
      const key = this.cacheKey(connection.address, credentials.username, callbackHash);
      const entry = this.entries.get(key);
      if (entry) {
        return entry;
      }
      return this.addEntry(key, callbackHash, requestCallback, refreshCallback);
    }
    addEntry(key, callbackHash, requestCallback, refreshCallback) {
      const entry = {
        requestCallback: withLock(requestCallback),
        refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,
        callbackHash
      };
      this.entries.set(key, entry);
      return entry;
    }
    cacheKey(address, username, callbackHash) {
      return this.hashedCacheKey(address, username, callbackHash);
    }
  }
  exports.CallbackLockCache = CallbackLockCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_entry_cache.js
var require_token_entry_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenEntryCache = exports.TokenEntry = undefined;
  var cache_1 = require_cache();
  var DEFAULT_EXPIRATION_SECS = 0;

  class TokenEntry extends cache_1.ExpiringCacheEntry {
    constructor(tokenResult, serverInfo, expiration) {
      super(expiration);
      this.tokenResult = tokenResult;
      this.serverInfo = serverInfo;
    }
  }
  exports.TokenEntry = TokenEntry;

  class TokenEntryCache extends cache_1.Cache {
    addEntry(address, username, callbackHash, tokenResult, serverInfo) {
      const entry = new TokenEntry(tokenResult, serverInfo, tokenResult.expiresInSeconds ?? DEFAULT_EXPIRATION_SECS);
      this.entries.set(this.cacheKey(address, username, callbackHash), entry);
      return entry;
    }
    deleteEntry(address, username, callbackHash) {
      this.entries.delete(this.cacheKey(address, username, callbackHash));
    }
    getEntry(address, username, callbackHash) {
      return this.entries.get(this.cacheKey(address, username, callbackHash));
    }
    deleteExpiredEntries() {
      for (const [key, entry] of this.entries) {
        if (!entry.isValid()) {
          this.entries.delete(key);
        }
      }
    }
    cacheKey(address, username, callbackHash) {
      return this.hashedCacheKey(address, username, callbackHash);
    }
  }
  exports.TokenEntryCache = TokenEntryCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js
var require_callback_workflow = __commonJS((exports) => {
  var finishCommandDocument = function(token, conversationId) {
    if (conversationId != null && typeof conversationId === "number") {
      return {
        saslContinue: 1,
        conversationId,
        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
      };
    }
    return {
      saslStart: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
    };
  };
  var isCallbackResultInvalid = function(tokenResult) {
    if (tokenResult == null || typeof tokenResult !== "object")
      return true;
    if (!("accessToken" in tokenResult))
      return true;
    return !Object.getOwnPropertyNames(tokenResult).every((prop) => RESULT_PROPERTIES.includes(prop));
  };
  var startCommandDocument = function(credentials) {
    const payload = {};
    if (credentials.username) {
      payload.n = credentials.username;
    }
    return {
      saslStart: 1,
      autoAuthorize: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallbackWorkflow = undefined;
  var bson_1 = require_bson();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var providers_1 = require_providers();
  var callback_lock_cache_1 = require_callback_lock_cache();
  var token_entry_cache_1 = require_token_entry_cache();
  var OIDC_VERSION = 0;
  var TIMEOUT_S = 300;
  var RESULT_PROPERTIES = ["accessToken", "expiresInSeconds", "refreshToken"];
  var CALLBACK_RESULT_ERROR = "User provided OIDC callbacks must return a valid object with an accessToken.";

  class CallbackWorkflow {
    constructor() {
      this.cache = new token_entry_cache_1.TokenEntryCache;
      this.callbackCache = new callback_lock_cache_1.CallbackLockCache;
    }
    async speculativeAuth(credentials) {
      const document = startCommandDocument(credentials);
      document.db = credentials.source;
      return { speculativeAuthenticate: document };
    }
    async execute(connection, credentials, reauthenticating, response) {
      const { requestCallback, refreshCallback, callbackHash } = this.callbackCache.getEntry(connection, credentials);
      const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
      let result;
      if (entry) {
        if (entry.isValid() && !reauthenticating) {
          result = await this.finishAuthentication(connection, credentials, entry.tokenResult, response?.speculativeAuthenticate?.conversationId);
        } else {
          const tokenResult = await this.fetchAccessToken(connection, credentials, entry.serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback);
          try {
            result = await this.finishAuthentication(connection, credentials, tokenResult, reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId);
          } catch (error21) {
            if (reauthenticating && error21 instanceof error_1.MongoError && error21.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
              this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
              result = await this.execute(connection, credentials, reauthenticating);
            } else {
              throw error21;
            }
          }
        }
      } else {
        const startDocument = await this.startAuthentication(connection, credentials, reauthenticating, response);
        const conversationId = startDocument.conversationId;
        const serverResult = bson_1.BSON.deserialize(startDocument.payload.buffer);
        const tokenResult = await this.fetchAccessToken(connection, credentials, serverResult, reauthenticating, callbackHash, requestCallback, refreshCallback);
        result = await this.finishAuthentication(connection, credentials, tokenResult, conversationId);
      }
      return result;
    }
    async startAuthentication(connection, credentials, reauthenticating, response) {
      let result;
      if (!reauthenticating && response?.speculativeAuthenticate) {
        result = response.speculativeAuthenticate;
      } else {
        result = await connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);
      }
      return result;
    }
    async finishAuthentication(connection, credentials, tokenResult, conversationId) {
      const result = await connection.commandAsync((0, utils_1.ns)(credentials.source), finishCommandDocument(tokenResult.accessToken, conversationId), undefined);
      return result;
    }
    async fetchAccessToken(connection, credentials, serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback) {
      const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
      let result;
      const context = { timeoutSeconds: TIMEOUT_S, version: OIDC_VERSION };
      if (entry) {
        if (entry.isValid() && !reauthenticating) {
          return entry.tokenResult;
        }
        if (refreshCallback) {
          context.refreshToken = entry.tokenResult.refreshToken;
          result = await refreshCallback(serverInfo, context);
        } else {
          result = await requestCallback(serverInfo, context);
        }
      } else {
        result = await requestCallback(serverInfo, context);
      }
      if (isCallbackResultInvalid(result)) {
        this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
        throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
      }
      this.cache.deleteExpiredEntries();
      this.cache.addEntry(connection.address, credentials.username || "", callbackHash, result, serverInfo);
      return result;
    }
  }
  exports.CallbackWorkflow = CallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js
var require_mongodb_oidc = __commonJS((exports) => {
  var getCredentials = function(authContext) {
    const { credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
    }
    return credentials;
  };
  var getWorkflow = function(credentials) {
    const providerName = credentials.mechanismProperties.PROVIDER_NAME;
    const workflow = exports.OIDC_WORKFLOWS.get(providerName || "callback");
    if (!workflow) {
      throw new error_1.MongoInvalidArgumentError(`Could not load workflow for provider ${credentials.mechanismProperties.PROVIDER_NAME}`);
    }
    return workflow;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = undefined;
  var error_1 = require_error();
  var auth_provider_1 = require_auth_provider();
  var aws_service_workflow_1 = require_aws_service_workflow();
  var azure_service_workflow_1 = require_azure_service_workflow();
  var callback_workflow_1 = require_callback_workflow();
  var MISSING_CREDENTIALS_ERROR = "AuthContext must provide credentials.";
  exports.OIDC_WORKFLOWS = new Map;
  exports.OIDC_WORKFLOWS.set("callback", new callback_workflow_1.CallbackWorkflow);
  exports.OIDC_WORKFLOWS.set("aws", new aws_service_workflow_1.AwsServiceWorkflow);
  exports.OIDC_WORKFLOWS.set("azure", new azure_service_workflow_1.AzureServiceWorkflow);

  class MongoDBOIDC extends auth_provider_1.AuthProvider {
    constructor() {
      super();
    }
    async auth(authContext) {
      const { connection, reauthenticating, response } = authContext;
      const credentials = getCredentials(authContext);
      const workflow = getWorkflow(credentials);
      await workflow.execute(connection, credentials, reauthenticating, response);
    }
    async prepare(handshakeDoc, authContext) {
      const credentials = getCredentials(authContext);
      const workflow = getWorkflow(credentials);
      const result = await workflow.speculativeAuth(credentials);
      return { ...handshakeDoc, ...result };
    }
  }
  exports.MongoDBOIDC = MongoDBOIDC;
});

// node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Plain = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class Plain extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const { username, password } = credentials;
      const payload = new bson_1.Binary(Buffer.from(`\0${username}\0${password}`));
      const command = {
        saslStart: 1,
        mechanism: "PLAIN",
        payload,
        autoAuthorize: 1
      };
      await connection.commandAsync((0, utils_1.ns)("$external.$cmd"), command, undefined);
    }
  }
  exports.Plain = Plain;
});

// node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var toCodePoints = function(input) {
    const codepoints = [];
    const size = input.length;
    for (let i2 = 0;i2 < size; i2 += 1) {
      const before = input.charCodeAt(i2);
      if (before >= 55296 && before <= 56319 && size > i2 + 1) {
        const next = input.charCodeAt(i2 + 1);
        if (next >= 56320 && next <= 57343) {
          codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
          i2 += 1;
          continue;
        }
      }
      codepoints.push(before);
    }
    return codepoints;
  };
  var saslprep = function({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l }, input, opts = {}) {
    const mapping2space = non_ASCII_space_characters;
    const mapping2nothing = commonly_mapped_to_nothing;
    if (typeof input !== "string") {
      throw new TypeError("Expected string.");
    }
    if (input.length === 0) {
      return "";
    }
    const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
    const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
    const normalized_map = toCodePoints(normalized_input);
    const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
    if (hasProhibited) {
      throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
    }
    if (opts.allowUnassigned !== true) {
      const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
      if (hasUnassigned) {
        throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
      }
    }
    const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
    const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
    if (hasBidiRAL && hasBidiL) {
      throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
    }
    const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
    const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
      throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
    }
    return normalized_input;
  };
  var getCodePoint = (character) => character.codePointAt(0);
  var first = (x) => x[0];
  var last = (x) => x[x.length - 1];
  saslprep.saslprep = saslprep;
  saslprep.default = saslprep;
  module.exports = saslprep;
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS((exports, module) => {
  var Pager = function(pageSize, opts) {
    if (!(this instanceof Pager))
      return new Pager(pageSize, opts);
    this.length = 0;
    this.updates = [];
    this.path = new Uint16Array(4);
    this.pages = new Array(32768);
    this.maxPages = this.pages.length;
    this.level = 0;
    this.pageSize = pageSize || 1024;
    this.deduplicate = opts ? opts.deduplicate : null;
    this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
  };
  var grow = function(pager, index) {
    while (pager.maxPages < index) {
      var old = pager.pages;
      pager.pages = new Array(32768);
      pager.pages[0] = old;
      pager.level++;
      pager.maxPages *= 32768;
    }
  };
  var truncate = function(buf, len) {
    if (buf.length === len)
      return buf;
    if (buf.length > len)
      return buf.slice(0, len);
    var cpy = alloc(len);
    buf.copy(cpy);
    return cpy;
  };
  var alloc = function(size) {
    if (Buffer.alloc)
      return Buffer.alloc(size);
    var buf = new Buffer(size);
    buf.fill(0);
    return buf;
  };
  var copy = function(buf) {
    var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
    buf.copy(cpy);
    return cpy;
  };
  var Page = function(i2, buf) {
    this.offset = i2 * buf.length;
    this.buffer = buf;
    this.updated = false;
    this.deduplicate = 0;
  };
  var factor = function(n2, out) {
    n2 = (n2 - (out[0] = n2 & 32767)) / 32768;
    n2 = (n2 - (out[1] = n2 & 32767)) / 32768;
    out[3] = (n2 - (out[2] = n2 & 32767)) / 32768 & 32767;
  };
  module.exports = Pager;
  Pager.prototype.updated = function(page) {
    while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
      page.deduplicate++;
      if (page.deduplicate === this.deduplicate.length) {
        page.deduplicate = 0;
        if (page.buffer.equals && page.buffer.equals(this.deduplicate))
          page.buffer = this.deduplicate;
        break;
      }
    }
    if (page.updated || !this.updates)
      return;
    page.updated = true;
    this.updates.push(page);
  };
  Pager.prototype.lastUpdate = function() {
    if (!this.updates || !this.updates.length)
      return null;
    var page = this.updates.pop();
    page.updated = false;
    return page;
  };
  Pager.prototype._array = function(i2, noAllocate) {
    if (i2 >= this.maxPages) {
      if (noAllocate)
        return;
      grow(this, i2);
    }
    factor(i2, this.path);
    var arr = this.pages;
    for (var j = this.level;j > 0; j--) {
      var p2 = this.path[j];
      var next = arr[p2];
      if (!next) {
        if (noAllocate)
          return;
        next = arr[p2] = new Array(32768);
      }
      arr = next;
    }
    return arr;
  };
  Pager.prototype.get = function(i2, noAllocate) {
    var arr = this._array(i2, noAllocate);
    var first = this.path[0];
    var page = arr && arr[first];
    if (!page && !noAllocate) {
      page = arr[first] = new Page(i2, alloc(this.pageSize));
      if (i2 >= this.length)
        this.length = i2 + 1;
    }
    if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
      page.buffer = copy(page.buffer);
      page.deduplicate = 0;
    }
    return page;
  };
  Pager.prototype.set = function(i2, buf) {
    var arr = this._array(i2, false);
    var first = this.path[0];
    if (i2 >= this.length)
      this.length = i2 + 1;
    if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
      arr[first] = undefined;
      return;
    }
    if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
      buf = this.deduplicate;
    }
    var page = arr[first];
    var b2 = truncate(buf, this.pageSize);
    if (page)
      page.buffer = b2;
    else
      arr[first] = new Page(i2, b2);
  };
  Pager.prototype.toBuffer = function() {
    var list = new Array(this.length);
    var empty = alloc(this.pageSize);
    var ptr = 0;
    while (ptr < list.length) {
      var arr = this._array(ptr, true);
      for (var i2 = 0;i2 < 32768 && ptr < list.length; i2++) {
        list[ptr++] = arr && arr[i2] ? arr[i2].buffer : empty;
      }
    }
    return Buffer.concat(list);
  };
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS((exports, module) => {
  var Bitfield = function(opts) {
    if (!(this instanceof Bitfield))
      return new Bitfield(opts);
    if (!opts)
      opts = {};
    if (Buffer.isBuffer(opts))
      opts = { buffer: opts };
    this.pageOffset = opts.pageOffset || 0;
    this.pageSize = opts.pageSize || 1024;
    this.pages = opts.pages || pager(this.pageSize);
    this.byteLength = this.pages.length * this.pageSize;
    this.length = 8 * this.byteLength;
    if (!powerOfTwo(this.pageSize))
      throw new Error("The page size should be a power of two");
    this._trackUpdates = !!opts.trackUpdates;
    this._pageMask = this.pageSize - 1;
    if (opts.buffer) {
      for (var i2 = 0;i2 < opts.buffer.length; i2 += this.pageSize) {
        this.pages.set(i2 / this.pageSize, opts.buffer.slice(i2, i2 + this.pageSize));
      }
      this.byteLength = opts.buffer.length;
      this.length = 8 * this.byteLength;
    }
  };
  var alloc = function(n2) {
    if (Buffer.alloc)
      return Buffer.alloc(n2);
    var b2 = new Buffer(n2);
    b2.fill(0);
    return b2;
  };
  var powerOfTwo = function(x) {
    return !(x & x - 1);
  };
  var pager = require_memory_pager();
  module.exports = Bitfield;
  Bitfield.prototype.get = function(i2) {
    var o2 = i2 & 7;
    var j = (i2 - o2) / 8;
    return !!(this.getByte(j) & 128 >> o2);
  };
  Bitfield.prototype.getByte = function(i2) {
    var o2 = i2 & this._pageMask;
    var j = (i2 - o2) / this.pageSize;
    var page = this.pages.get(j, true);
    return page ? page.buffer[o2 + this.pageOffset] : 0;
  };
  Bitfield.prototype.set = function(i2, v2) {
    var o2 = i2 & 7;
    var j = (i2 - o2) / 8;
    var b2 = this.getByte(j);
    return this.setByte(j, v2 ? b2 | 128 >> o2 : b2 & (255 ^ 128 >> o2));
  };
  Bitfield.prototype.toBuffer = function() {
    var all = alloc(this.pages.length * this.pageSize);
    for (var i2 = 0;i2 < this.pages.length; i2++) {
      var next = this.pages.get(i2, true);
      var allOffset = i2 * this.pageSize;
      if (next)
        next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
    }
    return all;
  };
  Bitfield.prototype.setByte = function(i2, b2) {
    var o2 = i2 & this._pageMask;
    var j = (i2 - o2) / this.pageSize;
    var page = this.pages.get(j, false);
    o2 += this.pageOffset;
    if (page.buffer[o2] === b2)
      return false;
    page.buffer[o2] = b2;
    if (i2 >= this.byteLength) {
      this.byteLength = i2 + 1;
      this.length = this.byteLength * 8;
    }
    if (this._trackUpdates)
      this.pages.updated(page);
    return true;
  };
});

// node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS((exports) => {
  var createMemoryCodePoints = function(data) {
    let offset = 0;
    function read() {
      const size = data.readUInt32BE(offset);
      offset += 4;
      const codepoints = data.slice(offset, offset + size);
      offset += size;
      return (0, sparse_bitfield_1.default)({ buffer: codepoints });
    }
    const unassigned_code_points = read();
    const commonly_mapped_to_nothing = read();
    const non_ASCII_space_characters = read();
    const prohibited_characters = read();
    const bidirectional_r_al = read();
    const bidirectional_l = read();
    return {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMemoryCodePoints = undefined;
  var sparse_bitfield_1 = __importDefault(require_sparse_bitfield());
  exports.createMemoryCodePoints = createMemoryCodePoints;
});

// node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var zlib_1 = import.meta.require("zlib");
  exports.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcWR0A8FfTnekQ47aCkBxiZpYV8RhwYQM7bA/ksoLgSRD0IOSiePAkLrowvWSF4CkHEW856MlTQHA9RKZ1ZJODsEcVcTOyhxUEbXdXtpPp1PNVV39Uz4czEyaTVOb3G6a7XtWrr/devX49/+qekG2Go7Aa2jHGyozG+Dmrzi2mP/xb/zMhLI+WlRm2byubm2h0ivVi7BYzusVjuNkt1l9uFWsutWL8OP4rzV9KeXdsKx1HFhbSc6vIG0fKBZ14UNfLFS6FRrGRtXh98ZvphL/x4uLV/IOzaat/vlikv/TixavxR8PQitfPpKNbffXSwgtr8fV07GX+L1967urwg5W0/t0LV37y/oWFlQtX8ping7reXE3LT680r9yPKyn/3Vn64SwdVs6m/KN0yHrp9D+RvXsqpe6MSia5mH6LSog//Xq/++O74YVTjfDFWK2VIuNSemiPppphcVYeyzcudKqFMiq6cs3vVkrzlcnE0mxeZ1Jf2ZXsSvk8TmRZWYdpalydxd5bc8eUkt1wlEbtqTVLr8XQLFpKMb+dpr9SbSOt4ozTgXUq8+Ihm8cTt0shtCvT6dwao6sxPf5ydmU208/Z0yH8IZtlvZi3e5fG12yn3PLSdPvnQ7vsK9rxyKpqevzFZGVfu3YHezvbnbvit9Xdm5fGbf/MZ7PuuNrTjLJnaofH7gm0h+VKU/g/tdUocrer3cO4yOcuycGoyLrba6Ta+lrlnkZ5ntvWCrfV39wLTuNg9QvsvHb37P8BAGCP0eNTOH5szf154JmnNQIcn7b+FziyAfX4eWnn+C6Lm4M0mj31ubkViiDV4WLvs56qN54xGS3HWER5su6nQtZubl9tcY/4atbr9e5kWewew/g2a8fdy2Yaa97+pgQAAAAAAIBHtt+dYmWwaN/byI5g/9PYVfMvb4YvvDpOLJxvFgueP9VbPXh8/yCZViZxNYATaejmDQAAAACgfjJ/3QUA4JD3Px1InT+5PtQCAAAAAAAAAKD2xP8BAAAAAAAAoP7E/wEAAAAAAACg/sT/AQAAAAAAAKD+xP8BAAAAAAAAoP7E/wEAAAAAAACg/sT/AQAAAAAAAKD+xP8BAAAAAAAAoP7E/wEAAAAAAACg/sT/AQAAAAAAAKD+xP8BAAAAAAAAoP6G6+khVCgSAAAAAAAAAKidYQjLYVfNcPSyAE+dhQsnvAAq59/VHAAAAAAAAOCJmv8E/w4HiLqf3nWuWCB1pe0esg/pT3sKd+m4XjhpFpZH3/1THTcU6cfRLnrHf3ZNPZs+bf9rwPuIUPYAWb+j/Zy0EaAxAAAAAADwrPJ1IMBenu6ea99M+0W/17wCAAAAAAAAnGRLm8oA4JnQUAQAAAAAAAAAUHvi/wAAAAAAAABQf+L/AAAAAAAAAFB/4v8AAAAAAAAAUH/i/wAAAAAAAABQf+L/AAAAAAAAAFB/4v8AAAAAAAAAUH/i/wAAAAAAAABQf+L/AAAAAAAAAFB/4v8AAAAAAAAAUH/i/wAAAAAAAABQf+L/AAAAAAAAAFB/jdX0ECsUCQAAAAAAAADUTiMCAAAAAAAAAHU3VAQAAAAAAAAAUH8hLNf1uwsWbhT/uWBzUEx/ei1Nxc001VqrnN2wuRjCK3G4HuNgtuJoSVj17Q9QyBQBAAAAAAAAHMKpuJ4/+Otc5L2XZi8dJlQ/LCPXhc4keJ9UI9uFre3rDfY9uoXZPQBFHL34HSWWm8sx5rH83d967IfZMRZHHG/2Qi8MFnbscXnhnzHei5NND8P2bW2OT3G8vFeebBHbz9dGEf5jDt+fK4/mTve1bnwndsNL92+mE/75xhs/yz65Ed/ZbP29SP96oxvCDxrxcjj333R262/d6X6tG66lYy/z/+rtMn83nHvv9nfOv/dw4+pvspCl4v7+1npa/nHvtbSvjSJ/mf79/VuLC7N03LiW8o/SMU8ldO+jPOul1OVQ3vVwK+TZqBLCt3/RXvveS7eaD0L8YyhrJeV/cC0WGTdD1hzlCo2H98vzK9a+963V7qRVTeaNa+ZGpWp+N62jSmOetJD8dn67fB4n8nzchG7n4+os2tcgzLWUQVg70rta8lE7nqW7IW710v7eDsV1F7e6433njYfd9j9Gl2KIveptMePVamOXQuhXO5tUk6Pv+kiPX43T7/3YevDy4MN+HLw8CHPX6OqOOwKe73z0+pnf3rvT6pX76j/SUU7/3UjqX5r7ZW7PdZU8Vq2id+29Pphdh3n1Tqp/t0aXaWVOPnsFGre+waRdpKf/TK+7fiX3bOWluVeJg77AAPNDwr37fwAA2GP0+BSOHwcn6/231ghwfPr6X+DIBtTj582d47s8LD3xMeYktt+YHXHe6XQuH9P4Nu+H3ctmGmve/qYEAAAAAACAR7bfnWJlsGgSNNoM54tPZ23EI4vYzPY1/fzq1ud/GP/01jjx8P2tYsG7DzrrB4/vHySTz5YB+n8AAAAAgJrJ/XEXAIDHEf/2yXUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgGdABAAAAAAAAADqbqgIAAAAAAAAAKD2hv8DWK79UBhoBgA=", "base64"));
});

// node_modules/@mongodb-js/saslprep/dist/node.js
var require_node = __commonJS((exports, module) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var index_1 = __importDefault(require_dist());
  var memory_code_points_1 = require_memory_code_points();
  var code_points_data_1 = __importDefault(require_code_points_data());
  var codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
  var saslprep = index_1.default.bind(null, codePoints);
  Object.assign(saslprep, { saslprep, default: saslprep });
  module.exports = saslprep;
});

// node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS((exports) => {
  var cleanUsername = function(username) {
    return username.replace("=", "=3D").replace(",", "=2C");
  };
  var clientFirstMessageBare = function(username, nonce) {
    return Buffer.concat([
      Buffer.from("n=", "utf8"),
      Buffer.from(username, "utf8"),
      Buffer.from(",r=", "utf8"),
      Buffer.from(nonce.toString("base64"), "utf8")
    ]);
  };
  var makeFirstMessage = function(cryptoMethod, credentials, nonce) {
    const username = cleanUsername(credentials.username);
    const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
    return {
      saslStart: 1,
      mechanism,
      payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
      autoAuthorize: 1,
      options: { skipEmptyExchange: true }
    };
  };
  async function executeScram(cryptoMethod, authContext) {
    const { connection, credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
    const response = await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslStartCmd, undefined);
    await continueScramConversation(cryptoMethod, response, authContext);
  }
  async function continueScramConversation(cryptoMethod, response, authContext) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const username = cleanUsername(credentials.username);
    const password = credentials.password;
    const processedPassword = cryptoMethod === "sha256" ? (0, saslprep_1.saslprep)(password) : passwordDigest(username, password);
    const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
    const dict = parsePayload(payload);
    const iterations = parseInt(dict.i, 10);
    if (iterations && iterations < 4096) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
    }
    const salt = dict.s;
    const rnonce = dict.r;
    if (rnonce.startsWith("nonce")) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
    }
    const withoutProof = `c=biws,r=${rnonce}`;
    const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
    const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
    const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
    const storedKey = H2(cryptoMethod, clientKey);
    const authMessage = [
      clientFirstMessageBare(username, nonce),
      payload.toString("utf8"),
      withoutProof
    ].join(",");
    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
    const clientProof = `p=${xor(clientKey, clientSignature)}`;
    const clientFinal = [withoutProof, clientProof].join(",");
    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
    const saslContinueCmd = {
      saslContinue: 1,
      conversationId: response.conversationId,
      payload: new bson_1.Binary(Buffer.from(clientFinal))
    };
    const r = await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslContinueCmd, undefined);
    const parsedResponse = parsePayload(r.payload);
    if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
      throw new error_1.MongoRuntimeError("Server returned an invalid signature");
    }
    if (r.done !== false) {
      return;
    }
    const retrySaslContinueCmd = {
      saslContinue: 1,
      conversationId: r.conversationId,
      payload: Buffer.alloc(0)
    };
    await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), retrySaslContinueCmd, undefined);
  }
  var parsePayload = function(payload) {
    const payloadStr = payload.toString("utf8");
    const dict = {};
    const parts = payloadStr.split(",");
    for (let i2 = 0;i2 < parts.length; i2++) {
      const valueParts = parts[i2].split("=");
      dict[valueParts[0]] = valueParts[1];
    }
    return dict;
  };
  var passwordDigest = function(username, password) {
    if (typeof username !== "string") {
      throw new error_1.MongoInvalidArgumentError("Username must be a string");
    }
    if (typeof password !== "string") {
      throw new error_1.MongoInvalidArgumentError("Password must be a string");
    }
    if (password.length === 0) {
      throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
    }
    let md5;
    try {
      md5 = crypto2.createHash("md5");
    } catch (err) {
      if (crypto2.getFips()) {
        throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
      }
      throw err;
    }
    md5.update(`${username}:mongo:${password}`, "utf8");
    return md5.digest("hex");
  };
  var xor = function(a2, b2) {
    if (!Buffer.isBuffer(a2)) {
      a2 = Buffer.from(a2);
    }
    if (!Buffer.isBuffer(b2)) {
      b2 = Buffer.from(b2);
    }
    const length = Math.max(a2.length, b2.length);
    const res = [];
    for (let i2 = 0;i2 < length; i2 += 1) {
      res.push(a2[i2] ^ b2[i2]);
    }
    return Buffer.from(res).toString("base64");
  };
  var H2 = function(method, text) {
    return crypto2.createHash(method).update(text).digest();
  };
  var HMAC = function(method, key, text) {
    return crypto2.createHmac(method, key).update(text).digest();
  };
  var _hiCachePurge = function() {
    _hiCache = {};
    _hiCacheCount = 0;
  };
  var HI = function(data, salt, iterations, cryptoMethod) {
    const key = [data, salt.toString("base64"), iterations].join("_");
    if (_hiCache[key] != null) {
      return _hiCache[key];
    }
    const saltedData = crypto2.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
    if (_hiCacheCount >= 200) {
      _hiCachePurge();
    }
    _hiCache[key] = saltedData;
    _hiCacheCount += 1;
    return saltedData;
  };
  var compareDigest = function(lhs, rhs) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    if (typeof crypto2.timingSafeEqual === "function") {
      return crypto2.timingSafeEqual(lhs, rhs);
    }
    let result = 0;
    for (let i2 = 0;i2 < lhs.length; i2++) {
      result |= lhs[i2] ^ rhs[i2];
    }
    return result === 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScramSHA256 = exports.ScramSHA1 = undefined;
  var saslprep_1 = require_node();
  var crypto2 = import.meta.require("crypto");
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var providers_1 = require_providers();

  class ScramSHA extends auth_provider_1.AuthProvider {
    constructor(cryptoMethod) {
      super();
      this.cryptoMethod = cryptoMethod || "sha1";
      this.randomBytesAsync = (0, util_1.promisify)(crypto2.randomBytes);
    }
    async prepare(handshakeDoc, authContext) {
      const cryptoMethod = this.cryptoMethod;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const nonce = await this.randomBytesAsync(24);
      authContext.nonce = nonce;
      const request = {
        ...handshakeDoc,
        speculativeAuthenticate: {
          ...makeFirstMessage(cryptoMethod, credentials, nonce),
          db: credentials.source
        }
      };
      return request;
    }
    async auth(authContext) {
      const { reauthenticating, response } = authContext;
      if (response?.speculativeAuthenticate && !reauthenticating) {
        return continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
      }
      return executeScram(this.cryptoMethod, authContext);
    }
  }
  var _hiCache = {};
  var _hiCacheCount = 0;
  var hiLengthMap = {
    sha256: 32,
    sha1: 20
  };

  class ScramSHA1 extends ScramSHA {
    constructor() {
      super("sha1");
    }
  }
  exports.ScramSHA1 = ScramSHA1;

  class ScramSHA256 extends ScramSHA {
    constructor() {
      super("sha256");
    }
  }
  exports.ScramSHA256 = ScramSHA256;
});

// node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS((exports) => {
  var x509AuthenticateCommand = function(credentials) {
    const command = { authenticate: 1, mechanism: "MONGODB-X509" };
    if (credentials.username) {
      command.user = credentials.username;
    }
    return command;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X509 = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class X509 extends auth_provider_1.AuthProvider {
    async prepare(handshakeDoc, authContext) {
      const { credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
    }
    async auth(authContext) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const response = authContext.response;
      if (response?.speculativeAuthenticate) {
        return;
      }
      await connection.commandAsync((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), undefined);
    }
  }
  exports.X509 = X509;
});

// node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS((exports) => {
  var extractCommand = function(command) {
    if (command instanceof commands_1.OpMsgRequest) {
      return (0, utils_1.deepCopy)(command.command);
    }
    if (command.query?.$query) {
      let result;
      if (command.ns === "admin.$cmd") {
        result = Object.assign({}, command.query.$query);
      } else {
        result = { find: collectionName(command) };
        Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
          if (command.query[key] != null) {
            result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);
          }
        });
      }
      Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
        const legacyKey = key;
        if (command[legacyKey] != null) {
          result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);
        }
      });
      OP_QUERY_KEYS.forEach((key) => {
        if (command[key]) {
          result[key] = command[key];
        }
      });
      if (command.pre32Limit != null) {
        result.limit = command.pre32Limit;
      }
      if (command.query.$explain) {
        return { explain: result };
      }
      return result;
    }
    const clonedQuery = {};
    const clonedCommand = {};
    if (command.query) {
      for (const k in command.query) {
        clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);
      }
      clonedCommand.query = clonedQuery;
    }
    for (const k in command) {
      if (k === "query")
        continue;
      clonedCommand[k] = (0, utils_1.deepCopy)(command[k]);
    }
    return command.query ? clonedQuery : clonedCommand;
  };
  var extractReply = function(command, reply) {
    if (!reply) {
      return reply;
    }
    if (command instanceof commands_1.OpMsgRequest) {
      return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
    }
    if (command.query && command.query.$query != null) {
      return {
        ok: 1,
        cursor: {
          id: (0, utils_1.deepCopy)(reply.cursorId),
          ns: namespace(command),
          firstBatch: (0, utils_1.deepCopy)(reply.documents)
        }
      };
    }
    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
  };
  var extractConnectionDetails = function(connection) {
    let connectionId;
    if ("id" in connection) {
      connectionId = connection.id;
    }
    return {
      address: connection.address,
      serviceId: connection.serviceId,
      connectionId
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = undefined;
  var constants_1 = require_constants2();
  var utils_1 = require_utils();
  var commands_1 = require_commands();

  class CommandStartedEvent {
    constructor(connection, command) {
      this.name = constants_1.COMMAND_STARTED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      if (exports.SENSITIVE_COMMANDS.has(commandName)) {
        this.commandObj = {};
        this.commandObj[commandName] = true;
      }
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.databaseName = command.databaseName;
      this.commandName = commandName;
      this.command = maybeRedact(commandName, cmd, cmd);
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandStartedEvent = CommandStartedEvent;

  class CommandSucceededEvent {
    constructor(connection, command, reply, started) {
      this.name = constants_1.COMMAND_SUCCEEDED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandSucceededEvent = CommandSucceededEvent;

  class CommandFailedEvent {
    constructor(connection, command, error21, started) {
      this.name = constants_1.COMMAND_FAILED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.failure = maybeRedact(commandName, cmd, error21);
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandFailedEvent = CommandFailedEvent;
  exports.SENSITIVE_COMMANDS = new Set([
    "authenticate",
    "saslStart",
    "saslContinue",
    "getnonce",
    "createUser",
    "updateUser",
    "copydbgetnonce",
    "copydbsaslstart",
    "copydb"
  ]);
  var HELLO_COMMANDS = new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
  var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
  var namespace = (command) => command.ns;
  var collectionName = (command) => command.ns.split(".")[1];
  var maybeRedact = (commandName, commandDoc, result) => exports.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
  var LEGACY_FIND_QUERY_MAP = {
    $query: "filter",
    $orderby: "sort",
    $hint: "hint",
    $comment: "comment",
    $maxScan: "maxScan",
    $max: "max",
    $min: "min",
    $returnKey: "returnKey",
    $showDiskLoc: "showRecordId",
    $maxTimeMS: "maxTimeMS",
    $snapshot: "snapshot"
  };
  var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: "skip",
    numberToReturn: "batchSize",
    returnFieldSelector: "projection"
  };
  var OP_QUERY_KEYS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "partial",
    "exhaust"
  ];
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS((exports) => {
  var processIncomingData = function(stream, callback) {
    const buffer = stream[kBuffer];
    const sizeOfMessage = buffer.getInt32();
    if (sizeOfMessage == null) {
      return callback();
    }
    if (sizeOfMessage < 0) {
      return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));
    }
    if (sizeOfMessage > stream.maxBsonMessageSize) {
      return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
    }
    if (sizeOfMessage > buffer.length) {
      return callback();
    }
    const message = buffer.read(sizeOfMessage);
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    const monitorHasAnotherHello = () => {
      if (stream.isMonitoringConnection) {
        const sizeOfMessage2 = buffer.getInt32();
        if (sizeOfMessage2 != null && sizeOfMessage2 <= buffer.length) {
          return true;
        }
      }
      return false;
    };
    let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpQueryResponse;
    if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {
      const messageBody = message.subarray(MESSAGE_HEADER_SIZE);
      if (monitorHasAnotherHello()) {
        return processIncomingData(stream, callback);
      }
      stream.emit("message", new ResponseType(message, messageHeader, messageBody));
      if (buffer.length >= 4) {
        return processIncomingData(stream, callback);
      }
      return callback();
    }
    messageHeader.fromCompressed = true;
    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpQueryResponse;
    (0, compression_1.decompress)(compressorID, compressedBuffer).then((messageBody) => {
      if (messageBody.length !== messageHeader.length) {
        return callback(new error_1.MongoDecompressionError("Message body and message header must be the same length"));
      }
      if (monitorHasAnotherHello()) {
        return processIncomingData(stream, callback);
      }
      stream.emit("message", new ResponseType(message, messageHeader, messageBody));
      if (buffer.length >= 4) {
        return processIncomingData(stream, callback);
      }
      return callback();
    }, (error21) => {
      return callback(error21);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStream = undefined;
  var stream_1 = import.meta.require("stream");
  var error_1 = require_error();
  var utils_1 = require_utils();
  var commands_1 = require_commands();
  var compression_1 = require_compression();
  var constants_1 = require_constants();
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;
  var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
  var kBuffer = Symbol("buffer");

  class MessageStream extends stream_1.Duplex {
    constructor(options = {}) {
      super(options);
      this.isMonitoringConnection = false;
      this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
      this[kBuffer] = new utils_1.BufferPool;
    }
    get buffer() {
      return this[kBuffer];
    }
    _write(chunk, _, callback) {
      this[kBuffer].append(chunk);
      processIncomingData(this, callback);
    }
    _read() {
      return;
    }
    writeCommand(command, operationDescription) {
      const agreedCompressor = operationDescription.agreedCompressor ?? "none";
      if (agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command)) {
        const data = command.toBin();
        this.push(Array.isArray(data) ? Buffer.concat(data) : data);
        return;
      }
      const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      const options = {
        agreedCompressor,
        zlibCompressionLevel: operationDescription.zlibCompressionLevel ?? 0
      };
      (0, compression_1.compress)(options, messageToBeCompressed).then((compressedMessage) => {
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compression_1.Compressor[agreedCompressor], 8);
        this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
      }, (error21) => {
        operationDescription.cb(error21);
      });
    }
  }
  exports.MessageStream = MessageStream;
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamDescription = undefined;
  var common_1 = require_common();
  var server_description_1 = require_server_description();
  var RESPONSE_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "logicalSessionTimeoutMinutes"
  ];

  class StreamDescription {
    constructor(address, options) {
      this.address = address;
      this.type = common_1.ServerType.Unknown;
      this.minWireVersion = undefined;
      this.maxWireVersion = undefined;
      this.maxBsonObjectSize = 16777216;
      this.maxMessageSizeBytes = 48000000;
      this.maxWriteBatchSize = 1e5;
      this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;
      this.loadBalanced = !!options?.loadBalanced;
      this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
    }
    receiveResponse(response) {
      if (response == null) {
        return;
      }
      this.type = (0, server_description_1.parseServerType)(response);
      for (const field of RESPONSE_FIELDS) {
        if (response[field] != null) {
          this[field] = response[field];
        }
        if ("__nodejs_mock_server__" in response) {
          this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
        }
      }
      if (response.compression) {
        this.compressor = this.compressors.filter((c2) => response.compression?.includes(c2))[0];
      }
    }
  }
  exports.StreamDescription = StreamDescription;
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS((exports) => {
  var hasSessionSupport = function(conn) {
    const description = conn.description;
    return description.logicalSessionTimeoutMinutes != null;
  };
  var supportsOpMsg = function(conn) {
    const description = conn.description;
    if (description == null) {
      return false;
    }
    return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;
  };
  var streamIdentifier = function(stream, options) {
    if (options.proxyHost) {
      return options.hostAddress.toString();
    }
    const { remoteAddress, remotePort } = stream;
    if (typeof remoteAddress === "string" && typeof remotePort === "number") {
      return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
    }
    return (0, utils_1.uuidV4)().toString("hex");
  };
  var write = function(conn, command, options, callback) {
    options = options ?? {};
    const operationDescription = {
      requestId: command.requestId,
      cb: callback,
      session: options.session,
      noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
      documentsReturnedIn: options.documentsReturnedIn,
      useBigInt64: typeof options.useBigInt64 === "boolean" ? options.useBigInt64 : false,
      promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
      bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
      enableUtf8Validation: typeof options.enableUtf8Validation === "boolean" ? options.enableUtf8Validation : true,
      raw: typeof options.raw === "boolean" ? options.raw : false,
      started: 0
    };
    if (conn[kDescription] && conn[kDescription].compressor) {
      operationDescription.agreedCompressor = conn[kDescription].compressor;
      if (conn[kDescription].zlibCompressionLevel) {
        operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;
      }
    }
    if (typeof options.socketTimeoutMS === "number") {
      conn[kStream].setTimeout(options.socketTimeoutMS);
    } else if (conn.socketTimeoutMS !== 0) {
      conn[kStream].setTimeout(conn.socketTimeoutMS);
    }
    if (conn.monitorCommands) {
      conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));
      operationDescription.started = (0, utils_1.now)();
      operationDescription.cb = (err, reply) => {
        if (err && reply?.ok !== 1) {
          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));
        } else {
          if (reply && (reply.ok === 0 || reply.$err)) {
            conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));
          } else {
            conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));
          }
        }
        if (typeof callback === "function") {
          callback(err, err instanceof error_1.MongoWriteConcernError ? undefined : reply);
        }
      };
    }
    if (!operationDescription.noResponse) {
      conn[kQueue].set(operationDescription.requestId, operationDescription);
    }
    try {
      conn[kMessageStream].writeCommand(command, operationDescription);
    } catch (e2) {
      if (!operationDescription.noResponse) {
        conn[kQueue].delete(operationDescription.requestId);
        operationDescription.cb(e2);
        return;
      }
    }
    if (operationDescription.noResponse) {
      operationDescription.cb();
    }
  };
  async function* readWireProtocolMessages(connection) {
    const bufferPool = new utils_1.BufferPool;
    const maxBsonMessageSize = connection.hello?.maxBsonMessageSize ?? kDefaultMaxBsonMessageSize;
    for await (const [chunk] of (0, stream_1.on)(connection.socket, "data")) {
      bufferPool.append(chunk);
      const sizeOfMessage = bufferPool.getInt32();
      if (sizeOfMessage == null) {
        continue;
      }
      if (sizeOfMessage < 0) {
        throw new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`);
      }
      if (sizeOfMessage > maxBsonMessageSize) {
        throw new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${maxBsonMessageSize}`);
      }
      if (sizeOfMessage > bufferPool.length) {
        continue;
      }
      yield bufferPool.read(sizeOfMessage);
    }
  }
  async function writeCommand(connection, command, options) {
    const drained = (0, events_1.once)(connection.socket, "drain");
    const finalCommand = options.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
      agreedCompressor: options.agreedCompressor ?? "none",
      zlibCompressionLevel: options.zlibCompressionLevel ?? 0
    });
    const buffer = Buffer.concat(await finalCommand.toBin());
    connection.socket.push(buffer);
    await drained;
  }
  async function* readMany(connection) {
    for await (const message of readWireProtocolMessages(connection)) {
      const response = await (0, compression_1.decompressResponse)(message);
      yield response;
      if (!("moreToCome" in response) || !response.moreToCome) {
        return;
      }
    }
  }
  async function read(connection) {
    for await (const value14 of readMany(connection)) {
      return value14;
    }
    throw new error_1.MongoRuntimeError("unable to read message off of connection");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = exports.readMany = exports.writeCommand = exports.readWireProtocolMessages = exports.ModernConnection = exports.hasSessionSupport = exports.CryptoConnection = exports.Connection = undefined;
  var events_1 = import.meta.require("events");
  var stream_1 = import.meta.require("stream");
  var timers_1 = import.meta.require("timers");
  var util_1 = import.meta.require("util");
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  var command_monitoring_events_1 = require_command_monitoring_events();
  var commands_1 = require_commands();
  var message_stream_1 = require_message_stream();
  var stream_description_1 = require_stream_description();
  var compression_1 = require_compression();
  var shared_1 = require_shared();
  var kStream = Symbol("stream");
  var kQueue = Symbol("queue");
  var kMessageStream = Symbol("messageStream");
  var kGeneration = Symbol("generation");
  var kLastUseTime = Symbol("lastUseTime");
  var kClusterTime = Symbol("clusterTime");
  var kDescription = Symbol("description");
  var kHello = Symbol("hello");
  var kAutoEncrypter = Symbol("autoEncrypter");
  var kDelayedTimeoutId = Symbol("delayedTimeoutId");
  var INVALID_QUEUE_SIZE = "Connection internal queue contains more than 1 operation description";

  class Connection extends mongo_types_1.TypedEventEmitter {
    constructor(stream, options) {
      super();
      this.commandAsync = (0, util_1.promisify)((ns, cmd, options2, callback) => this.command(ns, cmd, options2, callback));
      this.id = options.id;
      this.address = streamIdentifier(stream, options);
      this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
      this.monitorCommands = options.monitorCommands;
      this.serverApi = options.serverApi;
      this.closed = false;
      this[kHello] = null;
      this[kClusterTime] = null;
      this[kDescription] = new stream_description_1.StreamDescription(this.address, options);
      this[kGeneration] = options.generation;
      this[kLastUseTime] = (0, utils_1.now)();
      this[kQueue] = new Map;
      this[kMessageStream] = new message_stream_1.MessageStream({
        ...options,
        maxBsonMessageSize: this.hello?.maxBsonMessageSize
      });
      this[kStream] = stream;
      this[kDelayedTimeoutId] = null;
      this[kMessageStream].on("message", (message) => this.onMessage(message));
      this[kMessageStream].on("error", (error21) => this.onError(error21));
      this[kStream].on("close", () => this.onClose());
      this[kStream].on("timeout", () => this.onTimeout());
      this[kStream].on("error", () => {
      });
      this[kStream].pipe(this[kMessageStream]);
      this[kMessageStream].pipe(this[kStream]);
    }
    get description() {
      return this[kDescription];
    }
    get hello() {
      return this[kHello];
    }
    set hello(response) {
      this[kDescription].receiveResponse(response);
      this[kDescription] = Object.freeze(this[kDescription]);
      this[kHello] = response;
    }
    set isMonitoringConnection(value14) {
      this[kMessageStream].isMonitoringConnection = value14;
    }
    get isMonitoringConnection() {
      return this[kMessageStream].isMonitoringConnection;
    }
    get serviceId() {
      return this.hello?.serviceId;
    }
    get loadBalanced() {
      return this.description.loadBalanced;
    }
    get generation() {
      return this[kGeneration] || 0;
    }
    set generation(generation) {
      this[kGeneration] = generation;
    }
    get idleTime() {
      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);
    }
    get clusterTime() {
      return this[kClusterTime];
    }
    get stream() {
      return this[kStream];
    }
    markAvailable() {
      this[kLastUseTime] = (0, utils_1.now)();
    }
    onError(error21) {
      this.cleanup(true, error21);
    }
    onClose() {
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(true, new error_1.MongoNetworkError(message));
    }
    onTimeout() {
      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {
        const message = `connection ${this.id} to ${this.address} timed out`;
        const beforeHandshake = this.hello == null;
        this.cleanup(true, new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
      }, 1).unref();
    }
    onMessage(message) {
      const delayedTimeoutId = this[kDelayedTimeoutId];
      if (delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(delayedTimeoutId);
        this[kDelayedTimeoutId] = null;
      }
      const socketTimeoutMS = this[kStream].timeout ?? 0;
      this[kStream].setTimeout(0);
      this.emit("message", message);
      let operationDescription = this[kQueue].get(message.responseTo);
      if (!operationDescription && this.isMonitoringConnection) {
        if (this[kQueue].size > 1) {
          this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));
        } else {
          const entry = this[kQueue].entries().next();
          if (entry.value != null) {
            const [requestId, orphaned] = entry.value;
            operationDescription = orphaned;
            this[kQueue].delete(requestId);
          }
        }
      }
      if (!operationDescription) {
        return;
      }
      const callback = operationDescription.cb;
      this[kQueue].delete(message.responseTo);
      if ("moreToCome" in message && message.moreToCome) {
        this[kQueue].set(message.requestId, operationDescription);
        this[kStream].setTimeout(socketTimeoutMS);
      }
      try {
        message.parse(operationDescription);
      } catch (err) {
        callback(err);
        return;
      }
      if (message.documents[0]) {
        const document = message.documents[0];
        const session = operationDescription.session;
        if (session) {
          (0, sessions_1.updateSessionFromResponse)(session, document);
        }
        if (document.$clusterTime) {
          this[kClusterTime] = document.$clusterTime;
          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);
        }
        if (document.writeConcernError) {
          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);
          return;
        }
        if (document.ok === 0 || document.$err || document.errmsg || document.code) {
          callback(new error_1.MongoServerError(document));
          return;
        }
      }
      callback(undefined, message.documents[0]);
    }
    destroy(options, callback) {
      if (this.closed) {
        process.nextTick(() => callback?.());
        return;
      }
      if (typeof callback === "function") {
        this.once("close", () => process.nextTick(() => callback()));
      }
      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(options.force, new error_1.MongoNetworkError(message));
    }
    cleanup(force, error21) {
      if (this.closed) {
        return;
      }
      this.closed = true;
      const completeCleanup = () => {
        for (const op of this[kQueue].values()) {
          op.cb(error21);
        }
        this[kQueue].clear();
        this.emit(Connection.CLOSE);
      };
      this[kStream].removeAllListeners();
      this[kMessageStream].removeAllListeners();
      this[kMessageStream].destroy();
      if (force) {
        this[kStream].destroy();
        completeCleanup();
        return;
      }
      if (!this[kStream].writableEnded) {
        this[kStream].end(() => {
          this[kStream].destroy();
          completeCleanup();
        });
      } else {
        completeCleanup();
      }
    }
    command(ns, command, options, callback) {
      let cmd = { ...command };
      const readPreference = (0, shared_1.getReadPreference)(options);
      const shouldUseOpMsg = supportsOpMsg(this);
      const session = options?.session;
      let clusterTime = this.clusterTime;
      if (this.serverApi) {
        const { version, strict: strict3, deprecationErrors } = this.serverApi;
        cmd.apiVersion = version;
        if (strict3 != null)
          cmd.apiStrict = strict3;
        if (deprecationErrors != null)
          cmd.apiDeprecationErrors = deprecationErrors;
      }
      if (hasSessionSupport(this) && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }
        const err = (0, sessions_1.applySession)(session, cmd, options);
        if (err) {
          return callback(err);
        }
      } else if (session?.explicit) {
        return callback(new error_1.MongoCompatibilityError("Current topology does not support sessions"));
      }
      if (clusterTime) {
        cmd.$clusterTime = clusterTime;
      }
      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        cmd = {
          $query: cmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        secondaryOk: readPreference.secondaryOk()
      }, options);
      const message = shouldUseOpMsg ? new commands_1.OpMsgRequest(ns.db, cmd, commandOptions) : new commands_1.OpQueryRequest(ns.db, cmd, commandOptions);
      try {
        write(this, message, commandOptions, callback);
      } catch (err) {
        callback(err);
      }
    }
  }
  Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
  Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
  Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
  Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
  Connection.CLOSE = constants_1.CLOSE;
  Connection.MESSAGE = constants_1.MESSAGE;
  Connection.PINNED = constants_1.PINNED;
  Connection.UNPINNED = constants_1.UNPINNED;
  exports.Connection = Connection;

  class CryptoConnection extends Connection {
    constructor(stream, options) {
      super(stream, options);
      this[kAutoEncrypter] = options.autoEncrypter;
    }
    command(ns, cmd, options, callback) {
      const autoEncrypter = this[kAutoEncrypter];
      if (!autoEncrypter) {
        return callback(new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption"));
      }
      const serverWireVersion = (0, utils_1.maxWireVersion)(this);
      if (serverWireVersion === 0) {
        return super.command(ns, cmd, options, callback);
      }
      if (serverWireVersion < 8) {
        callback(new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
      const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
      autoEncrypter.encrypt(ns.toString(), cmd, options).then((encrypted) => {
        if (sort != null && (cmd.find || cmd.findAndModify)) {
          encrypted.sort = sort;
        }
        if (indexKeys != null && cmd.createIndexes) {
          for (const [offset, index] of indexKeys.entries()) {
            encrypted.indexes[offset].key = index;
          }
        }
        super.command(ns, encrypted, options, (err, response) => {
          if (err || response == null) {
            callback(err, response);
            return;
          }
          autoEncrypter.decrypt(response, options).then((res) => callback(undefined, res), (err2) => callback(err2));
        });
      }, (err) => {
        if (err) {
          callback(err, null);
        }
      });
    }
  }
  exports.CryptoConnection = CryptoConnection;
  exports.hasSessionSupport = hasSessionSupport;

  class ModernConnection extends mongo_types_1.TypedEventEmitter {
    constructor(stream, options) {
      super();
      this.commandAsync = (0, util_1.promisify)((ns, cmd, options2, callback) => this.command(ns, cmd, options2, callback));
      this.id = options.id;
      this.address = streamIdentifier(stream, options);
      this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
      this.monitorCommands = options.monitorCommands;
      this.serverApi = options.serverApi;
      this.closed = false;
      this[kHello] = null;
      this[kClusterTime] = null;
      this[kDescription] = new stream_description_1.StreamDescription(this.address, options);
      this[kGeneration] = options.generation;
      this[kLastUseTime] = (0, utils_1.now)();
      this[kQueue] = new Map;
      this[kMessageStream] = new message_stream_1.MessageStream({
        ...options,
        maxBsonMessageSize: this.hello?.maxBsonMessageSize
      });
      this.socket = stream;
      this[kDelayedTimeoutId] = null;
      this[kMessageStream].on("message", (message) => this.onMessage(message));
      this[kMessageStream].on("error", (error21) => this.onError(error21));
      this.socket.on("close", () => this.onClose());
      this.socket.on("timeout", () => this.onTimeout());
      this.socket.on("error", () => {
      });
      this.socket.pipe(this[kMessageStream]);
      this[kMessageStream].pipe(this.socket);
    }
    get description() {
      return this[kDescription];
    }
    get hello() {
      return this[kHello];
    }
    set hello(response) {
      this[kDescription].receiveResponse(response);
      this[kDescription] = Object.freeze(this[kDescription]);
      this[kHello] = response;
    }
    set isMonitoringConnection(value14) {
      this[kMessageStream].isMonitoringConnection = value14;
    }
    get isMonitoringConnection() {
      return this[kMessageStream].isMonitoringConnection;
    }
    get serviceId() {
      return this.hello?.serviceId;
    }
    get loadBalanced() {
      return this.description.loadBalanced;
    }
    get generation() {
      return this[kGeneration] || 0;
    }
    set generation(generation) {
      this[kGeneration] = generation;
    }
    get idleTime() {
      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);
    }
    get clusterTime() {
      return this[kClusterTime];
    }
    get stream() {
      return this.socket;
    }
    get hasSessionSupport() {
      return this.description.logicalSessionTimeoutMinutes != null;
    }
    get supportsOpMsg() {
      return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;
    }
    markAvailable() {
      this[kLastUseTime] = (0, utils_1.now)();
    }
    onError(error21) {
      this.cleanup(true, error21);
    }
    onClose() {
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(true, new error_1.MongoNetworkError(message));
    }
    onTimeout() {
      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {
        const message = `connection ${this.id} to ${this.address} timed out`;
        const beforeHandshake = this.hello == null;
        this.cleanup(true, new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
      }, 1).unref();
    }
    onMessage(message) {
      const delayedTimeoutId = this[kDelayedTimeoutId];
      if (delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(delayedTimeoutId);
        this[kDelayedTimeoutId] = null;
      }
      const socketTimeoutMS = this.socket.timeout ?? 0;
      this.socket.setTimeout(0);
      this.emit("message", message);
      let operationDescription = this[kQueue].get(message.responseTo);
      if (!operationDescription && this.isMonitoringConnection) {
        if (this[kQueue].size > 1) {
          this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));
        } else {
          const entry = this[kQueue].entries().next();
          if (entry.value != null) {
            const [requestId, orphaned] = entry.value;
            operationDescription = orphaned;
            this[kQueue].delete(requestId);
          }
        }
      }
      if (!operationDescription) {
        return;
      }
      const callback = operationDescription.cb;
      this[kQueue].delete(message.responseTo);
      if ("moreToCome" in message && message.moreToCome) {
        this[kQueue].set(message.requestId, operationDescription);
        this.socket.setTimeout(socketTimeoutMS);
      }
      try {
        message.parse(operationDescription);
      } catch (err) {
        callback(err);
        return;
      }
      if (message.documents[0]) {
        const document = message.documents[0];
        const session = operationDescription.session;
        if (session) {
          (0, sessions_1.updateSessionFromResponse)(session, document);
        }
        if (document.$clusterTime) {
          this[kClusterTime] = document.$clusterTime;
          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);
        }
        if (document.writeConcernError) {
          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);
          return;
        }
        if (document.ok === 0 || document.$err || document.errmsg || document.code) {
          callback(new error_1.MongoServerError(document));
          return;
        }
      }
      callback(undefined, message.documents[0]);
    }
    destroy(options, callback) {
      if (this.closed) {
        process.nextTick(() => callback?.());
        return;
      }
      if (typeof callback === "function") {
        this.once("close", () => process.nextTick(() => callback()));
      }
      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(options.force, new error_1.MongoNetworkError(message));
    }
    cleanup(force, error21) {
      if (this.closed) {
        return;
      }
      this.closed = true;
      const completeCleanup = () => {
        for (const op of this[kQueue].values()) {
          op.cb(error21);
        }
        this[kQueue].clear();
        this.emit(Connection.CLOSE);
      };
      this.socket.removeAllListeners();
      this[kMessageStream].removeAllListeners();
      this[kMessageStream].destroy();
      if (force) {
        this.socket.destroy();
        completeCleanup();
        return;
      }
      if (!this.socket.writableEnded) {
        this.socket.end(() => {
          this.socket.destroy();
          completeCleanup();
        });
      } else {
        completeCleanup();
      }
    }
    command(ns, command, options, callback) {
      let cmd = { ...command };
      const readPreference = (0, shared_1.getReadPreference)(options);
      const session = options?.session;
      let clusterTime = this.clusterTime;
      if (this.serverApi) {
        const { version, strict: strict3, deprecationErrors } = this.serverApi;
        cmd.apiVersion = version;
        if (strict3 != null)
          cmd.apiStrict = strict3;
        if (deprecationErrors != null)
          cmd.apiDeprecationErrors = deprecationErrors;
      }
      if (this.hasSessionSupport && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }
        const err = (0, sessions_1.applySession)(session, cmd, options);
        if (err) {
          return callback(err);
        }
      } else if (session?.explicit) {
        return callback(new error_1.MongoCompatibilityError("Current topology does not support sessions"));
      }
      if (clusterTime) {
        cmd.$clusterTime = clusterTime;
      }
      if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference && readPreference.mode !== "primary") {
        cmd = {
          $query: cmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        secondaryOk: readPreference.secondaryOk()
      }, options);
      const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(ns.db, cmd, commandOptions) : new commands_1.OpQueryRequest(ns.db, cmd, commandOptions);
      try {
        write(this, message, commandOptions, callback);
      } catch (err) {
        callback(err);
      }
    }
  }
  ModernConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
  ModernConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
  ModernConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
  ModernConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
  ModernConnection.CLOSE = constants_1.CLOSE;
  ModernConnection.MESSAGE = constants_1.MESSAGE;
  ModernConnection.PINNED = constants_1.PINNED;
  ModernConnection.UNPINNED = constants_1.UNPINNED;
  exports.ModernConnection = ModernConnection;
  var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
  exports.readWireProtocolMessages = readWireProtocolMessages;
  exports.writeCommand = writeCommand;
  exports.readMany = readMany;
  exports.read = read;
});

// node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS((exports) => {
  var connect = function(options, callback) {
    makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {
      if (err || !socket) {
        return callback(err);
      }
      let ConnectionType = options.connectionType ?? connection_1.Connection;
      if (options.autoEncrypter) {
        ConnectionType = connection_1.CryptoConnection;
      }
      const connection = new ConnectionType(socket, options);
      performInitialHandshake(connection, options).then(() => callback(undefined, connection), (error21) => {
        connection.destroy({ force: false });
        callback(error21);
      });
    });
  };
  var checkSupportedServer = function(hello, options) {
    const maxWireVersion = Number(hello.maxWireVersion);
    const minWireVersion = Number(hello.minWireVersion);
    const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
    const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
      if (serverVersionLowEnough) {
        return null;
      }
      const message2 = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message2);
    }
    const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
    return new error_1.MongoCompatibilityError(message);
  };
  async function performInitialHandshake(conn, options) {
    const credentials = options.credentials;
    if (credentials) {
      if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !exports.AUTH_PROVIDERS.get(credentials.mechanism)) {
        throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
      }
    }
    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
    conn.authContext = authContext;
    const handshakeDoc = await prepareHandshakeDocument(authContext);
    const handshakeOptions = { ...options };
    if (typeof options.connectTimeoutMS === "number") {
      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
    }
    const start = new Date().getTime();
    const response = await conn.commandAsync((0, utils_1.ns)("admin.$cmd"), handshakeDoc, handshakeOptions);
    if (!("isWritablePrimary" in response)) {
      response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
    }
    if (response.helloOk) {
      conn.helloOk = true;
    }
    const supportedServerErr = checkSupportedServer(response, options);
    if (supportedServerErr) {
      throw supportedServerErr;
    }
    if (options.loadBalanced) {
      if (!response.serviceId) {
        throw new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, but the server does not support this mode.");
      }
    }
    conn.hello = response;
    conn.lastHelloMS = new Date().getTime() - start;
    if (!response.arbiterOnly && credentials) {
      authContext.response = response;
      const resolvedCredentials = credentials.resolveAuthMechanism(response);
      const provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
      }
      try {
        await provider.auth(authContext);
      } catch (error21) {
        if (error21 instanceof error_1.MongoError) {
          error21.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
          if ((0, error_1.needsRetryableWriteLabel)(error21, response.maxWireVersion)) {
            error21.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        throw error21;
      }
    }
  }
  async function prepareHandshakeDocument(authContext) {
    const options = authContext.options;
    const compressors = options.compressors ? options.compressors : [];
    const { serverApi } = authContext.connection;
    const handshakeDoc = {
      [serverApi?.version || options.loadBalanced === true ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
      helloOk: true,
      client: options.metadata,
      compression: compressors
    };
    if (options.loadBalanced === true) {
      handshakeDoc.loadBalanced = true;
    }
    const credentials = authContext.credentials;
    if (credentials) {
      if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
        handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
        const provider2 = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);
        if (!provider2) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
        }
        return provider2.prepare(handshakeDoc, authContext);
      }
      const provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
      }
      return provider.prepare(handshakeDoc, authContext);
    }
    return handshakeDoc;
  }
  var parseConnectOptions = function(options) {
    const hostAddress = options.hostAddress;
    if (!hostAddress)
      throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
    const result = {};
    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (typeof hostAddress.socketPath === "string") {
      result.path = hostAddress.socketPath;
      return result;
    } else if (typeof hostAddress.host === "string") {
      result.host = hostAddress.host;
      result.port = hostAddress.port;
      return result;
    } else {
      throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
    }
  };
  var parseSslOptions = function(options) {
    const result = parseConnectOptions(options);
    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (options.existingSocket) {
      result.socket = options.existingSocket;
    }
    if (result.servername == null && result.host && !net.isIP(result.host)) {
      result.servername = result.host;
    }
    return result;
  };
  var makeConnection = function(options, _callback) {
    const useTLS = options.tls ?? false;
    const noDelay = options.noDelay ?? true;
    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;
    const rejectUnauthorized = options.rejectUnauthorized ?? true;
    const existingSocket = options.existingSocket;
    let socket;
    const callback = function(err, ret) {
      if (err && socket) {
        socket.destroy();
      }
      _callback(err, ret);
    };
    if (options.proxyHost != null) {
      return makeSocks5Connection({
        ...options,
        connectTimeoutMS
      }, callback);
    }
    if (useTLS) {
      const tlsSocket = tls.connect(parseSslOptions(options));
      if (typeof tlsSocket.disableRenegotiation === "function") {
        tlsSocket.disableRenegotiation();
      }
      socket = tlsSocket;
    } else if (existingSocket) {
      socket = existingSocket;
    } else {
      socket = net.createConnection(parseConnectOptions(options));
    }
    socket.setKeepAlive(true, 300000);
    socket.setTimeout(connectTimeoutMS);
    socket.setNoDelay(noDelay);
    const connectEvent = useTLS ? "secureConnect" : "connect";
    let cancellationHandler;
    function errorHandler(eventName) {
      return (err) => {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler && options.cancellationToken) {
          options.cancellationToken.removeListener("cancel", cancellationHandler);
        }
        socket.removeListener(connectEvent, connectHandler);
        callback(connectionFailureError(eventName, err));
      };
    }
    function connectHandler() {
      SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
      if (cancellationHandler && options.cancellationToken) {
        options.cancellationToken.removeListener("cancel", cancellationHandler);
      }
      if ("authorizationError" in socket) {
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
      }
      socket.setTimeout(0);
      callback(undefined, socket);
    }
    SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
    if (options.cancellationToken) {
      cancellationHandler = errorHandler("cancel");
      options.cancellationToken.once("cancel", cancellationHandler);
    }
    if (existingSocket) {
      process.nextTick(connectHandler);
    } else {
      socket.once(connectEvent, connectHandler);
    }
  };
  var loadSocks = function() {
    if (socks == null) {
      const socksImport = (0, deps_1.getSocks)();
      if ("kModuleError" in socksImport) {
        throw socksImport.kModuleError;
      }
      socks = socksImport;
    }
    return socks;
  };
  var makeSocks5Connection = function(options, callback) {
    const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? "", options.proxyPort ?? 1080);
    makeConnection({
      ...options,
      hostAddress,
      tls: false,
      proxyHost: undefined
    }, (err, rawSocket) => {
      if (err || !rawSocket) {
        return callback(err);
      }
      const destination = parseConnectOptions(options);
      if (typeof destination.host !== "string" || typeof destination.port !== "number") {
        return callback(new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts"));
      }
      try {
        socks ??= loadSocks();
      } catch (error21) {
        return callback(error21);
      }
      socks.SocksClient.createConnection({
        existing_socket: rawSocket,
        timeout: options.connectTimeoutMS,
        command: "connect",
        destination: {
          host: destination.host,
          port: destination.port
        },
        proxy: {
          host: "iLoveJavaScript",
          port: 0,
          type: 5,
          userId: options.proxyUsername || undefined,
          password: options.proxyPassword || undefined
        }
      }).then(({ socket }) => {
        makeConnection({
          ...options,
          existingSocket: socket,
          proxyHost: undefined
        }, callback);
      }, (error21) => callback(connectionFailureError("error", error21)));
    });
  };
  var connectionFailureError = function(type73, err) {
    switch (type73) {
      case "error":
        return new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(err), { cause: err });
      case "timeout":
        return new error_1.MongoNetworkTimeoutError("connection timed out");
      case "close":
        return new error_1.MongoNetworkError("connection closed");
      case "cancel":
        return new error_1.MongoNetworkError("connection establishment was cancelled");
      default:
        return new error_1.MongoNetworkError("unknown network error");
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = undefined;
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var gssapi_1 = require_gssapi();
  var mongocr_1 = require_mongocr();
  var mongodb_aws_1 = require_mongodb_aws();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var plain_1 = require_plain();
  var providers_1 = require_providers();
  var scram_1 = require_scram();
  var x509_1 = require_x509();
  var connection_1 = require_connection();
  var constants_2 = require_constants();
  exports.AUTH_PROVIDERS = new Map([
    [providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS],
    [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR],
    [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI],
    [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC],
    [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256],
    [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509]
  ]);
  exports.connect = connect;
  exports.prepareHandshakeDocument = prepareHandshakeDocument;
  exports.LEGAL_TLS_SOCKET_OPTIONS = [
    "ALPNProtocols",
    "ca",
    "cert",
    "checkServerIdentity",
    "ciphers",
    "crl",
    "ecdhCurve",
    "key",
    "minDHSize",
    "passphrase",
    "pfx",
    "rejectUnauthorized",
    "secureContext",
    "secureProtocol",
    "servername",
    "session"
  ];
  exports.LEGAL_TCP_SOCKET_OPTIONS = [
    "family",
    "hints",
    "localAddress",
    "localPort",
    "lookup"
  ];
  var SOCKET_ERROR_EVENT_LIST = ["error", "close", "timeout", "parseError"];
  var SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);
  var socks = null;
});

// node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = undefined;

  class ServerDescriptionChangedEvent {
    constructor(topologyId, address, previousDescription, newDescription) {
      this.topologyId = topologyId;
      this.address = address;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;

  class ServerOpeningEvent {
    constructor(topologyId, address) {
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerOpeningEvent = ServerOpeningEvent;

  class ServerClosedEvent {
    constructor(topologyId, address) {
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerClosedEvent = ServerClosedEvent;

  class TopologyDescriptionChangedEvent {
    constructor(topologyId, previousDescription, newDescription) {
      this.topologyId = topologyId;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;

  class TopologyOpeningEvent {
    constructor(topologyId) {
      this.topologyId = topologyId;
    }
  }
  exports.TopologyOpeningEvent = TopologyOpeningEvent;

  class TopologyClosedEvent {
    constructor(topologyId) {
      this.topologyId = topologyId;
    }
  }
  exports.TopologyClosedEvent = TopologyClosedEvent;

  class ServerHeartbeatStartedEvent {
    constructor(connectionId, awaited3) {
      this.connectionId = connectionId;
      this.awaited = awaited3;
    }
  }
  exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;

  class ServerHeartbeatSucceededEvent {
    constructor(connectionId, duration, reply, awaited3) {
      this.connectionId = connectionId;
      this.duration = duration;
      this.reply = reply ?? {};
      this.awaited = awaited3;
    }
  }
  exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;

  class ServerHeartbeatFailedEvent {
    constructor(connectionId, duration, failure, awaited3) {
      this.connectionId = connectionId;
      this.duration = duration;
      this.failure = failure;
      this.awaited = awaited3;
    }
  }
  exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
});

// node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = undefined;
  var constants_1 = require_constants2();

  class ConnectionPoolMonitoringEvent {
    constructor(pool) {
      this.time = new Date;
      this.address = pool.address;
    }
  }
  exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;

  class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CREATED;
      const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } = pool.options;
      this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };
    }
  }
  exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;

  class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_READY;
    }
  }
  exports.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;

  class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLOSED;
    }
  }
  exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;

  class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CREATED;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCreatedEvent = ConnectionCreatedEvent;

  class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_READY;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionReadyEvent = ConnectionReadyEvent;

  class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, reason, error21) {
      super(pool);
      this.name = constants_1.CONNECTION_CLOSED;
      this.connectionId = connection.id;
      this.reason = reason;
      this.serviceId = connection.serviceId;
      this.error = error21 ?? null;
    }
  }
  exports.ConnectionClosedEvent = ConnectionClosedEvent;

  class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
    }
  }
  exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;

  class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, reason, error21) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
      this.reason = reason;
      this.error = error21;
    }
  }
  exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;

  class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_OUT;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;

  class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_IN;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;

  class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, options = {}) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLEARED;
      this.serviceId = options.serviceId;
      this.interruptInUseConnections = options.interruptInUseConnections;
    }
  }
  exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueueTimeoutError = exports.PoolClearedOnNetworkError = exports.PoolClearedError = exports.PoolClosedError = undefined;
  var error_1 = require_error();

  class PoolClosedError extends error_1.MongoDriverError {
    constructor(pool) {
      super("Attempted to check out a connection from closed connection pool");
      this.address = pool.address;
    }
    get name() {
      return "MongoPoolClosedError";
    }
  }
  exports.PoolClosedError = PoolClosedError;

  class PoolClearedError extends error_1.MongoNetworkError {
    constructor(pool, message) {
      const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
      super(errorMessage, pool.serverError ? { cause: pool.serverError } : undefined);
      this.address = pool.address;
      this.addErrorLabel(error_1.MongoErrorLabel.PoolRequstedRetry);
    }
    get name() {
      return "MongoPoolClearedError";
    }
  }
  exports.PoolClearedError = PoolClearedError;

  class PoolClearedOnNetworkError extends PoolClearedError {
    constructor(pool) {
      super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
    }
    get name() {
      return "PoolClearedOnNetworkError";
    }
  }
  exports.PoolClearedOnNetworkError = PoolClearedOnNetworkError;

  class WaitQueueTimeoutError extends error_1.MongoDriverError {
    constructor(message, address) {
      super(message);
      this.address = address;
    }
    get name() {
      return "MongoWaitQueueTimeoutError";
    }
  }
  exports.WaitQueueTimeoutError = WaitQueueTimeoutError;
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPool = exports.PoolState = undefined;
  var timers_1 = import.meta.require("timers");
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var connect_1 = require_connect();
  var connection_1 = require_connection();
  var connection_pool_events_1 = require_connection_pool_events();
  var errors_1 = require_errors2();
  var metrics_1 = require_metrics();
  var kServer = Symbol("server");
  var kConnections = Symbol("connections");
  var kPending = Symbol("pending");
  var kCheckedOut = Symbol("checkedOut");
  var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
  var kGeneration = Symbol("generation");
  var kServiceGenerations = Symbol("serviceGenerations");
  var kConnectionCounter = Symbol("connectionCounter");
  var kCancellationToken = Symbol("cancellationToken");
  var kWaitQueue = Symbol("waitQueue");
  var kCancelled = Symbol("cancelled");
  var kMetrics = Symbol("metrics");
  var kProcessingWaitQueue = Symbol("processingWaitQueue");
  var kPoolState = Symbol("poolState");
  exports.PoolState = Object.freeze({
    paused: "paused",
    ready: "ready",
    closed: "closed"
  });

  class ConnectionPool extends mongo_types_1.TypedEventEmitter {
    constructor(server, options) {
      super();
      this.options = Object.freeze({
        ...options,
        connectionType: connection_1.Connection,
        maxPoolSize: options.maxPoolSize ?? 100,
        minPoolSize: options.minPoolSize ?? 0,
        maxConnecting: options.maxConnecting ?? 2,
        maxIdleTimeMS: options.maxIdleTimeMS ?? 0,
        waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,
        minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,
        autoEncrypter: options.autoEncrypter,
        metadata: options.metadata
      });
      if (this.options.minPoolSize > this.options.maxPoolSize) {
        throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
      }
      this[kPoolState] = exports.PoolState.paused;
      this[kServer] = server;
      this[kConnections] = new utils_1.List;
      this[kPending] = 0;
      this[kCheckedOut] = new Set;
      this[kMinPoolSizeTimer] = undefined;
      this[kGeneration] = 0;
      this[kServiceGenerations] = new Map;
      this[kConnectionCounter] = (0, utils_1.makeCounter)(1);
      this[kCancellationToken] = new mongo_types_1.CancellationToken;
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kWaitQueue] = new utils_1.List;
      this[kMetrics] = new metrics_1.ConnectionPoolMetrics;
      this[kProcessingWaitQueue] = false;
      this.mongoLogger = this[kServer].topology.client.mongoLogger;
      this.component = "connection";
      process.nextTick(() => {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
      });
    }
    get address() {
      return this.options.hostAddress.toString();
    }
    get closed() {
      return this[kPoolState] === exports.PoolState.closed;
    }
    get generation() {
      return this[kGeneration];
    }
    get totalConnectionCount() {
      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
    }
    get availableConnectionCount() {
      return this[kConnections].length;
    }
    get pendingConnectionCount() {
      return this[kPending];
    }
    get currentCheckedOutCount() {
      return this[kCheckedOut].size;
    }
    get waitQueueSize() {
      return this[kWaitQueue].length;
    }
    get loadBalanced() {
      return this.options.loadBalanced;
    }
    get serviceGenerations() {
      return this[kServiceGenerations];
    }
    get serverError() {
      return this[kServer].description.error;
    }
    get checkedOutConnections() {
      return this[kCheckedOut];
    }
    waitQueueErrorMetrics() {
      return this[kMetrics].info(this.options.maxPoolSize);
    }
    ready() {
      if (this[kPoolState] !== exports.PoolState.paused) {
        return;
      }
      this[kPoolState] = exports.PoolState.ready;
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
      (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
      this.ensureMinPoolSize();
    }
    checkOut(callback) {
      this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
      const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
      const waitQueueMember = {
        callback,
        timeoutController: new utils_1.TimeoutController(waitQueueTimeoutMS)
      };
      waitQueueMember.timeoutController.signal.addEventListener("abort", () => {
        waitQueueMember[kCancelled] = true;
        waitQueueMember.timeoutController.clear();
        this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout"));
        waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address));
      });
      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(() => this.processWaitQueue());
    }
    checkIn(connection) {
      if (!this[kCheckedOut].has(connection)) {
        return;
      }
      const poolClosed = this.closed;
      const stale = this.connectionIsStale(connection);
      const willDestroy = !!(poolClosed || stale || connection.closed);
      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].unshift(connection);
      }
      this[kCheckedOut].delete(connection);
      this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
      if (willDestroy) {
        const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
        this.destroyConnection(connection, reason);
      }
      process.nextTick(() => this.processWaitQueue());
    }
    clear(options = {}) {
      if (this.closed) {
        return;
      }
      if (this.loadBalanced) {
        const { serviceId } = options;
        if (!serviceId) {
          throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
        }
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        if (generation == null) {
          throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
        } else {
          this.serviceGenerations.set(sid, generation + 1);
        }
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
        return;
      }
      const interruptInUseConnections = options.interruptInUseConnections ?? false;
      const oldGeneration = this[kGeneration];
      this[kGeneration] += 1;
      const alreadyPaused = this[kPoolState] === exports.PoolState.paused;
      this[kPoolState] = exports.PoolState.paused;
      this.clearMinPoolSizeTimer();
      if (!alreadyPaused) {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
          interruptInUseConnections
        }));
      }
      if (interruptInUseConnections) {
        process.nextTick(() => this.interruptInUseConnections(oldGeneration));
      }
      this.processWaitQueue();
    }
    interruptInUseConnections(minGeneration) {
      for (const connection of this[kCheckedOut]) {
        if (connection.generation <= minGeneration) {
          this.checkIn(connection);
          connection.onError(new errors_1.PoolClearedOnNetworkError(this));
        }
      }
    }
    close(_options, _cb) {
      let options = _options;
      const callback = _cb ?? _options;
      if (typeof options === "function") {
        options = {};
      }
      options = Object.assign({ force: false }, options);
      if (this.closed) {
        return callback();
      }
      this[kCancellationToken].emit("cancel");
      if (typeof this[kConnectionCounter].return === "function") {
        this[kConnectionCounter].return(undefined);
      }
      this[kPoolState] = exports.PoolState.closed;
      this.clearMinPoolSizeTimer();
      this.processWaitQueue();
      (0, utils_1.eachAsync)(this[kConnections].toArray(), (conn, cb) => {
        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
        conn.destroy({ force: !!options.force }, cb);
      }, (err) => {
        this[kConnections].clear();
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
        callback(err);
      });
    }
    withConnection(conn, fn, callback) {
      if (conn) {
        fn(undefined, conn, (fnErr, result) => {
          if (fnErr) {
            return this.withReauthentication(fnErr, conn, fn, callback);
          }
          callback(undefined, result);
        });
        return;
      }
      this.checkOut((err, conn2) => {
        fn(err, conn2, (fnErr, result) => {
          if (fnErr) {
            if (conn2) {
              this.withReauthentication(fnErr, conn2, fn, callback);
            } else {
              callback(fnErr);
            }
          } else {
            callback(undefined, result);
          }
          if (conn2) {
            this.checkIn(conn2);
          }
        });
      });
    }
    withReauthentication(fnErr, conn, fn, callback) {
      if (fnErr instanceof error_1.MongoError && fnErr.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
        this.reauthenticate(conn, fn, (error21, res) => {
          if (error21) {
            return callback(error21);
          }
          callback(undefined, res);
        });
      } else {
        callback(fnErr);
      }
    }
    reauthenticate(connection, fn, callback) {
      const authContext = connection.authContext;
      if (!authContext) {
        return callback(new error_1.MongoRuntimeError("No auth context found on connection."));
      }
      const credentials = authContext.credentials;
      if (!credentials) {
        return callback(new error_1.MongoMissingCredentialsError("Connection is missing credentials when asked to reauthenticate"));
      }
      const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello || undefined);
      const provider = connect_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);
      if (!provider) {
        return callback(new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`));
      }
      provider.reauth(authContext).then(() => {
        fn(undefined, connection, (fnErr, fnResult) => {
          if (fnErr) {
            return callback(fnErr);
          }
          callback(undefined, fnResult);
        });
      }, (error21) => callback(error21));
    }
    clearMinPoolSizeTimer() {
      const minPoolSizeTimer = this[kMinPoolSizeTimer];
      if (minPoolSizeTimer) {
        (0, timers_1.clearTimeout)(minPoolSizeTimer);
      }
    }
    destroyConnection(connection, reason) {
      this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
      process.nextTick(() => connection.destroy({ force: false }));
    }
    connectionIsStale(connection) {
      const serviceId = connection.serviceId;
      if (this.loadBalanced && serviceId) {
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        return connection.generation !== generation;
      }
      return connection.generation !== this[kGeneration];
    }
    connectionIsIdle(connection) {
      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
    }
    destroyConnectionIfPerished(connection) {
      const isStale = this.connectionIsStale(connection);
      const isIdle = this.connectionIsIdle(connection);
      if (!isStale && !isIdle && !connection.closed) {
        return false;
      }
      const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
      this.destroyConnection(connection, reason);
      return true;
    }
    createConnection(callback) {
      const connectOptions = {
        ...this.options,
        id: this[kConnectionCounter].next().value,
        generation: this[kGeneration],
        cancellationToken: this[kCancellationToken]
      };
      this[kPending]++;
      this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
      (0, connect_1.connect)(connectOptions, (err, connection) => {
        if (err || !connection) {
          this[kPending]--;
          this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: undefined }, "error", err));
          if (err instanceof error_1.MongoNetworkError || err instanceof error_1.MongoServerError) {
            err.connectionGeneration = connectOptions.generation;
          }
          callback(err ?? new error_1.MongoRuntimeError("Connection creation failed without error"));
          return;
        }
        if (this[kPoolState] !== exports.PoolState.ready) {
          this[kPending]--;
          connection.destroy({ force: true });
          callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
          return;
        }
        for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
          connection.on(event, (e2) => this.emit(event, e2));
        }
        if (this.loadBalanced) {
          connection.on(connection_1.Connection.PINNED, (pinType) => this[kMetrics].markPinned(pinType));
          connection.on(connection_1.Connection.UNPINNED, (pinType) => this[kMetrics].markUnpinned(pinType));
          const serviceId = connection.serviceId;
          if (serviceId) {
            let generation;
            const sid = serviceId.toHexString();
            if (generation = this.serviceGenerations.get(sid)) {
              connection.generation = generation;
            } else {
              this.serviceGenerations.set(sid, 0);
              connection.generation = 0;
            }
          }
        }
        connection.markAvailable();
        this.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection));
        this[kPending]--;
        callback(undefined, connection);
        return;
      });
    }
    ensureMinPoolSize() {
      const minPoolSize = this.options.minPoolSize;
      if (this[kPoolState] !== exports.PoolState.ready || minPoolSize === 0) {
        return;
      }
      this[kConnections].prune((connection) => this.destroyConnectionIfPerished(connection));
      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
        this.createConnection((err, connection) => {
          if (err) {
            this[kServer].handleError(err);
          }
          if (!err && connection) {
            this[kConnections].push(connection);
            process.nextTick(() => this.processWaitQueue());
          }
          if (this[kPoolState] === exports.PoolState.ready) {
            (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
            this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
          }
        });
      } else {
        (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
        this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
      }
    }
    processWaitQueue() {
      if (this[kProcessingWaitQueue]) {
        return;
      }
      this[kProcessingWaitQueue] = true;
      while (this.waitQueueSize) {
        const waitQueueMember = this[kWaitQueue].first();
        if (!waitQueueMember) {
          this[kWaitQueue].shift();
          continue;
        }
        if (waitQueueMember[kCancelled]) {
          this[kWaitQueue].shift();
          continue;
        }
        if (this[kPoolState] !== exports.PoolState.ready) {
          const reason = this.closed ? "poolClosed" : "connectionError";
          const error21 = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, error21));
          waitQueueMember.timeoutController.clear();
          this[kWaitQueue].shift();
          waitQueueMember.callback(error21);
          continue;
        }
        if (!this.availableConnectionCount) {
          break;
        }
        const connection = this[kConnections].shift();
        if (!connection) {
          break;
        }
        if (!this.destroyConnectionIfPerished(connection)) {
          this[kCheckedOut].add(connection);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));
          waitQueueMember.timeoutController.clear();
          this[kWaitQueue].shift();
          waitQueueMember.callback(undefined, connection);
        }
      }
      const { maxPoolSize, maxConnecting } = this.options;
      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
        const waitQueueMember = this[kWaitQueue].shift();
        if (!waitQueueMember || waitQueueMember[kCancelled]) {
          continue;
        }
        this.createConnection((err, connection) => {
          if (waitQueueMember[kCancelled]) {
            if (!err && connection) {
              this[kConnections].push(connection);
            }
          } else {
            if (err) {
              this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError", err));
            } else if (connection) {
              this[kCheckedOut].add(connection);
              this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));
            }
            waitQueueMember.timeoutController.clear();
            waitQueueMember.callback(err, connection);
          }
          process.nextTick(() => this.processWaitQueue());
        });
      }
      this[kProcessingWaitQueue] = false;
    }
  }
  ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
  ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
  ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
  ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
  ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
  ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
  ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
  ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
  ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
  ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
  ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
  exports.ConnectionPool = ConnectionPool;
});

// node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS((exports) => {
  var calculateRoundTripTime = function(oldRtt, duration) {
    if (oldRtt === -1) {
      return duration;
    }
    const alpha = 0.2;
    return alpha * duration + (1 - alpha) * oldRtt;
  };
  var markServerUnknown = function(server, error21) {
    if (server.loadBalanced) {
      return;
    }
    if (error21 instanceof error_1.MongoNetworkError && !(error21 instanceof error_1.MongoNetworkTimeoutError)) {
      server.monitor?.reset();
    }
    server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, { error: error21 }));
  };
  var isPinnableCommand = function(cmd, session) {
    if (session) {
      return session.inTransaction() || "aggregate" in cmd || "find" in cmd || "getMore" in cmd || "listCollections" in cmd || "listIndexes" in cmd;
    }
    return false;
  };
  var connectionIsStale = function(pool, connection) {
    if (connection.serviceId) {
      return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
    }
    return connection.generation !== pool.generation;
  };
  var shouldHandleStateChangeError = function(server, err) {
    const etv = err.topologyVersion;
    const stv = server.description.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
  };
  var inActiveTransaction = function(session, cmd) {
    return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
  };
  var isRetryableWritesEnabled = function(topology) {
    return topology.s.options.retryWrites !== false;
  };
  var makeOperationHandler = function(server, connection, cmd, options, callback) {
    const session = options?.session;
    return function handleOperationResult(error21, result) {
      if (error21 == null && result != null) {
        return callback(undefined, result);
      }
      if (options != null && "noResponse" in options && options.noResponse === true) {
        return callback(undefined, null);
      }
      if (!error21) {
        return callback(new error_1.MongoUnexpectedServerResponseError("Empty response with no error"));
      }
      if (!(error21 instanceof error_1.MongoError)) {
        return callback(error21);
      }
      if (connectionIsStale(server.pool, connection)) {
        return callback(error21);
      }
      if (error21 instanceof error_1.MongoNetworkError) {
        if (session && !session.hasEnded && session.serverSession) {
          session.serverSession.isDirty = true;
        }
        if (inActiveTransaction(session, cmd) && !error21.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          error21.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
        }
        if ((isRetryableWritesEnabled(server.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(server) && !inActiveTransaction(session, cmd)) {
          error21.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      } else {
        if ((isRetryableWritesEnabled(server.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error21, (0, utils_1.maxWireVersion)(server)) && !inActiveTransaction(session, cmd)) {
          error21.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      }
      if (session && session.isPinned && error21.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        session.unpin({ force: true });
      }
      server.handleError(error21, connection);
      return callback(error21);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = undefined;
  var util_1 = import.meta.require("util");
  var connection_1 = require_connection();
  var connection_pool_1 = require_connection_pool();
  var errors_1 = require_errors2();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var monitor_1 = require_monitor();
  var server_description_1 = require_server_description();
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });

  class Server extends mongo_types_1.TypedEventEmitter {
    constructor(topology, description, options) {
      super();
      this.commandAsync = (0, util_1.promisify)((ns, cmd, options2, callback) => this.command(ns, cmd, options2, callback));
      this.serverApi = options.serverApi;
      const poolOptions = { hostAddress: description.hostAddress, ...options };
      this.topology = topology;
      this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
      this.s = {
        description,
        options,
        state: common_1.STATE_CLOSED,
        operationCount: 0
      };
      for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
        this.pool.on(event, (e2) => this.emit(event, e2));
      }
      this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
        this.clusterTime = clusterTime;
      });
      if (this.loadBalanced) {
        this.monitor = null;
        return;
      }
      this.monitor = new monitor_1.Monitor(this, this.s.options);
      for (const event of constants_1.HEARTBEAT_EVENTS) {
        this.monitor.on(event, (e2) => this.emit(event, e2));
      }
      this.monitor.on("resetServer", (error21) => markServerUnknown(this, error21));
      this.monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
        this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
        }));
        if (this.s.state === common_1.STATE_CONNECTING) {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(Server.CONNECT, this);
        }
      });
    }
    get clusterTime() {
      return this.topology.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.topology.clusterTime = clusterTime;
    }
    get description() {
      return this.s.description;
    }
    get name() {
      return this.s.description.address;
    }
    get autoEncrypter() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }
      return;
    }
    get loadBalanced() {
      return this.topology.description.type === common_1.TopologyType.LoadBalanced;
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      if (!this.loadBalanced) {
        this.monitor?.connect();
      } else {
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Server.CONNECT, this);
      }
    }
    destroy(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = { force: false };
      }
      options = Object.assign({}, { force: false }, options);
      if (this.s.state === common_1.STATE_CLOSED) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      if (!this.loadBalanced) {
        this.monitor?.close();
      }
      this.pool.close(options, (err) => {
        stateTransition(this, common_1.STATE_CLOSED);
        this.emit("closed");
        if (typeof callback === "function") {
          callback(err);
        }
      });
    }
    requestCheck() {
      if (!this.loadBalanced) {
        this.monitor?.requestCheck();
      }
    }
    command(ns, cmd, options, callback) {
      if (callback == null) {
        throw new error_1.MongoInvalidArgumentError("Callback must be provided");
      }
      if (ns.db == null || typeof ns === "string") {
        throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
      }
      if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
        callback(new error_1.MongoServerClosedError);
        return;
      }
      const finalOptions = Object.assign({}, options, { wireProtocolCommand: false });
      if (finalOptions.omitReadPreference) {
        delete finalOptions.readPreference;
      }
      const session = finalOptions.session;
      const conn = session?.pinnedConnection;
      if (this.loadBalanced && session && conn == null && isPinnableCommand(cmd, session)) {
        this.pool.checkOut((err, checkedOut) => {
          if (err || checkedOut == null) {
            if (callback)
              return callback(err);
            return;
          }
          session.pin(checkedOut);
          this.command(ns, cmd, finalOptions, callback);
        });
        return;
      }
      this.incrementOperationCount();
      this.pool.withConnection(conn, (err, conn2, cb) => {
        if (err || !conn2) {
          this.decrementOperationCount();
          if (!err) {
            return cb(new error_1.MongoRuntimeError("Failed to create connection without error"));
          }
          if (!(err instanceof errors_1.PoolClearedError)) {
            this.handleError(err);
          }
          return cb(err);
        }
        conn2.command(ns, cmd, finalOptions, makeOperationHandler(this, conn2, cmd, finalOptions, (error21, response) => {
          this.decrementOperationCount();
          cb(error21, response);
        }));
      }, callback);
    }
    handleError(error21, connection) {
      if (!(error21 instanceof error_1.MongoError)) {
        return;
      }
      const isStaleError = error21.connectionGeneration && error21.connectionGeneration < this.pool.generation;
      if (isStaleError) {
        return;
      }
      const isNetworkNonTimeoutError = error21 instanceof error_1.MongoNetworkError && !(error21 instanceof error_1.MongoNetworkTimeoutError);
      const isNetworkTimeoutBeforeHandshakeError = (0, error_1.isNetworkErrorBeforeHandshake)(error21);
      const isAuthHandshakeError = error21.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
      if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
        if (!this.loadBalanced) {
          error21.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
          markServerUnknown(this, error21);
        } else if (connection) {
          this.pool.clear({ serviceId: connection.serviceId });
        }
      } else {
        if ((0, error_1.isSDAMUnrecoverableError)(error21)) {
          if (shouldHandleStateChangeError(this, error21)) {
            const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error21);
            if (this.loadBalanced && connection && shouldClearPool) {
              this.pool.clear({ serviceId: connection.serviceId });
            }
            if (!this.loadBalanced) {
              if (shouldClearPool) {
                error21.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
              }
              markServerUnknown(this, error21);
              process.nextTick(() => this.requestCheck());
            }
          }
        }
      }
    }
    decrementOperationCount() {
      return this.s.operationCount -= 1;
    }
    incrementOperationCount() {
      return this.s.operationCount += 1;
    }
  }
  Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
  Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
  Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
  Server.CONNECT = constants_1.CONNECT;
  Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
  Server.CLOSED = constants_1.CLOSED;
  Server.ENDED = constants_1.ENDED;
  exports.Server = Server;
});

// node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS((exports) => {
  var isInCloseState = function(monitor) {
    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
  };
  var resetMonitorState = function(monitor) {
    monitor[kMonitorId]?.stop();
    monitor[kMonitorId] = undefined;
    monitor.rttPinger?.close();
    monitor.rttPinger = undefined;
    monitor[kCancellationToken].emit("cancel");
    monitor[kConnection]?.destroy({ force: true });
    monitor[kConnection] = undefined;
  };
  var useStreamingProtocol = function(monitor, topologyVersion) {
    if (topologyVersion == null)
      return false;
    const serverMonitoringMode = monitor.options.serverMonitoringMode;
    if (serverMonitoringMode === exports.ServerMonitoringMode.poll)
      return false;
    if (serverMonitoringMode === exports.ServerMonitoringMode.stream)
      return true;
    if (monitor.isRunningInFaasEnv)
      return false;
    return true;
  };
  var checkServer = function(monitor, callback) {
    let start = (0, utils_1.now)();
    const topologyVersion = monitor[kServer].description.topologyVersion;
    const isAwaitable = useStreamingProtocol(monitor, topologyVersion);
    monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
    function failureHandler(err, awaited3) {
      monitor[kConnection]?.destroy({ force: true });
      monitor[kConnection] = undefined;
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited3));
      const error21 = !(err instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err }) : err;
      error21.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
      if (error21 instanceof error_1.MongoNetworkTimeoutError) {
        error21.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
      }
      monitor.emit("resetServer", error21);
      callback(err);
    }
    const connection = monitor[kConnection];
    if (connection && !connection.closed) {
      const { serverApi, helloOk } = connection;
      const connectTimeoutMS = monitor.options.connectTimeoutMS;
      const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
      const cmd = {
        [serverApi?.version || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
        ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
      };
      const options = isAwaitable ? {
        socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
        exhaustAllowed: true
      } : { socketTimeoutMS: connectTimeoutMS };
      if (isAwaitable && monitor.rttPinger == null) {
        monitor.rttPinger = new RTTPinger(monitor[kCancellationToken], Object.assign({ heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS }, monitor.connectOptions));
      }
      connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options, (err, hello) => {
        if (err) {
          return failureHandler(err, isAwaitable);
        }
        if (!("isWritablePrimary" in hello)) {
          hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
        }
        const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
        if (isAwaitable) {
          monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
          start = (0, utils_1.now)();
        } else {
          monitor.rttPinger?.close();
          monitor.rttPinger = undefined;
          callback(undefined, hello);
        }
      });
      return;
    }
    (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {
      if (err) {
        monitor[kConnection] = undefined;
        failureHandler(err, false);
        return;
      }
      if (conn) {
        conn.isMonitoringConnection = true;
        if (isInCloseState(monitor)) {
          conn.destroy({ force: true });
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello, useStreamingProtocol(monitor, conn.hello?.topologyVersion)));
        callback(undefined, conn.hello);
      }
    });
  };
  var monitorServer = function(monitor) {
    return (callback) => {
      if (monitor.s.state === STATE_MONITORING) {
        process.nextTick(callback);
        return;
      }
      stateTransition(monitor, STATE_MONITORING);
      function done() {
        if (!isInCloseState(monitor)) {
          stateTransition(monitor, STATE_IDLE);
        }
        callback();
      }
      checkServer(monitor, (err, hello) => {
        if (err) {
          if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
            return done();
          }
        }
        if (useStreamingProtocol(monitor, hello?.topologyVersion)) {
          (0, timers_1.setTimeout)(() => {
            if (!isInCloseState(monitor)) {
              monitor[kMonitorId]?.wake();
            }
          }, 0);
        }
        done();
      });
    };
  };
  var makeTopologyVersion = function(tv) {
    return {
      processId: tv.processId,
      counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
    };
  };
  var measureRoundTripTime = function(rttPinger, options) {
    const start = (0, utils_1.now)();
    options.cancellationToken = rttPinger[kCancellationToken];
    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    if (rttPinger.closed) {
      return;
    }
    function measureAndReschedule(conn) {
      if (rttPinger.closed) {
        conn?.destroy({ force: true });
        return;
      }
      if (rttPinger.connection == null) {
        rttPinger.connection = conn;
      }
      rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);
      rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);
    }
    const connection = rttPinger.connection;
    if (connection == null) {
      (0, connect_1.connect)(options, (err, conn) => {
        if (err) {
          rttPinger.connection = undefined;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule(conn);
      });
      return;
    }
    const commandName = connection.serverApi?.version || connection.helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND;
    connection.commandAsync((0, utils_1.ns)("admin.$cmd"), { [commandName]: 1 }, undefined).then(() => measureAndReschedule(), () => {
      rttPinger.connection?.destroy({ force: true });
      rttPinger.connection = undefined;
      rttPinger[kRoundTripTime] = 0;
      return;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = undefined;
  var timers_1 = import.meta.require("timers");
  var bson_1 = require_bson2();
  var connect_1 = require_connect();
  var connection_1 = require_connection();
  var client_metadata_1 = require_client_metadata();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var events_1 = require_events();
  var server_1 = require_server();
  var kServer = Symbol("server");
  var kMonitorId = Symbol("monitorId");
  var kConnection = Symbol("connection");
  var kCancellationToken = Symbol("cancellationToken");
  var kRoundTripTime = Symbol("roundTripTime");
  var STATE_IDLE = "idle";
  var STATE_MONITORING = "monitoring";
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
  });
  var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
  exports.ServerMonitoringMode = Object.freeze({
    auto: "auto",
    poll: "poll",
    stream: "stream"
  });

  class Monitor extends mongo_types_1.TypedEventEmitter {
    get connection() {
      return this[kConnection];
    }
    constructor(server, options) {
      super();
      this[kServer] = server;
      this[kConnection] = undefined;
      this[kCancellationToken] = new mongo_types_1.CancellationToken;
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kMonitorId] = undefined;
      this.s = {
        state: common_1.STATE_CLOSED
      };
      this.address = server.description.address;
      this.options = Object.freeze({
        connectTimeoutMS: options.connectTimeoutMS ?? 1e4,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 1e4,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,
        serverMonitoringMode: options.serverMonitoringMode
      });
      this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;
      const cancellationToken = this[kCancellationToken];
      const connectOptions = Object.assign({
        id: "<monitor>",
        generation: server.pool.generation,
        connectionType: connection_1.Connection,
        cancellationToken,
        hostAddress: server.description.hostAddress
      }, options, {
        raw: false,
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: true
      });
      delete connectOptions.credentials;
      if (connectOptions.autoEncrypter) {
        delete connectOptions.autoEncrypter;
      }
      this.connectOptions = Object.freeze(connectOptions);
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS,
        immediate: true
      });
    }
    requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }
      this[kMonitorId]?.wake();
    }
    reset() {
      const topologyVersion = this[kServer].description.topologyVersion;
      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      stateTransition(this, STATE_IDLE);
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS
      });
    }
    close() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      this.emit("close");
      stateTransition(this, common_1.STATE_CLOSED);
    }
  }
  exports.Monitor = Monitor;

  class RTTPinger {
    constructor(cancellationToken, options) {
      this.connection = undefined;
      this[kCancellationToken] = cancellationToken;
      this[kRoundTripTime] = 0;
      this.closed = false;
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
    }
    get roundTripTime() {
      return this[kRoundTripTime];
    }
    close() {
      this.closed = true;
      (0, timers_1.clearTimeout)(this[kMonitorId]);
      this.connection?.destroy({ force: true });
      this.connection = undefined;
    }
  }
  exports.RTTPinger = RTTPinger;

  class MonitorInterval {
    constructor(fn, options = {}) {
      this.isExpeditedCallToFnScheduled = false;
      this.stopped = false;
      this.isExecutionInProgress = false;
      this.hasExecutedOnce = false;
      this._executeAndReschedule = () => {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.isExpeditedCallToFnScheduled = false;
        this.isExecutionInProgress = true;
        this.fn(() => {
          this.lastExecutionEnded = (0, utils_1.now)();
          this.isExecutionInProgress = false;
          this._reschedule(this.heartbeatFrequencyMS);
        });
      };
      this.fn = fn;
      this.lastExecutionEnded = (-Infinity);
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;
      this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;
      if (options.immediate) {
        this._executeAndReschedule();
      } else {
        this._reschedule(undefined);
      }
    }
    wake() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      if (timeSinceLastCall < 0) {
        return this._executeAndReschedule();
      }
      if (this.isExecutionInProgress) {
        return;
      }
      if (this.isExpeditedCallToFnScheduled) {
        return;
      }
      if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
        this.isExpeditedCallToFnScheduled = true;
        this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
        return;
      }
      this._executeAndReschedule();
    }
    stop() {
      this.stopped = true;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
        this.timerId = undefined;
      }
      this.lastExecutionEnded = (-Infinity);
      this.isExpeditedCallToFnScheduled = false;
    }
    toString() {
      return JSON.stringify(this);
    }
    toJSON() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      return {
        timerId: this.timerId != null ? "set" : "cleared",
        lastCallTime: this.lastExecutionEnded,
        isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
        stopped: this.stopped,
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
        currentTime,
        timeSinceLastCall
      };
    }
    _reschedule(ms) {
      if (this.stopped)
        return;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
      }
      this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
    }
  }
  exports.MonitorInterval = MonitorInterval;
});

// node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS((exports) => {
  async function resolveSRVRecord(options) {
    if (typeof options.srvHost !== "string") {
      throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
    }
    if (options.srvHost.split(".").length < 3) {
      throw new error_1.MongoAPIError("URI must include hostname, domain name, and tld");
    }
    const lookupAddress = options.srvHost;
    const addresses = await dns.promises.resolveSrv(`_${options.srvServiceName}._tcp.${lookupAddress}`);
    if (addresses.length === 0) {
      throw new error_1.MongoAPIError("No addresses found at host");
    }
    for (const { name } of addresses) {
      if (!(0, utils_1.matchesParentDomain)(name, lookupAddress)) {
        throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
      }
    }
    const hostAddresses = addresses.map((r) => utils_1.HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
    validateLoadBalancedOptions(hostAddresses, options, true);
    let record3;
    try {
      record3 = await dns.promises.resolveTxt(lookupAddress);
    } catch (error21) {
      if (error21.code !== "ENODATA" && error21.code !== "ENOTFOUND") {
        throw error21;
      }
      return hostAddresses;
    }
    if (record3.length > 1) {
      throw new error_1.MongoParseError("Multiple text records not allowed");
    }
    const txtRecordOptions = new url_1.URLSearchParams(record3[0].join(""));
    const txtRecordOptionKeys = [...txtRecordOptions.keys()];
    if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
      throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
    }
    if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
      throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
    }
    const source = txtRecordOptions.get("authSource") ?? undefined;
    const replicaSet = txtRecordOptions.get("replicaSet") ?? undefined;
    const loadBalanced = txtRecordOptions.get("loadBalanced") ?? undefined;
    if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
      options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
    }
    if (!options.userSpecifiedReplicaSet && replicaSet) {
      options.replicaSet = replicaSet;
    }
    if (loadBalanced === "true") {
      options.loadBalanced = true;
    }
    if (options.replicaSet && options.srvMaxHosts > 0) {
      throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
    }
    validateLoadBalancedOptions(hostAddresses, options, true);
    return hostAddresses;
  }
  var checkTLSOptions = function(allOptions) {
    if (!allOptions)
      return;
    const check10 = (a2, b2) => {
      if (allOptions.has(a2) && allOptions.has(b2)) {
        throw new error_1.MongoAPIError(`The '${a2}' option cannot be used with the '${b2}' option`);
      }
    };
    check10("tlsInsecure", "tlsAllowInvalidCertificates");
    check10("tlsInsecure", "tlsAllowInvalidHostnames");
    check10("tlsInsecure", "tlsDisableCertificateRevocationCheck");
    check10("tlsInsecure", "tlsDisableOCSPEndpointCheck");
    check10("tlsAllowInvalidCertificates", "tlsDisableCertificateRevocationCheck");
    check10("tlsAllowInvalidCertificates", "tlsDisableOCSPEndpointCheck");
    check10("tlsDisableCertificateRevocationCheck", "tlsDisableOCSPEndpointCheck");
  };
  var getBoolean = function(name, value14) {
    if (typeof value14 === "boolean")
      return value14;
    switch (value14) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new error_1.MongoParseError(`${name} must be either "true" or "false"`);
    }
  };
  var getIntFromOptions = function(name, value14) {
    const parsedInt = (0, utils_1.parseInteger)(value14);
    if (parsedInt != null) {
      return parsedInt;
    }
    throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value14}`);
  };
  var getUIntFromOptions = function(name, value14) {
    const parsedValue = getIntFromOptions(name, value14);
    if (parsedValue < 0) {
      throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value14}`);
    }
    return parsedValue;
  };
  function* entriesFromString(value14) {
    if (value14 === "") {
      return;
    }
    const keyValuePairs = value14.split(",");
    for (const keyValue of keyValuePairs) {
      const [key, value15] = keyValue.split(/:(.*)/);
      if (value15 == null) {
        throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
      }
      yield [key, value15];
    }
  }
  var parseOptions = function(uri, mongoClient = undefined, options = {}) {
    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
      options = mongoClient;
      mongoClient = undefined;
    }
    if (options.useBigInt64 && typeof options.promoteLongs === "boolean" && !options.promoteLongs) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    if (options.useBigInt64 && typeof options.promoteValues === "boolean" && !options.promoteValues) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    const url = new mongodb_connection_string_url_1.default(uri);
    const { hosts, isSRV } = url;
    const mongoOptions = Object.create(null);
    for (const flag of Object.getOwnPropertySymbols(options)) {
      if (exports.FEATURE_FLAGS.has(flag)) {
        mongoOptions[flag] = options[flag];
      }
    }
    mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
    const urlOptions = new CaseInsensitiveMap;
    if (url.pathname !== "/" && url.pathname !== "") {
      const dbName = decodeURIComponent(url.pathname[0] === "/" ? url.pathname.slice(1) : url.pathname);
      if (dbName) {
        urlOptions.set("dbName", [dbName]);
      }
    }
    if (url.username !== "") {
      const auth = {
        username: decodeURIComponent(url.username)
      };
      if (typeof url.password === "string") {
        auth.password = decodeURIComponent(url.password);
      }
      urlOptions.set("auth", [auth]);
    }
    for (const key of url.searchParams.keys()) {
      const values = url.searchParams.getAll(key);
      const isReadPreferenceTags = /readPreferenceTags/i.test(key);
      if (!isReadPreferenceTags && values.length > 1) {
        throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
      }
      if (!isReadPreferenceTags && values.includes("")) {
        throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
      }
      if (!urlOptions.has(key)) {
        urlOptions.set(key, values);
      }
    }
    const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v2]) => v2 != null));
    if (urlOptions.has("serverApi")) {
      throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
    }
    const uriMechanismProperties = urlOptions.get("authMechanismProperties");
    if (uriMechanismProperties) {
      for (const property of uriMechanismProperties) {
        if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
          throw new error_1.MongoParseError("Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.");
        }
      }
    }
    if (objectOptions.has("loadBalanced")) {
      throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
    }
    const allProvidedOptions = new CaseInsensitiveMap;
    const allProvidedKeys = new Set([...urlOptions.keys(), ...objectOptions.keys()]);
    for (const key of allProvidedKeys) {
      const values = [];
      const objectOptionValue = objectOptions.get(key);
      if (objectOptionValue != null) {
        values.push(objectOptionValue);
      }
      const urlValues = urlOptions.get(key) ?? [];
      values.push(...urlValues);
      allProvidedOptions.set(key, values);
    }
    if (allProvidedOptions.has("tls") || allProvidedOptions.has("ssl")) {
      const tlsAndSslOpts = (allProvidedOptions.get("tls") || []).concat(allProvidedOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
      if (new Set(tlsAndSslOpts).size !== 1) {
        throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
      }
    }
    checkTLSOptions(allProvidedOptions);
    const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map((s2) => s2.toLowerCase()));
    if (unsupportedOptions.size !== 0) {
      const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
      const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
      throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
    }
    for (const [key, descriptor] of Object.entries(exports.OPTIONS)) {
      const values = allProvidedOptions.get(key);
      if (!values || values.length === 0) {
        if (exports.DEFAULT_OPTIONS.has(key)) {
          setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
        }
      } else {
        const { deprecated } = descriptor;
        if (deprecated) {
          const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
          (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
        }
        setOption(mongoOptions, key, descriptor, values);
      }
    }
    if (mongoOptions.credentials) {
      const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
      const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
      const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
      const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
      if ((isGssapi || isX509) && allProvidedOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
        throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '\$external'`);
      }
      if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has("authSource")) {
        mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
          source: mongoOptions.dbName
        });
      }
      if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
        throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
      }
      mongoOptions.credentials.validate();
      if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
        delete mongoOptions.credentials;
      }
    }
    if (!mongoOptions.dbName) {
      mongoOptions.dbName = "test";
    }
    validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
    if (mongoClient && mongoOptions.autoEncryption) {
      encrypter_1.Encrypter.checkForMongoCrypt();
      mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
      mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
    }
    mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
    mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
    if (isSRV) {
      mongoOptions.srvHost = hosts[0];
      if (mongoOptions.directConnection) {
        throw new error_1.MongoAPIError("SRV URI does not support directConnection");
      }
      if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
      }
      const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
      const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
      if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
        mongoOptions.tls = true;
      }
    } else {
      const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
      if (userSpecifiedSrvOptions) {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
      }
    }
    if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
      throw new error_1.MongoParseError("directConnection option requires exactly one host");
    }
    if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
      throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
    }
    if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
      throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
    }
    const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => urlOptions.get(key) ?? []);
    if (proxyOptions.some((options2) => options2.length > 1)) {
      throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
    }
    const loggerFeatureFlag = Symbol.for("@@mdb.enableMongoLogger");
    mongoOptions[loggerFeatureFlag] = mongoOptions[loggerFeatureFlag] ?? false;
    let loggerEnvOptions = {};
    let loggerClientOptions = {};
    if (mongoOptions[loggerFeatureFlag]) {
      loggerEnvOptions = {
        MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
        MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
        MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
        MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
        MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT,
        MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
        MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
        MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH,
        ...mongoOptions[Symbol.for("@@mdb.internalLoggerConfig")]
      };
      loggerClientOptions = {
        mongodbLogPath: mongoOptions.mongodbLogPath,
        mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
        mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
      };
    }
    mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions(loggerEnvOptions, loggerClientOptions);
    mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
    return mongoOptions;
  };
  var validateLoadBalancedOptions = function(hosts, mongoOptions, isSrv) {
    if (mongoOptions.loadBalanced) {
      if (hosts.length > 1) {
        throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
      }
      if (mongoOptions.replicaSet) {
        throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
      }
      if (mongoOptions.directConnection) {
        throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
      }
      if (isSrv && mongoOptions.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
      }
    }
    return;
  };
  var setOption = function(mongoOptions, key, descriptor, values) {
    const { target, type: type73, transform: transform5 } = descriptor;
    const name = target ?? key;
    switch (type73) {
      case "boolean":
        mongoOptions[name] = getBoolean(name, values[0]);
        break;
      case "int":
        mongoOptions[name] = getIntFromOptions(name, values[0]);
        break;
      case "uint":
        mongoOptions[name] = getUIntFromOptions(name, values[0]);
        break;
      case "string":
        if (values[0] == null) {
          break;
        }
        mongoOptions[name] = String(values[0]);
        break;
      case "record":
        if (!(0, utils_1.isRecord)(values[0])) {
          throw new error_1.MongoParseError(`${name} must be an object`);
        }
        mongoOptions[name] = values[0];
        break;
      case "any":
        mongoOptions[name] = values[0];
        break;
      default: {
        if (!transform5) {
          throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
        }
        const transformValue = transform5({ name, options: mongoOptions, values });
        mongoOptions[name] = transformValue;
        break;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FEATURE_FLAGS = exports.DEFAULT_OPTIONS = exports.OPTIONS = exports.parseOptions = exports.resolveSRVRecord = undefined;
  var dns = import.meta.require("dns");
  var mongodb_connection_string_url_1 = require_lib2();
  var url_1 = import.meta.require("url");
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var client_metadata_1 = require_client_metadata();
  var compression_1 = require_compression();
  var encrypter_1 = require_encrypter();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_logger_1 = require_mongo_logger();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var monitor_1 = require_monitor();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
  var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
  var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
  var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
  exports.resolveSRVRecord = resolveSRVRecord;

  class CaseInsensitiveMap extends Map {
    constructor(entries = []) {
      super(entries.map(([k, v2]) => [k.toLowerCase(), v2]));
    }
    has(k) {
      return super.has(k.toLowerCase());
    }
    get(k) {
      return super.get(k.toLowerCase());
    }
    set(k, v2) {
      return super.set(k.toLowerCase(), v2);
    }
    delete(k) {
      return super.delete(k.toLowerCase());
    }
  }
  exports.parseOptions = parseOptions;
  exports.OPTIONS = {
    appName: {
      type: "string"
    },
    auth: {
      target: "credentials",
      transform({ name, options, values: [value14] }) {
        if (!(0, utils_1.isRecord)(value14, ["username", "password"])) {
          throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          username: value14.username,
          password: value14.password
        });
      }
    },
    authMechanism: {
      target: "credentials",
      transform({ options, values: [value14] }) {
        const mechanisms = Object.values(providers_1.AuthMechanism);
        const [mechanism] = mechanisms.filter((m2) => m2.match(RegExp(String.raw`\b${value14}\b`, "i")));
        if (!mechanism) {
          throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value14}`);
        }
        let source = options.credentials?.source;
        if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
          source = "$external";
        }
        let password = options.credentials?.password;
        if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
          password = undefined;
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanism,
          source,
          password
        });
      }
    },
    authMechanismProperties: {
      target: "credentials",
      transform({ options, values }) {
        let mechanismProperties = Object.create(null);
        for (const optionValue of values) {
          if (typeof optionValue === "string") {
            for (const [key, value14] of entriesFromString(optionValue)) {
              try {
                mechanismProperties[key] = getBoolean(key, value14);
              } catch {
                mechanismProperties[key] = value14;
              }
            }
          } else {
            if (!(0, utils_1.isRecord)(optionValue)) {
              throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
            }
            mechanismProperties = { ...optionValue };
          }
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanismProperties
        });
      }
    },
    authSource: {
      target: "credentials",
      transform({ options, values: [value14] }) {
        const source = String(value14);
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
      }
    },
    autoEncryption: {
      type: "record"
    },
    bsonRegExp: {
      type: "boolean"
    },
    serverApi: {
      target: "serverApi",
      transform({ values: [version] }) {
        const serverApiToValidate = typeof version === "string" ? { version } : version;
        const versionToValidate = serverApiToValidate && serverApiToValidate.version;
        if (!versionToValidate) {
          throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        if (!Object.values(mongo_client_1.ServerApiVersion).some((v2) => v2 === versionToValidate)) {
          throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        return serverApiToValidate;
      }
    },
    checkKeys: {
      type: "boolean"
    },
    compressors: {
      default: "none",
      target: "compressors",
      transform({ values }) {
        const compressionList = new Set;
        for (const compVal of values) {
          const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
          if (!Array.isArray(compValArray)) {
            throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
          }
          for (const c2 of compValArray) {
            if (Object.keys(compression_1.Compressor).includes(String(c2))) {
              compressionList.add(String(c2));
            } else {
              throw new error_1.MongoInvalidArgumentError(`${c2} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
            }
          }
        }
        return [...compressionList];
      }
    },
    connectTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    dbName: {
      type: "string"
    },
    directConnection: {
      default: false,
      type: "boolean"
    },
    driverInfo: {
      default: {},
      type: "record"
    },
    enableUtf8Validation: { type: "boolean", default: true },
    family: {
      transform({ name, values: [value14] }) {
        const transformValue = getIntFromOptions(name, value14);
        if (transformValue === 4 || transformValue === 6) {
          return transformValue;
        }
        throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
      }
    },
    fieldsAsRaw: {
      type: "record"
    },
    forceServerObjectId: {
      default: false,
      type: "boolean"
    },
    fsync: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value14] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            fsync: getBoolean(name, value14)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value14}`);
        return wc;
      }
    },
    heartbeatFrequencyMS: {
      default: 1e4,
      type: "uint"
    },
    ignoreUndefined: {
      type: "boolean"
    },
    j: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value14] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value14)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value14}`);
        return wc;
      }
    },
    journal: {
      target: "writeConcern",
      transform({ name, options, values: [value14] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value14)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value14}`);
        return wc;
      }
    },
    loadBalanced: {
      default: false,
      type: "boolean"
    },
    localThresholdMS: {
      default: 15,
      type: "uint"
    },
    maxConnecting: {
      default: 2,
      transform({ name, values: [value14] }) {
        const maxConnecting = getUIntFromOptions(name, value14);
        if (maxConnecting === 0) {
          throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
        }
        return maxConnecting;
      }
    },
    maxIdleTimeMS: {
      default: 0,
      type: "uint"
    },
    maxPoolSize: {
      default: 100,
      type: "uint"
    },
    maxStalenessSeconds: {
      target: "readPreference",
      transform({ name, options, values: [value14] }) {
        const maxStalenessSeconds = getUIntFromOptions(name, value14);
        if (options.readPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, maxStalenessSeconds }
          });
        } else {
          return new read_preference_1.ReadPreference("secondary", undefined, { maxStalenessSeconds });
        }
      }
    },
    minInternalBufferSize: {
      type: "uint"
    },
    minPoolSize: {
      default: 0,
      type: "uint"
    },
    minHeartbeatFrequencyMS: {
      default: 500,
      type: "uint"
    },
    monitorCommands: {
      default: false,
      type: "boolean"
    },
    name: {
      target: "driverInfo",
      transform({ values: [value14], options }) {
        return { ...options.driverInfo, name: String(value14) };
      }
    },
    noDelay: {
      default: true,
      type: "boolean"
    },
    pkFactory: {
      default: utils_1.DEFAULT_PK_FACTORY,
      transform({ values: [value14] }) {
        if ((0, utils_1.isRecord)(value14, ["createPk"]) && typeof value14.createPk === "function") {
          return value14;
        }
        throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value14}`);
      }
    },
    promoteBuffers: {
      type: "boolean"
    },
    promoteLongs: {
      type: "boolean"
    },
    promoteValues: {
      type: "boolean"
    },
    useBigInt64: {
      type: "boolean"
    },
    proxyHost: {
      type: "string"
    },
    proxyPassword: {
      type: "string"
    },
    proxyPort: {
      type: "uint"
    },
    proxyUsername: {
      type: "string"
    },
    raw: {
      default: false,
      type: "boolean"
    },
    readConcern: {
      transform({ values: [value14], options }) {
        if (value14 instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value14, ["level"])) {
          return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value14 });
        }
        throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value14)}`);
      }
    },
    readConcernLevel: {
      target: "readConcern",
      transform({ values: [level], options }) {
        return read_concern_1.ReadConcern.fromOptions({
          ...options.readConcern,
          level
        });
      }
    },
    readPreference: {
      default: read_preference_1.ReadPreference.primary,
      transform({ values: [value14], options }) {
        if (value14 instanceof read_preference_1.ReadPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value14 },
            ...value14
          });
        }
        if ((0, utils_1.isRecord)(value14, ["mode"])) {
          const rp = read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value14 },
            ...value14
          });
          if (rp)
            return rp;
          else
            throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value14)}`);
        }
        if (typeof value14 === "string") {
          const rpOpts = {
            hedge: options.readPreference?.hedge,
            maxStalenessSeconds: options.readPreference?.maxStalenessSeconds
          };
          return new read_preference_1.ReadPreference(value14, options.readPreference?.tags, rpOpts);
        }
        throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value14}`);
      }
    },
    readPreferenceTags: {
      target: "readPreference",
      transform({ values, options }) {
        const tags = Array.isArray(values[0]) ? values[0] : values;
        const readPreferenceTags = [];
        for (const tag of tags) {
          const readPreferenceTag = Object.create(null);
          if (typeof tag === "string") {
            for (const [k, v2] of entriesFromString(tag)) {
              readPreferenceTag[k] = v2;
            }
          }
          if ((0, utils_1.isRecord)(tag)) {
            for (const [k, v2] of Object.entries(tag)) {
              readPreferenceTag[k] = v2;
            }
          }
          readPreferenceTags.push(readPreferenceTag);
        }
        return read_preference_1.ReadPreference.fromOptions({
          readPreference: options.readPreference,
          readPreferenceTags
        });
      }
    },
    replicaSet: {
      type: "string"
    },
    retryReads: {
      default: true,
      type: "boolean"
    },
    retryWrites: {
      default: true,
      type: "boolean"
    },
    serializeFunctions: {
      type: "boolean"
    },
    serverMonitoringMode: {
      default: "auto",
      transform({ values: [value14] }) {
        if (!Object.values(monitor_1.ServerMonitoringMode).includes(value14)) {
          throw new error_1.MongoParseError("serverMonitoringMode must be one of `auto`, `poll`, or `stream`");
        }
        return value14;
      }
    },
    serverSelectionTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    servername: {
      type: "string"
    },
    socketTimeoutMS: {
      default: 0,
      type: "uint"
    },
    srvMaxHosts: {
      type: "uint",
      default: 0
    },
    srvServiceName: {
      type: "string",
      default: "mongodb"
    },
    ssl: {
      target: "tls",
      type: "boolean"
    },
    tls: {
      type: "boolean"
    },
    tlsAllowInvalidCertificates: {
      target: "rejectUnauthorized",
      transform({ name, values: [value14] }) {
        return !getBoolean(name, value14);
      }
    },
    tlsAllowInvalidHostnames: {
      target: "checkServerIdentity",
      transform({ name, values: [value14] }) {
        return getBoolean(name, value14) ? () => {
          return;
        } : undefined;
      }
    },
    tlsCAFile: {
      type: "string"
    },
    tlsCRLFile: {
      type: "string"
    },
    tlsCertificateKeyFile: {
      type: "string"
    },
    tlsCertificateKeyFilePassword: {
      target: "passphrase",
      type: "any"
    },
    tlsInsecure: {
      transform({ name, options, values: [value14] }) {
        const tlsInsecure = getBoolean(name, value14);
        if (tlsInsecure) {
          options.checkServerIdentity = () => {
            return;
          };
          options.rejectUnauthorized = false;
        } else {
          options.checkServerIdentity = options.tlsAllowInvalidHostnames ? () => {
            return;
          } : undefined;
          options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
        }
        return tlsInsecure;
      }
    },
    w: {
      target: "writeConcern",
      transform({ values: [value14], options }) {
        return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value14 } });
      }
    },
    waitQueueTimeoutMS: {
      default: 0,
      type: "uint"
    },
    writeConcern: {
      target: "writeConcern",
      transform({ values: [value14], options }) {
        if ((0, utils_1.isRecord)(value14) || value14 instanceof write_concern_1.WriteConcern) {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              ...value14
            }
          });
        } else if (value14 === "majority" || typeof value14 === "number") {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              w: value14
            }
          });
        }
        throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value14)}`);
      }
    },
    wtimeout: {
      deprecated: "Please use wtimeoutMS instead",
      target: "writeConcern",
      transform({ values: [value14], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeout: getUIntFromOptions("wtimeout", value14)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    wtimeoutMS: {
      target: "writeConcern",
      transform({ values: [value14], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeoutMS: getUIntFromOptions("wtimeoutMS", value14)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    zlibCompressionLevel: {
      default: 0,
      type: "int"
    },
    connectionType: { type: "any" },
    srvPoller: { type: "any" },
    minDHSize: { type: "any" },
    pskCallback: { type: "any" },
    secureContext: { type: "any" },
    enableTrace: { type: "any" },
    requestCert: { type: "any" },
    rejectUnauthorized: { type: "any" },
    checkServerIdentity: { type: "any" },
    ALPNProtocols: { type: "any" },
    SNICallback: { type: "any" },
    session: { type: "any" },
    requestOCSP: { type: "any" },
    localAddress: { type: "any" },
    localPort: { type: "any" },
    hints: { type: "any" },
    lookup: { type: "any" },
    ca: { type: "any" },
    cert: { type: "any" },
    ciphers: { type: "any" },
    crl: { type: "any" },
    ecdhCurve: { type: "any" },
    key: { type: "any" },
    passphrase: { type: "any" },
    pfx: { type: "any" },
    secureProtocol: { type: "any" },
    index: { type: "any" },
    useNewUrlParser: {
      type: "boolean",
      deprecated: "useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
    },
    useUnifiedTopology: {
      type: "boolean",
      deprecated: "useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
    },
    mongodbLogPath: { type: "any" },
    mongodbLogComponentSeverities: { type: "any" },
    mongodbLogMaxDocumentLength: { type: "uint" }
  };
  exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d2]) => [k, d2.default]));
  exports.FEATURE_FLAGS = new Set([
    Symbol.for("@@mdb.skipPingOnConnect"),
    Symbol.for("@@mdb.enableMongoLogger"),
    Symbol.for("@@mdb.internalLoggerConfig")
  ]);
});

// node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SrvPoller = exports.SrvPollingEvent = undefined;
  var dns = import.meta.require("dns");
  var timers_1 = import.meta.require("timers");
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();

  class SrvPollingEvent {
    constructor(srvRecords) {
      this.srvRecords = srvRecords;
    }
    hostnames() {
      return new Set(this.srvRecords.map((r) => utils_1.HostAddress.fromSrvRecord(r).toString()));
    }
  }
  exports.SrvPollingEvent = SrvPollingEvent;

  class SrvPoller extends mongo_types_1.TypedEventEmitter {
    constructor(options) {
      super();
      if (!options || !options.srvHost) {
        throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
      }
      this.srvHost = options.srvHost;
      this.srvMaxHosts = options.srvMaxHosts ?? 0;
      this.srvServiceName = options.srvServiceName ?? "mongodb";
      this.rescanSrvIntervalMS = 60000;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1e4;
      this.haMode = false;
      this.generation = 0;
      this._timeout = undefined;
    }
    get srvAddress() {
      return `_${this.srvServiceName}._tcp.${this.srvHost}`;
    }
    get intervalMS() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
    stop() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
        this.generation += 1;
        this._timeout = undefined;
      }
    }
    schedule() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
      }
      this._timeout = (0, timers_1.setTimeout)(() => {
        this._poll().catch(() => null);
      }, this.intervalMS);
    }
    success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
    failure() {
      this.haMode = true;
      this.schedule();
    }
    async _poll() {
      const generation = this.generation;
      let srvRecords;
      try {
        srvRecords = await dns.promises.resolveSrv(this.srvAddress);
      } catch (dnsError) {
        this.failure();
        return;
      }
      if (generation !== this.generation) {
        return;
      }
      const finalAddresses = [];
      for (const record3 of srvRecords) {
        if ((0, utils_1.matchesParentDomain)(record3.name, this.srvHost)) {
          finalAddresses.push(record3);
        }
      }
      if (!finalAddresses.length) {
        this.failure();
        return;
      }
      this.success(finalAddresses);
    }
  }
  SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
  exports.SrvPoller = SrvPoller;
});

// node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS((exports) => {
  var destroyServer = function(server, topology, options, callback) {
    options = options ?? { force: false };
    for (const event of constants_1.LOCAL_SERVER_EVENTS) {
      server.removeAllListeners(event);
    }
    server.destroy(options, () => {
      topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server.removeAllListeners(event);
      }
      if (typeof callback === "function") {
        callback();
      }
    });
  };
  var topologyTypeFromOptions = function(options) {
    if (options?.directConnection) {
      return common_1.TopologyType.Single;
    }
    if (options?.replicaSet) {
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
    if (options?.loadBalanced) {
      return common_1.TopologyType.LoadBalanced;
    }
    return common_1.TopologyType.Unknown;
  };
  var createAndConnectServer = function(topology, serverDescription) {
    topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new server_1.Server(topology, serverDescription, topology.s.options);
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
      server.on(event, (e2) => topology.emit(event, e2));
    }
    server.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
    server.connect();
    return server;
  };
  var updateServers = function(topology, incomingServerDescription) {
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
      const server = topology.s.servers.get(incomingServerDescription.address);
      if (server) {
        server.s.description = incomingServerDescription;
        if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
          const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
          server.pool.clear({ interruptInUseConnections });
        } else if (incomingServerDescription.error == null) {
          const newTopologyType = topology.s.description.type;
          const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
          if (shouldMarkPoolReady) {
            server.pool.ready();
          }
        }
      }
    }
    for (const serverDescription of topology.description.servers.values()) {
      if (!topology.s.servers.has(serverDescription.address)) {
        const server = createAndConnectServer(topology, serverDescription);
        topology.s.servers.set(serverDescription.address, server);
      }
    }
    for (const entry of topology.s.servers) {
      const serverAddress = entry[0];
      if (topology.description.hasServer(serverAddress)) {
        continue;
      }
      if (!topology.s.servers.has(serverAddress)) {
        continue;
      }
      const server = topology.s.servers.get(serverAddress);
      topology.s.servers.delete(serverAddress);
      if (server) {
        destroyServer(server, topology);
      }
    }
  };
  var drainWaitQueue = function(queue, err) {
    while (queue.length) {
      const waitQueueMember = queue.shift();
      if (!waitQueueMember) {
        continue;
      }
      waitQueueMember.timeoutController.clear();
      if (!waitQueueMember[kCancelled]) {
        waitQueueMember.callback(err);
      }
    }
  };
  var processWaitQueue = function(topology) {
    if (topology.s.state === common_1.STATE_CLOSED) {
      drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError);
      return;
    }
    const isSharded = topology.description.type === common_1.TopologyType.Sharded;
    const serverDescriptions = Array.from(topology.description.servers.values());
    const membersToProcess = topology[kWaitQueue].length;
    for (let i2 = 0;i2 < membersToProcess; ++i2) {
      const waitQueueMember = topology[kWaitQueue].shift();
      if (!waitQueueMember) {
        continue;
      }
      if (waitQueueMember[kCancelled]) {
        continue;
      }
      let selectedDescriptions;
      try {
        const serverSelector = waitQueueMember.serverSelector;
        selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
      } catch (e2) {
        waitQueueMember.timeoutController.clear();
        waitQueueMember.callback(e2);
        continue;
      }
      let selectedServer;
      if (selectedDescriptions.length === 0) {
        topology[kWaitQueue].push(waitQueueMember);
        continue;
      } else if (selectedDescriptions.length === 1) {
        selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
      } else {
        const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
        const server1 = topology.s.servers.get(descriptions[0].address);
        const server2 = topology.s.servers.get(descriptions[1].address);
        selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
      }
      if (!selectedServer) {
        waitQueueMember.callback(new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description));
        return;
      }
      const transaction = waitQueueMember.transaction;
      if (isSharded && transaction && transaction.isActive && selectedServer) {
        transaction.pinServer(selectedServer);
      }
      waitQueueMember.timeoutController.clear();
      waitQueueMember.callback(undefined, selectedServer);
    }
    if (topology[kWaitQueue].length > 0) {
      for (const [, server] of topology.s.servers) {
        process.nextTick(function scheduleServerCheck() {
          return server.requestCheck();
        });
      }
    }
  };
  var isStaleServerDescription = function(topologyDescription, incomingServerDescription) {
    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    const currentTopologyVersion = currentServerDescription?.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCapabilities = exports.Topology = undefined;
  var util_1 = import.meta.require("util");
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var events_1 = require_events();
  var server_1 = require_server();
  var server_description_1 = require_server_description();
  var server_selection_1 = require_server_selection();
  var srv_polling_1 = require_srv_polling();
  var topology_description_1 = require_topology_description();
  var globalTopologyCounter = 0;
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });
  var kCancelled = Symbol("cancelled");
  var kWaitQueue = Symbol("waitQueue");

  class Topology extends mongo_types_1.TypedEventEmitter {
    constructor(client, seeds, options) {
      super();
      this.client = client;
      this.selectServerAsync = (0, util_1.promisify)((selector, options2, callback) => this.selectServer(selector, options2, callback));
      options = options ?? {
        hosts: [utils_1.HostAddress.fromString("localhost:27017")],
        ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries()),
        ...Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries())
      };
      if (typeof seeds === "string") {
        seeds = [utils_1.HostAddress.fromString(seeds)];
      } else if (!Array.isArray(seeds)) {
        seeds = [seeds];
      }
      const seedlist = [];
      for (const seed of seeds) {
        if (typeof seed === "string") {
          seedlist.push(utils_1.HostAddress.fromString(seed));
        } else if (seed instanceof utils_1.HostAddress) {
          seedlist.push(seed);
        } else {
          throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
        }
      }
      const topologyType = topologyTypeFromOptions(options);
      const topologyId = globalTopologyCounter++;
      const selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
      const serverDescriptions = new Map;
      for (const hostAddress of selectedHosts) {
        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
      }
      this[kWaitQueue] = new utils_1.List;
      this.s = {
        id: topologyId,
        options,
        seedlist,
        state: common_1.STATE_CLOSED,
        description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
        serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
        servers: new Map,
        credentials: options?.credentials,
        clusterTime: undefined,
        connectionTimers: new Set,
        detectShardedTopology: (ev) => this.detectShardedTopology(ev),
        detectSrvRecords: (ev) => this.detectSrvRecords(ev)
      };
      if (options.srvHost && !options.loadBalanced) {
        this.s.srvPoller = options.srvPoller ?? new srv_polling_1.SrvPoller({
          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
          srvHost: options.srvHost,
          srvMaxHosts: options.srvMaxHosts,
          srvServiceName: options.srvServiceName
        });
        this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
      }
    }
    detectShardedTopology(event) {
      const previousType = event.previousDescription.type;
      const newType = event.newDescription.type;
      const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
      const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
      const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
      if (transitionToSharded && !listeningToSrvPolling) {
        this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        this.s.srvPoller?.start();
      }
    }
    detectSrvRecords(ev) {
      const previousTopologyDescription = this.s.description;
      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
      if (this.s.description === previousTopologyDescription) {
        return;
      }
      updateServers(this);
      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    get description() {
      return this.s.description;
    }
    get loadBalanced() {
      return this.s.options.loadBalanced;
    }
    get capabilities() {
      return new ServerCapabilities(this.lastHello());
    }
    connect(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ?? {};
      if (this.s.state === common_1.STATE_CONNECTED) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), this.s.description));
      const serverDescriptions = Array.from(this.s.description.servers.values());
      this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
        serverDescription.address,
        createAndConnectServer(this, serverDescription)
      ]));
      if (this.s.options.loadBalanced) {
        for (const description of serverDescriptions) {
          const newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
            loadBalanced: this.s.options.loadBalanced
          });
          this.serverUpdateHandler(newDescription);
        }
      }
      const exitWithError = (error21) => callback ? callback(error21) : this.emit(Topology.ERROR, error21);
      const readPreference = options.readPreference ?? read_preference_1.ReadPreference.primary;
      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, (err, server) => {
        if (err) {
          return this.close({ force: false }, () => exitWithError(err));
        }
        const skipPingOnConnect = this.s.options[Symbol.for("@@mdb.skipPingOnConnect")] === true;
        if (!skipPingOnConnect && server && this.s.credentials) {
          server.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, {}, (err2) => {
            if (err2) {
              return exitWithError(err2);
            }
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(Topology.OPEN, this);
            this.emit(Topology.CONNECT, this);
            callback?.(undefined, this);
          });
          return;
        }
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Topology.OPEN, this);
        this.emit(Topology.CONNECT, this);
        callback?.(undefined, this);
      });
    }
    close(options, callback) {
      options = options ?? { force: false };
      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
        return callback?.();
      }
      const destroyedServers = Array.from(this.s.servers.values(), (server) => {
        return (0, util_1.promisify)(destroyServer)(server, this, { force: !!options?.force });
      });
      Promise.all(destroyedServers).then(() => {
        this.s.servers.clear();
        stateTransition(this, common_1.STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError);
        (0, common_1.drainTimerQueue)(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        }
        this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        stateTransition(this, common_1.STATE_CLOSED);
        this.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
      }).finally(() => callback?.());
    }
    selectServer(selector, options, callback) {
      let serverSelector;
      if (typeof selector !== "function") {
        if (typeof selector === "string") {
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
        } else {
          let readPreference;
          if (selector instanceof read_preference_1.ReadPreference) {
            readPreference = selector;
          } else {
            read_preference_1.ReadPreference.translate(options);
            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
          }
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
        }
      } else {
        serverSelector = selector;
      }
      options = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options);
      const isSharded = this.description.type === common_1.TopologyType.Sharded;
      const session = options.session;
      const transaction = session && session.transaction;
      if (isSharded && transaction && transaction.server) {
        callback(undefined, transaction.server);
        return;
      }
      const waitQueueMember = {
        serverSelector,
        transaction,
        callback,
        timeoutController: new utils_1.TimeoutController(options.serverSelectionTimeoutMS)
      };
      waitQueueMember.timeoutController.signal.addEventListener("abort", () => {
        waitQueueMember[kCancelled] = true;
        waitQueueMember.timeoutController.clear();
        const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${options.serverSelectionTimeoutMS} ms`, this.description);
        waitQueueMember.callback(timeoutError);
      });
      this[kWaitQueue].push(waitQueueMember);
      processWaitQueue(this);
    }
    serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      }
      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      }
      const previousTopologyDescription = this.s.description;
      const previousServerDescription = this.s.description.servers.get(serverDescription.address);
      if (!previousServerDescription) {
        return;
      }
      const clusterTime = serverDescription.$clusterTime;
      if (clusterTime) {
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
      this.s.description = this.s.description.update(serverDescription);
      if (this.s.description.compatibilityError) {
        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
        return;
      }
      if (!equalDescriptions) {
        const newDescription = this.s.description.servers.get(serverDescription.address);
        if (newDescription) {
          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
        }
      }
      updateServers(this, serverDescription);
      if (this[kWaitQueue].length > 0) {
        processWaitQueue(this);
      }
      if (!equalDescriptions) {
        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
    auth(credentials, callback) {
      if (typeof credentials === "function")
        callback = credentials, credentials = undefined;
      if (typeof callback === "function")
        callback(undefined, true);
    }
    get clientMetadata() {
      return this.s.options.metadata;
    }
    isConnected() {
      return this.s.state === common_1.STATE_CONNECTED;
    }
    isDestroyed() {
      return this.s.state === common_1.STATE_CLOSED;
    }
    lastHello() {
      const serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0)
        return {};
      const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
      const result = sd || { maxWireVersion: this.description.commonWireVersion };
      return result;
    }
    get commonWireVersion() {
      return this.description.commonWireVersion;
    }
    get logicalSessionTimeoutMinutes() {
      return this.description.logicalSessionTimeoutMinutes;
    }
    get clusterTime() {
      return this.s.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  }
  Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
  Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
  Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
  Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
  Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
  Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
  Topology.ERROR = constants_1.ERROR;
  Topology.OPEN = constants_1.OPEN;
  Topology.CONNECT = constants_1.CONNECT;
  Topology.CLOSE = constants_1.CLOSE;
  Topology.TIMEOUT = constants_1.TIMEOUT;
  exports.Topology = Topology;

  class ServerCapabilities {
    constructor(hello) {
      this.minWireVersion = hello.minWireVersion || 0;
      this.maxWireVersion = hello.maxWireVersion || 0;
    }
    get hasAggregationCursor() {
      return this.maxWireVersion >= 1;
    }
    get hasWriteCommands() {
      return this.maxWireVersion >= 2;
    }
    get hasTextSearch() {
      return this.minWireVersion >= 0;
    }
    get hasAuthCommands() {
      return this.maxWireVersion >= 1;
    }
    get hasListCollectionsCommand() {
      return this.maxWireVersion >= 3;
    }
    get hasListIndexesCommand() {
      return this.maxWireVersion >= 3;
    }
    get supportsSnapshotReads() {
      return this.maxWireVersion >= 13;
    }
    get commandsTakeWriteConcern() {
      return this.maxWireVersion >= 5;
    }
    get commandsTakeCollation() {
      return this.maxWireVersion >= 5;
    }
  }
  exports.ServerCapabilities = ServerCapabilities;
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoClient = exports.ServerApiVersion = undefined;
  var fs_1 = import.meta.require("fs");
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants2();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_preference_1 = require_read_preference();
  var server_selection_1 = require_server_selection();
  var topology_1 = require_topology();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  exports.ServerApiVersion = Object.freeze({
    v1: "1"
  });
  var kOptions = Symbol("options");

  class MongoClient extends mongo_types_1.TypedEventEmitter {
    constructor(url, options) {
      super();
      this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);
      this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions);
      const client = this;
      this.s = {
        url,
        bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),
        namespace: (0, utils_1.ns)("admin"),
        hasBeenClosed: false,
        sessionPool: new sessions_1.ServerSessionPool(this),
        activeSessions: new Set,
        get options() {
          return client[kOptions];
        },
        get readConcern() {
          return client[kOptions].readConcern;
        },
        get writeConcern() {
          return client[kOptions].writeConcern;
        },
        get readPreference() {
          return client[kOptions].readPreference;
        },
        get isMongoClient() {
          return true;
        }
      };
      this.checkForNonGenuineHosts();
    }
    checkForNonGenuineHosts() {
      const documentDBHostnames = this[kOptions].hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, hostAddress.host));
      const srvHostIsDocumentDB = (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, this[kOptions].srvHost);
      const cosmosDBHostnames = this[kOptions].hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, hostAddress.host));
      const srvHostIsCosmosDB = (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, this[kOptions].srvHost);
      if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
        this.mongoLogger.info("client", utils_1.DOCUMENT_DB_MSG);
      } else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
        this.mongoLogger.info("client", utils_1.COSMOS_DB_MSG);
      }
    }
    get options() {
      return Object.freeze({ ...this[kOptions] });
    }
    get serverApi() {
      return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });
    }
    get monitorCommands() {
      return this[kOptions].monitorCommands;
    }
    set monitorCommands(value14) {
      this[kOptions].monitorCommands = value14;
    }
    get autoEncrypter() {
      return this[kOptions].autoEncrypter;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get readPreference() {
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    async connect() {
      if (this.connectionLock) {
        return this.connectionLock;
      }
      try {
        this.connectionLock = this._connect();
        await this.connectionLock;
      } finally {
        this.connectionLock = undefined;
      }
      return this;
    }
    async _connect() {
      if (this.topology && this.topology.isConnected()) {
        return this;
      }
      const options = this[kOptions];
      if (options.tls) {
        if (typeof options.tlsCAFile === "string") {
          options.ca ??= await fs_1.promises.readFile(options.tlsCAFile);
        }
        if (typeof options.tlsCRLFile === "string") {
          options.crl ??= await fs_1.promises.readFile(options.tlsCRLFile);
        }
        if (typeof options.tlsCertificateKeyFile === "string") {
          if (!options.key || !options.cert) {
            const contents = await fs_1.promises.readFile(options.tlsCertificateKeyFile);
            options.key ??= contents;
            options.cert ??= contents;
          }
        }
      }
      if (typeof options.srvHost === "string") {
        const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
        for (const [index, host] of hosts.entries()) {
          options.hosts[index] = host;
        }
      }
      if (options.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        const allowedHosts = options.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
        const isServiceAuth = !!options.credentials?.mechanismProperties?.PROVIDER_NAME;
        if (!isServiceAuth) {
          for (const host of options.hosts) {
            if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
              throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(",")}'`);
            }
          }
        }
      }
      this.topology = new topology_1.Topology(this, options.hosts, options);
      this.topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
      for (const event of constants_1.MONGO_CLIENT_EVENTS) {
        this.topology.on(event, (...args) => this.emit(event, ...args));
      }
      const topologyConnect = async () => {
        try {
          await (0, util_1.promisify)((callback) => this.topology?.connect(options, callback))();
        } catch (error21) {
          this.topology?.close({ force: true });
          throw error21;
        }
      };
      if (this.autoEncrypter) {
        await this.autoEncrypter?.init();
        await topologyConnect();
        await options.encrypter.connectInternalClient();
      } else {
        await topologyConnect();
      }
      return this;
    }
    async close(force = false) {
      Object.defineProperty(this.s, "hasBeenClosed", {
        value: true,
        enumerable: true,
        configurable: false,
        writable: false
      });
      const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
      this.s.activeSessions.clear();
      await Promise.all(activeSessionEnds);
      if (this.topology == null) {
        return;
      }
      const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
      const topologyDescription = this.topology.description;
      const serverDescriptions = Array.from(topologyDescription.servers.values());
      const servers = selector(topologyDescription, serverDescriptions);
      if (servers.length !== 0) {
        const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
        if (endSessions.length !== 0) {
          await (0, execute_operation_1.executeOperation)(this, new run_command_1.RunAdminCommandOperation({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true })).catch(() => null);
        }
      }
      const topology = this.topology;
      this.topology = undefined;
      await new Promise((resolve, reject) => {
        topology.close({ force }, (error21) => {
          if (error21)
            return reject(error21);
          const { encrypter } = this[kOptions];
          if (encrypter) {
            return encrypter.closeCallback(this, force, (error22) => {
              if (error22)
                return reject(error22);
              resolve();
            });
          }
          resolve();
        });
      });
    }
    db(dbName, options) {
      options = options ?? {};
      if (!dbName) {
        dbName = this.options.dbName;
      }
      const finalOptions = Object.assign({}, this[kOptions], options);
      const db = new db_1.Db(this, dbName, finalOptions);
      return db;
    }
    static async connect(url, options) {
      const client = new this(url, options);
      return client.connect();
    }
    startSession(options) {
      const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this[kOptions]);
      this.s.activeSessions.add(session);
      session.once("ended", () => {
        this.s.activeSessions.delete(session);
      });
      return session;
    }
    async withSession(optionsOrExecutor, executor) {
      const options = {
        owner: Symbol(),
        ...typeof optionsOrExecutor === "object" ? optionsOrExecutor : {}
      };
      const withSessionCallback = typeof optionsOrExecutor === "function" ? optionsOrExecutor : executor;
      if (withSessionCallback == null) {
        throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
      }
      const session = this.startSession(options);
      try {
        return await withSessionCallback(session);
      } finally {
        try {
          await session.endSession();
        } catch {
        }
      }
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
  }
  exports.MongoClient = MongoClient;
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStream = undefined;
  var collection_1 = require_collection();
  var constants_1 = require_constants2();
  var change_stream_cursor_1 = require_change_stream_cursor();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var kCursorStream = Symbol("cursorStream");
  var kClosed = Symbol("closed");
  var kMode = Symbol("mode");
  var CHANGE_STREAM_OPTIONS = [
    "resumeAfter",
    "startAfter",
    "startAtOperationTime",
    "fullDocument",
    "fullDocumentBeforeChange",
    "showExpandedEvents"
  ];
  var CHANGE_DOMAIN_TYPES = {
    COLLECTION: Symbol("Collection"),
    DATABASE: Symbol("Database"),
    CLUSTER: Symbol("Cluster")
  };
  var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
  var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
  var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";

  class ChangeStream extends mongo_types_1.TypedEventEmitter {
    constructor(parent, pipeline = [], options = {}) {
      super();
      this.pipeline = pipeline;
      this.options = { ...options };
      delete this.options.writeConcern;
      if (parent instanceof collection_1.Collection) {
        this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
      } else if (parent instanceof db_1.Db) {
        this.type = CHANGE_DOMAIN_TYPES.DATABASE;
      } else if (parent instanceof mongo_client_1.MongoClient) {
        this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
      } else {
        throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
      }
      this.parent = parent;
      this.namespace = parent.s.namespace;
      if (!this.options.readPreference && parent.readPreference) {
        this.options.readPreference = parent.readPreference;
      }
      this.cursor = this._createChangeStreamCursor(options);
      this[kClosed] = false;
      this[kMode] = false;
      this.on("newListener", (eventName) => {
        if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
          this._streamEvents(this.cursor);
        }
      });
      this.on("removeListener", (eventName) => {
        if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
          this[kCursorStream]?.removeAllListeners("data");
        }
      });
    }
    get cursorStream() {
      return this[kCursorStream];
    }
    get resumeToken() {
      return this.cursor?.resumeToken;
    }
    async hasNext() {
      this._setIsIterator();
      while (true) {
        try {
          const hasNext = await this.cursor.hasNext();
          return hasNext;
        } catch (error21) {
          try {
            await this._processErrorIteratorMode(error21);
          } catch (error22) {
            try {
              await this.close();
            } catch {
            }
            throw error22;
          }
        }
      }
    }
    async next() {
      this._setIsIterator();
      while (true) {
        try {
          const change = await this.cursor.next();
          const processedChange = this._processChange(change ?? null);
          return processedChange;
        } catch (error21) {
          try {
            await this._processErrorIteratorMode(error21);
          } catch (error22) {
            try {
              await this.close();
            } catch {
            }
            throw error22;
          }
        }
      }
    }
    async tryNext() {
      this._setIsIterator();
      while (true) {
        try {
          const change = await this.cursor.tryNext();
          return change ?? null;
        } catch (error21) {
          try {
            await this._processErrorIteratorMode(error21);
          } catch (error22) {
            try {
              await this.close();
            } catch {
            }
            throw error22;
          }
        }
      }
    }
    async* [Symbol.asyncIterator]() {
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          yield await this.next();
        }
      } finally {
        try {
          await this.close();
        } catch {
        }
      }
    }
    get closed() {
      return this[kClosed] || this.cursor.closed;
    }
    async close() {
      this[kClosed] = true;
      const cursor = this.cursor;
      try {
        await cursor.close();
      } finally {
        this._endStream();
      }
    }
    stream(options) {
      if (this.closed) {
        throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
      }
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    _setIsEmitter() {
      if (this[kMode] === "iterator") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
      }
      this[kMode] = "emitter";
    }
    _setIsIterator() {
      if (this[kMode] === "emitter") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
      }
      this[kMode] = "iterator";
    }
    _createChangeStreamCursor(options) {
      const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
      if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
      const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;
      if (client == null) {
        throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
      }
      const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, options);
      for (const event of CHANGE_STREAM_EVENTS) {
        changeStreamCursor.on(event, (e2) => this.emit(event, e2));
      }
      if (this.listenerCount(ChangeStream.CHANGE) > 0) {
        this._streamEvents(changeStreamCursor);
      }
      return changeStreamCursor;
    }
    _closeEmitterModeWithError(error21) {
      this.emit(ChangeStream.ERROR, error21);
      this.close().catch(() => null);
    }
    _streamEvents(cursor) {
      this._setIsEmitter();
      const stream = this[kCursorStream] ?? cursor.stream();
      this[kCursorStream] = stream;
      stream.on("data", (change) => {
        try {
          const processedChange = this._processChange(change);
          this.emit(ChangeStream.CHANGE, processedChange);
        } catch (error21) {
          this.emit(ChangeStream.ERROR, error21);
        }
      });
      stream.on("error", (error21) => this._processErrorStreamMode(error21));
    }
    _endStream() {
      const cursorStream = this[kCursorStream];
      if (cursorStream) {
        ["data", "close", "end", "error"].forEach((event) => cursorStream.removeAllListeners(event));
        cursorStream.destroy();
      }
      this[kCursorStream] = undefined;
    }
    _processChange(change) {
      if (this[kClosed]) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change == null) {
        throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change && !change._id) {
        throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
      }
      this.cursor.cacheResumeToken(change._id);
      this.options.startAtOperationTime = undefined;
      return change;
    }
    _processErrorStreamMode(changeStreamError) {
      if (this[kClosed])
        return;
      if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        this._endStream();
        this.cursor.close().catch(() => null);
        const topology = (0, utils_1.getTopology)(this.parent);
        topology.selectServer(this.cursor.readPreference, {}, (serverSelectionError) => {
          if (serverSelectionError)
            return this._closeEmitterModeWithError(changeStreamError);
          this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
        });
      } else {
        this._closeEmitterModeWithError(changeStreamError);
      }
    }
    async _processErrorIteratorMode(changeStreamError) {
      if (this[kClosed]) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (!(0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        try {
          await this.close();
        } catch {
        }
        throw changeStreamError;
      }
      await this.cursor.close().catch(() => null);
      const topology = (0, utils_1.getTopology)(this.parent);
      try {
        await topology.selectServerAsync(this.cursor.readPreference, {});
        this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
      } catch {
        await this.close();
        throw changeStreamError;
      }
    }
  }
  ChangeStream.RESPONSE = constants_1.RESPONSE;
  ChangeStream.MORE = constants_1.MORE;
  ChangeStream.INIT = constants_1.INIT;
  ChangeStream.CLOSE = constants_1.CLOSE;
  ChangeStream.CHANGE = constants_1.CHANGE;
  ChangeStream.END = constants_1.END;
  ChangeStream.ERROR = constants_1.ERROR;
  ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
  exports.ChangeStream = ChangeStream;
});

// node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS((exports) => {
  var throwIfInitialized = function(stream) {
    if (stream.s.init) {
      throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
    }
  };
  var doRead = function(stream) {
    if (stream.destroyed)
      return;
    if (!stream.s.cursor)
      return;
    if (!stream.s.file)
      return;
    const handleReadResult = ({ error: error21, doc }) => {
      if (stream.destroyed) {
        return;
      }
      if (error21) {
        stream.destroy(error21);
        return;
      }
      if (!doc) {
        stream.push(null);
        stream.s.cursor?.close().then(() => null, (error22) => stream.destroy(error22));
        return;
      }
      if (!stream.s.file)
        return;
      const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
      const expectedN = stream.s.expected++;
      const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
      if (doc.n > expectedN) {
        return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      if (doc.n < expectedN) {
        return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
      if (buf.byteLength !== expectedLength) {
        if (bytesRemaining <= 0) {
          return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
        }
        return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
      }
      stream.s.bytesRead += buf.byteLength;
      if (buf.byteLength === 0) {
        return stream.push(null);
      }
      let sliceStart = null;
      let sliceEnd = null;
      if (stream.s.bytesToSkip != null) {
        sliceStart = stream.s.bytesToSkip;
        stream.s.bytesToSkip = 0;
      }
      const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
      const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
      if (atEndOfStream && stream.s.bytesToTrim != null) {
        sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
      } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
        sliceEnd = bytesLeftToRead;
      }
      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
      }
      stream.push(buf);
      return;
    };
    stream.s.cursor.next().then((doc) => handleReadResult({ error: null, doc }), (error21) => handleReadResult({ error: error21, doc: null }));
  };
  var init = function(stream) {
    const findOneOptions = {};
    if (stream.s.readPreference) {
      findOneOptions.readPreference = stream.s.readPreference;
    }
    if (stream.s.options && stream.s.options.sort) {
      findOneOptions.sort = stream.s.options.sort;
    }
    if (stream.s.options && stream.s.options.skip) {
      findOneOptions.skip = stream.s.options.skip;
    }
    const handleReadResult = ({ error: error21, doc }) => {
      if (error21) {
        return stream.destroy(error21);
      }
      if (!doc) {
        const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
        const errmsg = `FileNotFound: file ${identifier} was not found`;
        const err = new error_1.MongoRuntimeError(errmsg);
        err.code = "ENOENT";
        return stream.destroy(err);
      }
      if (doc.length <= 0) {
        stream.push(null);
        return;
      }
      if (stream.destroyed) {
        stream.destroy();
        return;
      }
      try {
        stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
      } catch (error22) {
        return stream.destroy(error22);
      }
      const filter = { files_id: doc._id };
      if (stream.s.options && stream.s.options.start != null) {
        const skip = Math.floor(stream.s.options.start / doc.chunkSize);
        if (skip > 0) {
          filter["n"] = { $gte: skip };
        }
      }
      stream.s.cursor = stream.s.chunks.find(filter).sort({ n: 1 });
      if (stream.s.readPreference) {
        stream.s.cursor.withReadPreference(stream.s.readPreference);
      }
      stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      stream.s.file = doc;
      try {
        stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
      } catch (error22) {
        return stream.destroy(error22);
      }
      stream.emit(GridFSBucketReadStream.FILE, doc);
      return;
    };
    stream.s.files.findOne(stream.s.filter, findOneOptions).then((doc) => handleReadResult({ error: null, doc }), (error21) => handleReadResult({ error: error21, doc: null }));
  };
  var waitForFile = function(stream, callback) {
    if (stream.s.file) {
      return callback();
    }
    if (!stream.s.init) {
      init(stream);
      stream.s.init = true;
    }
    stream.once("file", () => {
      callback();
    });
  };
  var handleStartOption = function(stream, doc, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
      }
      if (options.end != null && options.end < options.start) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
      }
      stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream.s.expected = Math.floor(options.start / doc.chunkSize);
      return options.start - stream.s.bytesRead;
    }
    throw new error_1.MongoInvalidArgumentError("Start option must be defined");
  };
  var handleEndOption = function(stream, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start == null || options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
      }
      const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
      stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
    throw new error_1.MongoInvalidArgumentError("End option must be defined");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketReadStream = undefined;
  var stream_1 = import.meta.require("stream");
  var error_1 = require_error();

  class GridFSBucketReadStream extends stream_1.Readable {
    constructor(chunks, files, readPreference, filter, options) {
      super({ emitClose: true });
      this.s = {
        bytesToTrim: 0,
        bytesToSkip: 0,
        bytesRead: 0,
        chunks,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        options: {
          start: 0,
          end: 0,
          ...options
        },
        readPreference
      };
    }
    _read() {
      if (this.destroyed)
        return;
      waitForFile(this, () => doRead(this));
    }
    start(start = 0) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    }
    end(end = 0) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    }
    async abort() {
      this.push(null);
      this.destroy();
      await this.s.cursor?.close();
    }
  }
  GridFSBucketReadStream.FILE = "file";
  exports.GridFSBucketReadStream = GridFSBucketReadStream;
});

// node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS((exports) => {
  var handleError = function(stream, error21, callback) {
    if (stream.state.errored) {
      process.nextTick(callback);
      return;
    }
    stream.state.errored = true;
    process.nextTick(callback, error21);
  };
  var createChunkDoc = function(filesId, n2, data) {
    return {
      _id: new bson_1.ObjectId,
      files_id: filesId,
      n: n2,
      data
    };
  };
  async function checkChunksIndex(stream) {
    const index = { files_id: 1, n: 1 };
    let indexes;
    try {
      indexes = await stream.chunks.listIndexes().toArray();
    } catch (error21) {
      if (error21 instanceof error_1.MongoError && error21.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error21;
      }
    }
    const hasChunksIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
        return true;
      }
      return false;
    });
    if (!hasChunksIndex) {
      await stream.chunks.createIndex(index, {
        ...stream.writeConcern,
        background: true,
        unique: true
      });
    }
  }
  var checkDone = function(stream, callback) {
    if (stream.done) {
      return process.nextTick(callback);
    }
    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
      stream.done = true;
      const gridFSFile = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
      if (isAborted(stream, callback)) {
        return;
      }
      stream.files.insertOne(gridFSFile, { writeConcern: stream.writeConcern }).then(() => {
        stream.gridFSFile = gridFSFile;
        callback();
      }, (error21) => handleError(stream, error21, callback));
      return;
    }
    process.nextTick(callback);
  };
  async function checkIndexes(stream) {
    const doc = await stream.files.findOne({}, { projection: { _id: 1 } });
    if (doc != null) {
      return;
    }
    const index = { filename: 1, uploadDate: 1 };
    let indexes;
    try {
      indexes = await stream.files.listIndexes().toArray();
    } catch (error21) {
      if (error21 instanceof error_1.MongoError && error21.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error21;
      }
    }
    const hasFileIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
        return true;
      }
      return false;
    });
    if (!hasFileIndex) {
      await stream.files.createIndex(index, { background: false });
    }
    await checkChunksIndex(stream);
  }
  var createFilesDoc = function(_id, length, chunkSize, filename, contentType, aliases, metadata) {
    const ret = {
      _id,
      length,
      chunkSize,
      uploadDate: new Date,
      filename
    };
    if (contentType) {
      ret.contentType = contentType;
    }
    if (aliases) {
      ret.aliases = aliases;
    }
    if (metadata) {
      ret.metadata = metadata;
    }
    return ret;
  };
  var doWrite = function(stream, chunk, encoding, callback) {
    if (isAborted(stream, callback)) {
      return;
    }
    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
    stream.length += inputBuf.length;
    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
      inputBuf.copy(stream.bufToStore, stream.pos);
      stream.pos += inputBuf.length;
      process.nextTick(callback);
      return;
    }
    let inputBufRemaining = inputBuf.length;
    let spaceRemaining = stream.chunkSizeBytes - stream.pos;
    let numToCopy = Math.min(spaceRemaining, inputBuf.length);
    let outstandingRequests = 0;
    while (inputBufRemaining > 0) {
      const inputBufPos = inputBuf.length - inputBufRemaining;
      inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
      stream.pos += numToCopy;
      spaceRemaining -= numToCopy;
      let doc;
      if (spaceRemaining === 0) {
        doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
        ++stream.state.outstandingRequests;
        ++outstandingRequests;
        if (isAborted(stream, callback)) {
          return;
        }
        stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern }).then(() => {
          --stream.state.outstandingRequests;
          --outstandingRequests;
          if (!outstandingRequests) {
            checkDone(stream, callback);
          }
        }, (error21) => handleError(stream, error21, callback));
        spaceRemaining = stream.chunkSizeBytes;
        stream.pos = 0;
        ++stream.n;
      }
      inputBufRemaining -= numToCopy;
      numToCopy = Math.min(spaceRemaining, inputBufRemaining);
    }
  };
  var writeRemnant = function(stream, callback) {
    if (stream.pos === 0) {
      return checkDone(stream, callback);
    }
    ++stream.state.outstandingRequests;
    const remnant = Buffer.alloc(stream.pos);
    stream.bufToStore.copy(remnant, 0, 0, stream.pos);
    const doc = createChunkDoc(stream.id, stream.n, remnant);
    if (isAborted(stream, callback)) {
      return;
    }
    stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern }).then(() => {
      --stream.state.outstandingRequests;
      checkDone(stream, callback);
    }, (error21) => handleError(stream, error21, callback));
  };
  var isAborted = function(stream, callback) {
    if (stream.state.aborted) {
      process.nextTick(callback, new error_1.MongoAPIError("Stream has been aborted"));
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketWriteStream = undefined;
  var stream_1 = import.meta.require("stream");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var write_concern_1 = require_write_concern();

  class GridFSBucketWriteStream extends stream_1.Writable {
    constructor(bucket, filename, options) {
      super();
      this.gridFSFile = null;
      options = options ?? {};
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options;
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
      this.done = false;
      this.id = options.id ? options.id : new bson_1.ObjectId;
      this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
      this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        checkIndexes(this).then(() => {
          this.bucket.s.checkedIndexes = true;
          this.bucket.emit("index");
        }, () => null);
      }
    }
    _construct(callback) {
      if (this.bucket.s.checkedIndexes) {
        return process.nextTick(callback);
      }
      this.bucket.once("index", callback);
    }
    _write(chunk, encoding, callback) {
      doWrite(this, chunk, encoding, callback);
    }
    _final(callback) {
      if (this.state.streamEnd) {
        return process.nextTick(callback);
      }
      this.state.streamEnd = true;
      writeRemnant(this, callback);
    }
    async abort() {
      if (this.state.streamEnd) {
        throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
      }
      if (this.state.aborted) {
        throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
      }
      this.state.aborted = true;
      await this.chunks.deleteMany({ files_id: this.id });
    }
  }
  exports.GridFSBucketWriteStream = GridFSBucketWriteStream;
});

// node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucket = undefined;
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var write_concern_1 = require_write_concern();
  var download_1 = require_download();
  var upload_1 = require_upload();
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: "fs",
    chunkSizeBytes: 255 * 1024
  };

  class GridFSBucket extends mongo_types_1.TypedEventEmitter {
    constructor(db, options) {
      super();
      this.setMaxListeners(0);
      const privateOptions = {
        ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
        ...options,
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      };
      this.s = {
        db,
        options: privateOptions,
        _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
        _filesCollection: db.collection(privateOptions.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false
      };
    }
    openUploadStream(filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, options);
    }
    openUploadStreamWithId(id, filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, { ...options, id });
    }
    openDownloadStream(id, options) {
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, options);
    }
    async delete(id) {
      const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id });
      await this.s._chunksCollection.deleteMany({ files_id: id });
      if (deletedCount === 0) {
        throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
      }
    }
    find(filter = {}, options = {}) {
      return this.s._filesCollection.find(filter, options);
    }
    openDownloadStreamByName(filename, options) {
      let sort = { uploadDate: -1 };
      let skip = undefined;
      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { ...options, sort, skip });
    }
    async rename(id, filename) {
      const filter = { _id: id };
      const update = { $set: { filename } };
      const { matchedCount } = await this.s._filesCollection.updateOne(filter, update);
      if (matchedCount === 0) {
        throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
      }
    }
    async drop() {
      await this.s._filesCollection.drop();
      await this.s._chunksCollection.drop();
    }
  }
  GridFSBucket.INDEX = "index";
  exports.GridFSBucket = GridFSBucket;
});

// node_modules/mongodb/lib/client-side-encryption/client_encryption.js
var require_client_encryption = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientEncryption = undefined;
  var bson_1 = require_bson2();
  var deps_1 = require_deps();
  var utils_1 = require_utils();
  var cryptoCallbacks = require_crypto_callbacks();
  var errors_1 = require_errors();
  var index_1 = require_providers2();
  var state_machine_1 = require_state_machine();

  class ClientEncryption {
    static getMongoCrypt() {
      const encryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in encryption) {
        throw encryption.kModuleError;
      }
      return encryption.MongoCrypt;
    }
    constructor(client, options) {
      this._client = client;
      this._proxyOptions = options.proxyOptions ?? {};
      this._tlsOptions = options.tlsOptions ?? {};
      this._kmsProviders = options.kmsProviders || {};
      if (options.keyVaultNamespace == null) {
        throw new errors_1.MongoCryptInvalidArgumentError("Missing required option `keyVaultNamespace`");
      }
      const mongoCryptOptions = {
        ...options,
        cryptoCallbacks,
        kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders
      };
      this._keyVaultNamespace = options.keyVaultNamespace;
      this._keyVaultClient = options.keyVaultClient || client;
      const MongoCrypt = ClientEncryption.getMongoCrypt();
      this._mongoCrypt = new MongoCrypt(mongoCryptOptions);
    }
    async createDataKey(provider, options = {}) {
      if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {
        throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);
      }
      let keyAltNames = undefined;
      if (options.keyAltNames && options.keyAltNames.length > 0) {
        keyAltNames = options.keyAltNames.map((keyAltName, i2) => {
          if (typeof keyAltName !== "string") {
            throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but item at index ${i2} was of type ${typeof keyAltName}`);
          }
          return (0, bson_1.serialize)({ keyAltName });
        });
      }
      let keyMaterial = undefined;
      if (options.keyMaterial) {
        keyMaterial = (0, bson_1.serialize)({ keyMaterial: options.keyMaterial });
      }
      const dataKeyBson = (0, bson_1.serialize)({
        provider,
        ...options.masterKey
      });
      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {
        keyAltNames,
        keyMaterial
      });
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions
      });
      const dataKey = await stateMachine.execute(this, context);
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const { insertedId } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, { writeConcern: { w: "majority" } });
      return insertedId;
    }
    async rewrapManyDataKey(filter, options) {
      let keyEncryptionKeyBson = undefined;
      if (options) {
        const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);
        keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);
      }
      const filterBson = (0, bson_1.serialize)(filter);
      const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions
      });
      const { v: dataKeys } = await stateMachine.execute(this, context);
      if (dataKeys.length === 0) {
        return {};
      }
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const replacements = dataKeys.map((key) => ({
        updateOne: {
          filter: { _id: key._id },
          update: {
            $set: {
              masterKey: key.masterKey,
              keyMaterial: key.keyMaterial
            },
            $currentDate: {
              updateDate: true
            }
          }
        }
      }));
      const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {
        writeConcern: { w: "majority" }
      });
      return { bulkWriteResult: result };
    }
    async deleteKey(_id) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({ _id }, { writeConcern: { w: "majority" } });
    }
    getKeys() {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return this._keyVaultClient.db(dbName).collection(collectionName).find({}, { readConcern: { level: "majority" } });
    }
    async getKey(_id) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return this._keyVaultClient.db(dbName).collection(collectionName).findOne({ _id }, { readConcern: { level: "majority" } });
    }
    async getKeyByAltName(keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return this._keyVaultClient.db(dbName).collection(collectionName).findOne({ keyAltNames: keyAltName }, { readConcern: { level: "majority" } });
    }
    async addKeyAltName(_id, keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const value14 = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, { $addToSet: { keyAltNames: keyAltName } }, { writeConcern: { w: "majority" }, returnDocument: "before" });
      return value14;
    }
    async removeKeyAltName(_id, keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const pipeline = [
        {
          $set: {
            keyAltNames: {
              $cond: [
                {
                  $eq: ["$keyAltNames", [keyAltName]]
                },
                "$$REMOVE",
                {
                  $filter: {
                    input: "$keyAltNames",
                    cond: {
                      $ne: ["$$this", keyAltName]
                    }
                  }
                }
              ]
            }
          }
        }
      ];
      const value14 = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, pipeline, {
        writeConcern: { w: "majority" },
        returnDocument: "before"
      });
      return value14;
    }
    async createEncryptedCollection(db, name, options) {
      const { provider, masterKey, createCollectionOptions: { encryptedFields: { ...encryptedFields }, ...createCollectionOptions } } = options;
      if (Array.isArray(encryptedFields.fields)) {
        const createDataKeyPromises = encryptedFields.fields.map(async (field) => field == null || typeof field !== "object" || field.keyId != null ? field : {
          ...field,
          keyId: await this.createDataKey(provider, { masterKey })
        });
        const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);
        encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === "fulfilled" ? resolution.value : encryptedFields.fields[index]);
        const rejection = createDataKeyResolutions.find((result) => result.status === "rejected");
        if (rejection != null) {
          throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });
        }
      }
      try {
        const collection = await db.createCollection(name, {
          ...createCollectionOptions,
          encryptedFields
        });
        return { collection, encryptedFields };
      } catch (cause) {
        throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });
      }
    }
    async encrypt(value14, options) {
      return this._encrypt(value14, false, options);
    }
    async encryptExpression(expression, options) {
      return this._encrypt(expression, true, options);
    }
    async decrypt(value14) {
      const valueBuffer = (0, bson_1.serialize)({ v: value14 });
      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions
      });
      const { v: v2 } = await stateMachine.execute(this, context);
      return v2;
    }
    async askForKMSCredentials() {
      return (0, index_1.refreshKMSCredentials)(this._kmsProviders);
    }
    static get libmongocryptVersion() {
      return ClientEncryption.getMongoCrypt().libmongocryptVersion;
    }
    async _encrypt(value14, expressionMode, options) {
      const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;
      const contextOptions = {
        expressionMode,
        algorithm
      };
      if (keyId) {
        contextOptions.keyId = keyId.buffer;
      }
      if (keyAltName) {
        if (keyId) {
          throw new errors_1.MongoCryptInvalidArgumentError(`"options" cannot contain both "keyId" and "keyAltName"`);
        }
        if (typeof keyAltName !== "string") {
          throw new errors_1.MongoCryptInvalidArgumentError(`"options.keyAltName" must be of type string, but was of type ${typeof keyAltName}`);
        }
        contextOptions.keyAltName = (0, bson_1.serialize)({ keyAltName });
      }
      if (typeof contentionFactor === "number" || typeof contentionFactor === "bigint") {
        contextOptions.contentionFactor = contentionFactor;
      }
      if (typeof queryType === "string") {
        contextOptions.queryType = queryType;
      }
      if (typeof rangeOptions === "object") {
        contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);
      }
      const valueBuffer = (0, bson_1.serialize)({ v: value14 });
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions
      });
      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
      const result = await stateMachine.execute(this, context);
      return result.v;
    }
  }
  exports.ClientEncryption = ClientEncryption;
});

// node_modules/mongodb/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoServerSelectionError = exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.ClientEncryption = exports.MongoBulkWriteError = exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = undefined;
  exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.AutoEncryptionLoggerLevel = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = exports.AbstractCursor = exports.MongoWriteConcernError = undefined;
  exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptAzureKMSRequestError = exports.SrvPollingEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = exports.ServerClosedEvent = exports.ConnectionReadyEvent = undefined;
  var admin_1 = require_admin();
  Object.defineProperty(exports, "Admin", { enumerable: true, get: function() {
    return admin_1.Admin;
  } });
  var ordered_1 = require_ordered();
  Object.defineProperty(exports, "OrderedBulkOperation", { enumerable: true, get: function() {
    return ordered_1.OrderedBulkOperation;
  } });
  var unordered_1 = require_unordered();
  Object.defineProperty(exports, "UnorderedBulkOperation", { enumerable: true, get: function() {
    return unordered_1.UnorderedBulkOperation;
  } });
  var change_stream_1 = require_change_stream();
  Object.defineProperty(exports, "ChangeStream", { enumerable: true, get: function() {
    return change_stream_1.ChangeStream;
  } });
  var collection_1 = require_collection();
  Object.defineProperty(exports, "Collection", { enumerable: true, get: function() {
    return collection_1.Collection;
  } });
  var abstract_cursor_1 = require_abstract_cursor();
  Object.defineProperty(exports, "AbstractCursor", { enumerable: true, get: function() {
    return abstract_cursor_1.AbstractCursor;
  } });
  var aggregation_cursor_1 = require_aggregation_cursor();
  Object.defineProperty(exports, "AggregationCursor", { enumerable: true, get: function() {
    return aggregation_cursor_1.AggregationCursor;
  } });
  var find_cursor_1 = require_find_cursor();
  Object.defineProperty(exports, "FindCursor", { enumerable: true, get: function() {
    return find_cursor_1.FindCursor;
  } });
  var list_collections_cursor_1 = require_list_collections_cursor();
  Object.defineProperty(exports, "ListCollectionsCursor", { enumerable: true, get: function() {
    return list_collections_cursor_1.ListCollectionsCursor;
  } });
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  Object.defineProperty(exports, "ListIndexesCursor", { enumerable: true, get: function() {
    return list_indexes_cursor_1.ListIndexesCursor;
  } });
  var db_1 = require_db();
  Object.defineProperty(exports, "Db", { enumerable: true, get: function() {
    return db_1.Db;
  } });
  var gridfs_1 = require_gridfs();
  Object.defineProperty(exports, "GridFSBucket", { enumerable: true, get: function() {
    return gridfs_1.GridFSBucket;
  } });
  var download_1 = require_download();
  Object.defineProperty(exports, "GridFSBucketReadStream", { enumerable: true, get: function() {
    return download_1.GridFSBucketReadStream;
  } });
  var upload_1 = require_upload();
  Object.defineProperty(exports, "GridFSBucketWriteStream", { enumerable: true, get: function() {
    return upload_1.GridFSBucketWriteStream;
  } });
  var mongo_client_1 = require_mongo_client();
  Object.defineProperty(exports, "MongoClient", { enumerable: true, get: function() {
    return mongo_client_1.MongoClient;
  } });
  var mongo_types_1 = require_mongo_types();
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return mongo_types_1.CancellationToken;
  } });
  var sessions_1 = require_sessions();
  Object.defineProperty(exports, "ClientSession", { enumerable: true, get: function() {
    return sessions_1.ClientSession;
  } });
  var bson_1 = require_bson2();
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_1.BSON;
  } });
  var bson_2 = require_bson2();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_2.Binary;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_2.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_2.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_2.BSONType;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_2.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_2.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_2.Decimal128;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_2.Double;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_2.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_2.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_2.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_2.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_2.ObjectId;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_2.Timestamp;
  } });
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return bson_2.UUID;
  } });
  var common_1 = require_common2();
  Object.defineProperty(exports, "MongoBulkWriteError", { enumerable: true, get: function() {
    return common_1.MongoBulkWriteError;
  } });
  var client_encryption_1 = require_client_encryption();
  Object.defineProperty(exports, "ClientEncryption", { enumerable: true, get: function() {
    return client_encryption_1.ClientEncryption;
  } });
  var change_stream_cursor_1 = require_change_stream_cursor();
  Object.defineProperty(exports, "ChangeStreamCursor", { enumerable: true, get: function() {
    return change_stream_cursor_1.ChangeStreamCursor;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "MongoAPIError", { enumerable: true, get: function() {
    return error_1.MongoAPIError;
  } });
  Object.defineProperty(exports, "MongoAWSError", { enumerable: true, get: function() {
    return error_1.MongoAWSError;
  } });
  Object.defineProperty(exports, "MongoAzureError", { enumerable: true, get: function() {
    return error_1.MongoAzureError;
  } });
  Object.defineProperty(exports, "MongoBatchReExecutionError", { enumerable: true, get: function() {
    return error_1.MongoBatchReExecutionError;
  } });
  Object.defineProperty(exports, "MongoChangeStreamError", { enumerable: true, get: function() {
    return error_1.MongoChangeStreamError;
  } });
  Object.defineProperty(exports, "MongoCompatibilityError", { enumerable: true, get: function() {
    return error_1.MongoCompatibilityError;
  } });
  Object.defineProperty(exports, "MongoCursorExhaustedError", { enumerable: true, get: function() {
    return error_1.MongoCursorExhaustedError;
  } });
  Object.defineProperty(exports, "MongoCursorInUseError", { enumerable: true, get: function() {
    return error_1.MongoCursorInUseError;
  } });
  Object.defineProperty(exports, "MongoDecompressionError", { enumerable: true, get: function() {
    return error_1.MongoDecompressionError;
  } });
  Object.defineProperty(exports, "MongoDriverError", { enumerable: true, get: function() {
    return error_1.MongoDriverError;
  } });
  Object.defineProperty(exports, "MongoError", { enumerable: true, get: function() {
    return error_1.MongoError;
  } });
  Object.defineProperty(exports, "MongoExpiredSessionError", { enumerable: true, get: function() {
    return error_1.MongoExpiredSessionError;
  } });
  Object.defineProperty(exports, "MongoGridFSChunkError", { enumerable: true, get: function() {
    return error_1.MongoGridFSChunkError;
  } });
  Object.defineProperty(exports, "MongoGridFSStreamError", { enumerable: true, get: function() {
    return error_1.MongoGridFSStreamError;
  } });
  Object.defineProperty(exports, "MongoInvalidArgumentError", { enumerable: true, get: function() {
    return error_1.MongoInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoKerberosError", { enumerable: true, get: function() {
    return error_1.MongoKerberosError;
  } });
  Object.defineProperty(exports, "MongoMissingCredentialsError", { enumerable: true, get: function() {
    return error_1.MongoMissingCredentialsError;
  } });
  Object.defineProperty(exports, "MongoMissingDependencyError", { enumerable: true, get: function() {
    return error_1.MongoMissingDependencyError;
  } });
  Object.defineProperty(exports, "MongoNetworkError", { enumerable: true, get: function() {
    return error_1.MongoNetworkError;
  } });
  Object.defineProperty(exports, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
    return error_1.MongoNetworkTimeoutError;
  } });
  Object.defineProperty(exports, "MongoNotConnectedError", { enumerable: true, get: function() {
    return error_1.MongoNotConnectedError;
  } });
  Object.defineProperty(exports, "MongoParseError", { enumerable: true, get: function() {
    return error_1.MongoParseError;
  } });
  Object.defineProperty(exports, "MongoRuntimeError", { enumerable: true, get: function() {
    return error_1.MongoRuntimeError;
  } });
  Object.defineProperty(exports, "MongoServerClosedError", { enumerable: true, get: function() {
    return error_1.MongoServerClosedError;
  } });
  Object.defineProperty(exports, "MongoServerError", { enumerable: true, get: function() {
    return error_1.MongoServerError;
  } });
  Object.defineProperty(exports, "MongoServerSelectionError", { enumerable: true, get: function() {
    return error_1.MongoServerSelectionError;
  } });
  Object.defineProperty(exports, "MongoSystemError", { enumerable: true, get: function() {
    return error_1.MongoSystemError;
  } });
  Object.defineProperty(exports, "MongoTailableCursorError", { enumerable: true, get: function() {
    return error_1.MongoTailableCursorError;
  } });
  Object.defineProperty(exports, "MongoTopologyClosedError", { enumerable: true, get: function() {
    return error_1.MongoTopologyClosedError;
  } });
  Object.defineProperty(exports, "MongoTransactionError", { enumerable: true, get: function() {
    return error_1.MongoTransactionError;
  } });
  Object.defineProperty(exports, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
    return error_1.MongoUnexpectedServerResponseError;
  } });
  Object.defineProperty(exports, "MongoWriteConcernError", { enumerable: true, get: function() {
    return error_1.MongoWriteConcernError;
  } });
  var common_2 = require_common2();
  Object.defineProperty(exports, "BatchType", { enumerable: true, get: function() {
    return common_2.BatchType;
  } });
  var auto_encrypter_1 = require_auto_encrypter();
  Object.defineProperty(exports, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
    return auto_encrypter_1.AutoEncryptionLoggerLevel;
  } });
  var gssapi_1 = require_gssapi();
  Object.defineProperty(exports, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
    return gssapi_1.GSSAPICanonicalizationValue;
  } });
  var providers_1 = require_providers();
  Object.defineProperty(exports, "AuthMechanism", { enumerable: true, get: function() {
    return providers_1.AuthMechanism;
  } });
  var compression_1 = require_compression();
  Object.defineProperty(exports, "Compressor", { enumerable: true, get: function() {
    return compression_1.Compressor;
  } });
  var abstract_cursor_2 = require_abstract_cursor();
  Object.defineProperty(exports, "CURSOR_FLAGS", { enumerable: true, get: function() {
    return abstract_cursor_2.CURSOR_FLAGS;
  } });
  var error_2 = require_error();
  Object.defineProperty(exports, "MongoErrorLabel", { enumerable: true, get: function() {
    return error_2.MongoErrorLabel;
  } });
  var explain_1 = require_explain();
  Object.defineProperty(exports, "ExplainVerbosity", { enumerable: true, get: function() {
    return explain_1.ExplainVerbosity;
  } });
  var mongo_client_2 = require_mongo_client();
  Object.defineProperty(exports, "ServerApiVersion", { enumerable: true, get: function() {
    return mongo_client_2.ServerApiVersion;
  } });
  var find_and_modify_1 = require_find_and_modify();
  Object.defineProperty(exports, "ReturnDocument", { enumerable: true, get: function() {
    return find_and_modify_1.ReturnDocument;
  } });
  var set_profiling_level_1 = require_set_profiling_level();
  Object.defineProperty(exports, "ProfilingLevel", { enumerable: true, get: function() {
    return set_profiling_level_1.ProfilingLevel;
  } });
  var read_concern_1 = require_read_concern();
  Object.defineProperty(exports, "ReadConcernLevel", { enumerable: true, get: function() {
    return read_concern_1.ReadConcernLevel;
  } });
  var read_preference_1 = require_read_preference();
  Object.defineProperty(exports, "ReadPreferenceMode", { enumerable: true, get: function() {
    return read_preference_1.ReadPreferenceMode;
  } });
  var common_3 = require_common();
  Object.defineProperty(exports, "ServerType", { enumerable: true, get: function() {
    return common_3.ServerType;
  } });
  Object.defineProperty(exports, "TopologyType", { enumerable: true, get: function() {
    return common_3.TopologyType;
  } });
  var read_concern_2 = require_read_concern();
  Object.defineProperty(exports, "ReadConcern", { enumerable: true, get: function() {
    return read_concern_2.ReadConcern;
  } });
  var read_preference_2 = require_read_preference();
  Object.defineProperty(exports, "ReadPreference", { enumerable: true, get: function() {
    return read_preference_2.ReadPreference;
  } });
  var write_concern_1 = require_write_concern();
  Object.defineProperty(exports, "WriteConcern", { enumerable: true, get: function() {
    return write_concern_1.WriteConcern;
  } });
  var command_monitoring_events_1 = require_command_monitoring_events();
  Object.defineProperty(exports, "CommandFailedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandFailedEvent;
  } });
  Object.defineProperty(exports, "CommandStartedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandStartedEvent;
  } });
  Object.defineProperty(exports, "CommandSucceededEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandSucceededEvent;
  } });
  var connection_pool_events_1 = require_connection_pool_events();
  Object.defineProperty(exports, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedInEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedOutEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutFailedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutStartedEvent;
  } });
  Object.defineProperty(exports, "ConnectionClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClearedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolMonitoringEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolReadyEvent;
  } });
  Object.defineProperty(exports, "ConnectionReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionReadyEvent;
  } });
  var events_1 = require_events();
  Object.defineProperty(exports, "ServerClosedEvent", { enumerable: true, get: function() {
    return events_1.ServerClosedEvent;
  } });
  Object.defineProperty(exports, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.ServerDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatFailedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatStartedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatSucceededEvent;
  } });
  Object.defineProperty(exports, "ServerOpeningEvent", { enumerable: true, get: function() {
    return events_1.ServerOpeningEvent;
  } });
  Object.defineProperty(exports, "TopologyClosedEvent", { enumerable: true, get: function() {
    return events_1.TopologyClosedEvent;
  } });
  Object.defineProperty(exports, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.TopologyDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "TopologyOpeningEvent", { enumerable: true, get: function() {
    return events_1.TopologyOpeningEvent;
  } });
  var srv_polling_1 = require_srv_polling();
  Object.defineProperty(exports, "SrvPollingEvent", { enumerable: true, get: function() {
    return srv_polling_1.SrvPollingEvent;
  } });
  var errors_1 = require_errors();
  Object.defineProperty(exports, "MongoCryptAzureKMSRequestError", { enumerable: true, get: function() {
    return errors_1.MongoCryptAzureKMSRequestError;
  } });
  Object.defineProperty(exports, "MongoCryptCreateDataKeyError", { enumerable: true, get: function() {
    return errors_1.MongoCryptCreateDataKeyError;
  } });
  Object.defineProperty(exports, "MongoCryptCreateEncryptedCollectionError", { enumerable: true, get: function() {
    return errors_1.MongoCryptCreateEncryptedCollectionError;
  } });
  Object.defineProperty(exports, "MongoCryptError", { enumerable: true, get: function() {
    return errors_1.MongoCryptError;
  } });
  Object.defineProperty(exports, "MongoCryptInvalidArgumentError", { enumerable: true, get: function() {
    return errors_1.MongoCryptInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoCryptKMSRequestNetworkTimeoutError", { enumerable: true, get: function() {
    return errors_1.MongoCryptKMSRequestNetworkTimeoutError;
  } });
});

// node_modules/@mikro-orm/core/enums.js
var require_enums = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PlainObject = exports.EventTypeMap = exports.EventType = exports.IsolationLevel = exports.LockMode = exports.DataloaderType = exports.LoadStrategy = exports.Cascade = exports.ReferenceKind = exports.SCALAR_TYPES = exports.QueryFlag = exports.QueryOrderNumeric = exports.QueryOrder = exports.ARRAY_OPERATORS = exports.QueryOperator = exports.GroupOperator = exports.PopulateHint = exports.FlushMode = undefined;
  var FlushMode;
  (function(FlushMode2) {
    FlushMode2["COMMIT"] = "commit";
    FlushMode2["AUTO"] = "auto";
    FlushMode2["ALWAYS"] = "always";
  })(FlushMode || (exports.FlushMode = FlushMode = {}));
  var PopulateHint;
  (function(PopulateHint2) {
    PopulateHint2["INFER"] = "infer";
    PopulateHint2["ALL"] = "all";
  })(PopulateHint || (exports.PopulateHint = PopulateHint = {}));
  var GroupOperator;
  (function(GroupOperator2) {
    GroupOperator2["$and"] = "and";
    GroupOperator2["$or"] = "or";
  })(GroupOperator || (exports.GroupOperator = GroupOperator = {}));
  var QueryOperator;
  (function(QueryOperator2) {
    QueryOperator2["$eq"] = "=";
    QueryOperator2["$in"] = "in";
    QueryOperator2["$nin"] = "not in";
    QueryOperator2["$gt"] = ">";
    QueryOperator2["$gte"] = ">=";
    QueryOperator2["$lt"] = "<";
    QueryOperator2["$lte"] = "<=";
    QueryOperator2["$ne"] = "!=";
    QueryOperator2["$not"] = "not";
    QueryOperator2["$like"] = "like";
    QueryOperator2["$re"] = "regexp";
    QueryOperator2["$fulltext"] = "fulltext";
    QueryOperator2["$exists"] = "not null";
    QueryOperator2["$ilike"] = "ilike";
    QueryOperator2["$overlap"] = "&&";
    QueryOperator2["$contains"] = "@>";
    QueryOperator2["$contained"] = "<@";
    QueryOperator2["$none"] = "none";
    QueryOperator2["$some"] = "some";
    QueryOperator2["$every"] = "every";
  })(QueryOperator || (exports.QueryOperator = QueryOperator = {}));
  exports.ARRAY_OPERATORS = [
    "$eq",
    "$gt",
    "$gte",
    "$lt",
    "$lte",
    "$ne",
    "$overlap",
    "$contains",
    "$contained"
  ];
  var QueryOrder;
  (function(QueryOrder2) {
    QueryOrder2["ASC"] = "ASC";
    QueryOrder2["ASC_NULLS_LAST"] = "ASC NULLS LAST";
    QueryOrder2["ASC_NULLS_FIRST"] = "ASC NULLS FIRST";
    QueryOrder2["DESC"] = "DESC";
    QueryOrder2["DESC_NULLS_LAST"] = "DESC NULLS LAST";
    QueryOrder2["DESC_NULLS_FIRST"] = "DESC NULLS FIRST";
    QueryOrder2["asc"] = "asc";
    QueryOrder2["asc_nulls_last"] = "asc nulls last";
    QueryOrder2["asc_nulls_first"] = "asc nulls first";
    QueryOrder2["desc"] = "desc";
    QueryOrder2["desc_nulls_last"] = "desc nulls last";
    QueryOrder2["desc_nulls_first"] = "desc nulls first";
  })(QueryOrder || (exports.QueryOrder = QueryOrder = {}));
  var QueryOrderNumeric;
  (function(QueryOrderNumeric2) {
    QueryOrderNumeric2[QueryOrderNumeric2["ASC"] = 1] = "ASC";
    QueryOrderNumeric2[QueryOrderNumeric2["DESC"] = -1] = "DESC";
  })(QueryOrderNumeric || (exports.QueryOrderNumeric = QueryOrderNumeric = {}));
  var QueryFlag;
  (function(QueryFlag2) {
    QueryFlag2["DISTINCT"] = "DISTINCT";
    QueryFlag2["PAGINATE"] = "PAGINATE";
    QueryFlag2["DISABLE_PAGINATE"] = "DISABLE_PAGINATE";
    QueryFlag2["UPDATE_SUB_QUERY"] = "UPDATE_SUB_QUERY";
    QueryFlag2["DELETE_SUB_QUERY"] = "DELETE_SUB_QUERY";
    QueryFlag2["CONVERT_CUSTOM_TYPES"] = "CONVERT_CUSTOM_TYPES";
    QueryFlag2["INCLUDE_LAZY_FORMULAS"] = "INCLUDE_LAZY_FORMULAS";
    QueryFlag2["AUTO_JOIN_ONE_TO_ONE_OWNER"] = "AUTO_JOIN_ONE_TO_ONE_OWNER";
    QueryFlag2["INFER_POPULATE"] = "INFER_POPULATE";
  })(QueryFlag || (exports.QueryFlag = QueryFlag = {}));
  exports.SCALAR_TYPES = ["string", "number", "boolean", "Date", "Buffer", "RegExp"];
  var ReferenceKind;
  (function(ReferenceKind2) {
    ReferenceKind2["SCALAR"] = "scalar";
    ReferenceKind2["ONE_TO_ONE"] = "1:1";
    ReferenceKind2["ONE_TO_MANY"] = "1:m";
    ReferenceKind2["MANY_TO_ONE"] = "m:1";
    ReferenceKind2["MANY_TO_MANY"] = "m:n";
    ReferenceKind2["EMBEDDED"] = "embedded";
  })(ReferenceKind || (exports.ReferenceKind = ReferenceKind = {}));
  var Cascade;
  (function(Cascade2) {
    Cascade2["PERSIST"] = "persist";
    Cascade2["MERGE"] = "merge";
    Cascade2["REMOVE"] = "remove";
    Cascade2["ALL"] = "all";
    Cascade2["SCHEDULE_ORPHAN_REMOVAL"] = "schedule_orphan_removal";
    Cascade2["CANCEL_ORPHAN_REMOVAL"] = "cancel_orphan_removal";
  })(Cascade || (exports.Cascade = Cascade = {}));
  var LoadStrategy;
  (function(LoadStrategy2) {
    LoadStrategy2["SELECT_IN"] = "select-in";
    LoadStrategy2["JOINED"] = "joined";
  })(LoadStrategy || (exports.LoadStrategy = LoadStrategy = {}));
  var DataloaderType;
  (function(DataloaderType2) {
    DataloaderType2[DataloaderType2["NONE"] = 0] = "NONE";
    DataloaderType2[DataloaderType2["REFERENCE"] = 1] = "REFERENCE";
    DataloaderType2[DataloaderType2["COLLECTION"] = 2] = "COLLECTION";
    DataloaderType2[DataloaderType2["ALL"] = 3] = "ALL";
  })(DataloaderType || (exports.DataloaderType = DataloaderType = {}));
  var LockMode;
  (function(LockMode2) {
    LockMode2[LockMode2["NONE"] = 0] = "NONE";
    LockMode2[LockMode2["OPTIMISTIC"] = 1] = "OPTIMISTIC";
    LockMode2[LockMode2["PESSIMISTIC_READ"] = 2] = "PESSIMISTIC_READ";
    LockMode2[LockMode2["PESSIMISTIC_WRITE"] = 3] = "PESSIMISTIC_WRITE";
    LockMode2[LockMode2["PESSIMISTIC_PARTIAL_WRITE"] = 4] = "PESSIMISTIC_PARTIAL_WRITE";
    LockMode2[LockMode2["PESSIMISTIC_WRITE_OR_FAIL"] = 5] = "PESSIMISTIC_WRITE_OR_FAIL";
    LockMode2[LockMode2["PESSIMISTIC_PARTIAL_READ"] = 6] = "PESSIMISTIC_PARTIAL_READ";
    LockMode2[LockMode2["PESSIMISTIC_READ_OR_FAIL"] = 7] = "PESSIMISTIC_READ_OR_FAIL";
  })(LockMode || (exports.LockMode = LockMode = {}));
  var IsolationLevel;
  (function(IsolationLevel2) {
    IsolationLevel2["READ_UNCOMMITTED"] = "read uncommitted";
    IsolationLevel2["READ_COMMITTED"] = "read committed";
    IsolationLevel2["SNAPSHOT"] = "snapshot";
    IsolationLevel2["REPEATABLE_READ"] = "repeatable read";
    IsolationLevel2["SERIALIZABLE"] = "serializable";
  })(IsolationLevel || (exports.IsolationLevel = IsolationLevel = {}));
  var EventType;
  (function(EventType2) {
    EventType2["onInit"] = "onInit";
    EventType2["onLoad"] = "onLoad";
    EventType2["beforeCreate"] = "beforeCreate";
    EventType2["afterCreate"] = "afterCreate";
    EventType2["beforeUpdate"] = "beforeUpdate";
    EventType2["afterUpdate"] = "afterUpdate";
    EventType2["beforeUpsert"] = "beforeUpsert";
    EventType2["afterUpsert"] = "afterUpsert";
    EventType2["beforeDelete"] = "beforeDelete";
    EventType2["afterDelete"] = "afterDelete";
    EventType2["beforeFlush"] = "beforeFlush";
    EventType2["onFlush"] = "onFlush";
    EventType2["afterFlush"] = "afterFlush";
    EventType2["beforeTransactionStart"] = "beforeTransactionStart";
    EventType2["afterTransactionStart"] = "afterTransactionStart";
    EventType2["beforeTransactionCommit"] = "beforeTransactionCommit";
    EventType2["afterTransactionCommit"] = "afterTransactionCommit";
    EventType2["beforeTransactionRollback"] = "beforeTransactionRollback";
    EventType2["afterTransactionRollback"] = "afterTransactionRollback";
  })(EventType || (exports.EventType = EventType = {}));
  exports.EventTypeMap = Object.keys(EventType).reduce((a2, b2, i2) => {
    a2[b2] = i2;
    return a2;
  }, {});

  class PlainObject {
  }
  exports.PlainObject = PlainObject;
});

// node_modules/@mikro-orm/core/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotFoundError = exports.MetadataError = exports.OptimisticLockError = exports.CursorError = exports.ValidationError = undefined;
  var util_1 = import.meta.require("util");

  class ValidationError extends Error {
    entity;
    constructor(message, entity) {
      super(message);
      this.entity = entity;
      Error.captureStackTrace(this, this.constructor);
      this.name = this.constructor.name;
      this.message = message;
    }
    getEntity() {
      return this.entity;
    }
    static fromWrongPropertyType(entity, property, expectedType, givenType, givenValue) {
      const entityName = entity.constructor.name;
      const msg = `Trying to set ${entityName}.${property} of type '${expectedType}' to '${givenValue}' of type '${givenType}'`;
      return new ValidationError(msg);
    }
    static fromWrongRepositoryType(entityName, repoType, method) {
      const msg = `Trying to use EntityRepository.${method}() with '${entityName}' entity while the repository is of type '${repoType}'`;
      return new ValidationError(msg);
    }
    static fromCollectionNotInitialized(entity, prop) {
      const entityName = entity.constructor.name;
      const msg = `${entityName}.${prop.name} is not initialized, define it as '${prop.name} = new Collection<${prop.type}>(this);'`;
      return new ValidationError(msg);
    }
    static fromMergeWithoutPK(meta) {
      return new ValidationError(`You cannot merge entity '${meta.className}' without identifier!`);
    }
    static transactionRequired() {
      return new ValidationError("An open transaction is required for this operation");
    }
    static entityNotManaged(entity) {
      return new ValidationError(`Entity ${entity.constructor.name} is not managed. An entity is managed if its fetched from the database or registered as new through EntityManager.persist()`);
    }
    static notEntity(owner, prop, data) {
      const type73 = Object.prototype.toString.call(data).match(/\[object (\w+)]/)[1].toLowerCase();
      return new ValidationError(`Entity of type ${prop.type} expected for property ${owner.constructor.name}.${prop.name}, ${(0, util_1.inspect)(data)} of type ${type73} given. If you are using Object.assign(entity, data), use em.assign(entity, data) instead.`);
    }
    static notDiscoveredEntity(data, meta, action = "persist") {
      const type73 = meta?.className ?? Object.prototype.toString.call(data).match(/\[object (\w+)]/)[1].toLowerCase();
      let err = `Trying to ${action} not discovered entity of type ${type73}.`;
      if (meta) {
        err += ` Entity with this name was discovered, but not the prototype you are passing to the ORM. If using EntitySchema, be sure to point to the implementation via \`class\`.`;
      }
      return new ValidationError(err);
    }
    static invalidPropertyName(entityName, invalid) {
      return new ValidationError(`Entity '${entityName}' does not have property '${invalid}'`);
    }
    static invalidType(type73, value14, mode) {
      const valueType = Object.prototype.toString.call(value14).match(/\[object (\w+)]/)[1].toLowerCase();
      if (value14 instanceof Date) {
        value14 = value14.toISOString();
      }
      return new ValidationError(`Could not convert ${mode} value '${value14}' of type '${valueType}' to type ${type73.name}`);
    }
    static propertyRequired(entity, property) {
      const entityName = entity.__meta.className;
      return new ValidationError(`Value for ${entityName}.${property.name} is required, '${entity[property.name]}' found\nentity: ${(0, util_1.inspect)(entity)}`, entity);
    }
    static cannotModifyInverseCollection(owner, property) {
      const inverseCollection = `${owner.constructor.name}.${property.name}`;
      const ownerCollection = `${property.type}.${property.mappedBy}`;
      const error21 = `You cannot modify inverse side of M:N collection ${inverseCollection} when the owning side is not initialized. ` + `Consider working with the owning side instead (${ownerCollection}).`;
      return new ValidationError(error21, owner);
    }
    static cannotModifyReadonlyCollection(owner, property) {
      return new ValidationError(`You cannot modify collection ${owner.constructor.name}.${property.name} as it is marked as readonly.`, owner);
    }
    static cannotRemoveFromCollectionWithoutOrphanRemoval(owner, property) {
      const options = [
        " - add `orphanRemoval: true` to the collection options",
        " - add `deleteRule: \'cascade\'` to the owning side options",
        " - add `nullable: true` to the owning side options"
      ].join("\n");
      return new ValidationError(`Removing items from collection ${owner.constructor.name}.${property.name} without \`orphanRemoval: true\` would break non-null constraint on the owning side. You have several options: \n${options}`, owner);
    }
    static invalidCompositeIdentifier(meta) {
      return new ValidationError(`Composite key required for entity ${meta.className}.`);
    }
    static cannotCommit() {
      return new ValidationError("You cannot call em.flush() from inside lifecycle hook handlers");
    }
    static cannotUseGlobalContext() {
      return new ValidationError("Using global EntityManager instance methods for context specific actions is disallowed. If you need to work with the global instance\'s identity map, use `allowGlobalContext` configuration option or `fork()` instead.");
    }
    static cannotUseOperatorsInsideEmbeddables(className, propName, payload) {
      return new ValidationError(`Using operators inside embeddables is not allowed, move the operator above. (property: ${className}.${propName}, payload: ${(0, util_1.inspect)(payload)})`);
    }
    static invalidEmbeddableQuery(className, propName, embeddableType) {
      return new ValidationError(`Invalid query for entity '${className}', property '${propName}' does not exist in embeddable '${embeddableType}'`);
    }
  }
  exports.ValidationError = ValidationError;

  class CursorError extends ValidationError {
    static entityNotPopulated(entity, prop) {
      return new CursorError(`Cannot create cursor, value for '${entity.constructor.name}.${prop}' is missing.`);
    }
  }
  exports.CursorError = CursorError;

  class OptimisticLockError extends ValidationError {
    static notVersioned(meta) {
      return new OptimisticLockError(`Cannot obtain optimistic lock on unversioned entity ${meta.className}`);
    }
    static lockFailed(entityOrName) {
      const name = typeof entityOrName === "string" ? entityOrName : entityOrName.constructor.name;
      const entity = typeof entityOrName === "string" ? undefined : entityOrName;
      return new OptimisticLockError(`The optimistic lock on entity ${name} failed`, entity);
    }
    static lockFailedVersionMismatch(entity, expectedLockVersion, actualLockVersion) {
      expectedLockVersion = expectedLockVersion instanceof Date ? expectedLockVersion.getTime() : expectedLockVersion;
      actualLockVersion = actualLockVersion instanceof Date ? actualLockVersion.getTime() : actualLockVersion;
      return new OptimisticLockError(`The optimistic lock failed, version ${expectedLockVersion} was expected, but is actually ${actualLockVersion}`, entity);
    }
  }
  exports.OptimisticLockError = OptimisticLockError;

  class MetadataError extends ValidationError {
    static fromMissingPrimaryKey(meta) {
      return new MetadataError(`${meta.className} entity is missing @PrimaryKey()`);
    }
    static fromWrongReference(meta, prop, key, owner) {
      if (owner) {
        return MetadataError.fromMessage(meta, prop, `has wrong '${key}' reference type: ${owner.type} instead of ${meta.className}`);
      }
      return MetadataError.fromMessage(meta, prop, `has unknown '${key}' reference: ${prop.type}.${prop[key]}`);
    }
    static fromWrongTypeDefinition(meta, prop) {
      if (!prop.type) {
        return MetadataError.fromMessage(meta, prop, `is missing type definition`);
      }
      return MetadataError.fromMessage(meta, prop, `has unknown type: ${prop.type}`);
    }
    static fromWrongOwnership(meta, prop, key) {
      const type73 = key === "inversedBy" ? "owning" : "inverse";
      const other = key === "inversedBy" ? "mappedBy" : "inversedBy";
      return new MetadataError(`Both ${meta.className}.${prop.name} and ${prop.type}.${prop[key]} are defined as ${type73} sides, use '${other}' on one of them`);
    }
    static fromWrongReferenceKind(meta, owner, prop) {
      return new MetadataError(`${meta.className}.${prop.name} is of type ${prop.kind} which is incompatible with its owning side ${prop.type}.${owner.name} of type ${owner.kind}`);
    }
    static fromInversideSidePrimary(meta, owner, prop) {
      return new MetadataError(`${meta.className}.${prop.name} cannot be primary key as it is defined as inverse side. Maybe you should swap the use of 'inversedBy' and 'mappedBy'.`);
    }
    static entityNotFound(name, path) {
      return new MetadataError(`Entity '${name}' not found in ${path}`);
    }
    static unknownIndexProperty(meta, prop, type73) {
      return new MetadataError(`Entity ${meta.className} has wrong ${type73} definition: '${prop}' does not exist. You need to use property name, not column name.`);
    }
    static multipleVersionFields(meta, fields) {
      return new MetadataError(`Entity ${meta.className} has multiple version properties defined: '${fields.join("\', \'")}'. Only one version property is allowed per entity.`);
    }
    static invalidVersionFieldType(meta) {
      const prop = meta.properties[meta.versionProperty];
      return new MetadataError(`Version property ${meta.className}.${prop.name} has unsupported type '${prop.type}'. Only 'number' and 'Date' are allowed.`);
    }
    static fromUnknownEntity(className, source) {
      return new MetadataError(`Entity '${className}' was not discovered, please make sure to provide it in 'entities' array when initializing the ORM (used in ${source})`);
    }
    static noEntityDiscovered() {
      return new MetadataError("No entities were discovered");
    }
    static onlyAbstractEntitiesDiscovered() {
      return new MetadataError("Only abstract entities were discovered, maybe you forgot to use @Entity() decorator?");
    }
    static duplicateEntityDiscovered(paths, subject = "entity names") {
      return new MetadataError(`Duplicate ${subject} are not allowed: ${paths.join(", ")}`);
    }
    static duplicateFieldName(className, names) {
      return new MetadataError(`Duplicate fieldNames are not allowed: ${names.map((n2) => `${className}.${n2[0]} (fieldName: '${n2[1]}')`).join(", ")}`);
    }
    static multipleDecorators(entityName, propertyName) {
      return new MetadataError(`Multiple property decorators used on '${entityName}.${propertyName}' property`);
    }
    static missingMetadata(entity) {
      return new MetadataError(`Metadata for entity ${entity} not found`);
    }
    static invalidPrimaryKey(meta, prop, requiredName) {
      return this.fromMessage(meta, prop, `has wrong field name, '${requiredName}' is required in current driver`);
    }
    static invalidManyToManyWithPivotEntity(meta1, prop1, meta2, prop2) {
      const p12 = `${meta1.className}.${prop1.name}`;
      const p2 = `${meta2.className}.${prop2.name}`;
      return new MetadataError(`${p12} and ${p2} use the same 'pivotEntity', but don't form a bidirectional relation. Specify 'inversedBy' or 'mappedBy' to link them.`);
    }
    static targetIsAbstract(meta, prop) {
      return this.fromMessage(meta, prop, `targets abstract entity ${prop.type}. Maybe you forgot to put @Entity() decorator on the ${prop.type} class?`);
    }
    static propertyTargetsEntityType(meta, prop, target) {
      const suggestion = target.embeddable ? "Embedded" : "ManyToOne";
      return this.fromMessage(meta, prop, `is defined as scalar @Property(), but its type is a discovered entity ${target.className}. Maybe you want to use @${suggestion}() decorator instead?`);
    }
    static fromMissingOption(meta, prop, option) {
      return this.fromMessage(meta, prop, `is missing '${option}' option`);
    }
    static fromMessage(meta, prop, message) {
      return new MetadataError(`${meta.className}.${prop.name} ${message}`);
    }
  }
  exports.MetadataError = MetadataError;

  class NotFoundError extends ValidationError {
    static findOneFailed(name, where) {
      return new NotFoundError(`${name} not found (${(0, util_1.inspect)(where)})`);
    }
    static findExactlyOneFailed(name, where) {
      return new NotFoundError(`Wrong number of ${name} entities found for query ${(0, util_1.inspect)(where)}, expected exactly one`);
    }
  }
  exports.NotFoundError = NotFoundError;
});

// node_modules/array-union/index.js
var require_array_union = __commonJS((exports, module) => {
  module.exports = (...arguments_) => {
    return [...new Set([].concat(...arguments_))];
  };
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS((exports, module) => {
  var merge2 = function() {
    const streamsQueue = [];
    const args = slice.call(arguments);
    let merging = false;
    let options = args[args.length - 1];
    if (options && !Array.isArray(options) && options.pipe == null) {
      args.pop();
    } else {
      options = {};
    }
    const doEnd = options.end !== false;
    const doPipeError = options.pipeError === true;
    if (options.objectMode == null) {
      options.objectMode = true;
    }
    if (options.highWaterMark == null) {
      options.highWaterMark = 64 * 1024;
    }
    const mergedStream = PassThrough(options);
    function addStream() {
      for (let i2 = 0, len = arguments.length;i2 < len; i2++) {
        streamsQueue.push(pauseStreams(arguments[i2], options));
      }
      mergeStream();
      return this;
    }
    function mergeStream() {
      if (merging) {
        return;
      }
      merging = true;
      let streams = streamsQueue.shift();
      if (!streams) {
        process.nextTick(endStream);
        return;
      }
      if (!Array.isArray(streams)) {
        streams = [streams];
      }
      let pipesCount = streams.length + 1;
      function next() {
        if (--pipesCount > 0) {
          return;
        }
        merging = false;
        mergeStream();
      }
      function pipe(stream) {
        function onend() {
          stream.removeListener("merge2UnpipeEnd", onend);
          stream.removeListener("end", onend);
          if (doPipeError) {
            stream.removeListener("error", onerror);
          }
          next();
        }
        function onerror(err) {
          mergedStream.emit("error", err);
        }
        if (stream._readableState.endEmitted) {
          return next();
        }
        stream.on("merge2UnpipeEnd", onend);
        stream.on("end", onend);
        if (doPipeError) {
          stream.on("error", onerror);
        }
        stream.pipe(mergedStream, { end: false });
        stream.resume();
      }
      for (let i2 = 0;i2 < streams.length; i2++) {
        pipe(streams[i2]);
      }
      next();
    }
    function endStream() {
      merging = false;
      mergedStream.emit("queueDrain");
      if (doEnd) {
        mergedStream.end();
      }
    }
    mergedStream.setMaxListeners(0);
    mergedStream.add = addStream;
    mergedStream.on("unpipe", function(stream) {
      stream.emit("merge2UnpipeEnd");
    });
    if (args.length) {
      addStream.apply(null, args);
    }
    return mergedStream;
  };
  var pauseStreams = function(streams, options) {
    if (!Array.isArray(streams)) {
      if (!streams._readableState && streams.pipe) {
        streams = streams.pipe(PassThrough(options));
      }
      if (!streams._readableState || !streams.pause || !streams.pipe) {
        throw new Error("Only readable stream can be merged.");
      }
      streams.pause();
    } else {
      for (let i2 = 0, len = streams.length;i2 < len; i2++) {
        streams[i2] = pauseStreams(streams[i2], options);
      }
    }
    return streams;
  };
  var Stream = import.meta.require("stream");
  var PassThrough = Stream.PassThrough;
  var slice = Array.prototype.slice;
  module.exports = merge2;
});

// node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS((exports) => {
  var flatten = function(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
  };
  var splitWhen = function(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
      if (predicate(item)) {
        groupIndex++;
        result[groupIndex] = [];
      } else {
        result[groupIndex].push(item);
      }
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitWhen = exports.flatten = undefined;
  exports.flatten = flatten;
  exports.splitWhen = splitWhen;
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS((exports) => {
  var isEnoentCodeError = function(error21) {
    return error21.code === "ENOENT";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEnoentCodeError = undefined;
  exports.isEnoentCodeError = isEnoentCodeError;
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS((exports) => {
  var createDirentFromStats = function(name, stats) {
    return new DirentFromStats(name, stats);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDirentFromStats = undefined;

  class DirentFromStats {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  }
  exports.createDirentFromStats = createDirentFromStats;
});

// node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS((exports) => {
  var unixify = function(filepath) {
    return filepath.replace(/\\/g, "/");
  };
  var makeAbsolute = function(cwd, filepath) {
    return path.resolve(cwd, filepath);
  };
  var removeLeadingDotSegment = function(entry) {
    if (entry.charAt(0) === ".") {
      const secondCharactery = entry.charAt(1);
      if (secondCharactery === "/" || secondCharactery === "\\") {
        return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
    }
    return entry;
  };
  var escapeWindowsPath = function(pattern3) {
    return pattern3.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
  };
  var escapePosixPath = function(pattern3) {
    return pattern3.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
  };
  var convertWindowsPathToPattern = function(filepath) {
    return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
  };
  var convertPosixPathToPattern = function(filepath) {
    return escapePosixPath(filepath);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = undefined;
  var os = import.meta.require("os");
  var path = import.meta.require("path");
  var IS_WINDOWS_PLATFORM = os.platform() === "win32";
  var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
  var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
  var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
  var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
  var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
  exports.unixify = unixify;
  exports.makeAbsolute = makeAbsolute;
  exports.removeLeadingDotSegment = removeLeadingDotSegment;
  exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
  exports.escapeWindowsPath = escapeWindowsPath;
  exports.escapePosixPath = escapePosixPath;
  exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
  exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
  exports.convertPosixPathToPattern = convertPosixPathToPattern;
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS((exports, module) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS((exports, module) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isExtglob = require_is_extglob();
  var chars = { "{": "}", "(": ")", "[": "]" };
  var strictCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;
    while (index < str.length) {
      if (str[index] === "*") {
        return true;
      }
      if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
        return true;
      }
      if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
        if (closeSquareIndex < index) {
          closeSquareIndex = str.indexOf("]", index);
        }
        if (closeSquareIndex > index) {
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
        }
      }
      if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
        closeCurlyIndex = str.indexOf("}", index);
        if (closeCurlyIndex > index) {
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
            return true;
          }
        }
      }
      if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
        closeParenIndex = str.indexOf(")", index);
        if (closeParenIndex > index) {
          backSlashIndex = str.indexOf("\\", index);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
      if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
        if (pipeIndex < index) {
          pipeIndex = str.indexOf("|", index);
        }
        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
          closeParenIndex = str.indexOf(")", pipeIndex);
          if (closeParenIndex > pipeIndex) {
            backSlashIndex = str.indexOf("\\", pipeIndex);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
      }
      if (str[index] === "\\") {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];
        if (close) {
          var n2 = str.indexOf(close, index);
          if (n2 !== -1) {
            index = n2 + 1;
          }
        }
        if (str[index] === "!") {
          return true;
        }
      } else {
        index++;
      }
    }
    return false;
  };
  var relaxedCheck = function(str) {
    if (str[0] === "!") {
      return true;
    }
    var index = 0;
    while (index < str.length) {
      if (/[*?{}()[\]]/.test(str[index])) {
        return true;
      }
      if (str[index] === "\\") {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];
        if (close) {
          var n2 = str.indexOf(close, index);
          if (n2 !== -1) {
            index = n2 + 1;
          }
        }
        if (str[index] === "!") {
          return true;
        }
      } else {
        index++;
      }
    }
    return false;
  };
  module.exports = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var check10 = strictCheck;
    if (options && options.strict === false) {
      check10 = relaxedCheck;
    }
    return check10(str);
  };
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS((exports, module) => {
  var isGlob = require_is_glob();
  var pathPosixDirname = import.meta.require("path").posix.dirname;
  var isWin32 = import.meta.require("os").platform() === "win32";
  var slash = "/";
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  module.exports = function globParent(str, opts) {
    var options = Object.assign({ flipBackslashes: true }, opts);
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    }
    if (enclosure.test(str)) {
      str += slash;
    }
    str += "a";
    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str));
    return str.replace(escaped, "$1");
  };
});

// node_modules/braces/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  exports.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports.find = (node, type73) => node.nodes.find((node2) => node2.type === type73);
  exports.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports.isInteger(min) || !exports.isInteger(max))
      return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  exports.escapeNode = (block, n2 = 0, type73) => {
    let node = block.nodes[n2];
    if (!node)
      return;
    if (type73 && node.type === type73 || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i2 = 0;i2 < arr.length; i2++) {
        let ele = arr[i2];
        Array.isArray(ele) ? flat(ele, result) : ele !== undefined && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var utils = require_utils4();
  module.exports = (ast, options = {}) => {
    let stringify = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify(child);
        }
      }
      return output;
    };
    return stringify(ast);
  };
});

// node_modules/is-number/index.js
var require_is_number = __commonJS((exports, module) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports, module) => {
  var collatePatterns = function(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  };
  var splitToRanges = function(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([max]);
    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  };
  var rangeToPattern = function(start, stop, options) {
    if (start === stop) {
      return { pattern: start, count: [], digits: 0 };
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern3 = "";
    let count = 0;
    for (let i2 = 0;i2 < digits; i2++) {
      let [startDigit, stopDigit] = zipped[i2];
      if (startDigit === stopDigit) {
        pattern3 += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern3 += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count++;
      }
    }
    if (count) {
      pattern3 += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return { pattern: pattern3, count: [count], digits };
  };
  var splitToPatterns = function(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;
    for (let i2 = 0;i2 < ranges.length; i2++) {
      let max2 = ranges[i2];
      let obj = rangeToPattern(String(start), String(max2), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max2 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max2, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max2 + 1;
      prev = obj;
    }
    return tokens;
  };
  var filterPatterns = function(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let { string: string6 } = ele;
      if (!intersection && !contains(comparison, "string", string6)) {
        result.push(prefix + string6);
      }
      if (intersection && contains(comparison, "string", string6)) {
        result.push(prefix + string6);
      }
    }
    return result;
  };
  var zip = function(a2, b2) {
    let arr = [];
    for (let i2 = 0;i2 < a2.length; i2++)
      arr.push([a2[i2], b2[i2]]);
    return arr;
  };
  var compare = function(a2, b2) {
    return a2 > b2 ? 1 : b2 > a2 ? -1 : 0;
  };
  var contains = function(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  };
  var countNines = function(min, len) {
    return Number(String(min).slice(0, -len) + "9".repeat(len));
  };
  var countZeros = function(integer3, zeros) {
    return integer3 - integer3 % Math.pow(10, zeros);
  };
  var toQuantifier = function(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  };
  var toCharacterClass = function(a2, b2, options) {
    return `[${a2}${b2 - a2 === 1 ? "" : "-"}${b2}]`;
  };
  var hasPadding = function(str) {
    return /^-?(0+)\d/.test(str);
  };
  var padZeros = function(value14, tok, options) {
    if (!tok.isPadded) {
      return value14;
    }
    let diff = Math.abs(tok.maxLen - String(value14).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  };
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isNumber = require_is_number();
  var toRegexRange = (min, max, options) => {
    if (isNumber(min) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max === undefined || min === max) {
      return String(min);
    }
    if (isNumber(max) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = { relaxZeros: true, ...options };
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a2 = Math.min(min, max);
    let b2 = Math.max(min, max);
    if (Math.abs(a2 - b2) === 1) {
      let result = min + "|" + max;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min) || hasPadding(max);
    let state = { min, max, a: a2, b: b2 };
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a2 < 0) {
      let newMin = b2 < 0 ? Math.abs(b2) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a2), state, opts);
      a2 = state.a = 0;
    }
    if (b2 >= 0) {
      positives = splitToPatterns(a2, b2, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module.exports = toRegexRange;
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports, module) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var util = import.meta.require("util");
  var toRegexRange = require_to_regex_range();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform5 = (toNumber) => {
    return (value14) => toNumber === true ? Number(value14) : String(value14);
  };
  var isValidValue = (value14) => {
    return typeof value14 === "number" || typeof value14 === "string" && value14 !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value14 = `${input}`;
    let index = -1;
    if (value14[0] === "-")
      value14 = value14.slice(1);
    if (value14 === "0")
      return false;
    while (value14[++index] === "0")
      ;
    return index > 0;
  };
  var stringify = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options) => {
    parts.negatives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
    parts.positives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a2, b2, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a2, b2, { wrap: false, ...options });
    }
    let start = String.fromCharCode(a2);
    if (a2 === b2)
      return start;
    let stop = String.fromCharCode(b2);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util.inspect(...args));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a2 = Number(start);
    let b2 = Number(end);
    if (!Number.isInteger(a2) || !Number.isInteger(b2)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a2 === 0)
      a2 = 0;
    if (b2 === 0)
      b2 = 0;
    let descending = a2 > b2;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format = options.transform || transform5(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = { negatives: [], positives: [] };
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a2 >= b2 : a2 <= b2) {
      if (options.toRegex === true && step > 1) {
        push(a2);
      } else {
        range.push(pad(format(a2, index), maxLen, toNumber));
      }
      a2 = descending ? a2 - step : a2 + step;
      index++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format = options.transform || ((val) => String.fromCharCode(val));
    let a2 = `${start}`.charCodeAt(0);
    let b2 = `${end}`.charCodeAt(0);
    let descending = a2 > b2;
    let min = Math.min(a2, b2);
    let max = Math.max(a2, b2);
    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }
    let range = [];
    let index = 0;
    while (descending ? a2 >= b2 : a2 <= b2) {
      range.push(format(a2, index));
      a2 = descending ? a2 - step : a2 + step;
      index++;
    }
    if (options.toRegex === true) {
      return toRegex(range, null, { wrap: false, options });
    }
    return range;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, { transform: step });
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = { ...options };
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module.exports = fill;
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports, module) => {
  var fill = require_fill_range();
  var utils = require_utils4();
  var compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        let range = fill(...args, { ...options, wrap: false, toRegex: true });
        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module.exports = compile;
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports, module) => {
  var fill = require_fill_range();
  var stringify = require_stringify();
  var utils = require_utils4();
  var append = (queue = "", stash = "", enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value14 of item) {
          result.push(append(value14, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils.flatten(result);
  };
  var expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;
    let walk = (node, parent = {}) => {
      node.queue = [];
      let p2 = parent;
      let q2 = parent.queue;
      while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
        p2 = p2.parent;
        q2 = p2.queue;
      }
      if (node.invalid || node.dollar) {
        q2.push(append(q2.pop(), stringify(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q2.push(append(q2.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args, options);
        if (range.length === 0) {
          range = stringify(node, options);
        }
        q2.push(append(q2.pop(), range));
        node.nodes = [];
        return;
      }
      let enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i2 = 0;i2 < node.nodes.length; i2++) {
        let child = node.nodes[i2];
        if (child.type === "comma" && node.type === "brace") {
          if (i2 === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q2.push(append(q2.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils.flatten(walk(ast));
  };
  module.exports = expand;
});

// node_modules/braces/lib/constants.js
var require_constants3 = __commonJS((exports, module) => {
  module.exports = {
    MAX_LENGTH: 1024 * 64,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "\'",
    CHAR_SPACE: " ",
    CHAR_TAB: "\t",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants3();
  var parse4 = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    let opts = options || {};
    let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }
    let ast = { type: "root", input, nodes: [] };
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value14;
    let memo = {};
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({ type: "bos" });
    while (index < length) {
      block = stack[stack.length - 1];
      value14 = advance();
      if (value14 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value14 === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value14 === CHAR_BACKSLASH) {
        push({ type: "text", value: (options.keepEscaping ? value14 : "") + advance() });
        continue;
      }
      if (value14 === CHAR_RIGHT_SQUARE_BRACKET) {
        push({ type: "text", value: "\\" + value14 });
        continue;
      }
      if (value14 === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let closed = true;
        let next;
        while (index < length && (next = advance())) {
          value14 += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value14 += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({ type: "text", value: value14 });
        continue;
      }
      if (value14 === CHAR_LEFT_PARENTHESES) {
        block = push({ type: "paren", nodes: [] });
        stack.push(block);
        push({ type: "text", value: value14 });
        continue;
      }
      if (value14 === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({ type: "text", value: value14 });
          continue;
        }
        block = stack.pop();
        push({ type: "text", value: value14 });
        block = stack[stack.length - 1];
        continue;
      }
      if (value14 === CHAR_DOUBLE_QUOTE || value14 === CHAR_SINGLE_QUOTE || value14 === CHAR_BACKTICK) {
        let open = value14;
        let next;
        if (options.keepQuotes !== true) {
          value14 = "";
        }
        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value14 += next + advance();
            continue;
          }
          if (next === open) {
            if (options.keepQuotes === true)
              value14 += next;
            break;
          }
          value14 += next;
        }
        push({ type: "text", value: value14 });
        continue;
      }
      if (value14 === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        let brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({ type: "open", value: value14 });
        continue;
      }
      if (value14 === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({ type: "text", value: value14 });
          continue;
        }
        let type73 = "close";
        block = stack.pop();
        block.close = true;
        push({ type: type73, value: value14 });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value14 === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open = block.nodes.shift();
          block.nodes = [open, { type: "text", value: stringify(block) }];
        }
        push({ type: "comma", value: value14 });
        block.commas++;
        continue;
      }
      if (value14 === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({ type: "text", value: value14 });
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value14;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value14;
          prev = before;
          block.ranges--;
          continue;
        }
        push({ type: "dot", value: value14 });
        continue;
      }
      push({ type: "text", value: value14 });
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        let parent = stack[stack.length - 1];
        let index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({ type: "eos" });
    return ast;
  };
  module.exports = parse4;
});

// node_modules/braces/index.js
var require_braces = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var compile = require_compile();
  var expand = require_expand();
  var parse4 = require_parse();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (let pattern3 of input) {
        let result = braces.create(pattern3, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse4(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module.exports = braces;
});

// node_modules/picomatch/lib/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|\$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|\$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|\$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|\$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path.sep,
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// node_modules/picomatch/lib/utils.js
var require_utils5 = __commonJS((exports) => {
  var path = import.meta.require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants4();
  exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path.sep === "\\";
  };
  exports.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*\$)`;
    }
    return output;
  };
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports, module) => {
  var utils = require_utils5();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants4();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = { value: "", depth: 0, isGlob: false };
    const eos = () => index >= length;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = { value: "", depth: 0, isGlob: false };
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx = 0;idx < slashes.length; idx++) {
        const n2 = prevIndex ? prevIndex + 1 : start;
        const i2 = slashes[idx];
        const value14 = input.slice(n2, i2);
        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value14;
          }
          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }
        if (idx !== 0 || value14 !== "") {
          parts.push(value14);
        }
        prevIndex = i2;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value14 = input.slice(prevIndex + 1);
        parts.push(value14);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value14;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module.exports = scan;
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var constants = require_constants4();
  var utils = require_utils5();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value14 = `[${args.join("-")}]`;
    try {
      new RegExp(value14);
    } catch (ex) {
      return args.map((v2) => utils.escapeRegex(v2)).join("..");
    }
    return value14;
  };
  var syntaxError = (type73, char) => {
    return `Missing ${type73}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse4 = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = { ...options };
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = { type: "bos", value: "", output: opts.prepend || "" };
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils.isWindows(options);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value14;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n2 = 1) => input[state.index + n2];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value15 = "", num = 0) => {
      state.consumed += value15;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type73) => {
      state[type73]++;
      stack.push(type73);
    };
    const decrement = (type73) => {
      state[type73]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type73, value15) => {
      const token = { ...EXTGLOB_CHARS[value15], conditions: 1, inner: "" };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({ type: type73, value: value15, output: state.output ? "" : ONE_CHAR });
      push({ type: "paren", extglob: true, value: advance(), output });
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest3;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)\$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest3 = remaining()) && /^\.[^\\/.]+$/.test(rest3)) {
          const expression = parse4(rest3, { ...options, fastpaths: false }).output;
          output = token.close = `)${expression})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({ type: "paren", extglob: true, value: value14, output });
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m2, esc, chars, first, rest3, index) => {
        if (first === "\\") {
          backslashes = true;
          return m2;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest3 ? QMARK.repeat(rest3.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest3 ? QMARK.repeat(rest3.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest3 ? star : "");
          }
          return star;
        }
        return esc ? m2 : `\\${m2}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m2) => {
            return m2.length % 2 === 0 ? "\\\\" : m2 ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value14 = advance();
      if (value14 === "\0") {
        continue;
      }
      if (value14 === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value14 += "\\";
          push({ type: "text", value: value14 });
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value14 += "\\";
          }
        }
        if (opts.unescape === true) {
          value14 = advance();
        } else {
          value14 += advance();
        }
        if (state.brackets === 0) {
          push({ type: "text", value: value14 });
          continue;
        }
      }
      if (state.brackets > 0 && (value14 !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value14 === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest4 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest4];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value14 === "[" && peek() !== ":" || value14 === "-" && peek() === "]") {
          value14 = `\\${value14}`;
        }
        if (value14 === "]" && (prev.value === "[" || prev.value === "[^")) {
          value14 = `\\${value14}`;
        }
        if (opts.posix === true && value14 === "!" && prev.value === "[") {
          value14 = "^";
        }
        prev.value += value14;
        append({ value: value14 });
        continue;
      }
      if (state.quotes === 1 && value14 !== '"') {
        value14 = utils.escapeRegex(value14);
        prev.value += value14;
        append({ value: value14 });
        continue;
      }
      if (value14 === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({ type: "text", value: value14 });
        }
        continue;
      }
      if (value14 === "(") {
        increment("parens");
        push({ type: "paren", value: value14 });
        continue;
      }
      if (value14 === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({ type: "paren", value: value14, output: state.parens ? ")" : "\\)" });
        decrement("parens");
        continue;
      }
      if (value14 === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value14 = `\\${value14}`;
        } else {
          increment("brackets");
        }
        push({ type: "bracket", value: value14 });
        continue;
      }
      if (value14 === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({ type: "text", value: value14, output: `\\${value14}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({ type: "text", value: value14, output: `\\${value14}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value14 = `/${value14}`;
        }
        prev.value += value14;
        append({ value: value14 });
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value14 === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value: value14,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }
      if (value14 === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({ type: "text", value: value14, output: value14 });
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i2 = arr.length - 1;i2 >= 0; i2--) {
            tokens.pop();
            if (arr[i2].type === "brace") {
              break;
            }
            if (arr[i2].type !== "dots") {
              range.unshift(arr[i2].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value14 = output = "\\}";
          state.output = out;
          for (const t2 of toks) {
            state.output += t2.output || t2.value;
          }
        }
        push({ type: "brace", value: value14, output });
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value14 === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({ type: "text", value: value14 });
        continue;
      }
      if (value14 === ",") {
        let output = value14;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({ type: "comma", value: value14, output });
        continue;
      }
      if (value14 === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({ type: "slash", value: value14, output: SLASH_LITERAL });
        continue;
      }
      if (value14 === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value14;
          prev.value += value14;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({ type: "text", value: value14, output: DOT_LITERAL });
          continue;
        }
        push({ type: "dot", value: value14, output: DOT_LITERAL });
        continue;
      }
      if (value14 === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value14);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value14;
          if (next === "<" && !utils.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value14}`;
          }
          push({ type: "text", value: value14, output });
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({ type: "qmark", value: value14, output: QMARK_NO_DOT });
          continue;
        }
        push({ type: "qmark", value: value14, output: QMARK });
        continue;
      }
      if (value14 === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value14);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value14 === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value14);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({ type: "plus", value: value14, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({ type: "plus", value: value14 });
          continue;
        }
        push({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value14 === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({ type: "at", extglob: true, value: value14, output: "" });
          continue;
        }
        push({ type: "text", value: value14 });
        continue;
      }
      if (value14 !== "*") {
        if (value14 === "$" || value14 === "^") {
          value14 = `\\${value14}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value14 += match[0];
          state.index += match[0].length;
        }
        push({ type: "text", value: value14 });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value14;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value14);
        continue;
      }
      let rest3 = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest3)) {
        extglobOpen("star", value14);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value14);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest3[0] && rest3[0] !== "/")) {
          push({ type: "star", value: value14, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({ type: "star", value: value14, output: "" });
          continue;
        }
        while (rest3.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest3 = rest3.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value14;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value14);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value14;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value14);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest3[0] === "/") {
          const end = rest3[1] !== undefined ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value14;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value14 + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest3[0] === "/") {
          prev.type = "globstar";
          prev.value += value14;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value14 + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value14;
        state.output += prev.output;
        state.globstar = true;
        consume(value14);
        continue;
      }
      const token = { type: "star", value: value14, output: star };
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value14;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse4.fastpaths = (input, options) => {
    const opts = { ...options };
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = { negated: false, prefix: "" };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create4 = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create4(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils.removePrefix(input, state);
    let source = create4(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module.exports = parse4;
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var scan = require_scan();
  var parse4 = require_parse2();
  var utils = require_utils5();
  var constants = require_constants4();
  var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
      const result = { glob, state, regex, posix, input, output, match, isMatch };
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, { glob, posix } = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return { isMatch: false, output: "" };
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return { isMatch: Boolean(match), match, output };
  };
  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
  };
  picomatch.isMatch = (str, patterns6, options) => picomatch(patterns6, options)(str);
  picomatch.parse = (pattern3, options) => {
    if (Array.isArray(pattern3))
      return pattern3.map((p2) => picomatch.parse(p2, options));
    return parse4(pattern3, { ...options, fastpaths: false });
  };
  picomatch.scan = (input, options) => scan(input, options);
  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*\$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = { negated: false, fastpaths: true };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse4.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse4(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module.exports = picomatch;
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var braces = require_braces();
  var picomatch = require_picomatch();
  var utils = require_utils5();
  var isEmptyString = (val) => val === "" || val === "./";
  var micromatch = (list, patterns6, options) => {
    patterns6 = [].concat(patterns6);
    list = [].concat(list);
    let omit5 = new Set;
    let keep = new Set;
    let items = new Set;
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i2 = 0;i2 < patterns6.length; i2++) {
      let isMatch = picomatch(String(patterns6[i2]), { ...options, onResult }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit5.add(matched.output);
        } else {
          omit5.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns6.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit5.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns6.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns6.map((p2) => p2.replace(/\\/g, "")) : patterns6;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern3, options) => picomatch(pattern3, options);
  micromatch.isMatch = (str, patterns6, options) => picomatch(patterns6, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list, patterns6, options = {}) => {
    patterns6 = [].concat(patterns6).map(String);
    let result = new Set;
    let items = [];
    let onResult = (state) => {
      if (options.onResult)
        options.onResult(state);
      items.push(state.output);
    };
    let matches = new Set(micromatch(list, patterns6, { ...options, onResult }));
    for (let item of items) {
      if (!matches.has(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern3, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    if (Array.isArray(pattern3)) {
      return pattern3.some((p2) => micromatch.contains(str, p2, options));
    }
    if (typeof pattern3 === "string") {
      if (isEmptyString(str) || isEmptyString(pattern3)) {
        return false;
      }
      if (str.includes(pattern3) || str.startsWith("./") && str.slice(2).includes(pattern3)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern3, { ...options, contains: true });
  };
  micromatch.matchKeys = (obj, patterns6, options) => {
    if (!utils.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch(Object.keys(obj), patterns6, options);
    let res = {};
    for (let key of keys)
      res[key] = obj[key];
    return res;
  };
  micromatch.some = (list, patterns6, options) => {
    let items = [].concat(list);
    for (let pattern3 of [].concat(patterns6)) {
      let isMatch = picomatch(String(pattern3), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list, patterns6, options) => {
    let items = [].concat(list);
    for (let pattern3 of [].concat(patterns6)) {
      let isMatch = picomatch(String(pattern3), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns6, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    return [].concat(patterns6).every((p2) => picomatch(p2, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v2) => v2 === undefined ? "" : v2);
    }
  };
  micromatch.makeRe = (...args) => picomatch.makeRe(...args);
  micromatch.scan = (...args) => picomatch.scan(...args);
  micromatch.parse = (patterns6, options) => {
    let res = [];
    for (let pattern3 of [].concat(patterns6 || [])) {
      for (let str of braces(String(pattern3), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern3, options) => {
    if (typeof pattern3 !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern3)) {
      return [pattern3];
    }
    return braces(pattern3, options);
  };
  micromatch.braceExpand = (pattern3, options) => {
    if (typeof pattern3 !== "string")
      throw new TypeError("Expected a string");
    return micromatch.braces(pattern3, { ...options, expand: true });
  };
  module.exports = micromatch;
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS((exports) => {
  var isStaticPattern = function(pattern3, options = {}) {
    return !isDynamicPattern(pattern3, options);
  };
  var isDynamicPattern = function(pattern3, options = {}) {
    if (pattern3 === "") {
      return false;
    }
    if (options.caseSensitiveMatch === false || pattern3.includes(ESCAPE_SYMBOL)) {
      return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern3) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern3) || REGEX_GROUP_SYMBOLS_RE.test(pattern3)) {
      return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern3)) {
      return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern3)) {
      return true;
    }
    return false;
  };
  var hasBraceExpansion = function(pattern3) {
    const openingBraceIndex = pattern3.indexOf("{");
    if (openingBraceIndex === -1) {
      return false;
    }
    const closingBraceIndex = pattern3.indexOf("}", openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
      return false;
    }
    const braceContent = pattern3.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
  };
  var convertToPositivePattern = function(pattern3) {
    return isNegativePattern(pattern3) ? pattern3.slice(1) : pattern3;
  };
  var convertToNegativePattern = function(pattern3) {
    return "!" + pattern3;
  };
  var isNegativePattern = function(pattern3) {
    return pattern3.startsWith("!") && pattern3[1] !== "(";
  };
  var isPositivePattern = function(pattern3) {
    return !isNegativePattern(pattern3);
  };
  var getNegativePatterns = function(patterns6) {
    return patterns6.filter(isNegativePattern);
  };
  var getPositivePatterns = function(patterns6) {
    return patterns6.filter(isPositivePattern);
  };
  var getPatternsInsideCurrentDirectory = function(patterns6) {
    return patterns6.filter((pattern3) => !isPatternRelatedToParentDirectory(pattern3));
  };
  var getPatternsOutsideCurrentDirectory = function(patterns6) {
    return patterns6.filter(isPatternRelatedToParentDirectory);
  };
  var isPatternRelatedToParentDirectory = function(pattern3) {
    return pattern3.startsWith("..") || pattern3.startsWith("./..");
  };
  var getBaseDirectory = function(pattern3) {
    return globParent(pattern3, { flipBackslashes: false });
  };
  var hasGlobStar = function(pattern3) {
    return pattern3.includes(GLOBSTAR);
  };
  var endsWithSlashGlobStar = function(pattern3) {
    return pattern3.endsWith("/" + GLOBSTAR);
  };
  var isAffectDepthOfReadingPattern = function(pattern3) {
    const basename = path.basename(pattern3);
    return endsWithSlashGlobStar(pattern3) || isStaticPattern(basename);
  };
  var expandPatternsWithBraceExpansion = function(patterns6) {
    return patterns6.reduce((collection, pattern3) => {
      return collection.concat(expandBraceExpansion(pattern3));
    }, []);
  };
  var expandBraceExpansion = function(pattern3) {
    const patterns6 = micromatch.braces(pattern3, { expand: true, nodupes: true, keepEscaping: true });
    patterns6.sort((a2, b2) => a2.length - b2.length);
    return patterns6.filter((pattern4) => pattern4 !== "");
  };
  var getPatternParts = function(pattern3, options) {
    let { parts } = micromatch.scan(pattern3, Object.assign(Object.assign({}, options), { parts: true }));
    if (parts.length === 0) {
      parts = [pattern3];
    }
    if (parts[0].startsWith("/")) {
      parts[0] = parts[0].slice(1);
      parts.unshift("");
    }
    return parts;
  };
  var makeRe = function(pattern3, options) {
    return micromatch.makeRe(pattern3, options);
  };
  var convertPatternsToRe = function(patterns6, options) {
    return patterns6.map((pattern3) => makeRe(pattern3, options));
  };
  var matchAny = function(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
  };
  var removeDuplicateSlashes = function(pattern3) {
    return pattern3.replace(DOUBLE_SLASH_RE, "/");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = undefined;
  var path = import.meta.require("path");
  var globParent = require_glob_parent();
  var micromatch = require_micromatch();
  var GLOBSTAR = "**";
  var ESCAPE_SYMBOL = "\\";
  var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
  var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
  var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
  var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
  var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
  var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
  exports.isStaticPattern = isStaticPattern;
  exports.isDynamicPattern = isDynamicPattern;
  exports.convertToPositivePattern = convertToPositivePattern;
  exports.convertToNegativePattern = convertToNegativePattern;
  exports.isNegativePattern = isNegativePattern;
  exports.isPositivePattern = isPositivePattern;
  exports.getNegativePatterns = getNegativePatterns;
  exports.getPositivePatterns = getPositivePatterns;
  exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
  exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
  exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
  exports.getBaseDirectory = getBaseDirectory;
  exports.hasGlobStar = hasGlobStar;
  exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
  exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
  exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
  exports.expandBraceExpansion = expandBraceExpansion;
  exports.getPatternParts = getPatternParts;
  exports.makeRe = makeRe;
  exports.convertPatternsToRe = convertPatternsToRe;
  exports.matchAny = matchAny;
  exports.removeDuplicateSlashes = removeDuplicateSlashes;
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS((exports) => {
  var merge = function(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
      stream.once("error", (error21) => mergedStream.emit("error", error21));
    });
    mergedStream.once("close", () => propagateCloseEventToSources(streams));
    mergedStream.once("end", () => propagateCloseEventToSources(streams));
    return mergedStream;
  };
  var propagateCloseEventToSources = function(streams) {
    streams.forEach((stream) => stream.emit("close"));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var merge2 = require_merge2();
  exports.merge = merge;
});

// node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS((exports) => {
  var isString = function(input) {
    return typeof input === "string";
  };
  var isEmpty = function(input) {
    return input === "";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = exports.isString = undefined;
  exports.isString = isString;
  exports.isEmpty = isEmpty;
});

// node_modules/fast-glob/out/utils/index.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = undefined;
  var array4 = require_array();
  exports.array = array4;
  var errno = require_errno();
  exports.errno = errno;
  var fs = require_fs();
  exports.fs = fs;
  var path = require_path();
  exports.path = path;
  var pattern3 = require_pattern();
  exports.pattern = pattern3;
  var stream = require_stream();
  exports.stream = stream;
  var string6 = require_string();
  exports.string = string6;
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS((exports) => {
  var generate3 = function(input, settings) {
    const patterns6 = processPatterns(input, settings);
    const ignore = processPatterns(settings.ignore, settings);
    const positivePatterns = getPositivePatterns(patterns6);
    const negativePatterns = getNegativePatternsAsPositive(patterns6, ignore);
    const staticPatterns = positivePatterns.filter((pattern3) => utils.pattern.isStaticPattern(pattern3, settings));
    const dynamicPatterns = positivePatterns.filter((pattern3) => utils.pattern.isDynamicPattern(pattern3, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
    return staticTasks.concat(dynamicTasks);
  };
  var processPatterns = function(input, settings) {
    let patterns6 = input;
    if (settings.braceExpansion) {
      patterns6 = utils.pattern.expandPatternsWithBraceExpansion(patterns6);
    }
    if (settings.baseNameMatch) {
      patterns6 = patterns6.map((pattern3) => pattern3.includes("/") ? pattern3 : `**/${pattern3}`);
    }
    return patterns6.map((pattern3) => utils.pattern.removeDuplicateSlashes(pattern3));
  };
  var convertPatternsToTasks = function(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    if ("." in insideCurrentDirectoryGroup) {
      tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
    } else {
      tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
  };
  var getPositivePatterns = function(patterns6) {
    return utils.pattern.getPositivePatterns(patterns6);
  };
  var getNegativePatternsAsPositive = function(patterns6, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns6).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
  };
  var groupPatternsByBaseDirectory = function(patterns6) {
    const group = {};
    return patterns6.reduce((collection, pattern3) => {
      const base = utils.pattern.getBaseDirectory(pattern3);
      if (base in collection) {
        collection[base].push(pattern3);
      } else {
        collection[base] = [pattern3];
      }
      return collection;
    }, group);
  };
  var convertPatternGroupsToTasks = function(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
      return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
  };
  var convertPatternGroupToTask = function(base, positive, negative, dynamic) {
    return {
      dynamic,
      positive,
      negative,
      base,
      patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = undefined;
  var utils = require_utils6();
  exports.generate = generate3;
  exports.convertPatternsToTasks = convertPatternsToTasks;
  exports.getPositivePatterns = getPositivePatterns;
  exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
  exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
  exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
  exports.convertPatternGroupToTask = convertPatternGroupToTask;
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS((exports) => {
  var read = function(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
      if (lstatError !== null) {
        callFailureCallback(callback, lstatError);
        return;
      }
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        callSuccessCallback(callback, lstat);
        return;
      }
      settings.fs.stat(path, (statError, stat) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            callFailureCallback(callback, statError);
            return;
          }
          callSuccessCallback(callback, lstat);
          return;
        }
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        callSuccessCallback(callback, stat);
      });
    });
  };
  var callFailureCallback = function(callback, error21) {
    callback(error21);
  };
  var callSuccessCallback = function(callback, result) {
    callback(null, result);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = undefined;
  exports.read = read;
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS((exports) => {
  var read = function(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
      return lstat;
    }
    try {
      const stat = settings.fs.statSync(path);
      if (settings.markSymbolicLink) {
        stat.isSymbolicLink = () => true;
      }
      return stat;
    } catch (error21) {
      if (!settings.throwErrorOnBrokenSymbolicLink) {
        return lstat;
      }
      throw error21;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = undefined;
  exports.read = read;
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS((exports) => {
  var createFileSystemAdapter = function(fsMethods) {
    if (fsMethods === undefined) {
      return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = undefined;
  var fs = import.meta.require("fs");
  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
  };
  exports.createFileSystemAdapter = createFileSystemAdapter;
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fs = require_fs2();

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
      this.fs = fs.createFileSystemAdapter(this._options.fs);
      this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value14) {
      return option !== null && option !== undefined ? option : value14;
    }
  }
  exports.default = Settings;
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS((exports) => {
  var stat = function(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      async.read(path, getSettings(), optionsOrSettingsOrCallback);
      return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
  };
  var statSync = function(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
  };
  var getSettings = function(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.statSync = exports.stat = exports.Settings = undefined;
  var async = require_async();
  var sync = require_sync();
  var settings_1 = require_settings();
  exports.Settings = settings_1.default;
  exports.stat = stat;
  exports.statSync = statSync;
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS((exports, module) => {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var promise4;
  module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise4 || (promise4 = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS((exports, module) => {
  var runParallel = function(tasks, cb) {
    let results, pending, keys;
    let isSync = true;
    if (Array.isArray(tasks)) {
      results = [];
      pending = tasks.length;
    } else {
      keys = Object.keys(tasks);
      results = {};
      pending = keys.length;
    }
    function done(err) {
      function end() {
        if (cb)
          cb(err, results);
        cb = null;
      }
      if (isSync)
        queueMicrotask2(end);
      else
        end();
    }
    function each(i2, err, result) {
      results[i2] = result;
      if (--pending === 0 || err) {
        done(err);
      }
    }
    if (!pending) {
      done(null);
    } else if (keys) {
      keys.forEach(function(key) {
        tasks[key](function(err, result) {
          each(key, err, result);
        });
      });
    } else {
      tasks.forEach(function(task, i2) {
        task(function(err, result) {
          each(i2, err, result);
        });
      });
    }
    isSync = false;
  };
  /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  module.exports = runParallel;
  var queueMicrotask2 = require_queue_microtask();
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = undefined;
  var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
  if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
  }
  var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
  var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
  var SUPPORTED_MAJOR_VERSION = 10;
  var SUPPORTED_MINOR_VERSION = 10;
  var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
  var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
  exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS((exports) => {
  var createDirentFromStats = function(name, stats) {
    return new DirentFromStats(name, stats);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDirentFromStats = undefined;

  class DirentFromStats {
    constructor(name, stats) {
      this.name = name;
      this.isBlockDevice = stats.isBlockDevice.bind(stats);
      this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
      this.isDirectory = stats.isDirectory.bind(stats);
      this.isFIFO = stats.isFIFO.bind(stats);
      this.isFile = stats.isFile.bind(stats);
      this.isSocket = stats.isSocket.bind(stats);
      this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
  }
  exports.createDirentFromStats = createDirentFromStats;
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fs = undefined;
  var fs = require_fs3();
  exports.fs = fs;
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common3 = __commonJS((exports) => {
  var joinPathSegments = function(a2, b2, separator) {
    if (a2.endsWith(separator)) {
      return a2 + b2;
    }
    return a2 + separator + b2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinPathSegments = undefined;
  exports.joinPathSegments = joinPathSegments;
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS((exports) => {
  var read = function(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      readdirWithFileTypes(directory, settings, callback);
      return;
    }
    readdir(directory, settings, callback);
  };
  var readdirWithFileTypes = function(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
      if (readdirError !== null) {
        callFailureCallback(callback, readdirError);
        return;
      }
      const entries = dirents.map((dirent) => ({
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      }));
      if (!settings.followSymbolicLinks) {
        callSuccessCallback(callback, entries);
        return;
      }
      const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
      rpl(tasks, (rplError, rplEntries) => {
        if (rplError !== null) {
          callFailureCallback(callback, rplError);
          return;
        }
        callSuccessCallback(callback, rplEntries);
      });
    });
  };
  var makeRplTaskEntry = function(entry, settings) {
    return (done) => {
      if (!entry.dirent.isSymbolicLink()) {
        done(null, entry);
        return;
      }
      settings.fs.stat(entry.path, (statError, stats) => {
        if (statError !== null) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            done(statError);
            return;
          }
          done(null, entry);
          return;
        }
        entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
        done(null, entry);
      });
    };
  };
  var readdir = function(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
      if (readdirError !== null) {
        callFailureCallback(callback, readdirError);
        return;
      }
      const tasks = names.map((name) => {
        const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        return (done) => {
          fsStat.stat(path, settings.fsStatSettings, (error21, stats) => {
            if (error21 !== null) {
              done(error21);
              return;
            }
            const entry = {
              name,
              path,
              dirent: utils.fs.createDirentFromStats(name, stats)
            };
            if (settings.stats) {
              entry.stats = stats;
            }
            done(null, entry);
          });
        };
      });
      rpl(tasks, (rplError, entries) => {
        if (rplError !== null) {
          callFailureCallback(callback, rplError);
          return;
        }
        callSuccessCallback(callback, entries);
      });
    });
  };
  var callFailureCallback = function(callback, error21) {
    callback(error21);
  };
  var callSuccessCallback = function(callback, result) {
    callback(null, result);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readdir = exports.readdirWithFileTypes = exports.read = undefined;
  var fsStat = require_out();
  var rpl = require_run_parallel();
  var constants_1 = require_constants5();
  var utils = require_utils7();
  var common = require_common3();
  exports.read = read;
  exports.readdirWithFileTypes = readdirWithFileTypes;
  exports.readdir = readdir;
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS((exports) => {
  var read = function(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
  };
  var readdirWithFileTypes = function(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
      const entry = {
        dirent,
        name: dirent.name,
        path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
      };
      if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
        try {
          const stats = settings.fs.statSync(entry.path);
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
        } catch (error21) {
          if (settings.throwErrorOnBrokenSymbolicLink) {
            throw error21;
          }
        }
      }
      return entry;
    });
  };
  var readdir = function(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
      const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
      const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
      const entry = {
        name,
        path: entryPath,
        dirent: utils.fs.createDirentFromStats(name, stats)
      };
      if (settings.stats) {
        entry.stats = stats;
      }
      return entry;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readdir = exports.readdirWithFileTypes = exports.read = undefined;
  var fsStat = require_out();
  var constants_1 = require_constants5();
  var utils = require_utils7();
  var common = require_common3();
  exports.read = read;
  exports.readdirWithFileTypes = readdirWithFileTypes;
  exports.readdir = readdir;
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS((exports) => {
  var createFileSystemAdapter = function(fsMethods) {
    if (fsMethods === undefined) {
      return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = undefined;
  var fs = import.meta.require("fs");
  exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
  };
  exports.createFileSystemAdapter = createFileSystemAdapter;
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = import.meta.require("path");
  var fsStat = require_out();
  var fs = require_fs4();

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
      this.fs = fs.createFileSystemAdapter(this._options.fs);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
      this.stats = this._getValue(this._options.stats, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      this.fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value14) {
      return option !== null && option !== undefined ? option : value14;
    }
  }
  exports.default = Settings;
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS((exports) => {
  var scandir = function(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      async.read(path, getSettings(), optionsOrSettingsOrCallback);
      return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
  };
  var scandirSync = function(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
  };
  var getSettings = function(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Settings = exports.scandirSync = exports.scandir = undefined;
  var async = require_async2();
  var sync = require_sync2();
  var settings_1 = require_settings2();
  exports.Settings = settings_1.default;
  exports.scandir = scandir;
  exports.scandirSync = scandirSync;
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS((exports, module) => {
  var reusify = function(Constructor2) {
    var head = new Constructor2;
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor2;
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  };
  module.exports = reusify;
});

// node_modules/fastq/queue.js
var require_queue = __commonJS((exports, module) => {
  var fastqueue = function(context, worker, _concurrency) {
    if (typeof context === "function") {
      _concurrency = worker;
      worker = context;
      context = null;
    }
    if (!(_concurrency >= 1)) {
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push,
      drain: noop,
      saturated: noop,
      pause,
      paused: false,
      get concurrency() {
        return _concurrency;
      },
      set concurrency(value14) {
        if (!(value14 >= 1)) {
          throw new Error("fastqueue concurrency must be equal to or greater than 1");
        }
        _concurrency = value14;
        if (self2.paused)
          return;
        for (;queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      },
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop,
      kill,
      killAndDrain,
      error: error21
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter = 0;
      while (current) {
        current = current.next;
        counter++;
      }
      return counter;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      for (;queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value14, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value14;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running >= _concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function unshift(value14, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value14;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running >= _concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next && _running <= _concurrency) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop;
    }
    function error21(handler) {
      errorHandler = handler;
    }
  };
  var noop = function() {
  };
  var Task = function() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop;
      if (self2.errorHandler) {
        errorHandler(err, val);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  };
  var queueAsPromised = function(context, worker, _concurrency) {
    if (typeof context === "function") {
      _concurrency = worker;
      worker = context;
      context = null;
    }
    function asyncWrapper(arg, cb) {
      worker.call(this, arg).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, _concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    queue.drained = drained;
    return queue;
    function push(value14) {
      var p2 = new Promise(function(resolve, reject) {
        pushCb(value14, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      p2.catch(noop);
      return p2;
    }
    function unshift(value14) {
      var p2 = new Promise(function(resolve, reject) {
        unshiftCb(value14, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      p2.catch(noop);
      return p2;
    }
    function drained() {
      if (queue.idle()) {
        return new Promise(function(resolve) {
          resolve();
        });
      }
      var previousDrain = queue.drain;
      var p2 = new Promise(function(resolve) {
        queue.drain = function() {
          previousDrain();
          resolve();
        };
      });
      return p2;
    }
  };
  var reusify = require_reusify();
  module.exports = fastqueue;
  module.exports.promise = queueAsPromised;
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common4 = __commonJS((exports) => {
  var isFatalError = function(settings, error21) {
    if (settings.errorFilter === null) {
      return true;
    }
    return !settings.errorFilter(error21);
  };
  var isAppliedFilter = function(filter, value14) {
    return filter === null || filter(value14);
  };
  var replacePathSegmentSeparator = function(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
  };
  var joinPathSegments = function(a2, b2, separator) {
    if (a2 === "") {
      return b2;
    }
    if (a2.endsWith(separator)) {
      return a2 + b2;
    }
    return a2 + separator + b2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = undefined;
  exports.isFatalError = isFatalError;
  exports.isAppliedFilter = isAppliedFilter;
  exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
  exports.joinPathSegments = joinPathSegments;
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var common = require_common4();

  class Reader {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
  }
  exports.default = Reader;
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = import.meta.require("events");
  var fsScandir = require_out2();
  var fastq = require_queue();
  var common = require_common4();
  var reader_1 = require_reader();

  class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
      super(_root, _settings);
      this._settings = _settings;
      this._scandir = fsScandir.scandir;
      this._emitter = new events_1.EventEmitter;
      this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
      this._isFatalError = false;
      this._isDestroyed = false;
      this._queue.drain = () => {
        if (!this._isFatalError) {
          this._emitter.emit("end");
        }
      };
    }
    read() {
      this._isFatalError = false;
      this._isDestroyed = false;
      setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      });
      return this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed) {
        throw new Error("The reader is already destroyed");
      }
      this._isDestroyed = true;
      this._queue.killAndDrain();
    }
    onEntry(callback) {
      this._emitter.on("entry", callback);
    }
    onError(callback) {
      this._emitter.once("error", callback);
    }
    onEnd(callback) {
      this._emitter.once("end", callback);
    }
    _pushToQueue(directory, base) {
      const queueItem = { directory, base };
      this._queue.push(queueItem, (error21) => {
        if (error21 !== null) {
          this._handleError(error21);
        }
      });
    }
    _worker(item, done) {
      this._scandir(item.directory, this._settings.fsScandirSettings, (error21, entries) => {
        if (error21 !== null) {
          done(error21, undefined);
          return;
        }
        for (const entry of entries) {
          this._handleEntry(entry, item.base);
        }
        done(null, undefined);
      });
    }
    _handleError(error21) {
      if (this._isDestroyed || !common.isFatalError(this._settings, error21)) {
        return;
      }
      this._isFatalError = true;
      this._isDestroyed = true;
      this._emitter.emit("error", error21);
    }
    _handleEntry(entry, base) {
      if (this._isDestroyed || this._isFatalError) {
        return;
      }
      const fullpath = entry.path;
      if (base !== undefined) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._emitEntry(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
      }
    }
    _emitEntry(entry) {
      this._emitter.emit("entry", entry);
    }
  }
  exports.default = AsyncReader;
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS((exports) => {
  var callFailureCallback = function(callback, error21) {
    callback(error21);
  };
  var callSuccessCallback = function(callback, entries) {
    callback(null, entries);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var async_1 = require_async3();

  class AsyncProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._storage = [];
    }
    read(callback) {
      this._reader.onError((error21) => {
        callFailureCallback(callback, error21);
      });
      this._reader.onEntry((entry) => {
        this._storage.push(entry);
      });
      this._reader.onEnd(() => {
        callSuccessCallback(callback, this._storage);
      });
      this._reader.read();
    }
  }
  exports.default = AsyncProvider;
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = import.meta.require("stream");
  var async_1 = require_async3();

  class StreamProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new async_1.default(this._root, this._settings);
      this._stream = new stream_1.Readable({
        objectMode: true,
        read: () => {
        },
        destroy: () => {
          if (!this._reader.isDestroyed) {
            this._reader.destroy();
          }
        }
      });
    }
    read() {
      this._reader.onError((error21) => {
        this._stream.emit("error", error21);
      });
      this._reader.onEntry((entry) => {
        this._stream.push(entry);
      });
      this._reader.onEnd(() => {
        this._stream.push(null);
      });
      this._reader.read();
      return this._stream;
    }
  }
  exports.default = StreamProvider;
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsScandir = require_out2();
  var common = require_common4();
  var reader_1 = require_reader();

  class SyncReader extends reader_1.default {
    constructor() {
      super(...arguments);
      this._scandir = fsScandir.scandirSync;
      this._storage = [];
      this._queue = new Set;
    }
    read() {
      this._pushToQueue(this._root, this._settings.basePath);
      this._handleQueue();
      return this._storage;
    }
    _pushToQueue(directory, base) {
      this._queue.add({ directory, base });
    }
    _handleQueue() {
      for (const item of this._queue.values()) {
        this._handleDirectory(item.directory, item.base);
      }
    }
    _handleDirectory(directory, base) {
      try {
        const entries = this._scandir(directory, this._settings.fsScandirSettings);
        for (const entry of entries) {
          this._handleEntry(entry, base);
        }
      } catch (error21) {
        this._handleError(error21);
      }
    }
    _handleError(error21) {
      if (!common.isFatalError(this._settings, error21)) {
        return;
      }
      throw error21;
    }
    _handleEntry(entry, base) {
      const fullpath = entry.path;
      if (base !== undefined) {
        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
      }
      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
        this._pushToStorage(entry);
      }
      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
        this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
      }
    }
    _pushToStorage(entry) {
      this._storage.push(entry);
    }
  }
  exports.default = SyncReader;
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var sync_1 = require_sync3();

  class SyncProvider {
    constructor(_root, _settings) {
      this._root = _root;
      this._settings = _settings;
      this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  }
  exports.default = SyncProvider;
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = import.meta.require("path");
  var fsScandir = require_out2();

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.basePath = this._getValue(this._options.basePath, undefined);
      this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
      this.deepFilter = this._getValue(this._options.deepFilter, null);
      this.entryFilter = this._getValue(this._options.entryFilter, null);
      this.errorFilter = this._getValue(this._options.errorFilter, null);
      this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
      this.fsScandirSettings = new fsScandir.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(option, value14) {
      return option !== null && option !== undefined ? option : value14;
    }
  }
  exports.default = Settings;
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS((exports) => {
  var walk = function(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === "function") {
      new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
      return;
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
  };
  var walkSync = function(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
  };
  var walkStream = function(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
  };
  var getSettings = function(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
      return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Settings = exports.walkStream = exports.walkSync = exports.walk = undefined;
  var async_1 = require_async4();
  var stream_1 = require_stream2();
  var sync_1 = require_sync4();
  var settings_1 = require_settings3();
  exports.Settings = settings_1.default;
  exports.walk = walk;
  exports.walkSync = walkSync;
  exports.walkStream = walkStream;
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = import.meta.require("path");
  var fsStat = require_out();
  var utils = require_utils6();

  class Reader {
    constructor(_settings) {
      this._settings = _settings;
      this._fsStatSettings = new fsStat.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(filepath) {
      return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern3) {
      const entry = {
        name: pattern3,
        path: pattern3,
        dirent: utils.fs.createDirentFromStats(pattern3, stats)
      };
      if (this._settings.stats) {
        entry.stats = stats;
      }
      return entry;
    }
    _isFatalError(error21) {
      return !utils.errno.isEnoentCodeError(error21) && !this._settings.suppressErrors;
    }
  }
  exports.default = Reader;
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = import.meta.require("stream");
  var fsStat = require_out();
  var fsWalk = require_out3();
  var reader_1 = require_reader2();

  class ReaderStream extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkStream = fsWalk.walkStream;
      this._stat = fsStat.stat;
    }
    dynamic(root, options) {
      return this._walkStream(root, options);
    }
    static(patterns6, options) {
      const filepaths = patterns6.map(this._getFullEntryPath, this);
      const stream = new stream_1.PassThrough({ objectMode: true });
      stream._write = (index, _enc, done) => {
        return this._getEntry(filepaths[index], patterns6[index], options).then((entry) => {
          if (entry !== null && options.entryFilter(entry)) {
            stream.push(entry);
          }
          if (index === filepaths.length - 1) {
            stream.end();
          }
          done();
        }).catch(done);
      };
      for (let i2 = 0;i2 < filepaths.length; i2++) {
        stream.write(i2);
      }
      return stream;
    }
    _getEntry(filepath, pattern3, options) {
      return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern3)).catch((error21) => {
        if (options.errorFilter(error21)) {
          return null;
        }
        throw error21;
      });
    }
    _getStat(filepath) {
      return new Promise((resolve, reject) => {
        this._stat(filepath, this._fsStatSettings, (error21, stats) => {
          return error21 === null ? resolve(stats) : reject(error21);
        });
      });
    }
  }
  exports.default = ReaderStream;
});

// node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsWalk = require_out3();
  var reader_1 = require_reader2();
  var stream_1 = require_stream3();

  class ReaderAsync extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkAsync = fsWalk.walk;
      this._readerStream = new stream_1.default(this._settings);
    }
    dynamic(root, options) {
      return new Promise((resolve, reject) => {
        this._walkAsync(root, options, (error21, entries) => {
          if (error21 === null) {
            resolve(entries);
          } else {
            reject(error21);
          }
        });
      });
    }
    async static(patterns6, options) {
      const entries = [];
      const stream = this._readerStream.static(patterns6, options);
      return new Promise((resolve, reject) => {
        stream.once("error", reject);
        stream.on("data", (entry) => entries.push(entry));
        stream.once("end", () => resolve(entries));
      });
    }
  }
  exports.default = ReaderAsync;
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils6();

  class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
      this._patterns = _patterns;
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this._storage = [];
      this._fillStorage();
    }
    _fillStorage() {
      for (const pattern3 of this._patterns) {
        const segments = this._getPatternSegments(pattern3);
        const sections = this._splitSegmentsIntoSections(segments);
        this._storage.push({
          complete: sections.length <= 1,
          pattern: pattern3,
          segments,
          sections
        });
      }
    }
    _getPatternSegments(pattern3) {
      const parts = utils.pattern.getPatternParts(pattern3, this._micromatchOptions);
      return parts.map((part) => {
        const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
        if (!dynamic) {
          return {
            dynamic: false,
            pattern: part
          };
        }
        return {
          dynamic: true,
          pattern: part,
          patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
        };
      });
    }
    _splitSegmentsIntoSections(segments) {
      return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
  }
  exports.default = Matcher;
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var matcher_1 = require_matcher();

  class PartialMatcher extends matcher_1.default {
    match(filepath) {
      const parts = filepath.split("/");
      const levels = parts.length;
      const patterns6 = this._storage.filter((info) => !info.complete || info.segments.length > levels);
      for (const pattern3 of patterns6) {
        const section = pattern3.sections[0];
        if (!pattern3.complete && levels > section.length) {
          return true;
        }
        const match = parts.every((part, index) => {
          const segment = pattern3.segments[index];
          if (segment.dynamic && segment.patternRe.test(part)) {
            return true;
          }
          if (!segment.dynamic && segment.pattern === part) {
            return true;
          }
          return false;
        });
        if (match) {
          return true;
        }
      }
      return false;
    }
  }
  exports.default = PartialMatcher;
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils6();
  var partial_1 = require_partial();

  class DeepFilter {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
      const matcher = this._getMatcher(positive);
      const negativeRe = this._getNegativePatternsRe(negative);
      return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns6) {
      return new partial_1.default(patterns6, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns6) {
      const affectDepthOfReadingPatterns = patterns6.filter(utils.pattern.isAffectDepthOfReadingPattern);
      return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
      if (this._isSkippedByDeep(basePath, entry.path)) {
        return false;
      }
      if (this._isSkippedSymbolicLink(entry)) {
        return false;
      }
      const filepath = utils.path.removeLeadingDotSegment(entry.path);
      if (this._isSkippedByPositivePatterns(filepath, matcher)) {
        return false;
      }
      return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
      if (this._settings.deep === Infinity) {
        return false;
      }
      return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
      const entryPathDepth = entryPath.split("/").length;
      if (basePath === "") {
        return entryPathDepth;
      }
      const basePathDepth = basePath.split("/").length;
      return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
      return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
      return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
      return !utils.pattern.matchAny(entryPath, patternsRe);
    }
  }
  exports.default = DeepFilter;
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils6();

  class EntryFilter {
    constructor(_settings, _micromatchOptions) {
      this._settings = _settings;
      this._micromatchOptions = _micromatchOptions;
      this.index = new Map;
    }
    getFilter(positive, negative) {
      const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
      return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
      const filepath = utils.path.removeLeadingDotSegment(entry.path);
      if (this._settings.unique && this._isDuplicateEntry(filepath)) {
        return false;
      }
      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }
      if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
        return false;
      }
      const isDirectory = entry.dirent.isDirectory();
      const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
      if (this._settings.unique && isMatched) {
        this._createIndexRecord(filepath);
      }
      return isMatched;
    }
    _isDuplicateEntry(filepath) {
      return this.index.has(filepath);
    }
    _createIndexRecord(filepath) {
      this.index.set(filepath, undefined);
    }
    _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }
      const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(filepath, patternsRe, isDirectory) {
      const isMatched = utils.pattern.matchAny(filepath, patternsRe);
      if (!isMatched && isDirectory) {
        return utils.pattern.matchAny(filepath + "/", patternsRe);
      }
      return isMatched;
    }
  }
  exports.default = EntryFilter;
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils6();

  class ErrorFilter {
    constructor(_settings) {
      this._settings = _settings;
    }
    getFilter() {
      return (error21) => this._isNonFatalError(error21);
    }
    _isNonFatalError(error21) {
      return utils.errno.isEnoentCodeError(error21) || this._settings.suppressErrors;
    }
  }
  exports.default = ErrorFilter;
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils = require_utils6();

  class EntryTransformer {
    constructor(_settings) {
      this._settings = _settings;
    }
    getTransformer() {
      return (entry) => this._transform(entry);
    }
    _transform(entry) {
      let filepath = entry.path;
      if (this._settings.absolute) {
        filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        filepath = utils.path.unixify(filepath);
      }
      if (this._settings.markDirectories && entry.dirent.isDirectory()) {
        filepath += "/";
      }
      if (!this._settings.objectMode) {
        return filepath;
      }
      return Object.assign(Object.assign({}, entry), { path: filepath });
    }
  }
  exports.default = EntryTransformer;
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var path = import.meta.require("path");
  var deep_1 = require_deep();
  var entry_1 = require_entry();
  var error_1 = require_error2();
  var entry_2 = require_entry2();

  class Provider {
    constructor(_settings) {
      this._settings = _settings;
      this.errorFilter = new error_1.default(this._settings);
      this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
      this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
      this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
      return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
      const basePath = task.base === "." ? "" : task.base;
      return {
        basePath,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
        entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: true,
        strictSlashes: false
      };
    }
  }
  exports.default = Provider;
});

// node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var async_1 = require_async5();
  var provider_1 = require_provider();

  class ProviderAsync extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new async_1.default(this._settings);
    }
    async read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = await this.api(root, task, options);
      return entries.map((entry) => options.transform(entry));
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  }
  exports.default = ProviderAsync;
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = import.meta.require("stream");
  var stream_2 = require_stream3();
  var provider_1 = require_provider();

  class ProviderStream extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new stream_2.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const source = this.api(root, task, options);
      const destination = new stream_1.Readable({ objectMode: true, read: () => {
      } });
      source.once("error", (error21) => destination.emit("error", error21)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
      destination.once("close", () => source.destroy());
      return destination;
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  }
  exports.default = ProviderStream;
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var fsStat = require_out();
  var fsWalk = require_out3();
  var reader_1 = require_reader2();

  class ReaderSync extends reader_1.default {
    constructor() {
      super(...arguments);
      this._walkSync = fsWalk.walkSync;
      this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
      return this._walkSync(root, options);
    }
    static(patterns6, options) {
      const entries = [];
      for (const pattern3 of patterns6) {
        const filepath = this._getFullEntryPath(pattern3);
        const entry = this._getEntry(filepath, pattern3, options);
        if (entry === null || !options.entryFilter(entry)) {
          continue;
        }
        entries.push(entry);
      }
      return entries;
    }
    _getEntry(filepath, pattern3, options) {
      try {
        const stats = this._getStat(filepath);
        return this._makeEntry(stats, pattern3);
      } catch (error21) {
        if (options.errorFilter(error21)) {
          return null;
        }
        throw error21;
      }
    }
    _getStat(filepath) {
      return this._statSync(filepath, this._fsStatSettings);
    }
  }
  exports.default = ReaderSync;
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var sync_1 = require_sync5();
  var provider_1 = require_provider();

  class ProviderSync extends provider_1.default {
    constructor() {
      super(...arguments);
      this._reader = new sync_1.default(this._settings);
    }
    read(task) {
      const root = this._getRootDirectory(task);
      const options = this._getReaderOptions(task);
      const entries = this.api(root, task, options);
      return entries.map(options.transform);
    }
    api(root, task, options) {
      if (task.dynamic) {
        return this._reader.dynamic(root, options);
      }
      return this._reader.static(task.patterns, options);
    }
  }
  exports.default = ProviderSync;
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = undefined;
  var fs = import.meta.require("fs");
  var os = import.meta.require("os");
  var CPU_COUNT = Math.max(os.cpus().length, 1);
  exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
  };

  class Settings {
    constructor(_options = {}) {
      this._options = _options;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);
      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }
      if (this.stats) {
        this.objectMode = true;
      }
      this.ignore = [].concat(this.ignore);
    }
    _getValue(option, value14) {
      return option === undefined ? value14 : option;
    }
    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
  }
  exports.default = Settings;
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS((exports, module) => {
  async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
  }
  var getWorks = function(source, _Provider, options) {
    const patterns6 = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns6, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
  };
  var assertPatternsInput = function(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
  };
  var taskManager = require_tasks();
  var async_1 = require_async6();
  var stream_1 = require_stream4();
  var sync_1 = require_sync6();
  var settings_1 = require_settings4();
  var utils = require_utils6();
  (function(FastGlob2) {
    FastGlob2.glob = FastGlob2;
    FastGlob2.globSync = sync;
    FastGlob2.globStream = stream;
    FastGlob2.async = FastGlob2;
    function sync(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, sync_1.default, options);
      return utils.array.flatten(works);
    }
    FastGlob2.sync = sync;
    function stream(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, stream_1.default, options);
      return utils.stream.merge(works);
    }
    FastGlob2.stream = stream;
    function generateTasks(source, options) {
      assertPatternsInput(source);
      const patterns6 = [].concat(source);
      const settings = new settings_1.default(options);
      return taskManager.generate(patterns6, settings);
    }
    FastGlob2.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
      assertPatternsInput(source);
      const settings = new settings_1.default(options);
      return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob2.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
      assertPatternsInput(source);
      return utils.path.escape(source);
    }
    FastGlob2.escapePath = escapePath;
    function convertPathToPattern(source) {
      assertPatternsInput(source);
      return utils.path.convertPathToPattern(source);
    }
    FastGlob2.convertPathToPattern = convertPathToPattern;
    let posix;
    (function(posix2) {
      function escapePath2(source) {
        assertPatternsInput(source);
        return utils.path.escapePosixPath(source);
      }
      posix2.escapePath = escapePath2;
      function convertPathToPattern2(source) {
        assertPatternsInput(source);
        return utils.path.convertPosixPathToPattern(source);
      }
      posix2.convertPathToPattern = convertPathToPattern2;
    })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
    let win32;
    (function(win322) {
      function escapePath2(source) {
        assertPatternsInput(source);
        return utils.path.escapeWindowsPath(source);
      }
      win322.escapePath = escapePath2;
      function convertPathToPattern2(source) {
        assertPatternsInput(source);
        return utils.path.convertWindowsPathToPattern(source);
      }
      win322.convertPathToPattern = convertPathToPattern2;
    })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
  })(FastGlob || (FastGlob = {}));
  module.exports = FastGlob;
});

// node_modules/path-type/index.js
var require_path_type = __commonJS((exports) => {
  async function isType(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== "string") {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
      const stats = await promisify(fs[fsStatType])(filePath);
      return stats[statsMethodName]();
    } catch (error21) {
      if (error21.code === "ENOENT") {
        return false;
      }
      throw error21;
    }
  }
  var isTypeSync = function(fsStatType, statsMethodName, filePath) {
    if (typeof filePath !== "string") {
      throw new TypeError(`Expected a string, got ${typeof filePath}`);
    }
    try {
      return fs[fsStatType](filePath)[statsMethodName]();
    } catch (error21) {
      if (error21.code === "ENOENT") {
        return false;
      }
      throw error21;
    }
  };
  var { promisify } = import.meta.require("util");
  var fs = import.meta.require("fs");
  exports.isFile = isType.bind(null, "stat", "isFile");
  exports.isDirectory = isType.bind(null, "stat", "isDirectory");
  exports.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
  exports.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
  exports.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
  exports.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
});

// node_modules/dir-glob/index.js
var require_dir_glob = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var pathType = require_path_type();
  var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
  var getPath = (filepath, cwd) => {
    const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
    return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
  };
  var addExtensions = (file, extensions) => {
    if (path.extname(file)) {
      return `**/${file}`;
    }
    return `**/${file}.${getExtensions(extensions)}`;
  };
  var getGlob = (directory, options) => {
    if (options.files && !Array.isArray(options.files)) {
      throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
    }
    if (options.extensions && !Array.isArray(options.extensions)) {
      throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
    }
    if (options.files && options.extensions) {
      return options.files.map((x) => path.posix.join(directory, addExtensions(x, options.extensions)));
    }
    if (options.files) {
      return options.files.map((x) => path.posix.join(directory, `**/${x}`));
    }
    if (options.extensions) {
      return [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
    }
    return [path.posix.join(directory, "**")];
  };
  module.exports = async (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };
    if (typeof options.cwd !== "string") {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = await Promise.all([].concat(input).map(async (x) => {
      const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
      return isDirectory ? getGlob(x, options) : x;
    }));
    return [].concat.apply([], globs);
  };
  module.exports.sync = (input, options) => {
    options = {
      cwd: process.cwd(),
      ...options
    };
    if (typeof options.cwd !== "string") {
      throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
    }
    const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
    return [].concat.apply([], globs);
  };
});

// node_modules/ignore/index.js
var require_ignore = __commonJS((exports, module) => {
  var makeArray = function(subject) {
    return Array.isArray(subject) ? subject : [subject];
  };
  var EMPTY = "";
  var SPACE = " ";
  var ESCAPE = "\\";
  var REGEX_TEST_BLANK_LINE = /^\s+$/;
  var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
  var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  var REGEX_SPLITALL_CRLF = /\r?\n/g;
  var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  var SLASH = "/";
  var TMP_KEY_IGNORE = "node-ignore";
  if (typeof Symbol !== "undefined") {
    TMP_KEY_IGNORE = Symbol.for("node-ignore");
  }
  var KEY_IGNORE = TMP_KEY_IGNORE;
  var define2 = (object12, key, value14) => Object.defineProperty(object12, key, { value: value14 });
  var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  var RETURN_FALSE = () => false;
  var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
  var cleanRangeBackSlash = (slashes) => {
    const { length } = slashes;
    return slashes.slice(0, length - length % 2);
  };
  var REPLACERS = [
    [
      /^\uFEFF/,
      () => EMPTY
    ],
    [
      /\\?\s+$/,
      (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
    ],
    [
      /\\\s/g,
      () => SPACE
    ],
    [
      /[\\$.|*+(){^]/g,
      (match) => `\\${match}`
    ],
    [
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    [
      /^\//,
      () => "^"
    ],
    [
      /\//g,
      () => "\\/"
    ],
    [
      /^\^*\\\*\\\*\\\//,
      () => "^(?:.*\\/)?"
    ],
    [
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    [
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    [
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      (_, p12, p2) => {
        const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
        return p12 + unescaped;
      }
    ],
    [
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE
    ],
    [
      /\\\\/g,
      () => ESCAPE
    ],
    [
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    [
      /(?:[^*])$/,
      (match) => /\/$/.test(match) ? `${match}\$` : `${match}(?=\$|\\/\$)`
    ],
    [
      /(\^|\\\/)?\\\*$/,
      (_, p12) => {
        const prefix = p12 ? `${p12}[^/]+` : "[^/]*";
        return `${prefix}(?=\$|\\/\$)`;
      }
    ]
  ];
  var regexCache = Object.create(null);
  var makeRegex = (pattern3, ignoreCase) => {
    let source = regexCache[pattern3];
    if (!source) {
      source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern3)), pattern3);
      regexCache[pattern3] = source;
    }
    return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
  };
  var isString = (subject) => typeof subject === "string";
  var checkPattern = (pattern3) => pattern3 && isString(pattern3) && !REGEX_TEST_BLANK_LINE.test(pattern3) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern3) && pattern3.indexOf("#") !== 0;
  var splitPattern = (pattern3) => pattern3.split(REGEX_SPLITALL_CRLF);

  class IgnoreRule {
    constructor(origin, pattern3, negative, regex) {
      this.origin = origin;
      this.pattern = pattern3;
      this.negative = negative;
      this.regex = regex;
    }
  }
  var createRule = (pattern3, ignoreCase) => {
    const origin = pattern3;
    let negative = false;
    if (pattern3.indexOf("!") === 0) {
      negative = true;
      pattern3 = pattern3.substr(1);
    }
    pattern3 = pattern3.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regex = makeRegex(pattern3, ignoreCase);
    return new IgnoreRule(origin, pattern3, negative, regex);
  };
  var throwError = (message, Ctor) => {
    throw new Ctor(message);
  };
  var checkPath = (path, originalPath, doThrow) => {
    if (!isString(path)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    if (!path) {
      return doThrow(`path must not be empty`, TypeError);
    }
    if (checkPath.isNotRelative(path)) {
      const r = "`path.relative()`d";
      return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
  };
  var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
  checkPath.isNotRelative = isNotRelative;
  checkPath.convert = (p2) => p2;

  class Ignore {
    constructor({
      ignorecase = true,
      ignoreCase = ignorecase,
      allowRelativePaths = false
    } = {}) {
      define2(this, KEY_IGNORE, true);
      this._rules = [];
      this._ignoreCase = ignoreCase;
      this._allowRelativePaths = allowRelativePaths;
      this._initCache();
    }
    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
    _addPattern(pattern3) {
      if (pattern3 && pattern3[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern3._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern3)) {
        const rule = createRule(pattern3, this._ignoreCase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    add(pattern3) {
      this._added = false;
      makeArray(isString(pattern3) ? splitPattern(pattern3) : pattern3).forEach(this._addPattern, this);
      if (this._added) {
        this._initCache();
      }
      return this;
    }
    addPattern(pattern3) {
      return this.add(pattern3);
    }
    _testOne(path, checkUnignored) {
      let ignored = false;
      let unignored = false;
      this._rules.forEach((rule) => {
        const { negative } = rule;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        const matched = rule.regex.test(path);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored,
        unignored
      };
    }
    _test(originalPath, cache, checkUnignored, slices) {
      const path = originalPath && checkPath.convert(originalPath);
      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
      return this._t(path, cache, checkUnignored, slices);
    }
    _t(path, cache, checkUnignored, slices) {
      if (path in cache) {
        return cache[path];
      }
      if (!slices) {
        slices = path.split(SLASH);
      }
      slices.pop();
      if (!slices.length) {
        return cache[path] = this._testOne(path, checkUnignored);
      }
      const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
      return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
    }
    ignores(path) {
      return this._test(path, this._ignoreCache, false).ignored;
    }
    createFilter() {
      return (path) => !this.ignores(path);
    }
    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }
    test(path) {
      return this._test(path, this._testCache, true);
    }
  }
  var factory = (options) => new Ignore(options);
  var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
  factory.isPathValid = isPathValid;
  factory.default = factory;
  module.exports = factory;
  if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    checkPath.convert = makePosix;
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
  }
});

// node_modules/slash/index.js
var require_slash = __commonJS((exports, module) => {
  module.exports = (path) => {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(path);
    if (isExtendedLengthPath || hasNonAscii) {
      return path;
    }
    return path.replace(/\\/g, "/");
  };
});

// node_modules/globby/gitignore.js
var require_gitignore = __commonJS((exports, module) => {
  var { promisify } = import.meta.require("util");
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var fastGlob = require_out4();
  var gitIgnore = require_ignore();
  var slash = require_slash();
  var DEFAULT_IGNORE = [
    "**/node_modules/**",
    "**/flow-typed/**",
    "**/coverage/**",
    "**/.git"
  ];
  var readFileP = promisify(fs.readFile);
  var mapGitIgnorePatternTo = (base) => (ignore) => {
    if (ignore.startsWith("!")) {
      return "!" + path.posix.join(base, ignore.slice(1));
    }
    return path.posix.join(base, ignore);
  };
  var parseGitIgnore = (content, options) => {
    const base = slash(path.relative(options.cwd, path.dirname(options.fileName)));
    return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
  };
  var reduceIgnore = (files) => {
    const ignores = gitIgnore();
    for (const file of files) {
      ignores.add(parseGitIgnore(file.content, {
        cwd: file.cwd,
        fileName: file.filePath
      }));
    }
    return ignores;
  };
  var ensureAbsolutePathForCwd = (cwd, p2) => {
    cwd = slash(cwd);
    if (path.isAbsolute(p2)) {
      if (slash(p2).startsWith(cwd)) {
        return p2;
      }
      throw new Error(`Path ${p2} is not in cwd ${cwd}`);
    }
    return path.join(cwd, p2);
  };
  var getIsIgnoredPredecate = (ignores, cwd) => {
    return (p2) => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p2.path || p2))));
  };
  var getFile = async (file, cwd) => {
    const filePath = path.join(cwd, file);
    const content = await readFileP(filePath, "utf8");
    return {
      cwd,
      filePath,
      content
    };
  };
  var getFileSync = (file, cwd) => {
    const filePath = path.join(cwd, file);
    const content = fs.readFileSync(filePath, "utf8");
    return {
      cwd,
      filePath,
      content
    };
  };
  var normalizeOptions = ({
    ignore = [],
    cwd = slash(process.cwd())
  } = {}) => {
    return { ignore, cwd };
  };
  module.exports = async (options) => {
    options = normalizeOptions(options);
    const paths = await fastGlob("**/.gitignore", {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
  module.exports.sync = (options) => {
    options = normalizeOptions(options);
    const paths = fastGlob.sync("**/.gitignore", {
      ignore: DEFAULT_IGNORE.concat(options.ignore),
      cwd: options.cwd
    });
    const files = paths.map((file) => getFileSync(file, options.cwd));
    const ignores = reduceIgnore(files);
    return getIsIgnoredPredecate(ignores, options.cwd);
  };
});

// node_modules/globby/stream-utils.js
var require_stream_utils = __commonJS((exports, module) => {
  var { Transform: Transform2 } = import.meta.require("stream");

  class ObjectTransform extends Transform2 {
    constructor() {
      super({
        objectMode: true
      });
    }
  }

  class FilterStream extends ObjectTransform {
    constructor(filter) {
      super();
      this._filter = filter;
    }
    _transform(data, encoding, callback) {
      if (this._filter(data)) {
        this.push(data);
      }
      callback();
    }
  }

  class UniqueStream extends ObjectTransform {
    constructor() {
      super();
      this._pushed = new Set;
    }
    _transform(data, encoding, callback) {
      if (!this._pushed.has(data)) {
        this.push(data);
        this._pushed.add(data);
      }
      callback();
    }
  }
  module.exports = {
    FilterStream,
    UniqueStream
  };
});

// node_modules/globby/index.js
var require_globby = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var arrayUnion = require_array_union();
  var merge2 = require_merge2();
  var fastGlob = require_out4();
  var dirGlob = require_dir_glob();
  var gitignore = require_gitignore();
  var { FilterStream, UniqueStream } = require_stream_utils();
  var DEFAULT_FILTER = () => false;
  var isNegative = (pattern3) => pattern3[0] === "!";
  var assertPatternsInput = (patterns6) => {
    if (!patterns6.every((pattern3) => typeof pattern3 === "string")) {
      throw new TypeError("Patterns must be a string or an array of strings");
    }
  };
  var checkCwdOption = (options = {}) => {
    if (!options.cwd) {
      return;
    }
    let stat;
    try {
      stat = fs.statSync(options.cwd);
    } catch {
      return;
    }
    if (!stat.isDirectory()) {
      throw new Error("The `cwd` option must be a path to a directory");
    }
  };
  var getPathString = (p2) => p2.stats instanceof fs.Stats ? p2.path : p2;
  var generateGlobTasks = (patterns6, taskOptions) => {
    patterns6 = arrayUnion([].concat(patterns6));
    assertPatternsInput(patterns6);
    checkCwdOption(taskOptions);
    const globTasks = [];
    taskOptions = {
      ignore: [],
      expandDirectories: true,
      ...taskOptions
    };
    for (const [index, pattern3] of patterns6.entries()) {
      if (isNegative(pattern3)) {
        continue;
      }
      const ignore = patterns6.slice(index).filter((pattern4) => isNegative(pattern4)).map((pattern4) => pattern4.slice(1));
      const options = {
        ...taskOptions,
        ignore: taskOptions.ignore.concat(ignore)
      };
      globTasks.push({ pattern: pattern3, options });
    }
    return globTasks;
  };
  var globDirs = (task, fn) => {
    let options = {};
    if (task.options.cwd) {
      options.cwd = task.options.cwd;
    }
    if (Array.isArray(task.options.expandDirectories)) {
      options = {
        ...options,
        files: task.options.expandDirectories
      };
    } else if (typeof task.options.expandDirectories === "object") {
      options = {
        ...options,
        ...task.options.expandDirectories
      };
    }
    return fn(task.pattern, options);
  };
  var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
  var getFilterSync = (options) => {
    return options && options.gitignore ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
  };
  var globToTask = (task) => (glob) => {
    const { options } = task;
    if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
      options.ignore = dirGlob.sync(options.ignore);
    }
    return {
      pattern: glob,
      options
    };
  };
  module.exports = async (patterns6, options) => {
    const globTasks = generateGlobTasks(patterns6, options);
    const getFilter = async () => {
      return options && options.gitignore ? gitignore({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
    };
    const getTasks = async () => {
      const tasks2 = await Promise.all(globTasks.map(async (task) => {
        const globs = await getPattern(task, dirGlob);
        return Promise.all(globs.map(globToTask(task)));
      }));
      return arrayUnion(...tasks2);
    };
    const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
    const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
    return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
  };
  module.exports.sync = (patterns6, options) => {
    const globTasks = generateGlobTasks(patterns6, options);
    const tasks = [];
    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    let matches = [];
    for (const task of tasks) {
      matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
    }
    return matches.filter((path_) => !filter(path_));
  };
  module.exports.stream = (patterns6, options) => {
    const globTasks = generateGlobTasks(patterns6, options);
    const tasks = [];
    for (const task of globTasks) {
      const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
      tasks.push(...newTask);
    }
    const filter = getFilterSync(options);
    const filterStream = new FilterStream((p2) => !filter(p2));
    const uniqueStream = new UniqueStream;
    return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
  };
  module.exports.generateGlobTasks = generateGlobTasks;
  module.exports.hasMagic = (patterns6, options) => [].concat(patterns6).some((pattern3) => fastGlob.isDynamicPattern(pattern3, options));
  module.exports.gitignore = gitignore;
});

// node_modules/universalify/index.js
var require_universalify = __commonJS((exports) => {
  exports.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  exports.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  var patch = function(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }
    if (!fs.lutimes) {
      patchLutimes(fs);
    }
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    if (fs.chmod && !fs.lchmod) {
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchmodSync = function() {
      };
    }
    if (fs.chown && !fs.lchown) {
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    }
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs2.futimes) {
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  };
  var constants = import.meta.require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d2) {
      cwd = null;
      chdir.call(process, d2);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  var legacy = function(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  };
  var Stream = import.meta.require("stream").Stream;
  module.exports = legacy;
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports, module) => {
  var clone11 = function(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  };
  module.exports = clone11;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  var noop = function() {
  };
  var publishQueue = function(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  };
  var patch = function(fs2) {
    polyfills(fs2);
    fs2.gracefulify = patch;
    fs2.createReadStream = createReadStream;
    fs2.createWriteStream = createWriteStream;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs2, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs2, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs2, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs2.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs2.WriteStream(path, options);
    }
    var fs$open = fs2.open;
    fs2.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs2;
  };
  var enqueue = function(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
  };
  var resetQueue = function() {
    var now = Date.now();
    for (var i2 = 0;i2 < fs[gracefulQueue].length; ++i2) {
      if (fs[gracefulQueue][i2].length > 2) {
        fs[gracefulQueue][i2][3] = now;
        fs[gracefulQueue][i2][4] = now;
      }
    }
    retry();
  };
  var retry = function() {
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0)
      return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === undefined) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  };
  var fs = import.meta.require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone11 = require_clone();
  var util = import.meta.require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m2 = util.format.apply(util, arguments);
      m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
      console.error(m2);
    };
  if (!fs[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs[gracefulQueue]);
        import.meta.require("assert").equal(fs[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
  }
  module.exports = patch(clone11(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
  }
  var retryTimer;
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs5 = __commonJS((exports) => {
  var u2 = require_universalify().fromCallback;
  var fs = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs[key] === "function";
  });
  Object.assign(exports, fs);
  api.forEach((method) => {
    exports[method] = u2(fs[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.readv(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.writev(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs.realpath.native === "function") {
    exports.realpath.native = u2(fs.realpath.native);
  } else {
    process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils8 = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  exports.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error21 = new Error(`Path contains invalid characters: ${pth}`);
        error21.code = "EINVAL";
        throw error21;
      }
    }
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports, module) => {
  var fs = require_fs5();
  var { checkPath } = require_utils8();
  var getMode = (options) => {
    const defaults = { mode: 511 };
    if (typeof options === "number")
      return options;
    return { ...defaults, ...options }.mode;
  };
  exports.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  exports.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS((exports, module) => {
  var u2 = require_universalify().fromPromise;
  var { makeDir: _makeDir, makeDirSync } = require_make_dir();
  var makeDir = u2(_makeDir);
  module.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports, module) => {
  var pathExists = function(path) {
    return fs.access(path).then(() => true).catch(() => false);
  };
  var u2 = require_universalify().fromPromise;
  var fs = require_fs5();
  module.exports = {
    pathExists: u2(pathExists),
    pathExistsSync: fs.existsSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports, module) => {
  async function utimesMillis(path, atime, mtime) {
    const fd = await fs.open(path, "r+");
    let closeErr = null;
    try {
      await fs.futimes(fd, atime, mtime);
    } finally {
      try {
        await fs.close(fd);
      } catch (e2) {
        closeErr = e2;
      }
    }
    if (closeErr) {
      throw closeErr;
    }
  }
  var utimesMillisSync = function(path, atime, mtime) {
    const fd = fs.openSync(path, "r+");
    fs.futimesSync(fd, atime, mtime);
    return fs.closeSync(fd);
  };
  var fs = require_fs5();
  var u2 = require_universalify().fromPromise;
  module.exports = {
    utimesMillis: u2(utimesMillis),
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports, module) => {
  var getStats = function(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => fs.stat(file, { bigint: true }) : (file) => fs.lstat(file, { bigint: true });
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  };
  var getStatsSync = function(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file) => fs.statSync(file, { bigint: true }) : (file) => fs.lstatSync(file, { bigint: true });
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  };
  async function checkPaths(src, dest, funcName, opts) {
    const { srcStat, destStat } = await getStats(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  var checkPathsSync = function(src, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  };
  async function checkParentPaths(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = await fs.stat(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPaths(src, srcStat, destParent, funcName);
  }
  var checkParentPathsSync = function(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = fs.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  };
  var areIdentical = function(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  };
  var isSrcSubdir = function(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter((i2) => i2);
    const destArr = path.resolve(dest).split(path.sep).filter((i2) => i2);
    return srcArr.every((cur, i2) => destArr[i2] === cur);
  };
  var errMsg = function(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  };
  var fs = require_fs5();
  var path = import.meta.require("path");
  var u2 = require_universalify().fromPromise;
  module.exports = {
    checkPaths: u2(checkPaths),
    checkPathsSync,
    checkParentPaths: u2(checkParentPaths),
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports, module) => {
  async function copy(src, dest, opts = {}) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
    }
    const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
    await stat.checkParentPaths(src, srcStat, dest, "copy");
    const include = await runFilter(src, dest, opts);
    if (!include)
      return;
    const destParent = path.dirname(dest);
    const dirExists = await pathExists(destParent);
    if (!dirExists) {
      await mkdirs(destParent);
    }
    await getStatsAndPerformCopy(destStat, src, dest, opts);
  }
  async function runFilter(src, dest, opts) {
    if (!opts.filter)
      return true;
    return opts.filter(src, dest);
  }
  async function getStatsAndPerformCopy(destStat, src, dest, opts) {
    const statFn = opts.dereference ? fs.stat : fs.lstat;
    const srcStat = await statFn(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  async function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    if (opts.overwrite) {
      await fs.unlink(dest);
      return copyFile(srcStat, src, dest, opts);
    }
    if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  async function copyFile(srcStat, src, dest, opts) {
    await fs.copyFile(src, dest);
    if (opts.preserveTimestamps) {
      if (fileIsNotWritable(srcStat.mode)) {
        await makeFileWritable(dest, srcStat.mode);
      }
      const updatedSrcStat = await fs.stat(src);
      await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    return fs.chmod(dest, srcStat.mode);
  }
  var fileIsNotWritable = function(srcMode) {
    return (srcMode & 128) === 0;
  };
  var makeFileWritable = function(dest, srcMode) {
    return fs.chmod(dest, srcMode | 128);
  };
  async function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) {
      await fs.mkdir(dest);
    }
    const items = await fs.readdir(src);
    await Promise.all(items.map(async (item) => {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      const include = await runFilter(srcItem, destItem, opts);
      if (!include)
        return;
      const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
      return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
    }));
    if (!destStat) {
      await fs.chmod(dest, srcStat.mode);
    }
  }
  async function onLink(destStat, src, dest, opts) {
    let resolvedSrc = await fs.readlink(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlink(resolvedSrc, dest);
    }
    let resolvedDest = null;
    try {
      resolvedDest = await fs.readlink(dest);
    } catch (e2) {
      if (e2.code === "EINVAL" || e2.code === "UNKNOWN")
        return fs.symlink(resolvedSrc, dest);
      throw e2;
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest);
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    await fs.unlink(dest);
    return fs.symlink(resolvedSrc, dest);
  }
  var fs = require_fs5();
  var path = import.meta.require("path");
  var { mkdirs } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { utimesMillis } = require_utimes();
  var stat = require_stat();
  module.exports = copy;
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS((exports, module) => {
  var copySync = function(src, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
    }
    const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path.dirname(dest);
    if (!fs.existsSync(destParent))
      mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  };
  var getStats = function(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    else if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    else if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  };
  var onFile = function(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  };
  var mayCopyFile = function(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  };
  var copyFile = function(srcStat, src, dest, opts) {
    fs.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  };
  var handleTimestamps = function(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  };
  var fileIsNotWritable = function(srcMode) {
    return (srcMode & 128) === 0;
  };
  var makeFileWritable = function(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  };
  var setDestMode = function(dest, srcMode) {
    return fs.chmodSync(dest, srcMode);
  };
  var setDestTimestamps = function(src, dest) {
    const updatedSrcStat = fs.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  };
  var onDir = function(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  };
  var mkDirAndCopy = function(srcMode, src, dest, opts) {
    fs.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  };
  var copyDir = function(src, dest, opts) {
    fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  };
  var copyDirItem = function(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    if (opts.filter && !opts.filter(srcItem, destItem))
      return;
    const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
    return getStats(destStat, srcItem, destItem, opts);
  };
  var onLink = function(destStat, src, dest, opts) {
    let resolvedSrc = fs.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  };
  var copyLink = function(resolvedSrc, dest) {
    fs.unlinkSync(dest);
    return fs.symlinkSync(resolvedSrc, dest);
  };
  var fs = require_graceful_fs();
  var path = import.meta.require("path");
  var mkdirsSync = require_mkdirs().mkdirsSync;
  var utimesMillisSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  module.exports = copySync;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports, module) => {
  var u2 = require_universalify().fromPromise;
  module.exports = {
    copy: u2(require_copy()),
    copySync: require_copy_sync()
  };
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports, module) => {
  var remove = function(path, callback) {
    fs.rm(path, { recursive: true, force: true }, callback);
  };
  var removeSync = function(path) {
    fs.rmSync(path, { recursive: true, force: true });
  };
  var fs = require_graceful_fs();
  var u2 = require_universalify().fromCallback;
  module.exports = {
    remove: u2(remove),
    removeSync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports, module) => {
  var emptyDirSync = function(dir) {
    let items;
    try {
      items = fs.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  };
  var u2 = require_universalify().fromPromise;
  var fs = require_fs5();
  var path = import.meta.require("path");
  var mkdir = require_mkdirs();
  var remove = require_remove();
  var emptyDir = u2(async function emptyDir(dir) {
    let items;
    try {
      items = await fs.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  module.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports, module) => {
  async function createFile(file) {
    let stats;
    try {
      stats = await fs.stat(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    let dirStats = null;
    try {
      dirStats = await fs.stat(dir);
    } catch (err) {
      if (err.code === "ENOENT") {
        await mkdir.mkdirs(dir);
        await fs.writeFile(file, "");
        return;
      } else {
        throw err;
      }
    }
    if (dirStats.isDirectory()) {
      await fs.writeFile(file, "");
    } else {
      await fs.readdir(dir);
    }
  }
  var createFileSync = function(file) {
    let stats;
    try {
      stats = fs.statSync(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    try {
      if (!fs.statSync(dir).isDirectory()) {
        fs.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs.writeFileSync(file, "");
  };
  var u2 = require_universalify().fromPromise;
  var path = import.meta.require("path");
  var fs = require_fs5();
  var mkdir = require_mkdirs();
  module.exports = {
    createFile: u2(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports, module) => {
  async function createLink(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = await fs.lstat(dstpath);
    } catch {
    }
    let srcStat;
    try {
      srcStat = await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    if (dstStat && areIdentical(srcStat, dstStat))
      return;
    const dir = path.dirname(dstpath);
    const dirExists = await pathExists(dir);
    if (!dirExists) {
      await mkdir.mkdirs(dir);
    }
    await fs.link(srcpath, dstpath);
  }
  var createLinkSync = function(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs.lstatSync(dstpath);
    } catch {
    }
    try {
      const srcStat = fs.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs.existsSync(dir);
    if (dirExists)
      return fs.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs.linkSync(srcpath, dstpath);
  };
  var u2 = require_universalify().fromPromise;
  var path = import.meta.require("path");
  var fs = require_fs5();
  var mkdir = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  module.exports = {
    createLink: u2(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports, module) => {
  async function symlinkPaths(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      try {
        await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = await pathExists(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    try {
      await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  var symlinkPathsSync = function(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      const exists2 = fs.existsSync(srcpath);
      if (!exists2)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    const srcExists = fs.existsSync(srcpath);
    if (!srcExists)
      throw new Error("relative srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  };
  var path = import.meta.require("path");
  var fs = require_fs5();
  var { pathExists } = require_path_exists();
  var u2 = require_universalify().fromPromise;
  module.exports = {
    symlinkPaths: u2(symlinkPaths),
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports, module) => {
  async function symlinkType(srcpath, type73) {
    if (type73)
      return type73;
    let stats;
    try {
      stats = await fs.lstat(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  var symlinkTypeSync = function(srcpath, type73) {
    if (type73)
      return type73;
    let stats;
    try {
      stats = fs.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  };
  var fs = require_fs5();
  var u2 = require_universalify().fromPromise;
  module.exports = {
    symlinkType: u2(symlinkType),
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports, module) => {
  async function createSymlink(srcpath, dstpath, type73) {
    let stats;
    try {
      stats = await fs.lstat(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const [srcStat, dstStat] = await Promise.all([
        fs.stat(srcpath),
        fs.stat(dstpath)
      ]);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = await symlinkPaths(srcpath, dstpath);
    srcpath = relative.toDst;
    const toType = await symlinkType(relative.toCwd, type73);
    const dir = path.dirname(dstpath);
    if (!await pathExists(dir)) {
      await mkdirs(dir);
    }
    return fs.symlink(srcpath, dstpath, toType);
  }
  var createSymlinkSync = function(srcpath, dstpath, type73) {
    let stats;
    try {
      stats = fs.lstatSync(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs.statSync(srcpath);
      const dstStat = fs.statSync(dstpath);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type73 = symlinkTypeSync(relative.toCwd, type73);
    const dir = path.dirname(dstpath);
    const exists = fs.existsSync(dir);
    if (exists)
      return fs.symlinkSync(srcpath, dstpath, type73);
    mkdirsSync(dir);
    return fs.symlinkSync(srcpath, dstpath, type73);
  };
  var u2 = require_universalify().fromPromise;
  var path = import.meta.require("path");
  var fs = require_fs5();
  var { mkdirs, mkdirsSync } = require_mkdirs();
  var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
  var { symlinkType, symlinkTypeSync } = require_symlink_type();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  module.exports = {
    createSymlink: u2(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports, module) => {
  var { createFile, createFileSync } = require_file();
  var { createLink, createLinkSync } = require_link();
  var { createSymlink, createSymlinkSync } = require_symlink();
  module.exports = {
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
});

// node_modules/jsonfile/utils.js
var require_utils9 = __commonJS((exports, module) => {
  var stringify = function(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  };
  var stripBom = function(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  };
  module.exports = { stringify, stripBom };
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports, module) => {
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  var readFileSync = function(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  };
  async function _writeFile(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    await universalify.fromCallback(fs.writeFile)(file, str, options);
  }
  var writeFileSync = function(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    return fs.writeFileSync(file, str, options);
  };
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_) {
    _fs = import.meta.require("fs");
  }
  var universalify = require_universalify();
  var { stringify, stripBom } = require_utils9();
  var readFile = universalify.fromPromise(_readFile);
  var writeFile = universalify.fromPromise(_writeFile);
  var jsonfile = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  module.exports = jsonfile;
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports, module) => {
  var jsonFile = require_jsonfile();
  module.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS((exports, module) => {
  async function outputFile(file, data, encoding = "utf-8") {
    const dir = path.dirname(file);
    if (!await pathExists(dir)) {
      await mkdir.mkdirs(dir);
    }
    return fs.writeFile(file, data, encoding);
  }
  var outputFileSync = function(file, ...args) {
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs.writeFileSync(file, ...args);
  };
  var u2 = require_universalify().fromPromise;
  var fs = require_fs5();
  var path = import.meta.require("path");
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  module.exports = {
    outputFile: u2(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports, module) => {
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  var { stringify } = require_utils9();
  var { outputFile } = require_output_file();
  module.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports, module) => {
  var outputJsonSync = function(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  };
  var { stringify } = require_utils9();
  var { outputFileSync } = require_output_file();
  module.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports, module) => {
  var u2 = require_universalify().fromPromise;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u2(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module.exports = jsonFile;
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports, module) => {
  async function move(src, dest, opts = {}) {
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
    await stat.checkParentPaths(src, srcStat, dest, "move");
    const destParent = path.dirname(dest);
    const parsedParentPath = path.parse(destParent);
    if (parsedParentPath.root !== destParent) {
      await mkdirp(destParent);
    }
    return doRename(src, dest, overwrite, isChangingCase);
  }
  async function doRename(src, dest, overwrite, isChangingCase) {
    if (!isChangingCase) {
      if (overwrite) {
        await remove(dest);
      } else if (await pathExists(dest)) {
        throw new Error("dest already exists.");
      }
    }
    try {
      await fs.rename(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV") {
        throw err;
      }
      await moveAcrossDevice(src, dest, overwrite);
    }
  }
  async function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    await copy(src, dest, opts);
    return remove(src);
  }
  var fs = require_fs5();
  var path = import.meta.require("path");
  var { copy } = require_copy2();
  var { remove } = require_remove();
  var { mkdirp } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var stat = require_stat();
  module.exports = move;
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS((exports, module) => {
  var moveSync = function(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    if (!isParentRoot(dest))
      mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  };
  var isParentRoot = function(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  };
  var doRename = function(src, dest, overwrite, isChangingCase) {
    if (isChangingCase)
      return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  };
  var rename = function(src, dest, overwrite) {
    try {
      fs.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  };
  var moveAcrossDevice = function(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  };
  var fs = require_graceful_fs();
  var path = import.meta.require("path");
  var copySync = require_copy2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs().mkdirpSync;
  var stat = require_stat();
  module.exports = moveSync;
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports, module) => {
  var u2 = require_universalify().fromPromise;
  module.exports = {
    move: u2(require_move()),
    moveSync: require_move_sync()
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  module.exports = {
    ...require_fs5(),
    ...require_copy2(),
    ...require_empty(),
    ...require_ensure(),
    ...require_json(),
    ...require_mkdirs(),
    ...require_move2(),
    ...require_output_file(),
    ...require_path_exists(),
    ...require_remove()
  };
});

// node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["esprima"] = factory();
    else
      root["esprima"] = factory();
  })(exports, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module2 = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.loaded = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var comment_handler_1 = __webpack_require__(1);
        var jsx_parser_1 = __webpack_require__(3);
        var parser_1 = __webpack_require__(8);
        var tokenizer_1 = __webpack_require__(15);
        function parse4(code, options, delegate) {
          var commentHandler = null;
          var proxyDelegate = function(node, metadata) {
            if (delegate) {
              delegate(node, metadata);
            }
            if (commentHandler) {
              commentHandler.visit(node, metadata);
            }
          };
          var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
          var collectComment = false;
          if (options) {
            collectComment = typeof options.comment === "boolean" && options.comment;
            var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
            if (collectComment || attachComment) {
              commentHandler = new comment_handler_1.CommentHandler;
              commentHandler.attach = attachComment;
              options.comment = true;
              parserDelegate = proxyDelegate;
            }
          }
          var isModule = false;
          if (options && typeof options.sourceType === "string") {
            isModule = options.sourceType === "module";
          }
          var parser;
          if (options && typeof options.jsx === "boolean" && options.jsx) {
            parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
          } else {
            parser = new parser_1.Parser(code, options, parserDelegate);
          }
          var program = isModule ? parser.parseModule() : parser.parseScript();
          var ast = program;
          if (collectComment && commentHandler) {
            ast.comments = commentHandler.comments;
          }
          if (parser.config.tokens) {
            ast.tokens = parser.tokens;
          }
          if (parser.config.tolerant) {
            ast.errors = parser.errorHandler.errors;
          }
          return ast;
        }
        exports2.parse = parse4;
        function parseModule(code, options, delegate) {
          var parsingOptions = options || {};
          parsingOptions.sourceType = "module";
          return parse4(code, parsingOptions, delegate);
        }
        exports2.parseModule = parseModule;
        function parseScript(code, options, delegate) {
          var parsingOptions = options || {};
          parsingOptions.sourceType = "script";
          return parse4(code, parsingOptions, delegate);
        }
        exports2.parseScript = parseScript;
        function tokenize(code, options, delegate) {
          var tokenizer = new tokenizer_1.Tokenizer(code, options);
          var tokens;
          tokens = [];
          try {
            while (true) {
              var token = tokenizer.getNextToken();
              if (!token) {
                break;
              }
              if (delegate) {
                token = delegate(token);
              }
              tokens.push(token);
            }
          } catch (e2) {
            tokenizer.errorHandler.tolerate(e2);
          }
          if (tokenizer.errorHandler.tolerant) {
            tokens.errors = tokenizer.errors();
          }
          return tokens;
        }
        exports2.tokenize = tokenize;
        var syntax_1 = __webpack_require__(2);
        exports2.Syntax = syntax_1.Syntax;
        exports2.version = "4.0.1";
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var CommentHandler = function() {
          function CommentHandler2() {
            this.attach = false;
            this.comments = [];
            this.stack = [];
            this.leading = [];
            this.trailing = [];
          }
          CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
            if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
              var innerComments = [];
              for (var i2 = this.leading.length - 1;i2 >= 0; --i2) {
                var entry = this.leading[i2];
                if (metadata.end.offset >= entry.start) {
                  innerComments.unshift(entry.comment);
                  this.leading.splice(i2, 1);
                  this.trailing.splice(i2, 1);
                }
              }
              if (innerComments.length) {
                node.innerComments = innerComments;
              }
            }
          };
          CommentHandler2.prototype.findTrailingComments = function(metadata) {
            var trailingComments = [];
            if (this.trailing.length > 0) {
              for (var i2 = this.trailing.length - 1;i2 >= 0; --i2) {
                var entry_1 = this.trailing[i2];
                if (entry_1.start >= metadata.end.offset) {
                  trailingComments.unshift(entry_1.comment);
                }
              }
              this.trailing.length = 0;
              return trailingComments;
            }
            var entry = this.stack[this.stack.length - 1];
            if (entry && entry.node.trailingComments) {
              var firstComment = entry.node.trailingComments[0];
              if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                trailingComments = entry.node.trailingComments;
                delete entry.node.trailingComments;
              }
            }
            return trailingComments;
          };
          CommentHandler2.prototype.findLeadingComments = function(metadata) {
            var leadingComments = [];
            var target;
            while (this.stack.length > 0) {
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.start >= metadata.start.offset) {
                target = entry.node;
                this.stack.pop();
              } else {
                break;
              }
            }
            if (target) {
              var count = target.leadingComments ? target.leadingComments.length : 0;
              for (var i2 = count - 1;i2 >= 0; --i2) {
                var comment = target.leadingComments[i2];
                if (comment.range[1] <= metadata.start.offset) {
                  leadingComments.unshift(comment);
                  target.leadingComments.splice(i2, 1);
                }
              }
              if (target.leadingComments && target.leadingComments.length === 0) {
                delete target.leadingComments;
              }
              return leadingComments;
            }
            for (var i2 = this.leading.length - 1;i2 >= 0; --i2) {
              var entry = this.leading[i2];
              if (entry.start <= metadata.start.offset) {
                leadingComments.unshift(entry.comment);
                this.leading.splice(i2, 1);
              }
            }
            return leadingComments;
          };
          CommentHandler2.prototype.visitNode = function(node, metadata) {
            if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
              return;
            }
            this.insertInnerComments(node, metadata);
            var trailingComments = this.findTrailingComments(metadata);
            var leadingComments = this.findLeadingComments(metadata);
            if (leadingComments.length > 0) {
              node.leadingComments = leadingComments;
            }
            if (trailingComments.length > 0) {
              node.trailingComments = trailingComments;
            }
            this.stack.push({
              node,
              start: metadata.start.offset
            });
          };
          CommentHandler2.prototype.visitComment = function(node, metadata) {
            var type73 = node.type[0] === "L" ? "Line" : "Block";
            var comment = {
              type: type73,
              value: node.value
            };
            if (node.range) {
              comment.range = node.range;
            }
            if (node.loc) {
              comment.loc = node.loc;
            }
            this.comments.push(comment);
            if (this.attach) {
              var entry = {
                comment: {
                  type: type73,
                  value: node.value,
                  range: [metadata.start.offset, metadata.end.offset]
                },
                start: metadata.start.offset
              };
              if (node.loc) {
                entry.comment.loc = node.loc;
              }
              node.type = type73;
              this.leading.push(entry);
              this.trailing.push(entry);
            }
          };
          CommentHandler2.prototype.visit = function(node, metadata) {
            if (node.type === "LineComment") {
              this.visitComment(node, metadata);
            } else if (node.type === "BlockComment") {
              this.visitComment(node, metadata);
            } else if (this.attach) {
              this.visitNode(node, metadata);
            }
          };
          return CommentHandler2;
        }();
        exports2.CommentHandler = CommentHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Syntax = {
          AssignmentExpression: "AssignmentExpression",
          AssignmentPattern: "AssignmentPattern",
          ArrayExpression: "ArrayExpression",
          ArrayPattern: "ArrayPattern",
          ArrowFunctionExpression: "ArrowFunctionExpression",
          AwaitExpression: "AwaitExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ClassBody: "ClassBody",
          ClassDeclaration: "ClassDeclaration",
          ClassExpression: "ClassExpression",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExportAllDeclaration: "ExportAllDeclaration",
          ExportDefaultDeclaration: "ExportDefaultDeclaration",
          ExportNamedDeclaration: "ExportNamedDeclaration",
          ExportSpecifier: "ExportSpecifier",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForOfStatement: "ForOfStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          ImportDeclaration: "ImportDeclaration",
          ImportDefaultSpecifier: "ImportDefaultSpecifier",
          ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
          ImportSpecifier: "ImportSpecifier",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          MetaProperty: "MetaProperty",
          MethodDefinition: "MethodDefinition",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          ObjectPattern: "ObjectPattern",
          Program: "Program",
          Property: "Property",
          RestElement: "RestElement",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SpreadElement: "SpreadElement",
          Super: "Super",
          SwitchCase: "SwitchCase",
          SwitchStatement: "SwitchStatement",
          TaggedTemplateExpression: "TaggedTemplateExpression",
          TemplateElement: "TemplateElement",
          TemplateLiteral: "TemplateLiteral",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement",
          YieldExpression: "YieldExpression"
        };
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var character_1 = __webpack_require__(4);
        var JSXNode = __webpack_require__(5);
        var jsx_syntax_1 = __webpack_require__(6);
        var Node = __webpack_require__(7);
        var parser_1 = __webpack_require__(8);
        var token_1 = __webpack_require__(13);
        var xhtml_entities_1 = __webpack_require__(14);
        token_1.TokenName[100] = "JSXIdentifier";
        token_1.TokenName[101] = "JSXText";
        function getQualifiedElementName(elementName) {
          var qualifiedName;
          switch (elementName.type) {
            case jsx_syntax_1.JSXSyntax.JSXIdentifier:
              var id = elementName;
              qualifiedName = id.name;
              break;
            case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
              var ns = elementName;
              qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
              break;
            case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
              var expr = elementName;
              qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
              break;
            default:
              break;
          }
          return qualifiedName;
        }
        var JSXParser = function(_super) {
          __extends(JSXParser2, _super);
          function JSXParser2(code, options, delegate) {
            return _super.call(this, code, options, delegate) || this;
          }
          JSXParser2.prototype.parsePrimaryExpression = function() {
            return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
          };
          JSXParser2.prototype.startJSX = function() {
            this.scanner.index = this.startMarker.index;
            this.scanner.lineNumber = this.startMarker.line;
            this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
          };
          JSXParser2.prototype.finishJSX = function() {
            this.nextToken();
          };
          JSXParser2.prototype.reenterJSX = function() {
            this.startJSX();
            this.expectJSX("}");
            if (this.config.tokens) {
              this.tokens.pop();
            }
          };
          JSXParser2.prototype.createJSXNode = function() {
            this.collectComments();
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.createJSXChildNode = function() {
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.scanXHTMLEntity = function(quote) {
            var result = "&";
            var valid = true;
            var terminated = false;
            var numeric = false;
            var hex = false;
            while (!this.scanner.eof() && valid && !terminated) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === quote) {
                break;
              }
              terminated = ch === ";";
              result += ch;
              ++this.scanner.index;
              if (!terminated) {
                switch (result.length) {
                  case 2:
                    numeric = ch === "#";
                    break;
                  case 3:
                    if (numeric) {
                      hex = ch === "x";
                      valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                      numeric = numeric && !hex;
                    }
                    break;
                  default:
                    valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                    valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                    break;
                }
              }
            }
            if (valid && terminated && result.length > 2) {
              var str = result.substr(1, result.length - 2);
              if (numeric && str.length > 1) {
                result = String.fromCharCode(parseInt(str.substr(1), 10));
              } else if (hex && str.length > 2) {
                result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
              } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                result = xhtml_entities_1.XHTMLEntities[str];
              }
            }
            return result;
          };
          JSXParser2.prototype.lexJSX = function() {
            var cp = this.scanner.source.charCodeAt(this.scanner.index);
            if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
              var value14 = this.scanner.source[this.scanner.index++];
              return {
                type: 7,
                value: value14,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index - 1,
                end: this.scanner.index
              };
            }
            if (cp === 34 || cp === 39) {
              var start = this.scanner.index;
              var quote = this.scanner.source[this.scanner.index++];
              var str = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index++];
                if (ch === quote) {
                  break;
                } else if (ch === "&") {
                  str += this.scanXHTMLEntity(quote);
                } else {
                  str += ch;
                }
              }
              return {
                type: 8,
                value: str,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 46) {
              var n12 = this.scanner.source.charCodeAt(this.scanner.index + 1);
              var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
              var value14 = n12 === 46 && n2 === 46 ? "..." : ".";
              var start = this.scanner.index;
              this.scanner.index += value14.length;
              return {
                type: 7,
                value: value14,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 96) {
              return {
                type: 10,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index,
                end: this.scanner.index
              };
            }
            if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
              var start = this.scanner.index;
              ++this.scanner.index;
              while (!this.scanner.eof()) {
                var ch = this.scanner.source.charCodeAt(this.scanner.index);
                if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                  ++this.scanner.index;
                } else if (ch === 45) {
                  ++this.scanner.index;
                } else {
                  break;
                }
              }
              var id = this.scanner.source.slice(start, this.scanner.index);
              return {
                type: 100,
                value: id,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            return this.scanner.lex();
          };
          JSXParser2.prototype.nextJSXToken = function() {
            this.collectComments();
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = this.lexJSX();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            if (this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.nextJSXText = function() {
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var start = this.scanner.index;
            var text = "";
            while (!this.scanner.eof()) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === "{" || ch === "<") {
                break;
              }
              ++this.scanner.index;
              text += ch;
              if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.scanner.lineNumber;
                if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                  ++this.scanner.index;
                }
                this.scanner.lineStart = this.scanner.index;
              }
            }
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = {
              type: 101,
              value: text,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start,
              end: this.scanner.index
            };
            if (text.length > 0 && this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.peekJSXToken = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.lexJSX();
            this.scanner.restoreState(state);
            return next;
          };
          JSXParser2.prototype.expectJSX = function(value14) {
            var token = this.nextJSXToken();
            if (token.type !== 7 || token.value !== value14) {
              this.throwUnexpectedToken(token);
            }
          };
          JSXParser2.prototype.matchJSX = function(value14) {
            var next = this.peekJSXToken();
            return next.type === 7 && next.value === value14;
          };
          JSXParser2.prototype.parseJSXIdentifier = function() {
            var node = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 100) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
          };
          JSXParser2.prototype.parseJSXElementName = function() {
            var node = this.createJSXNode();
            var elementName = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = elementName;
              this.expectJSX(":");
              var name_1 = this.parseJSXIdentifier();
              elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
            } else if (this.matchJSX(".")) {
              while (this.matchJSX(".")) {
                var object12 = elementName;
                this.expectJSX(".");
                var property = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object12, property));
              }
            }
            return elementName;
          };
          JSXParser2.prototype.parseJSXAttributeName = function() {
            var node = this.createJSXNode();
            var attributeName;
            var identifier = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = identifier;
              this.expectJSX(":");
              var name_2 = this.parseJSXIdentifier();
              attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
            } else {
              attributeName = identifier;
            }
            return attributeName;
          };
          JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
            var node = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 8) {
              this.throwUnexpectedToken(token);
            }
            var raw = this.getTokenRaw(token);
            return this.finalize(node, new Node.Literal(token.value, raw));
          };
          JSXParser2.prototype.parseJSXExpressionAttribute = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            this.finishJSX();
            if (this.match("}")) {
              this.tolerateError("JSX attributes must only be assigned a non-empty expression");
            }
            var expression = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXAttributeValue = function() {
            return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
          };
          JSXParser2.prototype.parseJSXNameValueAttribute = function() {
            var node = this.createJSXNode();
            var name = this.parseJSXAttributeName();
            var value14 = null;
            if (this.matchJSX("=")) {
              this.expectJSX("=");
              value14 = this.parseJSXAttributeValue();
            }
            return this.finalize(node, new JSXNode.JSXAttribute(name, value14));
          };
          JSXParser2.prototype.parseJSXSpreadAttribute = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            this.expectJSX("...");
            this.finishJSX();
            var argument = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
          };
          JSXParser2.prototype.parseJSXAttributes = function() {
            var attributes = [];
            while (!this.matchJSX("/") && !this.matchJSX(">")) {
              var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
              attributes.push(attribute);
            }
            return attributes;
          };
          JSXParser2.prototype.parseJSXOpeningElement = function() {
            var node = this.createJSXNode();
            this.expectJSX("<");
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXBoundaryElement = function() {
            var node = this.createJSXNode();
            this.expectJSX("<");
            if (this.matchJSX("/")) {
              this.expectJSX("/");
              var name_3 = this.parseJSXElementName();
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
            }
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXEmptyExpression = function() {
            var node = this.createJSXChildNode();
            this.collectComments();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            return this.finalize(node, new JSXNode.JSXEmptyExpression);
          };
          JSXParser2.prototype.parseJSXExpressionContainer = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            var expression;
            if (this.matchJSX("}")) {
              expression = this.parseJSXEmptyExpression();
              this.expectJSX("}");
            } else {
              this.finishJSX();
              expression = this.parseAssignmentExpression();
              this.reenterJSX();
            }
            return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXChildren = function() {
            var children = [];
            while (!this.scanner.eof()) {
              var node = this.createJSXChildNode();
              var token = this.nextJSXText();
              if (token.start < token.end) {
                var raw = this.getTokenRaw(token);
                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                children.push(child);
              }
              if (this.scanner.source[this.scanner.index] === "{") {
                var container = this.parseJSXExpressionContainer();
                children.push(container);
              } else {
                break;
              }
            }
            return children;
          };
          JSXParser2.prototype.parseComplexJSXElement = function(el) {
            var stack = [];
            while (!this.scanner.eof()) {
              el.children = el.children.concat(this.parseJSXChildren());
              var node = this.createJSXChildNode();
              var element = this.parseJSXBoundaryElement();
              if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                var opening = element;
                if (opening.selfClosing) {
                  var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                  el.children.push(child);
                } else {
                  stack.push(el);
                  el = { node, opening, closing: null, children: [] };
                }
              }
              if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                el.closing = element;
                var open_1 = getQualifiedElementName(el.opening.name);
                var close_1 = getQualifiedElementName(el.closing.name);
                if (open_1 !== close_1) {
                  this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                }
                if (stack.length > 0) {
                  var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                  el = stack[stack.length - 1];
                  el.children.push(child);
                  stack.pop();
                } else {
                  break;
                }
              }
            }
            return el;
          };
          JSXParser2.prototype.parseJSXElement = function() {
            var node = this.createJSXNode();
            var opening = this.parseJSXOpeningElement();
            var children = [];
            var closing = null;
            if (!opening.selfClosing) {
              var el = this.parseComplexJSXElement({ node, opening, closing, children });
              children = el.children;
              closing = el.closing;
            }
            return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
          };
          JSXParser2.prototype.parseJSXRoot = function() {
            if (this.config.tokens) {
              this.tokens.pop();
            }
            this.startJSX();
            var element = this.parseJSXElement();
            this.finishJSX();
            return element;
          };
          JSXParser2.prototype.isStartOfExpression = function() {
            return _super.prototype.isStartOfExpression.call(this) || this.match("<");
          };
          return JSXParser2;
        }(parser_1.Parser);
        exports2.JSXParser = JSXParser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var Regex = {
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
          NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
        exports2.Character = {
          fromCodePoint: function(cp) {
            return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
          },
          isWhiteSpace: function(cp) {
            return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
          },
          isLineTerminator: function(cp) {
            return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
          },
          isIdentifierStart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
          },
          isIdentifierPart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
          },
          isDecimalDigit: function(cp) {
            return cp >= 48 && cp <= 57;
          },
          isHexDigit: function(cp) {
            return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
          },
          isOctalDigit: function(cp) {
            return cp >= 48 && cp <= 55;
          }
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var jsx_syntax_1 = __webpack_require__(6);
        var JSXClosingElement = function() {
          function JSXClosingElement2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
            this.name = name;
          }
          return JSXClosingElement2;
        }();
        exports2.JSXClosingElement = JSXClosingElement;
        var JSXElement = function() {
          function JSXElement2(openingElement, children, closingElement) {
            this.type = jsx_syntax_1.JSXSyntax.JSXElement;
            this.openingElement = openingElement;
            this.children = children;
            this.closingElement = closingElement;
          }
          return JSXElement2;
        }();
        exports2.JSXElement = JSXElement;
        var JSXEmptyExpression = function() {
          function JSXEmptyExpression2() {
            this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
          }
          return JSXEmptyExpression2;
        }();
        exports2.JSXEmptyExpression = JSXEmptyExpression;
        var JSXExpressionContainer = function() {
          function JSXExpressionContainer2(expression) {
            this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
            this.expression = expression;
          }
          return JSXExpressionContainer2;
        }();
        exports2.JSXExpressionContainer = JSXExpressionContainer;
        var JSXIdentifier = function() {
          function JSXIdentifier2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
            this.name = name;
          }
          return JSXIdentifier2;
        }();
        exports2.JSXIdentifier = JSXIdentifier;
        var JSXMemberExpression = function() {
          function JSXMemberExpression2(object12, property) {
            this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
            this.object = object12;
            this.property = property;
          }
          return JSXMemberExpression2;
        }();
        exports2.JSXMemberExpression = JSXMemberExpression;
        var JSXAttribute = function() {
          function JSXAttribute2(name, value14) {
            this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
            this.name = name;
            this.value = value14;
          }
          return JSXAttribute2;
        }();
        exports2.JSXAttribute = JSXAttribute;
        var JSXNamespacedName = function() {
          function JSXNamespacedName2(namespace, name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
            this.namespace = namespace;
            this.name = name;
          }
          return JSXNamespacedName2;
        }();
        exports2.JSXNamespacedName = JSXNamespacedName;
        var JSXOpeningElement = function() {
          function JSXOpeningElement2(name, selfClosing, attributes) {
            this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
            this.name = name;
            this.selfClosing = selfClosing;
            this.attributes = attributes;
          }
          return JSXOpeningElement2;
        }();
        exports2.JSXOpeningElement = JSXOpeningElement;
        var JSXSpreadAttribute = function() {
          function JSXSpreadAttribute2(argument) {
            this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
            this.argument = argument;
          }
          return JSXSpreadAttribute2;
        }();
        exports2.JSXSpreadAttribute = JSXSpreadAttribute;
        var JSXText = function() {
          function JSXText2(value14, raw) {
            this.type = jsx_syntax_1.JSXSyntax.JSXText;
            this.value = value14;
            this.raw = raw;
          }
          return JSXText2;
        }();
        exports2.JSXText = JSXText;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.JSXSyntax = {
          JSXAttribute: "JSXAttribute",
          JSXClosingElement: "JSXClosingElement",
          JSXElement: "JSXElement",
          JSXEmptyExpression: "JSXEmptyExpression",
          JSXExpressionContainer: "JSXExpressionContainer",
          JSXIdentifier: "JSXIdentifier",
          JSXMemberExpression: "JSXMemberExpression",
          JSXNamespacedName: "JSXNamespacedName",
          JSXOpeningElement: "JSXOpeningElement",
          JSXSpreadAttribute: "JSXSpreadAttribute",
          JSXText: "JSXText"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var ArrayExpression = function() {
          function ArrayExpression2(elements) {
            this.type = syntax_1.Syntax.ArrayExpression;
            this.elements = elements;
          }
          return ArrayExpression2;
        }();
        exports2.ArrayExpression = ArrayExpression;
        var ArrayPattern = function() {
          function ArrayPattern2(elements) {
            this.type = syntax_1.Syntax.ArrayPattern;
            this.elements = elements;
          }
          return ArrayPattern2;
        }();
        exports2.ArrayPattern = ArrayPattern;
        var ArrowFunctionExpression = function() {
          function ArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = false;
          }
          return ArrowFunctionExpression2;
        }();
        exports2.ArrowFunctionExpression = ArrowFunctionExpression;
        var AssignmentExpression = function() {
          function AssignmentExpression2(operator, left, right) {
            this.type = syntax_1.Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
          }
          return AssignmentExpression2;
        }();
        exports2.AssignmentExpression = AssignmentExpression;
        var AssignmentPattern = function() {
          function AssignmentPattern2(left, right) {
            this.type = syntax_1.Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
          }
          return AssignmentPattern2;
        }();
        exports2.AssignmentPattern = AssignmentPattern;
        var AsyncArrowFunctionExpression = function() {
          function AsyncArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = true;
          }
          return AsyncArrowFunctionExpression2;
        }();
        exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
        var AsyncFunctionDeclaration = function() {
          function AsyncFunctionDeclaration2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionDeclaration2;
        }();
        exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
        var AsyncFunctionExpression = function() {
          function AsyncFunctionExpression2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionExpression2;
        }();
        exports2.AsyncFunctionExpression = AsyncFunctionExpression;
        var AwaitExpression = function() {
          function AwaitExpression2(argument) {
            this.type = syntax_1.Syntax.AwaitExpression;
            this.argument = argument;
          }
          return AwaitExpression2;
        }();
        exports2.AwaitExpression = AwaitExpression;
        var BinaryExpression = function() {
          function BinaryExpression2(operator, left, right) {
            var logical = operator === "||" || operator === "&&";
            this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
          }
          return BinaryExpression2;
        }();
        exports2.BinaryExpression = BinaryExpression;
        var BlockStatement = function() {
          function BlockStatement2(body) {
            this.type = syntax_1.Syntax.BlockStatement;
            this.body = body;
          }
          return BlockStatement2;
        }();
        exports2.BlockStatement = BlockStatement;
        var BreakStatement = function() {
          function BreakStatement2(label) {
            this.type = syntax_1.Syntax.BreakStatement;
            this.label = label;
          }
          return BreakStatement2;
        }();
        exports2.BreakStatement = BreakStatement;
        var CallExpression = function() {
          function CallExpression2(callee, args) {
            this.type = syntax_1.Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return CallExpression2;
        }();
        exports2.CallExpression = CallExpression;
        var CatchClause = function() {
          function CatchClause2(param, body) {
            this.type = syntax_1.Syntax.CatchClause;
            this.param = param;
            this.body = body;
          }
          return CatchClause2;
        }();
        exports2.CatchClause = CatchClause;
        var ClassBody = function() {
          function ClassBody2(body) {
            this.type = syntax_1.Syntax.ClassBody;
            this.body = body;
          }
          return ClassBody2;
        }();
        exports2.ClassBody = ClassBody;
        var ClassDeclaration = function() {
          function ClassDeclaration2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassDeclaration2;
        }();
        exports2.ClassDeclaration = ClassDeclaration;
        var ClassExpression = function() {
          function ClassExpression2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassExpression2;
        }();
        exports2.ClassExpression = ClassExpression;
        var ComputedMemberExpression = function() {
          function ComputedMemberExpression2(object12, property) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = true;
            this.object = object12;
            this.property = property;
          }
          return ComputedMemberExpression2;
        }();
        exports2.ComputedMemberExpression = ComputedMemberExpression;
        var ConditionalExpression = function() {
          function ConditionalExpression2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return ConditionalExpression2;
        }();
        exports2.ConditionalExpression = ConditionalExpression;
        var ContinueStatement = function() {
          function ContinueStatement2(label) {
            this.type = syntax_1.Syntax.ContinueStatement;
            this.label = label;
          }
          return ContinueStatement2;
        }();
        exports2.ContinueStatement = ContinueStatement;
        var DebuggerStatement = function() {
          function DebuggerStatement2() {
            this.type = syntax_1.Syntax.DebuggerStatement;
          }
          return DebuggerStatement2;
        }();
        exports2.DebuggerStatement = DebuggerStatement;
        var Directive = function() {
          function Directive2(expression, directive) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
            this.directive = directive;
          }
          return Directive2;
        }();
        exports2.Directive = Directive;
        var DoWhileStatement = function() {
          function DoWhileStatement2(body, test) {
            this.type = syntax_1.Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
          }
          return DoWhileStatement2;
        }();
        exports2.DoWhileStatement = DoWhileStatement;
        var EmptyStatement = function() {
          function EmptyStatement2() {
            this.type = syntax_1.Syntax.EmptyStatement;
          }
          return EmptyStatement2;
        }();
        exports2.EmptyStatement = EmptyStatement;
        var ExportAllDeclaration = function() {
          function ExportAllDeclaration2(source) {
            this.type = syntax_1.Syntax.ExportAllDeclaration;
            this.source = source;
          }
          return ExportAllDeclaration2;
        }();
        exports2.ExportAllDeclaration = ExportAllDeclaration;
        var ExportDefaultDeclaration = function() {
          function ExportDefaultDeclaration2(declaration) {
            this.type = syntax_1.Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
          }
          return ExportDefaultDeclaration2;
        }();
        exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
        var ExportNamedDeclaration = function() {
          function ExportNamedDeclaration2(declaration, specifiers, source) {
            this.type = syntax_1.Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ExportNamedDeclaration2;
        }();
        exports2.ExportNamedDeclaration = ExportNamedDeclaration;
        var ExportSpecifier = function() {
          function ExportSpecifier2(local, exported) {
            this.type = syntax_1.Syntax.ExportSpecifier;
            this.exported = exported;
            this.local = local;
          }
          return ExportSpecifier2;
        }();
        exports2.ExportSpecifier = ExportSpecifier;
        var ExpressionStatement = function() {
          function ExpressionStatement2(expression) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
          }
          return ExpressionStatement2;
        }();
        exports2.ExpressionStatement = ExpressionStatement;
        var ForInStatement = function() {
          function ForInStatement2(left, right, body) {
            this.type = syntax_1.Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
          }
          return ForInStatement2;
        }();
        exports2.ForInStatement = ForInStatement;
        var ForOfStatement = function() {
          function ForOfStatement2(left, right, body) {
            this.type = syntax_1.Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
          }
          return ForOfStatement2;
        }();
        exports2.ForOfStatement = ForOfStatement;
        var ForStatement = function() {
          function ForStatement2(init, test, update, body) {
            this.type = syntax_1.Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
          }
          return ForStatement2;
        }();
        exports2.ForStatement = ForStatement;
        var FunctionDeclaration = function() {
          function FunctionDeclaration2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionDeclaration2;
        }();
        exports2.FunctionDeclaration = FunctionDeclaration;
        var FunctionExpression = function() {
          function FunctionExpression2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionExpression2;
        }();
        exports2.FunctionExpression = FunctionExpression;
        var Identifier2 = function() {
          function Identifier3(name) {
            this.type = syntax_1.Syntax.Identifier;
            this.name = name;
          }
          return Identifier3;
        }();
        exports2.Identifier = Identifier2;
        var IfStatement = function() {
          function IfStatement2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return IfStatement2;
        }();
        exports2.IfStatement = IfStatement;
        var ImportDeclaration = function() {
          function ImportDeclaration2(specifiers, source) {
            this.type = syntax_1.Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ImportDeclaration2;
        }();
        exports2.ImportDeclaration = ImportDeclaration;
        var ImportDefaultSpecifier = function() {
          function ImportDefaultSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportDefaultSpecifier;
            this.local = local;
          }
          return ImportDefaultSpecifier2;
        }();
        exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
        var ImportNamespaceSpecifier = function() {
          function ImportNamespaceSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
            this.local = local;
          }
          return ImportNamespaceSpecifier2;
        }();
        exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
        var ImportSpecifier = function() {
          function ImportSpecifier2(local, imported) {
            this.type = syntax_1.Syntax.ImportSpecifier;
            this.local = local;
            this.imported = imported;
          }
          return ImportSpecifier2;
        }();
        exports2.ImportSpecifier = ImportSpecifier;
        var LabeledStatement = function() {
          function LabeledStatement2(label, body) {
            this.type = syntax_1.Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
          }
          return LabeledStatement2;
        }();
        exports2.LabeledStatement = LabeledStatement;
        var Literal2 = function() {
          function Literal3(value14, raw) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value14;
            this.raw = raw;
          }
          return Literal3;
        }();
        exports2.Literal = Literal2;
        var MetaProperty = function() {
          function MetaProperty2(meta, property) {
            this.type = syntax_1.Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
          }
          return MetaProperty2;
        }();
        exports2.MetaProperty = MetaProperty;
        var MethodDefinition = function() {
          function MethodDefinition2(key, computed, value14, kind, isStatic) {
            this.type = syntax_1.Syntax.MethodDefinition;
            this.key = key;
            this.computed = computed;
            this.value = value14;
            this.kind = kind;
            this.static = isStatic;
          }
          return MethodDefinition2;
        }();
        exports2.MethodDefinition = MethodDefinition;
        var Module = function() {
          function Module2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "module";
          }
          return Module2;
        }();
        exports2.Module = Module;
        var NewExpression = function() {
          function NewExpression2(callee, args) {
            this.type = syntax_1.Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return NewExpression2;
        }();
        exports2.NewExpression = NewExpression;
        var ObjectExpression = function() {
          function ObjectExpression2(properties) {
            this.type = syntax_1.Syntax.ObjectExpression;
            this.properties = properties;
          }
          return ObjectExpression2;
        }();
        exports2.ObjectExpression = ObjectExpression;
        var ObjectPattern = function() {
          function ObjectPattern2(properties) {
            this.type = syntax_1.Syntax.ObjectPattern;
            this.properties = properties;
          }
          return ObjectPattern2;
        }();
        exports2.ObjectPattern = ObjectPattern;
        var Property2 = function() {
          function Property3(kind, key, computed, value14, method, shorthand) {
            this.type = syntax_1.Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value14;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
          }
          return Property3;
        }();
        exports2.Property = Property2;
        var RegexLiteral = function() {
          function RegexLiteral2(value14, raw, pattern3, flags) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value14;
            this.raw = raw;
            this.regex = { pattern: pattern3, flags };
          }
          return RegexLiteral2;
        }();
        exports2.RegexLiteral = RegexLiteral;
        var RestElement = function() {
          function RestElement2(argument) {
            this.type = syntax_1.Syntax.RestElement;
            this.argument = argument;
          }
          return RestElement2;
        }();
        exports2.RestElement = RestElement;
        var ReturnStatement = function() {
          function ReturnStatement2(argument) {
            this.type = syntax_1.Syntax.ReturnStatement;
            this.argument = argument;
          }
          return ReturnStatement2;
        }();
        exports2.ReturnStatement = ReturnStatement;
        var Script = function() {
          function Script2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "script";
          }
          return Script2;
        }();
        exports2.Script = Script;
        var SequenceExpression = function() {
          function SequenceExpression2(expressions) {
            this.type = syntax_1.Syntax.SequenceExpression;
            this.expressions = expressions;
          }
          return SequenceExpression2;
        }();
        exports2.SequenceExpression = SequenceExpression;
        var SpreadElement = function() {
          function SpreadElement2(argument) {
            this.type = syntax_1.Syntax.SpreadElement;
            this.argument = argument;
          }
          return SpreadElement2;
        }();
        exports2.SpreadElement = SpreadElement;
        var StaticMemberExpression = function() {
          function StaticMemberExpression2(object12, property) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = false;
            this.object = object12;
            this.property = property;
          }
          return StaticMemberExpression2;
        }();
        exports2.StaticMemberExpression = StaticMemberExpression;
        var Super = function() {
          function Super2() {
            this.type = syntax_1.Syntax.Super;
          }
          return Super2;
        }();
        exports2.Super = Super;
        var SwitchCase = function() {
          function SwitchCase2(test, consequent) {
            this.type = syntax_1.Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
          }
          return SwitchCase2;
        }();
        exports2.SwitchCase = SwitchCase;
        var SwitchStatement = function() {
          function SwitchStatement2(discriminant, cases) {
            this.type = syntax_1.Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
          }
          return SwitchStatement2;
        }();
        exports2.SwitchStatement = SwitchStatement;
        var TaggedTemplateExpression = function() {
          function TaggedTemplateExpression2(tag, quasi) {
            this.type = syntax_1.Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
          }
          return TaggedTemplateExpression2;
        }();
        exports2.TaggedTemplateExpression = TaggedTemplateExpression;
        var TemplateElement = function() {
          function TemplateElement2(value14, tail) {
            this.type = syntax_1.Syntax.TemplateElement;
            this.value = value14;
            this.tail = tail;
          }
          return TemplateElement2;
        }();
        exports2.TemplateElement = TemplateElement;
        var TemplateLiteral2 = function() {
          function TemplateLiteral3(quasis, expressions) {
            this.type = syntax_1.Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
          }
          return TemplateLiteral3;
        }();
        exports2.TemplateLiteral = TemplateLiteral2;
        var ThisExpression = function() {
          function ThisExpression2() {
            this.type = syntax_1.Syntax.ThisExpression;
          }
          return ThisExpression2;
        }();
        exports2.ThisExpression = ThisExpression;
        var ThrowStatement = function() {
          function ThrowStatement2(argument) {
            this.type = syntax_1.Syntax.ThrowStatement;
            this.argument = argument;
          }
          return ThrowStatement2;
        }();
        exports2.ThrowStatement = ThrowStatement;
        var TryStatement = function() {
          function TryStatement2(block, handler, finalizer) {
            this.type = syntax_1.Syntax.TryStatement;
            this.block = block;
            this.handler = handler;
            this.finalizer = finalizer;
          }
          return TryStatement2;
        }();
        exports2.TryStatement = TryStatement;
        var UnaryExpression = function() {
          function UnaryExpression2(operator, argument) {
            this.type = syntax_1.Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
          }
          return UnaryExpression2;
        }();
        exports2.UnaryExpression = UnaryExpression;
        var UpdateExpression = function() {
          function UpdateExpression2(operator, argument, prefix) {
            this.type = syntax_1.Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = prefix;
          }
          return UpdateExpression2;
        }();
        exports2.UpdateExpression = UpdateExpression;
        var VariableDeclaration = function() {
          function VariableDeclaration2(declarations, kind) {
            this.type = syntax_1.Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
          }
          return VariableDeclaration2;
        }();
        exports2.VariableDeclaration = VariableDeclaration;
        var VariableDeclarator = function() {
          function VariableDeclarator2(id, init) {
            this.type = syntax_1.Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
          }
          return VariableDeclarator2;
        }();
        exports2.VariableDeclarator = VariableDeclarator;
        var WhileStatement = function() {
          function WhileStatement2(test, body) {
            this.type = syntax_1.Syntax.WhileStatement;
            this.test = test;
            this.body = body;
          }
          return WhileStatement2;
        }();
        exports2.WhileStatement = WhileStatement;
        var WithStatement = function() {
          function WithStatement2(object12, body) {
            this.type = syntax_1.Syntax.WithStatement;
            this.object = object12;
            this.body = body;
          }
          return WithStatement2;
        }();
        exports2.WithStatement = WithStatement;
        var YieldExpression = function() {
          function YieldExpression2(argument, delegate) {
            this.type = syntax_1.Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
          }
          return YieldExpression2;
        }();
        exports2.YieldExpression = YieldExpression;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var error_handler_1 = __webpack_require__(10);
        var messages_1 = __webpack_require__(11);
        var Node = __webpack_require__(7);
        var scanner_1 = __webpack_require__(12);
        var syntax_1 = __webpack_require__(2);
        var token_1 = __webpack_require__(13);
        var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
        var Parser = function() {
          function Parser2(code, options, delegate) {
            if (options === undefined) {
              options = {};
            }
            this.config = {
              range: typeof options.range === "boolean" && options.range,
              loc: typeof options.loc === "boolean" && options.loc,
              source: null,
              tokens: typeof options.tokens === "boolean" && options.tokens,
              comment: typeof options.comment === "boolean" && options.comment,
              tolerant: typeof options.tolerant === "boolean" && options.tolerant
            };
            if (this.config.loc && options.source && options.source !== null) {
              this.config.source = String(options.source);
            }
            this.delegate = delegate;
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = this.config.tolerant;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = this.config.comment;
            this.operatorPrecedence = {
              ")": 0,
              ";": 0,
              ",": 0,
              "=": 0,
              "]": 0,
              "||": 1,
              "&&": 2,
              "|": 3,
              "^": 4,
              "&": 5,
              "==": 6,
              "!=": 6,
              "===": 6,
              "!==": 6,
              "<": 7,
              ">": 7,
              "<=": 7,
              ">=": 7,
              "<<": 8,
              ">>": 8,
              ">>>": 8,
              "+": 9,
              "-": 9,
              "*": 11,
              "/": 11,
              "%": 11
            };
            this.lookahead = {
              type: 2,
              value: "",
              lineNumber: this.scanner.lineNumber,
              lineStart: 0,
              start: 0,
              end: 0
            };
            this.hasLineTerminator = false;
            this.context = {
              isModule: false,
              await: false,
              allowIn: true,
              allowStrictDirective: true,
              allowYield: true,
              firstCoverInitializedNameError: null,
              isAssignmentTarget: false,
              isBindingElement: false,
              inFunctionBody: false,
              inIteration: false,
              inSwitch: false,
              labelSet: {},
              strict: false
            };
            this.tokens = [];
            this.startMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.lastMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.nextToken();
            this.lastMarker = {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          }
          Parser2.prototype.throwError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
              assert_1.assert(idx < args.length, "Message reference must be in range");
              return args[idx];
            });
            var index = this.lastMarker.index;
            var line = this.lastMarker.line;
            var column = this.lastMarker.column + 1;
            throw this.errorHandler.createError(index, line, column, msg);
          };
          Parser2.prototype.tolerateError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
              assert_1.assert(idx < args.length, "Message reference must be in range");
              return args[idx];
            });
            var index = this.lastMarker.index;
            var line = this.scanner.lineNumber;
            var column = this.lastMarker.column + 1;
            this.errorHandler.tolerateError(index, line, column, msg);
          };
          Parser2.prototype.unexpectedTokenError = function(token, message) {
            var msg = message || messages_1.Messages.UnexpectedToken;
            var value14;
            if (token) {
              if (!message) {
                msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                if (token.type === 4) {
                  if (this.scanner.isFutureReservedWord(token.value)) {
                    msg = messages_1.Messages.UnexpectedReserved;
                  } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                    msg = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              value14 = token.value;
            } else {
              value14 = "ILLEGAL";
            }
            msg = msg.replace("%0", value14);
            if (token && typeof token.lineNumber === "number") {
              var index = token.start;
              var line = token.lineNumber;
              var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
              var column = token.start - lastMarkerLineStart + 1;
              return this.errorHandler.createError(index, line, column, msg);
            } else {
              var index = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              return this.errorHandler.createError(index, line, column, msg);
            }
          };
          Parser2.prototype.throwUnexpectedToken = function(token, message) {
            throw this.unexpectedTokenError(token, message);
          };
          Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
            this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
          };
          Parser2.prototype.collectComments = function() {
            if (!this.config.comment) {
              this.scanner.scanComments();
            } else {
              var comments = this.scanner.scanComments();
              if (comments.length > 0 && this.delegate) {
                for (var i2 = 0;i2 < comments.length; ++i2) {
                  var e2 = comments[i2];
                  var node = undefined;
                  node = {
                    type: e2.multiLine ? "BlockComment" : "LineComment",
                    value: this.scanner.source.slice(e2.slice[0], e2.slice[1])
                  };
                  if (this.config.range) {
                    node.range = e2.range;
                  }
                  if (this.config.loc) {
                    node.loc = e2.loc;
                  }
                  var metadata = {
                    start: {
                      line: e2.loc.start.line,
                      column: e2.loc.start.column,
                      offset: e2.range[0]
                    },
                    end: {
                      line: e2.loc.end.line,
                      column: e2.loc.end.column,
                      offset: e2.range[1]
                    }
                  };
                  this.delegate(node, metadata);
                }
              }
            }
          };
          Parser2.prototype.getTokenRaw = function(token) {
            return this.scanner.source.slice(token.start, token.end);
          };
          Parser2.prototype.convertToken = function(token) {
            var t2 = {
              type: token_1.TokenName[token.type],
              value: this.getTokenRaw(token)
            };
            if (this.config.range) {
              t2.range = [token.start, token.end];
            }
            if (this.config.loc) {
              t2.loc = {
                start: {
                  line: this.startMarker.line,
                  column: this.startMarker.column
                },
                end: {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                }
              };
            }
            if (token.type === 9) {
              var pattern3 = token.pattern;
              var flags = token.flags;
              t2.regex = { pattern: pattern3, flags };
            }
            return t2;
          };
          Parser2.prototype.nextToken = function() {
            var token = this.lookahead;
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            this.collectComments();
            if (this.scanner.index !== this.startMarker.index) {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            }
            var next = this.scanner.lex();
            this.hasLineTerminator = token.lineNumber !== next.lineNumber;
            if (next && this.context.strict && next.type === 3) {
              if (this.scanner.isStrictModeReservedWord(next.value)) {
                next.type = 4;
              }
            }
            this.lookahead = next;
            if (this.config.tokens && next.type !== 2) {
              this.tokens.push(this.convertToken(next));
            }
            return token;
          };
          Parser2.prototype.nextRegexToken = function() {
            this.collectComments();
            var token = this.scanner.scanRegExp();
            if (this.config.tokens) {
              this.tokens.pop();
              this.tokens.push(this.convertToken(token));
            }
            this.lookahead = token;
            this.nextToken();
            return token;
          };
          Parser2.prototype.createNode = function() {
            return {
              index: this.startMarker.index,
              line: this.startMarker.line,
              column: this.startMarker.column
            };
          };
          Parser2.prototype.startNode = function(token, lastLineStart) {
            if (lastLineStart === undefined) {
              lastLineStart = 0;
            }
            var column = token.start - token.lineStart;
            var line = token.lineNumber;
            if (column < 0) {
              column += lastLineStart;
              line--;
            }
            return {
              index: token.start,
              line,
              column
            };
          };
          Parser2.prototype.finalize = function(marker, node) {
            if (this.config.range) {
              node.range = [marker.index, this.lastMarker.index];
            }
            if (this.config.loc) {
              node.loc = {
                start: {
                  line: marker.line,
                  column: marker.column
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column
                }
              };
              if (this.config.source) {
                node.loc.source = this.config.source;
              }
            }
            if (this.delegate) {
              var metadata = {
                start: {
                  line: marker.line,
                  column: marker.column,
                  offset: marker.index
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column,
                  offset: this.lastMarker.index
                }
              };
              this.delegate(node, metadata);
            }
            return node;
          };
          Parser2.prototype.expect = function(value14) {
            var token = this.nextToken();
            if (token.type !== 7 || token.value !== value14) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser2.prototype.expectCommaSeparator = function() {
            if (this.config.tolerant) {
              var token = this.lookahead;
              if (token.type === 7 && token.value === ",") {
                this.nextToken();
              } else if (token.type === 7 && token.value === ";") {
                this.nextToken();
                this.tolerateUnexpectedToken(token);
              } else {
                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
              }
            } else {
              this.expect(",");
            }
          };
          Parser2.prototype.expectKeyword = function(keyword) {
            var token = this.nextToken();
            if (token.type !== 4 || token.value !== keyword) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser2.prototype.match = function(value14) {
            return this.lookahead.type === 7 && this.lookahead.value === value14;
          };
          Parser2.prototype.matchKeyword = function(keyword) {
            return this.lookahead.type === 4 && this.lookahead.value === keyword;
          };
          Parser2.prototype.matchContextualKeyword = function(keyword) {
            return this.lookahead.type === 3 && this.lookahead.value === keyword;
          };
          Parser2.prototype.matchAssign = function() {
            if (this.lookahead.type !== 7) {
              return false;
            }
            var op = this.lookahead.value;
            return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
          };
          Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            if (this.context.firstCoverInitializedNameError !== null) {
              this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
            }
            this.context.isBindingElement = previousIsBindingElement;
            this.context.isAssignmentTarget = previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
            return result;
          };
          Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
            this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
            return result;
          };
          Parser2.prototype.consumeSemicolon = function() {
            if (this.match(";")) {
              this.nextToken();
            } else if (!this.hasLineTerminator) {
              if (this.lookahead.type !== 2 && !this.match("}")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.lastMarker.index = this.startMarker.index;
              this.lastMarker.line = this.startMarker.line;
              this.lastMarker.column = this.startMarker.column;
            }
          };
          Parser2.prototype.parsePrimaryExpression = function() {
            var node = this.createNode();
            var expr;
            var token, raw;
            switch (this.lookahead.type) {
              case 3:
                if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                  this.tolerateUnexpectedToken(this.lookahead);
                }
                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                break;
              case 6:
              case 8:
                if (this.context.strict && this.lookahead.octal) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value, raw));
                break;
              case 1:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                break;
              case 5:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(null, raw));
                break;
              case 10:
                expr = this.parseTemplateLiteral();
                break;
              case 7:
                switch (this.lookahead.value) {
                  case "(":
                    this.context.isBindingElement = false;
                    expr = this.inheritCoverGrammar(this.parseGroupExpression);
                    break;
                  case "[":
                    expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                    break;
                  case "{":
                    expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                    break;
                  case "/":
                  case "/=":
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.scanner.index = this.startMarker.index;
                    token = this.nextRegexToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                break;
              case 4:
                if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseIdentifierName();
                } else if (!this.context.strict && this.matchKeyword("let")) {
                  expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                } else {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  if (this.matchKeyword("function")) {
                    expr = this.parseFunctionExpression();
                  } else if (this.matchKeyword("this")) {
                    this.nextToken();
                    expr = this.finalize(node, new Node.ThisExpression);
                  } else if (this.matchKeyword("class")) {
                    expr = this.parseClassExpression();
                  } else {
                    expr = this.throwUnexpectedToken(this.nextToken());
                  }
                }
                break;
              default:
                expr = this.throwUnexpectedToken(this.nextToken());
            }
            return expr;
          };
          Parser2.prototype.parseSpreadElement = function() {
            var node = this.createNode();
            this.expect("...");
            var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
            return this.finalize(node, new Node.SpreadElement(arg));
          };
          Parser2.prototype.parseArrayInitializer = function() {
            var node = this.createNode();
            var elements = [];
            this.expect("[");
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else if (this.match("...")) {
                var element = this.parseSpreadElement();
                if (!this.match("]")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  this.expect(",");
                }
                elements.push(element);
              } else {
                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node, new Node.ArrayExpression(elements));
          };
          Parser2.prototype.parsePropertyMethod = function(params) {
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = params.simple;
            var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
            if (this.context.strict && params.firstRestricted) {
              this.tolerateUnexpectedToken(params.firstRestricted, params.message);
            }
            if (this.context.strict && params.stricted) {
              this.tolerateUnexpectedToken(params.stricted, params.message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            return body;
          };
          Parser2.prototype.parsePropertyMethodFunction = function() {
            var isGenerator = false;
            var node = this.createNode();
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
            var node = this.createNode();
            var previousAllowYield = this.context.allowYield;
            var previousAwait = this.context.await;
            this.context.allowYield = false;
            this.context.await = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            this.context.await = previousAwait;
            return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
          };
          Parser2.prototype.parseObjectPropertyKey = function() {
            var node = this.createNode();
            var token = this.nextToken();
            var key;
            switch (token.type) {
              case 8:
              case 6:
                if (this.context.strict && token.octal) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                }
                var raw = this.getTokenRaw(token);
                key = this.finalize(node, new Node.Literal(token.value, raw));
                break;
              case 3:
              case 1:
              case 5:
              case 4:
                key = this.finalize(node, new Node.Identifier(token.value));
                break;
              case 7:
                if (token.value === "[") {
                  key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.expect("]");
                } else {
                  key = this.throwUnexpectedToken(token);
                }
                break;
              default:
                key = this.throwUnexpectedToken(token);
            }
            return key;
          };
          Parser2.prototype.isPropertyKey = function(key, value14) {
            return key.type === syntax_1.Syntax.Identifier && key.name === value14 || key.type === syntax_1.Syntax.Literal && key.value === value14;
          };
          Parser2.prototype.parseObjectProperty = function(hasProto) {
            var node = this.createNode();
            var token = this.lookahead;
            var kind;
            var key = null;
            var value14 = null;
            var computed = false;
            var method = false;
            var shorthand = false;
            var isAsync = false;
            if (token.type === 3) {
              var id = token.value;
              this.nextToken();
              computed = this.match("[");
              isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
              key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
            } else if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
              kind = "get";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.context.allowYield = false;
              value14 = this.parseGetterMethod();
            } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
              kind = "set";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value14 = this.parseSetterMethod();
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value14 = this.parseGeneratorMethod();
              method = true;
            } else {
              if (!key) {
                this.throwUnexpectedToken(this.lookahead);
              }
              kind = "init";
              if (this.match(":") && !isAsync) {
                if (!computed && this.isPropertyKey(key, "__proto__")) {
                  if (hasProto.value) {
                    this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                  }
                  hasProto.value = true;
                }
                this.nextToken();
                value14 = this.inheritCoverGrammar(this.parseAssignmentExpression);
              } else if (this.match("(")) {
                value14 = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              } else if (token.type === 3) {
                var id = this.finalize(node, new Node.Identifier(token.value));
                if (this.match("=")) {
                  this.context.firstCoverInitializedNameError = this.lookahead;
                  this.nextToken();
                  shorthand = true;
                  var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  value14 = this.finalize(node, new Node.AssignmentPattern(id, init));
                } else {
                  shorthand = true;
                  value14 = id;
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node, new Node.Property(kind, key, computed, value14, method, shorthand));
          };
          Parser2.prototype.parseObjectInitializer = function() {
            var node = this.createNode();
            this.expect("{");
            var properties = [];
            var hasProto = { value: false };
            while (!this.match("}")) {
              properties.push(this.parseObjectProperty(hasProto));
              if (!this.match("}")) {
                this.expectCommaSeparator();
              }
            }
            this.expect("}");
            return this.finalize(node, new Node.ObjectExpression(properties));
          };
          Parser2.prototype.parseTemplateHead = function() {
            assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
            var node = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser2.prototype.parseTemplateElement = function() {
            if (this.lookahead.type !== 10) {
              this.throwUnexpectedToken();
            }
            var node = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser2.prototype.parseTemplateLiteral = function() {
            var node = this.createNode();
            var expressions = [];
            var quasis = [];
            var quasi = this.parseTemplateHead();
            quasis.push(quasi);
            while (!quasi.tail) {
              expressions.push(this.parseExpression());
              quasi = this.parseTemplateElement();
              quasis.push(quasi);
            }
            return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
          };
          Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
              case syntax_1.Syntax.MemberExpression:
              case syntax_1.Syntax.RestElement:
              case syntax_1.Syntax.AssignmentPattern:
                break;
              case syntax_1.Syntax.SpreadElement:
                expr.type = syntax_1.Syntax.RestElement;
                this.reinterpretExpressionAsPattern(expr.argument);
                break;
              case syntax_1.Syntax.ArrayExpression:
                expr.type = syntax_1.Syntax.ArrayPattern;
                for (var i2 = 0;i2 < expr.elements.length; i2++) {
                  if (expr.elements[i2] !== null) {
                    this.reinterpretExpressionAsPattern(expr.elements[i2]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectExpression:
                expr.type = syntax_1.Syntax.ObjectPattern;
                for (var i2 = 0;i2 < expr.properties.length; i2++) {
                  this.reinterpretExpressionAsPattern(expr.properties[i2].value);
                }
                break;
              case syntax_1.Syntax.AssignmentExpression:
                expr.type = syntax_1.Syntax.AssignmentPattern;
                delete expr.operator;
                this.reinterpretExpressionAsPattern(expr.left);
                break;
              default:
                break;
            }
          };
          Parser2.prototype.parseGroupExpression = function() {
            var expr;
            this.expect("(");
            if (this.match(")")) {
              this.nextToken();
              if (!this.match("=>")) {
                this.expect("=>");
              }
              expr = {
                type: ArrowParameterPlaceHolder,
                params: [],
                async: false
              };
            } else {
              var startToken = this.lookahead;
              var params = [];
              if (this.match("...")) {
                expr = this.parseRestElement(params);
                this.expect(")");
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [expr],
                  async: false
                };
              } else {
                var arrow = false;
                this.context.isBindingElement = true;
                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  this.context.isAssignmentTarget = false;
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    if (this.match(")")) {
                      this.nextToken();
                      for (var i2 = 0;i2 < expressions.length; i2++) {
                        this.reinterpretExpressionAsPattern(expressions[i2]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else if (this.match("...")) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      expressions.push(this.parseRestElement(params));
                      this.expect(")");
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      this.context.isBindingElement = false;
                      for (var i2 = 0;i2 < expressions.length; i2++) {
                        this.reinterpretExpressionAsPattern(expressions[i2]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else {
                      expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    }
                    if (arrow) {
                      break;
                    }
                  }
                  if (!arrow) {
                    expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                  }
                }
                if (!arrow) {
                  this.expect(")");
                  if (this.match("=>")) {
                    if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [expr],
                        async: false
                      };
                    }
                    if (!arrow) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      if (expr.type === syntax_1.Syntax.SequenceExpression) {
                        for (var i2 = 0;i2 < expr.expressions.length; i2++) {
                          this.reinterpretExpressionAsPattern(expr.expressions[i2]);
                        }
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      var parameters3 = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: parameters3,
                        async: false
                      };
                    }
                  }
                  this.context.isBindingElement = false;
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser2.prototype.isIdentifierName = function(token) {
            return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
          };
          Parser2.prototype.parseIdentifierName = function() {
            var node = this.createNode();
            var token = this.nextToken();
            if (!this.isIdentifierName(token)) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node, new Node.Identifier(token.value));
          };
          Parser2.prototype.parseNewExpression = function() {
            var node = this.createNode();
            var id = this.parseIdentifierName();
            assert_1.assert(id.name === "new", "New expression must start with `new`");
            var expr;
            if (this.match(".")) {
              this.nextToken();
              if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                var property = this.parseIdentifierName();
                expr = new Node.MetaProperty(id, property);
              } else {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
              var args = this.match("(") ? this.parseArguments() : [];
              expr = new Node.NewExpression(callee, args);
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return this.finalize(node, expr);
          };
          Parser2.prototype.parseAsyncArgument = function() {
            var arg = this.parseAssignmentExpression();
            this.context.firstCoverInitializedNameError = null;
            return arg;
          };
          Parser2.prototype.parseAsyncArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
            var startToken = this.lookahead;
            var maybeAsync = this.matchContextualKeyword("async");
            var previousAllowIn = this.context.allowIn;
            this.context.allowIn = true;
            var expr;
            if (this.matchKeyword("super") && this.context.inFunctionBody) {
              expr = this.createNode();
              this.nextToken();
              expr = this.finalize(expr, new Node.Super);
              if (!this.match("(") && !this.match(".") && !this.match("[")) {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            }
            while (true) {
              if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property = this.parseIdentifierName();
                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
              } else if (this.match("(")) {
                var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = false;
                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                if (asyncArrow && this.match("=>")) {
                  for (var i2 = 0;i2 < args.length; ++i2) {
                    this.reinterpretExpressionAsPattern(args[i2]);
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: args,
                    async: true
                  };
                }
              } else if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            this.context.allowIn = previousAllowIn;
            return expr;
          };
          Parser2.prototype.parseSuper = function() {
            var node = this.createNode();
            this.expectKeyword("super");
            if (!this.match("[") && !this.match(".")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            return this.finalize(node, new Node.Super);
          };
          Parser2.prototype.parseLeftHandSideExpression = function() {
            assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
            var node = this.startNode(this.lookahead);
            var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            while (true) {
              if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
              } else if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property = this.parseIdentifierName();
                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            return expr;
          };
          Parser2.prototype.parseUpdateExpression = function() {
            var expr;
            var startToken = this.lookahead;
            if (this.match("++") || this.match("--")) {
              var node = this.startNode(startToken);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
              }
              if (!this.context.isAssignmentTarget) {
                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
              }
              var prefix = true;
              expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else {
              expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              if (!this.hasLineTerminator && this.lookahead.type === 7) {
                if (this.match("++") || this.match("--")) {
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var operator = this.nextToken().value;
                  var prefix = false;
                  expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseAwaitExpression = function() {
            var node = this.createNode();
            this.nextToken();
            var argument = this.parseUnaryExpression();
            return this.finalize(node, new Node.AwaitExpression(argument));
          };
          Parser2.prototype.parseUnaryExpression = function() {
            var expr;
            if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
              var node = this.startNode(this.lookahead);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
              if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                this.tolerateError(messages_1.Messages.StrictDelete);
              }
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else if (this.context.await && this.matchContextualKeyword("await")) {
              expr = this.parseAwaitExpression();
            } else {
              expr = this.parseUpdateExpression();
            }
            return expr;
          };
          Parser2.prototype.parseExponentiationExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var left = expr;
              var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
              expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
            }
            return expr;
          };
          Parser2.prototype.binaryPrecedence = function(token) {
            var op = token.value;
            var precedence;
            if (token.type === 7) {
              precedence = this.operatorPrecedence[op] || 0;
            } else if (token.type === 4) {
              precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
            } else {
              precedence = 0;
            }
            return precedence;
          };
          Parser2.prototype.parseBinaryExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
            var token = this.lookahead;
            var prec = this.binaryPrecedence(token);
            if (prec > 0) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var markers = [startToken, this.lookahead];
              var left = expr;
              var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
              var stack = [left, token.value, right];
              var precedences = [prec];
              while (true) {
                prec = this.binaryPrecedence(this.lookahead);
                if (prec <= 0) {
                  break;
                }
                while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                  right = stack.pop();
                  var operator = stack.pop();
                  precedences.pop();
                  left = stack.pop();
                  markers.pop();
                  var node = this.startNode(markers[markers.length - 1]);
                  stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                }
                stack.push(this.nextToken().value);
                precedences.push(prec);
                markers.push(this.lookahead);
                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
              }
              var i2 = stack.length - 1;
              expr = stack[i2];
              var lastMarker = markers.pop();
              while (i2 > 1) {
                var marker = markers.pop();
                var lastLineStart = lastMarker && lastMarker.lineStart;
                var node = this.startNode(marker, lastLineStart);
                var operator = stack[i2 - 1];
                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i2 - 2], expr));
                i2 -= 2;
                lastMarker = marker;
              }
            }
            return expr;
          };
          Parser2.prototype.parseConditionalExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
            if (this.match("?")) {
              this.nextToken();
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowIn = previousAllowIn;
              this.expect(":");
              var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
              expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return expr;
          };
          Parser2.prototype.checkPatternParam = function(options, param) {
            switch (param.type) {
              case syntax_1.Syntax.Identifier:
                this.validateParam(options, param, param.name);
                break;
              case syntax_1.Syntax.RestElement:
                this.checkPatternParam(options, param.argument);
                break;
              case syntax_1.Syntax.AssignmentPattern:
                this.checkPatternParam(options, param.left);
                break;
              case syntax_1.Syntax.ArrayPattern:
                for (var i2 = 0;i2 < param.elements.length; i2++) {
                  if (param.elements[i2] !== null) {
                    this.checkPatternParam(options, param.elements[i2]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectPattern:
                for (var i2 = 0;i2 < param.properties.length; i2++) {
                  this.checkPatternParam(options, param.properties[i2].value);
                }
                break;
              default:
                break;
            }
            options.simple = options.simple && param instanceof Node.Identifier;
          };
          Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
            var params = [expr];
            var options;
            var asyncArrow = false;
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
                break;
              case ArrowParameterPlaceHolder:
                params = expr.params;
                asyncArrow = expr.async;
                break;
              default:
                return null;
            }
            options = {
              simple: true,
              paramSet: {}
            };
            for (var i2 = 0;i2 < params.length; ++i2) {
              var param = params[i2];
              if (param.type === syntax_1.Syntax.AssignmentPattern) {
                if (param.right.type === syntax_1.Syntax.YieldExpression) {
                  if (param.right.argument) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  param.right.type = syntax_1.Syntax.Identifier;
                  param.right.name = "yield";
                  delete param.right.argument;
                  delete param.right.delegate;
                }
              } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.checkPatternParam(options, param);
              params[i2] = param;
            }
            if (this.context.strict || !this.context.allowYield) {
              for (var i2 = 0;i2 < params.length; ++i2) {
                var param = params[i2];
                if (param.type === syntax_1.Syntax.YieldExpression) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              }
            }
            if (options.message === messages_1.Messages.StrictParamDupe) {
              var token = this.context.strict ? options.stricted : options.firstRestricted;
              this.throwUnexpectedToken(token, options.message);
            }
            return {
              simple: options.simple,
              params,
              stricted: options.stricted,
              firstRestricted: options.firstRestricted,
              message: options.message
            };
          };
          Parser2.prototype.parseAssignmentExpression = function() {
            var expr;
            if (!this.context.allowYield && this.matchKeyword("yield")) {
              expr = this.parseYieldExpression();
            } else {
              var startToken = this.lookahead;
              var token = startToken;
              expr = this.parseConditionalExpression();
              if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                  var arg = this.parsePrimaryExpression();
                  this.reinterpretExpressionAsPattern(arg);
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [arg],
                    async: true
                  };
                }
              }
              if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var isAsync = expr.async;
                var list = this.reinterpretAsCoverFormalsList(expr);
                if (list) {
                  if (this.hasLineTerminator) {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  this.context.firstCoverInitializedNameError = null;
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = list.simple;
                  var previousAllowYield = this.context.allowYield;
                  var previousAwait = this.context.await;
                  this.context.allowYield = true;
                  this.context.await = isAsync;
                  var node = this.startNode(startToken);
                  this.expect("=>");
                  var body = undefined;
                  if (this.match("{")) {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    body = this.parseFunctionSourceElements();
                    this.context.allowIn = previousAllowIn;
                  } else {
                    body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  }
                  var expression = body.type !== syntax_1.Syntax.BlockStatement;
                  if (this.context.strict && list.firstRestricted) {
                    this.throwUnexpectedToken(list.firstRestricted, list.message);
                  }
                  if (this.context.strict && list.stricted) {
                    this.tolerateUnexpectedToken(list.stricted, list.message);
                  }
                  expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  this.context.allowYield = previousAllowYield;
                  this.context.await = previousAwait;
                }
              } else {
                if (this.matchAssign()) {
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                    var id = expr;
                    if (this.scanner.isRestrictedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                    }
                    if (this.scanner.isStrictModeReservedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                    }
                  }
                  if (!this.match("=")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  } else {
                    this.reinterpretExpressionAsPattern(expr);
                  }
                  token = this.nextToken();
                  var operator = token.value;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                  this.context.firstCoverInitializedNameError = null;
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseExpression = function() {
            var startToken = this.lookahead;
            var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
            if (this.match(",")) {
              var expressions = [];
              expressions.push(expr);
              while (this.lookahead.type !== 2) {
                if (!this.match(",")) {
                  break;
                }
                this.nextToken();
                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
              }
              expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
            }
            return expr;
          };
          Parser2.prototype.parseStatementListItem = function() {
            var statement;
            this.context.isAssignmentTarget = true;
            this.context.isBindingElement = true;
            if (this.lookahead.type === 4) {
              switch (this.lookahead.value) {
                case "export":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                  }
                  statement = this.parseExportDeclaration();
                  break;
                case "import":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                  }
                  statement = this.parseImportDeclaration();
                  break;
                case "const":
                  statement = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "function":
                  statement = this.parseFunctionDeclaration();
                  break;
                case "class":
                  statement = this.parseClassDeclaration();
                  break;
                case "let":
                  statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                  break;
                default:
                  statement = this.parseStatement();
                  break;
              }
            } else {
              statement = this.parseStatement();
            }
            return statement;
          };
          Parser2.prototype.parseBlock = function() {
            var node = this.createNode();
            this.expect("{");
            var block = [];
            while (true) {
              if (this.match("}")) {
                break;
              }
              block.push(this.parseStatementListItem());
            }
            this.expect("}");
            return this.finalize(node, new Node.BlockStatement(block));
          };
          Parser2.prototype.parseLexicalBinding = function(kind, options) {
            var node = this.createNode();
            var params = [];
            var id = this.parsePattern(params, kind);
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (kind === "const") {
              if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else {
                  this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                }
              }
            } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
              this.expect("=");
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            }
            return this.finalize(node, new Node.VariableDeclarator(id, init));
          };
          Parser2.prototype.parseBindingList = function(kind, options) {
            var list = [this.parseLexicalBinding(kind, options)];
            while (this.match(",")) {
              this.nextToken();
              list.push(this.parseLexicalBinding(kind, options));
            }
            return list;
          };
          Parser2.prototype.isLexicalDeclaration = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.scanner.lex();
            this.scanner.restoreState(state);
            return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
          };
          Parser2.prototype.parseLexicalDeclaration = function(options) {
            var node = this.createNode();
            var kind = this.nextToken().value;
            assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
            var declarations = this.parseBindingList(kind, options);
            this.consumeSemicolon();
            return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
          };
          Parser2.prototype.parseBindingRestElement = function(params, kind) {
            var node = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params, kind);
            return this.finalize(node, new Node.RestElement(arg));
          };
          Parser2.prototype.parseArrayPattern = function(params, kind) {
            var node = this.createNode();
            this.expect("[");
            var elements = [];
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else {
                if (this.match("...")) {
                  elements.push(this.parseBindingRestElement(params, kind));
                  break;
                } else {
                  elements.push(this.parsePatternWithDefault(params, kind));
                }
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node, new Node.ArrayPattern(elements));
          };
          Parser2.prototype.parsePropertyPattern = function(params, kind) {
            var node = this.createNode();
            var computed = false;
            var shorthand = false;
            var method = false;
            var key;
            var value14;
            if (this.lookahead.type === 3) {
              var keyToken = this.lookahead;
              key = this.parseVariableIdentifier();
              var init = this.finalize(node, new Node.Identifier(keyToken.value));
              if (this.match("=")) {
                params.push(keyToken);
                shorthand = true;
                this.nextToken();
                var expr = this.parseAssignmentExpression();
                value14 = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
              } else if (!this.match(":")) {
                params.push(keyToken);
                shorthand = true;
                value14 = init;
              } else {
                this.expect(":");
                value14 = this.parsePatternWithDefault(params, kind);
              }
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.expect(":");
              value14 = this.parsePatternWithDefault(params, kind);
            }
            return this.finalize(node, new Node.Property("init", key, computed, value14, method, shorthand));
          };
          Parser2.prototype.parseObjectPattern = function(params, kind) {
            var node = this.createNode();
            var properties = [];
            this.expect("{");
            while (!this.match("}")) {
              properties.push(this.parsePropertyPattern(params, kind));
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return this.finalize(node, new Node.ObjectPattern(properties));
          };
          Parser2.prototype.parsePattern = function(params, kind) {
            var pattern3;
            if (this.match("[")) {
              pattern3 = this.parseArrayPattern(params, kind);
            } else if (this.match("{")) {
              pattern3 = this.parseObjectPattern(params, kind);
            } else {
              if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
              }
              params.push(this.lookahead);
              pattern3 = this.parseVariableIdentifier(kind);
            }
            return pattern3;
          };
          Parser2.prototype.parsePatternWithDefault = function(params, kind) {
            var startToken = this.lookahead;
            var pattern3 = this.parsePattern(params, kind);
            if (this.match("=")) {
              this.nextToken();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowYield = previousAllowYield;
              pattern3 = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern3, right));
            }
            return pattern3;
          };
          Parser2.prototype.parseVariableIdentifier = function(kind) {
            var node = this.createNode();
            var token = this.nextToken();
            if (token.type === 4 && token.value === "yield") {
              if (this.context.strict) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else if (!this.context.allowYield) {
                this.throwUnexpectedToken(token);
              }
            } else if (token.type !== 3) {
              if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else {
                if (this.context.strict || token.value !== "let" || kind !== "var") {
                  this.throwUnexpectedToken(token);
                }
              }
            } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
              this.tolerateUnexpectedToken(token);
            }
            return this.finalize(node, new Node.Identifier(token.value));
          };
          Parser2.prototype.parseVariableDeclaration = function(options) {
            var node = this.createNode();
            var params = [];
            var id = this.parsePattern(params, "var");
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (this.match("=")) {
              this.nextToken();
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
              this.expect("=");
            }
            return this.finalize(node, new Node.VariableDeclarator(id, init));
          };
          Parser2.prototype.parseVariableDeclarationList = function(options) {
            var opt = { inFor: options.inFor };
            var list = [];
            list.push(this.parseVariableDeclaration(opt));
            while (this.match(",")) {
              this.nextToken();
              list.push(this.parseVariableDeclaration(opt));
            }
            return list;
          };
          Parser2.prototype.parseVariableStatement = function() {
            var node = this.createNode();
            this.expectKeyword("var");
            var declarations = this.parseVariableDeclarationList({ inFor: false });
            this.consumeSemicolon();
            return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
          };
          Parser2.prototype.parseEmptyStatement = function() {
            var node = this.createNode();
            this.expect(";");
            return this.finalize(node, new Node.EmptyStatement);
          };
          Parser2.prototype.parseExpressionStatement = function() {
            var node = this.createNode();
            var expr = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node, new Node.ExpressionStatement(expr));
          };
          Parser2.prototype.parseIfClause = function() {
            if (this.context.strict && this.matchKeyword("function")) {
              this.tolerateError(messages_1.Messages.StrictFunction);
            }
            return this.parseStatement();
          };
          Parser2.prototype.parseIfStatement = function() {
            var node = this.createNode();
            var consequent;
            var alternate = null;
            this.expectKeyword("if");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              consequent = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              consequent = this.parseIfClause();
              if (this.matchKeyword("else")) {
                this.nextToken();
                alternate = this.parseIfClause();
              }
            }
            return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
          };
          Parser2.prototype.parseDoWhileStatement = function() {
            var node = this.createNode();
            this.expectKeyword("do");
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            var body = this.parseStatement();
            this.context.inIteration = previousInIteration;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
            } else {
              this.expect(")");
              if (this.match(";")) {
                this.nextToken();
              }
            }
            return this.finalize(node, new Node.DoWhileStatement(body, test));
          };
          Parser2.prototype.parseWhileStatement = function() {
            var node = this.createNode();
            var body;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.parseStatement();
              this.context.inIteration = previousInIteration;
            }
            return this.finalize(node, new Node.WhileStatement(test, body));
          };
          Parser2.prototype.parseForStatement = function() {
            var init = null;
            var test = null;
            var update = null;
            var forIn = true;
            var left, right;
            var node = this.createNode();
            this.expectKeyword("for");
            this.expect("(");
            if (this.match(";")) {
              this.nextToken();
            } else {
              if (this.matchKeyword("var")) {
                init = this.createNode();
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                var declarations = this.parseVariableDeclarationList({ inFor: true });
                this.context.allowIn = previousAllowIn;
                if (declarations.length === 1 && this.matchKeyword("in")) {
                  var decl = declarations[0];
                  if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                    this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                  }
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.expect(";");
                }
              } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                init = this.createNode();
                var kind = this.nextToken().value;
                if (!this.context.strict && this.lookahead.value === "in") {
                  init = this.finalize(init, new Node.Identifier(kind));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else {
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseBindingList(kind, { inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    this.nextToken();
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    this.consumeSemicolon();
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                  }
                }
              } else {
                var initStartToken = this.lookahead;
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                if (this.matchKeyword("in")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else if (this.matchContextualKeyword("of")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  if (this.match(",")) {
                    var initSeq = [init];
                    while (this.match(",")) {
                      this.nextToken();
                      initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                    }
                    init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                  }
                  this.expect(";");
                }
              }
            }
            if (typeof left === "undefined") {
              if (!this.match(";")) {
                test = this.parseExpression();
              }
              this.expect(";");
              if (!this.match(")")) {
                update = this.parseExpression();
              }
            }
            var body;
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.isolateCoverGrammar(this.parseStatement);
              this.context.inIteration = previousInIteration;
            }
            return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
          };
          Parser2.prototype.parseContinueStatement = function() {
            var node = this.createNode();
            this.expectKeyword("continue");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              label = id;
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration) {
              this.throwError(messages_1.Messages.IllegalContinue);
            }
            return this.finalize(node, new Node.ContinueStatement(label));
          };
          Parser2.prototype.parseBreakStatement = function() {
            var node = this.createNode();
            this.expectKeyword("break");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
              label = id;
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration && !this.context.inSwitch) {
              this.throwError(messages_1.Messages.IllegalBreak);
            }
            return this.finalize(node, new Node.BreakStatement(label));
          };
          Parser2.prototype.parseReturnStatement = function() {
            if (!this.context.inFunctionBody) {
              this.tolerateError(messages_1.Messages.IllegalReturn);
            }
            var node = this.createNode();
            this.expectKeyword("return");
            var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
            var argument = hasArgument ? this.parseExpression() : null;
            this.consumeSemicolon();
            return this.finalize(node, new Node.ReturnStatement(argument));
          };
          Parser2.prototype.parseWithStatement = function() {
            if (this.context.strict) {
              this.tolerateError(messages_1.Messages.StrictModeWith);
            }
            var node = this.createNode();
            var body;
            this.expectKeyword("with");
            this.expect("(");
            var object12 = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              body = this.parseStatement();
            }
            return this.finalize(node, new Node.WithStatement(object12, body));
          };
          Parser2.prototype.parseSwitchCase = function() {
            var node = this.createNode();
            var test;
            if (this.matchKeyword("default")) {
              this.nextToken();
              test = null;
            } else {
              this.expectKeyword("case");
              test = this.parseExpression();
            }
            this.expect(":");
            var consequent = [];
            while (true) {
              if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                break;
              }
              consequent.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.SwitchCase(test, consequent));
          };
          Parser2.prototype.parseSwitchStatement = function() {
            var node = this.createNode();
            this.expectKeyword("switch");
            this.expect("(");
            var discriminant = this.parseExpression();
            this.expect(")");
            var previousInSwitch = this.context.inSwitch;
            this.context.inSwitch = true;
            var cases = [];
            var defaultFound = false;
            this.expect("{");
            while (true) {
              if (this.match("}")) {
                break;
              }
              var clause = this.parseSwitchCase();
              if (clause.test === null) {
                if (defaultFound) {
                  this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
              }
              cases.push(clause);
            }
            this.expect("}");
            this.context.inSwitch = previousInSwitch;
            return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
          };
          Parser2.prototype.parseLabelledStatement = function() {
            var node = this.createNode();
            var expr = this.parseExpression();
            var statement;
            if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
              this.nextToken();
              var id = expr;
              var key = "$" + id.name;
              if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
              }
              this.context.labelSet[key] = true;
              var body = undefined;
              if (this.matchKeyword("class")) {
                this.tolerateUnexpectedToken(this.lookahead);
                body = this.parseClassDeclaration();
              } else if (this.matchKeyword("function")) {
                var token = this.lookahead;
                var declaration = this.parseFunctionDeclaration();
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                } else if (declaration.generator) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                }
                body = declaration;
              } else {
                body = this.parseStatement();
              }
              delete this.context.labelSet[key];
              statement = new Node.LabeledStatement(id, body);
            } else {
              this.consumeSemicolon();
              statement = new Node.ExpressionStatement(expr);
            }
            return this.finalize(node, statement);
          };
          Parser2.prototype.parseThrowStatement = function() {
            var node = this.createNode();
            this.expectKeyword("throw");
            if (this.hasLineTerminator) {
              this.throwError(messages_1.Messages.NewlineAfterThrow);
            }
            var argument = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node, new Node.ThrowStatement(argument));
          };
          Parser2.prototype.parseCatchClause = function() {
            var node = this.createNode();
            this.expectKeyword("catch");
            this.expect("(");
            if (this.match(")")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            var params = [];
            var param = this.parsePattern(params);
            var paramMap = {};
            for (var i2 = 0;i2 < params.length; i2++) {
              var key = "$" + params[i2].value;
              if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i2].value);
              }
              paramMap[key] = true;
            }
            if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(param.name)) {
                this.tolerateError(messages_1.Messages.StrictCatchVariable);
              }
            }
            this.expect(")");
            var body = this.parseBlock();
            return this.finalize(node, new Node.CatchClause(param, body));
          };
          Parser2.prototype.parseFinallyClause = function() {
            this.expectKeyword("finally");
            return this.parseBlock();
          };
          Parser2.prototype.parseTryStatement = function() {
            var node = this.createNode();
            this.expectKeyword("try");
            var block = this.parseBlock();
            var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
            var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
            if (!handler && !finalizer) {
              this.throwError(messages_1.Messages.NoCatchOrFinally);
            }
            return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
          };
          Parser2.prototype.parseDebuggerStatement = function() {
            var node = this.createNode();
            this.expectKeyword("debugger");
            this.consumeSemicolon();
            return this.finalize(node, new Node.DebuggerStatement);
          };
          Parser2.prototype.parseStatement = function() {
            var statement;
            switch (this.lookahead.type) {
              case 1:
              case 5:
              case 6:
              case 8:
              case 10:
              case 9:
                statement = this.parseExpressionStatement();
                break;
              case 7:
                var value14 = this.lookahead.value;
                if (value14 === "{") {
                  statement = this.parseBlock();
                } else if (value14 === "(") {
                  statement = this.parseExpressionStatement();
                } else if (value14 === ";") {
                  statement = this.parseEmptyStatement();
                } else {
                  statement = this.parseExpressionStatement();
                }
                break;
              case 3:
                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                break;
              case 4:
                switch (this.lookahead.value) {
                  case "break":
                    statement = this.parseBreakStatement();
                    break;
                  case "continue":
                    statement = this.parseContinueStatement();
                    break;
                  case "debugger":
                    statement = this.parseDebuggerStatement();
                    break;
                  case "do":
                    statement = this.parseDoWhileStatement();
                    break;
                  case "for":
                    statement = this.parseForStatement();
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "if":
                    statement = this.parseIfStatement();
                    break;
                  case "return":
                    statement = this.parseReturnStatement();
                    break;
                  case "switch":
                    statement = this.parseSwitchStatement();
                    break;
                  case "throw":
                    statement = this.parseThrowStatement();
                    break;
                  case "try":
                    statement = this.parseTryStatement();
                    break;
                  case "var":
                    statement = this.parseVariableStatement();
                    break;
                  case "while":
                    statement = this.parseWhileStatement();
                    break;
                  case "with":
                    statement = this.parseWithStatement();
                    break;
                  default:
                    statement = this.parseExpressionStatement();
                    break;
                }
                break;
              default:
                statement = this.throwUnexpectedToken(this.lookahead);
            }
            return statement;
          };
          Parser2.prototype.parseFunctionSourceElements = function() {
            var node = this.createNode();
            this.expect("{");
            var body = this.parseDirectivePrologues();
            var previousLabelSet = this.context.labelSet;
            var previousInIteration = this.context.inIteration;
            var previousInSwitch = this.context.inSwitch;
            var previousInFunctionBody = this.context.inFunctionBody;
            this.context.labelSet = {};
            this.context.inIteration = false;
            this.context.inSwitch = false;
            this.context.inFunctionBody = true;
            while (this.lookahead.type !== 2) {
              if (this.match("}")) {
                break;
              }
              body.push(this.parseStatementListItem());
            }
            this.expect("}");
            this.context.labelSet = previousLabelSet;
            this.context.inIteration = previousInIteration;
            this.context.inSwitch = previousInSwitch;
            this.context.inFunctionBody = previousInFunctionBody;
            return this.finalize(node, new Node.BlockStatement(body));
          };
          Parser2.prototype.validateParam = function(options, param, name) {
            var key = "$" + name;
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(name)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamDupe;
              }
            } else if (!options.firstRestricted) {
              if (this.scanner.isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = messages_1.Messages.StrictParamName;
              } else if (this.scanner.isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = messages_1.Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamDupe;
              }
            }
            if (typeof Object.defineProperty === "function") {
              Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
            } else {
              options.paramSet[key] = true;
            }
          };
          Parser2.prototype.parseRestElement = function(params) {
            var node = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params);
            if (this.match("=")) {
              this.throwError(messages_1.Messages.DefaultRestParameter);
            }
            if (!this.match(")")) {
              this.throwError(messages_1.Messages.ParameterAfterRestParameter);
            }
            return this.finalize(node, new Node.RestElement(arg));
          };
          Parser2.prototype.parseFormalParameter = function(options) {
            var params = [];
            var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
            for (var i2 = 0;i2 < params.length; i2++) {
              this.validateParam(options, params[i2], params[i2].value);
            }
            options.simple = options.simple && param instanceof Node.Identifier;
            options.params.push(param);
          };
          Parser2.prototype.parseFormalParameters = function(firstRestricted) {
            var options;
            options = {
              simple: true,
              params: [],
              firstRestricted
            };
            this.expect("(");
            if (!this.match(")")) {
              options.paramSet = {};
              while (this.lookahead.type !== 2) {
                this.parseFormalParameter(options);
                if (this.match(")")) {
                  break;
                }
                this.expect(",");
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return {
              simple: options.simple,
              params: options.params,
              stricted: options.stricted,
              firstRestricted: options.firstRestricted,
              message: options.message
            };
          };
          Parser2.prototype.matchAsyncFunction = function() {
            var match = this.matchContextualKeyword("async");
            if (match) {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
            }
            return match;
          };
          Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
            var node = this.createNode();
            var isAsync = this.matchContextualKeyword("async");
            if (isAsync) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted = null;
            if (!identifierIsOptional || !this.match("(")) {
              var token = this.lookahead;
              id = this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
          };
          Parser2.prototype.parseFunctionExpression = function() {
            var node = this.createNode();
            var isAsync = this.matchContextualKeyword("async");
            if (isAsync) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted;
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync;
            this.context.allowYield = !isGenerator;
            if (!this.match("(")) {
              var token = this.lookahead;
              id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
          };
          Parser2.prototype.parseDirective = function() {
            var token = this.lookahead;
            var node = this.createNode();
            var expr = this.parseExpression();
            var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
            this.consumeSemicolon();
            return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
          };
          Parser2.prototype.parseDirectivePrologues = function() {
            var firstRestricted = null;
            var body = [];
            while (true) {
              var token = this.lookahead;
              if (token.type !== 8) {
                break;
              }
              var statement = this.parseDirective();
              body.push(statement);
              var directive = statement.directive;
              if (typeof directive !== "string") {
                break;
              }
              if (directive === "use strict") {
                this.context.strict = true;
                if (firstRestricted) {
                  this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                }
                if (!this.context.allowStrictDirective) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                }
              } else {
                if (!firstRestricted && token.octal) {
                  firstRestricted = token;
                }
              }
            }
            return body;
          };
          Parser2.prototype.qualifiedPropertyName = function(token) {
            switch (token.type) {
              case 3:
              case 8:
              case 1:
              case 5:
              case 6:
              case 4:
                return true;
              case 7:
                return token.value === "[";
              default:
                break;
            }
            return false;
          };
          Parser2.prototype.parseGetterMethod = function() {
            var node = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length > 0) {
              this.tolerateError(messages_1.Messages.BadGetterArity);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser2.prototype.parseSetterMethod = function() {
            var node = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length !== 1) {
              this.tolerateError(messages_1.Messages.BadSetterArity);
            } else if (formalParameters.params[0] instanceof Node.RestElement) {
              this.tolerateError(messages_1.Messages.BadSetterRestParameter);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser2.prototype.parseGeneratorMethod = function() {
            var node = this.createNode();
            var isGenerator = true;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            this.context.allowYield = false;
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser2.prototype.isStartOfExpression = function() {
            var start = true;
            var value14 = this.lookahead.value;
            switch (this.lookahead.type) {
              case 7:
                start = value14 === "[" || value14 === "(" || value14 === "{" || value14 === "+" || value14 === "-" || value14 === "!" || value14 === "~" || value14 === "++" || value14 === "--" || value14 === "/" || value14 === "/=";
                break;
              case 4:
                start = value14 === "class" || value14 === "delete" || value14 === "function" || value14 === "let" || value14 === "new" || value14 === "super" || value14 === "this" || value14 === "typeof" || value14 === "void" || value14 === "yield";
                break;
              default:
                break;
            }
            return start;
          };
          Parser2.prototype.parseYieldExpression = function() {
            var node = this.createNode();
            this.expectKeyword("yield");
            var argument = null;
            var delegate = false;
            if (!this.hasLineTerminator) {
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = false;
              delegate = this.match("*");
              if (delegate) {
                this.nextToken();
                argument = this.parseAssignmentExpression();
              } else if (this.isStartOfExpression()) {
                argument = this.parseAssignmentExpression();
              }
              this.context.allowYield = previousAllowYield;
            }
            return this.finalize(node, new Node.YieldExpression(argument, delegate));
          };
          Parser2.prototype.parseClassElement = function(hasConstructor) {
            var token = this.lookahead;
            var node = this.createNode();
            var kind = "";
            var key = null;
            var value14 = null;
            var computed = false;
            var method = false;
            var isStatic = false;
            var isAsync = false;
            if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              var id = key;
              if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                token = this.lookahead;
                isStatic = true;
                computed = this.match("[");
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  key = this.parseObjectPropertyKey();
                }
              }
              if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                var punctuator = this.lookahead.value;
                if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                  isAsync = true;
                  token = this.lookahead;
                  key = this.parseObjectPropertyKey();
                  if (token.type === 3 && token.value === "constructor") {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                  }
                }
              }
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3) {
              if (token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value14 = this.parseGetterMethod();
              } else if (token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value14 = this.parseSetterMethod();
              }
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value14 = this.parseGeneratorMethod();
              method = true;
            }
            if (!kind && key && this.match("(")) {
              kind = "init";
              value14 = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
              method = true;
            }
            if (!kind) {
              this.throwUnexpectedToken(this.lookahead);
            }
            if (kind === "init") {
              kind = "method";
            }
            if (!computed) {
              if (isStatic && this.isPropertyKey(key, "prototype")) {
                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
              }
              if (!isStatic && this.isPropertyKey(key, "constructor")) {
                if (kind !== "method" || !method || value14 && value14.generator) {
                  this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                }
                if (hasConstructor.value) {
                  this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                } else {
                  hasConstructor.value = true;
                }
                kind = "constructor";
              }
            }
            return this.finalize(node, new Node.MethodDefinition(key, computed, value14, kind, isStatic));
          };
          Parser2.prototype.parseClassElementList = function() {
            var body = [];
            var hasConstructor = { value: false };
            this.expect("{");
            while (!this.match("}")) {
              if (this.match(";")) {
                this.nextToken();
              } else {
                body.push(this.parseClassElement(hasConstructor));
              }
            }
            this.expect("}");
            return body;
          };
          Parser2.prototype.parseClassBody = function() {
            var node = this.createNode();
            var elementList = this.parseClassElementList();
            return this.finalize(node, new Node.ClassBody(elementList));
          };
          Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
            var node = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
          };
          Parser2.prototype.parseClassExpression = function() {
            var node = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
          };
          Parser2.prototype.parseModule = function() {
            this.context.strict = true;
            this.context.isModule = true;
            this.scanner.isModule = true;
            var node = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.Module(body));
          };
          Parser2.prototype.parseScript = function() {
            var node = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.Script(body));
          };
          Parser2.prototype.parseModuleSpecifier = function() {
            var node = this.createNode();
            if (this.lookahead.type !== 8) {
              this.throwError(messages_1.Messages.InvalidModuleSpecifier);
            }
            var token = this.nextToken();
            var raw = this.getTokenRaw(token);
            return this.finalize(node, new Node.Literal(token.value, raw));
          };
          Parser2.prototype.parseImportSpecifier = function() {
            var node = this.createNode();
            var imported;
            var local;
            if (this.lookahead.type === 3) {
              imported = this.parseVariableIdentifier();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              }
            } else {
              imported = this.parseIdentifierName();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node, new Node.ImportSpecifier(local, imported));
          };
          Parser2.prototype.parseNamedImports = function() {
            this.expect("{");
            var specifiers = [];
            while (!this.match("}")) {
              specifiers.push(this.parseImportSpecifier());
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return specifiers;
          };
          Parser2.prototype.parseImportDefaultSpecifier = function() {
            var node = this.createNode();
            var local = this.parseIdentifierName();
            return this.finalize(node, new Node.ImportDefaultSpecifier(local));
          };
          Parser2.prototype.parseImportNamespaceSpecifier = function() {
            var node = this.createNode();
            this.expect("*");
            if (!this.matchContextualKeyword("as")) {
              this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
            }
            this.nextToken();
            var local = this.parseIdentifierName();
            return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
          };
          Parser2.prototype.parseImportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalImportDeclaration);
            }
            var node = this.createNode();
            this.expectKeyword("import");
            var src;
            var specifiers = [];
            if (this.lookahead.type === 8) {
              src = this.parseModuleSpecifier();
            } else {
              if (this.match("{")) {
                specifiers = specifiers.concat(this.parseNamedImports());
              } else if (this.match("*")) {
                specifiers.push(this.parseImportNamespaceSpecifier());
              } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                specifiers.push(this.parseImportDefaultSpecifier());
                if (this.match(",")) {
                  this.nextToken();
                  if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              src = this.parseModuleSpecifier();
            }
            this.consumeSemicolon();
            return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
          };
          Parser2.prototype.parseExportSpecifier = function() {
            var node = this.createNode();
            var local = this.parseIdentifierName();
            var exported = local;
            if (this.matchContextualKeyword("as")) {
              this.nextToken();
              exported = this.parseIdentifierName();
            }
            return this.finalize(node, new Node.ExportSpecifier(local, exported));
          };
          Parser2.prototype.parseExportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalExportDeclaration);
            }
            var node = this.createNode();
            this.expectKeyword("export");
            var exportDeclaration;
            if (this.matchKeyword("default")) {
              this.nextToken();
              if (this.matchKeyword("function")) {
                var declaration = this.parseFunctionDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchKeyword("class")) {
                var declaration = this.parseClassDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchContextualKeyword("async")) {
                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else {
                if (this.matchContextualKeyword("from")) {
                  this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                }
                var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              }
            } else if (this.match("*")) {
              this.nextToken();
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              var src = this.parseModuleSpecifier();
              this.consumeSemicolon();
              exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
            } else if (this.lookahead.type === 4) {
              var declaration = undefined;
              switch (this.lookahead.value) {
                case "let":
                case "const":
                  declaration = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "var":
                case "class":
                case "function":
                  declaration = this.parseStatementListItem();
                  break;
                default:
                  this.throwUnexpectedToken(this.lookahead);
              }
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
            } else if (this.matchAsyncFunction()) {
              var declaration = this.parseFunctionDeclaration();
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
            } else {
              var specifiers = [];
              var source = null;
              var isExportFromIdentifier = false;
              this.expect("{");
              while (!this.match("}")) {
                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                specifiers.push(this.parseExportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              if (this.matchContextualKeyword("from")) {
                this.nextToken();
                source = this.parseModuleSpecifier();
                this.consumeSemicolon();
              } else if (isExportFromIdentifier) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              } else {
                this.consumeSemicolon();
              }
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
            }
            return exportDeclaration;
          };
          return Parser2;
        }();
        exports2.Parser = Parser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function assert(condition, message) {
          if (!condition) {
            throw new Error("ASSERT: " + message);
          }
        }
        exports2.assert = assert;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var ErrorHandler = function() {
          function ErrorHandler2() {
            this.errors = [];
            this.tolerant = false;
          }
          ErrorHandler2.prototype.recordError = function(error21) {
            this.errors.push(error21);
          };
          ErrorHandler2.prototype.tolerate = function(error21) {
            if (this.tolerant) {
              this.recordError(error21);
            } else {
              throw error21;
            }
          };
          ErrorHandler2.prototype.constructError = function(msg, column) {
            var error21 = new Error(msg);
            try {
              throw error21;
            } catch (base) {
              if (Object.create && Object.defineProperty) {
                error21 = Object.create(base);
                Object.defineProperty(error21, "column", { value: column });
              }
            }
            return error21;
          };
          ErrorHandler2.prototype.createError = function(index, line, col, description) {
            var msg = "Line " + line + ": " + description;
            var error21 = this.constructError(msg, col);
            error21.index = index;
            error21.lineNumber = line;
            error21.description = description;
            return error21;
          };
          ErrorHandler2.prototype.throwError = function(index, line, col, description) {
            throw this.createError(index, line, col, description);
          };
          ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
            var error21 = this.createError(index, line, col, description);
            if (this.tolerant) {
              this.recordError(error21);
            } else {
              throw error21;
            }
          };
          return ErrorHandler2;
        }();
        exports2.ErrorHandler = ErrorHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Messages = {
          BadGetterArity: "Getter must not have any formal parameters",
          BadSetterArity: "Setter must have exactly one formal parameter",
          BadSetterRestParameter: "Setter function argument must not be a rest parameter",
          ConstructorIsAsync: "Class constructor may not be an async method",
          ConstructorSpecialMethod: "Class constructor may not be an accessor",
          DeclarationMissingInitializer: "Missing initializer in %0 declaration",
          DefaultRestParameter: "Unexpected token =",
          DuplicateBinding: "Duplicate binding %0",
          DuplicateConstructor: "A class may only have one constructor",
          DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
          ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
          GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
          IllegalBreak: "Illegal break statement",
          IllegalContinue: "Illegal continue statement",
          IllegalExportDeclaration: "Unexpected token",
          IllegalImportDeclaration: "Unexpected token",
          IllegalLanguageModeDirective: "Illegal \'use strict\' directive in function with non-simple parameter list",
          IllegalReturn: "Illegal return statement",
          InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
          InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
          InvalidModuleSpecifier: "Unexpected token",
          InvalidRegExp: "Invalid regular expression",
          LetInLexicalBinding: "let is disallowed as a lexically bound name",
          MissingFromClause: "Unexpected token",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NewlineAfterThrow: "Illegal newline after throw",
          NoAsAfterImportNamespace: "Unexpected token",
          NoCatchOrFinally: "Missing catch or finally after try",
          ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
          Redeclaration: "%0 \'%1\' has already been declared",
          StaticPrototype: "Classes may not have static property named prototype",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
          UnexpectedEOS: "Unexpected end of input",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedNumber: "Unexpected number",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedString: "Unexpected string",
          UnexpectedTemplate: "Unexpected quasi %0",
          UnexpectedToken: "Unexpected token %0",
          UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
          UnknownLabel: "Undefined label \'%0\'",
          UnterminatedRegExp: "Invalid regular expression: missing /"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var character_1 = __webpack_require__(4);
        var messages_1 = __webpack_require__(11);
        function hexValue(ch) {
          return "0123456789abcdef".indexOf(ch.toLowerCase());
        }
        function octalValue(ch) {
          return "01234567".indexOf(ch);
        }
        var Scanner = function() {
          function Scanner2(code, handler) {
            this.source = code;
            this.errorHandler = handler;
            this.trackComment = false;
            this.isModule = false;
            this.length = code.length;
            this.index = 0;
            this.lineNumber = code.length > 0 ? 1 : 0;
            this.lineStart = 0;
            this.curlyStack = [];
          }
          Scanner2.prototype.saveState = function() {
            return {
              index: this.index,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart
            };
          };
          Scanner2.prototype.restoreState = function(state) {
            this.index = state.index;
            this.lineNumber = state.lineNumber;
            this.lineStart = state.lineStart;
          };
          Scanner2.prototype.eof = function() {
            return this.index >= this.length;
          };
          Scanner2.prototype.throwUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.tolerateUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.skipSingleLineComment = function(offset) {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - offset;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - offset
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              ++this.index;
              if (character_1.Character.isLineTerminator(ch)) {
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 1
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index - 1],
                    range: [start, this.index - 1],
                    loc
                  };
                  comments.push(entry);
                }
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                return comments;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: false,
                slice: [start + offset, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            return comments;
          };
          Scanner2.prototype.skipMultiLineComment = function() {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - 2;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 2
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isLineTerminator(ch)) {
                if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                ++this.index;
                this.lineStart = this.index;
              } else if (ch === 42) {
                if (this.source.charCodeAt(this.index + 1) === 47) {
                  this.index += 2;
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart
                    };
                    var entry = {
                      multiLine: true,
                      slice: [start + 2, this.index - 2],
                      range: [start, this.index],
                      loc
                    };
                    comments.push(entry);
                  }
                  return comments;
                }
                ++this.index;
              } else {
                ++this.index;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: true,
                slice: [start + 2, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            this.tolerateUnexpectedToken();
            return comments;
          };
          Scanner2.prototype.scanComments = function() {
            var comments;
            if (this.trackComment) {
              comments = [];
            }
            var start = this.index === 0;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isWhiteSpace(ch)) {
                ++this.index;
              } else if (character_1.Character.isLineTerminator(ch)) {
                ++this.index;
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                start = true;
              } else if (ch === 47) {
                ch = this.source.charCodeAt(this.index + 1);
                if (ch === 47) {
                  this.index += 2;
                  var comment = this.skipSingleLineComment(2);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                  start = true;
                } else if (ch === 42) {
                  this.index += 2;
                  var comment = this.skipMultiLineComment();
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (start && ch === 45) {
                if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                  this.index += 3;
                  var comment = this.skipSingleLineComment(3);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (ch === 60 && !this.isModule) {
                if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                  this.index += 4;
                  var comment = this.skipSingleLineComment(4);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return comments;
          };
          Scanner2.prototype.isFutureReservedWord = function(id) {
            switch (id) {
              case "enum":
              case "export":
              case "import":
              case "super":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isStrictModeReservedWord = function(id) {
            switch (id) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isRestrictedWord = function(id) {
            return id === "eval" || id === "arguments";
          };
          Scanner2.prototype.isKeyword = function(id) {
            switch (id.length) {
              case 2:
                return id === "if" || id === "in" || id === "do";
              case 3:
                return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
              case 4:
                return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
              case 5:
                return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
              case 6:
                return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
              case 7:
                return id === "default" || id === "finally" || id === "extends";
              case 8:
                return id === "function" || id === "continue" || id === "debugger";
              case 10:
                return id === "instanceof";
              default:
                return false;
            }
          };
          Scanner2.prototype.codePointAt = function(i2) {
            var cp = this.source.charCodeAt(i2);
            if (cp >= 55296 && cp <= 56319) {
              var second = this.source.charCodeAt(i2 + 1);
              if (second >= 56320 && second <= 57343) {
                var first = cp;
                cp = (first - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return cp;
          };
          Scanner2.prototype.scanHexEscape = function(prefix) {
            var len = prefix === "u" ? 4 : 2;
            var code = 0;
            for (var i2 = 0;i2 < len; ++i2) {
              if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                code = code * 16 + hexValue(this.source[this.index++]);
              } else {
                return null;
              }
            }
            return String.fromCharCode(code);
          };
          Scanner2.prototype.scanUnicodeCodePointEscape = function() {
            var ch = this.source[this.index];
            var code = 0;
            if (ch === "}") {
              this.throwUnexpectedToken();
            }
            while (!this.eof()) {
              ch = this.source[this.index++];
              if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                break;
              }
              code = code * 16 + hexValue(ch);
            }
            if (code > 1114111 || ch !== "}") {
              this.throwUnexpectedToken();
            }
            return character_1.Character.fromCodePoint(code);
          };
          Scanner2.prototype.getIdentifier = function() {
            var start = this.index++;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (ch === 92) {
                this.index = start;
                return this.getComplexIdentifier();
              } else if (ch >= 55296 && ch < 57343) {
                this.index = start;
                return this.getComplexIdentifier();
              }
              if (character_1.Character.isIdentifierPart(ch)) {
                ++this.index;
              } else {
                break;
              }
            }
            return this.source.slice(start, this.index);
          };
          Scanner2.prototype.getComplexIdentifier = function() {
            var cp = this.codePointAt(this.index);
            var id = character_1.Character.fromCodePoint(cp);
            this.index += id.length;
            var ch;
            if (cp === 92) {
              if (this.source.charCodeAt(this.index) !== 117) {
                this.throwUnexpectedToken();
              }
              ++this.index;
              if (this.source[this.index] === "{") {
                ++this.index;
                ch = this.scanUnicodeCodePointEscape();
              } else {
                ch = this.scanHexEscape("u");
                if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken();
                }
              }
              id = ch;
            }
            while (!this.eof()) {
              cp = this.codePointAt(this.index);
              if (!character_1.Character.isIdentifierPart(cp)) {
                break;
              }
              ch = character_1.Character.fromCodePoint(cp);
              id += ch;
              this.index += ch.length;
              if (cp === 92) {
                id = id.substr(0, id.length - 1);
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id += ch;
              }
            }
            return id;
          };
          Scanner2.prototype.octalToDecimal = function(ch) {
            var octal = ch !== "0";
            var code = octalValue(ch);
            if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              octal = true;
              code = code * 8 + octalValue(this.source[this.index++]);
              if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                code = code * 8 + octalValue(this.source[this.index++]);
              }
            }
            return {
              code,
              octal
            };
          };
          Scanner2.prototype.scanIdentifier = function() {
            var type73;
            var start = this.index;
            var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
            if (id.length === 1) {
              type73 = 3;
            } else if (this.isKeyword(id)) {
              type73 = 4;
            } else if (id === "null") {
              type73 = 5;
            } else if (id === "true" || id === "false") {
              type73 = 1;
            } else {
              type73 = 3;
            }
            if (type73 !== 3 && start + id.length !== this.index) {
              var restore = this.index;
              this.index = start;
              this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
              this.index = restore;
            }
            return {
              type: type73,
              value: id,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanPunctuator = function() {
            var start = this.index;
            var str = this.source[this.index];
            switch (str) {
              case "(":
              case "{":
                if (str === "{") {
                  this.curlyStack.push("{");
                }
                ++this.index;
                break;
              case ".":
                ++this.index;
                if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                  this.index += 2;
                  str = "...";
                }
                break;
              case "}":
                ++this.index;
                this.curlyStack.pop();
                break;
              case ")":
              case ";":
              case ",":
              case "[":
              case "]":
              case ":":
              case "?":
              case "~":
                ++this.index;
                break;
              default:
                str = this.source.substr(this.index, 4);
                if (str === ">>>=") {
                  this.index += 4;
                } else {
                  str = str.substr(0, 3);
                  if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                    this.index += 3;
                  } else {
                    str = str.substr(0, 2);
                    if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                      this.index += 2;
                    } else {
                      str = this.source[this.index];
                      if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                        ++this.index;
                      }
                    }
                  }
                }
            }
            if (this.index === start) {
              this.throwUnexpectedToken();
            }
            return {
              type: 7,
              value: str,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanHexLiteral = function(start) {
            var num = "";
            while (!this.eof()) {
              if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt("0x" + num, 16),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanBinaryLiteral = function(start) {
            var num = "";
            var ch;
            while (!this.eof()) {
              ch = this.source[this.index];
              if (ch !== "0" && ch !== "1") {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (!this.eof()) {
              ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                this.throwUnexpectedToken();
              }
            }
            return {
              type: 6,
              value: parseInt(num, 2),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
            var num = "";
            var octal = false;
            if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
              octal = true;
              num = "0" + this.source[this.index++];
            } else {
              ++this.index;
            }
            while (!this.eof()) {
              if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (!octal && num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt(num, 8),
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.isImplicitOctalLiteral = function() {
            for (var i2 = this.index + 1;i2 < this.length; ++i2) {
              var ch = this.source[i2];
              if (ch === "8" || ch === "9") {
                return false;
              }
              if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                return true;
              }
            }
            return true;
          };
          Scanner2.prototype.scanNumericLiteral = function() {
            var start = this.index;
            var ch = this.source[start];
            assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
            var num = "";
            if (ch !== ".") {
              num = this.source[this.index++];
              ch = this.source[this.index];
              if (num === "0") {
                if (ch === "x" || ch === "X") {
                  ++this.index;
                  return this.scanHexLiteral(start);
                }
                if (ch === "b" || ch === "B") {
                  ++this.index;
                  return this.scanBinaryLiteral(start);
                }
                if (ch === "o" || ch === "O") {
                  return this.scanOctalLiteral(ch, start);
                }
                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  if (this.isImplicitOctalLiteral()) {
                    return this.scanOctalLiteral(ch, start);
                  }
                }
              }
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === ".") {
              num += this.source[this.index++];
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === "e" || ch === "E") {
              num += this.source[this.index++];
              ch = this.source[this.index];
              if (ch === "+" || ch === "-") {
                num += this.source[this.index++];
              }
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
              } else {
                this.throwUnexpectedToken();
              }
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseFloat(num),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanStringLiteral = function() {
            var start = this.index;
            var quote = this.source[start];
            assert_1.assert(quote === "\'" || quote === '"', "String literal must starts with a quote");
            ++this.index;
            var octal = false;
            var str = "";
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === quote) {
                quote = "";
                break;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        str += this.scanUnicodeCodePointEscape();
                      } else {
                        var unescaped_1 = this.scanHexEscape(ch);
                        if (unescaped_1 === null) {
                          this.throwUnexpectedToken();
                        }
                        str += unescaped_1;
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      str += unescaped;
                      break;
                    case "n":
                      str += "\n";
                      break;
                    case "r":
                      str += "\r";
                      break;
                    case "t":
                      str += "\t";
                      break;
                    case "b":
                      str += "\b";
                      break;
                    case "f":
                      str += "\f";
                      break;
                    case "v":
                      str += "\v";
                      break;
                    case "8":
                    case "9":
                      str += ch;
                      this.tolerateUnexpectedToken();
                      break;
                    default:
                      if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        var octToDec = this.octalToDecimal(ch);
                        octal = octToDec.octal || octal;
                        str += String.fromCharCode(octToDec.code);
                      } else {
                        str += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                break;
              } else {
                str += ch;
              }
            }
            if (quote !== "") {
              this.index = start;
              this.throwUnexpectedToken();
            }
            return {
              type: 8,
              value: str,
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanTemplate = function() {
            var cooked = "";
            var terminated = false;
            var start = this.index;
            var head = this.source[start] === "`";
            var tail = false;
            var rawOffset = 2;
            ++this.index;
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === "`") {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
              } else if (ch === "$") {
                if (this.source[this.index] === "{") {
                  this.curlyStack.push("${");
                  ++this.index;
                  terminated = true;
                  break;
                }
                cooked += ch;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "n":
                      cooked += "\n";
                      break;
                    case "r":
                      cooked += "\r";
                      break;
                    case "t":
                      cooked += "\t";
                      break;
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        cooked += this.scanUnicodeCodePointEscape();
                      } else {
                        var restore = this.index;
                        var unescaped_2 = this.scanHexEscape(ch);
                        if (unescaped_2 !== null) {
                          cooked += unescaped_2;
                        } else {
                          this.index = restore;
                          cooked += ch;
                        }
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      cooked += unescaped;
                      break;
                    case "b":
                      cooked += "\b";
                      break;
                    case "f":
                      cooked += "\f";
                      break;
                    case "v":
                      cooked += "\v";
                      break;
                    default:
                      if (ch === "0") {
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        }
                        cooked += "\0";
                      } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                      } else {
                        cooked += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.lineNumber;
                if (ch === "\r" && this.source[this.index] === "\n") {
                  ++this.index;
                }
                this.lineStart = this.index;
                cooked += "\n";
              } else {
                cooked += ch;
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken();
            }
            if (!head) {
              this.curlyStack.pop();
            }
            return {
              type: 10,
              value: this.source.slice(start + 1, this.index - rawOffset),
              cooked,
              head,
              tail,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.testRegExp = function(pattern3, flags) {
            var astralSubstitute = "\uFFFF";
            var tmp = pattern3;
            var self2 = this;
            if (flags.indexOf("u") >= 0) {
              tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($02, $12, $2) {
                var codePoint = parseInt($12 || $2, 16);
                if (codePoint > 1114111) {
                  self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                if (codePoint <= 65535) {
                  return String.fromCharCode(codePoint);
                }
                return astralSubstitute;
              }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
            }
            try {
              RegExp(tmp);
            } catch (e2) {
              this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
            }
            try {
              return new RegExp(pattern3, flags);
            } catch (exception) {
              return null;
            }
          };
          Scanner2.prototype.scanRegExpBody = function() {
            var ch = this.source[this.index];
            assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
            var str = this.source[this.index++];
            var classMarker = false;
            var terminated = false;
            while (!this.eof()) {
              ch = this.source[this.index++];
              str += ch;
              if (ch === "\\") {
                ch = this.source[this.index++];
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                str += ch;
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              } else if (classMarker) {
                if (ch === "]") {
                  classMarker = false;
                }
              } else {
                if (ch === "/") {
                  terminated = true;
                  break;
                } else if (ch === "[") {
                  classMarker = true;
                }
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
            }
            return str.substr(1, str.length - 2);
          };
          Scanner2.prototype.scanRegExpFlags = function() {
            var str = "";
            var flags = "";
            while (!this.eof()) {
              var ch = this.source[this.index];
              if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                break;
              }
              ++this.index;
              if (ch === "\\" && !this.eof()) {
                ch = this.source[this.index];
                if (ch === "u") {
                  ++this.index;
                  var restore = this.index;
                  var char = this.scanHexEscape("u");
                  if (char !== null) {
                    flags += char;
                    for (str += "\\u";restore < this.index; ++restore) {
                      str += this.source[restore];
                    }
                  } else {
                    this.index = restore;
                    flags += "u";
                    str += "\\u";
                  }
                  this.tolerateUnexpectedToken();
                } else {
                  str += "\\";
                  this.tolerateUnexpectedToken();
                }
              } else {
                flags += ch;
                str += ch;
              }
            }
            return flags;
          };
          Scanner2.prototype.scanRegExp = function() {
            var start = this.index;
            var pattern3 = this.scanRegExpBody();
            var flags = this.scanRegExpFlags();
            var value14 = this.testRegExp(pattern3, flags);
            return {
              type: 9,
              value: "",
              pattern: pattern3,
              flags,
              regex: value14,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.lex = function() {
            if (this.eof()) {
              return {
                type: 2,
                value: "",
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: this.index,
                end: this.index
              };
            }
            var cp = this.source.charCodeAt(this.index);
            if (character_1.Character.isIdentifierStart(cp)) {
              return this.scanIdentifier();
            }
            if (cp === 40 || cp === 41 || cp === 59) {
              return this.scanPunctuator();
            }
            if (cp === 39 || cp === 34) {
              return this.scanStringLiteral();
            }
            if (cp === 46) {
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                return this.scanNumericLiteral();
              }
              return this.scanPunctuator();
            }
            if (character_1.Character.isDecimalDigit(cp)) {
              return this.scanNumericLiteral();
            }
            if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
              return this.scanTemplate();
            }
            if (cp >= 55296 && cp < 57343) {
              if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                return this.scanIdentifier();
              }
            }
            return this.scanPunctuator();
          };
          return Scanner2;
        }();
        exports2.Scanner = Scanner;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TokenName = {};
        exports2.TokenName[1] = "Boolean";
        exports2.TokenName[2] = "<end>";
        exports2.TokenName[3] = "Identifier";
        exports2.TokenName[4] = "Keyword";
        exports2.TokenName[5] = "Null";
        exports2.TokenName[6] = "Numeric";
        exports2.TokenName[7] = "Punctuator";
        exports2.TokenName[8] = "String";
        exports2.TokenName[9] = "RegularExpression";
        exports2.TokenName[10] = "Template";
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.XHTMLEntities = {
          quot: '"',
          amp: "&",
          apos: "'",
          gt: ">",
          nbsp: "\xA0",
          iexcl: "\xA1",
          cent: "\xA2",
          pound: "\xA3",
          curren: "\xA4",
          yen: "\xA5",
          brvbar: "\xA6",
          sect: "\xA7",
          uml: "\xA8",
          copy: "\xA9",
          ordf: "\xAA",
          laquo: "\xAB",
          not: "\xAC",
          shy: "\xAD",
          reg: "\xAE",
          macr: "\xAF",
          deg: "\xB0",
          plusmn: "\xB1",
          sup2: "\xB2",
          sup3: "\xB3",
          acute: "\xB4",
          micro: "\xB5",
          para: "\xB6",
          middot: "\xB7",
          cedil: "\xB8",
          sup1: "\xB9",
          ordm: "\xBA",
          raquo: "\xBB",
          frac14: "\xBC",
          frac12: "\xBD",
          frac34: "\xBE",
          iquest: "\xBF",
          Agrave: "\xC0",
          Aacute: "\xC1",
          Acirc: "\xC2",
          Atilde: "\xC3",
          Auml: "\xC4",
          Aring: "\xC5",
          AElig: "\xC6",
          Ccedil: "\xC7",
          Egrave: "\xC8",
          Eacute: "\xC9",
          Ecirc: "\xCA",
          Euml: "\xCB",
          Igrave: "\xCC",
          Iacute: "\xCD",
          Icirc: "\xCE",
          Iuml: "\xCF",
          ETH: "\xD0",
          Ntilde: "\xD1",
          Ograve: "\xD2",
          Oacute: "\xD3",
          Ocirc: "\xD4",
          Otilde: "\xD5",
          Ouml: "\xD6",
          times: "\xD7",
          Oslash: "\xD8",
          Ugrave: "\xD9",
          Uacute: "\xDA",
          Ucirc: "\xDB",
          Uuml: "\xDC",
          Yacute: "\xDD",
          THORN: "\xDE",
          szlig: "\xDF",
          agrave: "\xE0",
          aacute: "\xE1",
          acirc: "\xE2",
          atilde: "\xE3",
          auml: "\xE4",
          aring: "\xE5",
          aelig: "\xE6",
          ccedil: "\xE7",
          egrave: "\xE8",
          eacute: "\xE9",
          ecirc: "\xEA",
          euml: "\xEB",
          igrave: "\xEC",
          iacute: "\xED",
          icirc: "\xEE",
          iuml: "\xEF",
          eth: "\xF0",
          ntilde: "\xF1",
          ograve: "\xF2",
          oacute: "\xF3",
          ocirc: "\xF4",
          otilde: "\xF5",
          ouml: "\xF6",
          divide: "\xF7",
          oslash: "\xF8",
          ugrave: "\xF9",
          uacute: "\xFA",
          ucirc: "\xFB",
          uuml: "\xFC",
          yacute: "\xFD",
          thorn: "\xFE",
          yuml: "\xFF",
          OElig: "\u0152",
          oelig: "\u0153",
          Scaron: "\u0160",
          scaron: "\u0161",
          Yuml: "\u0178",
          fnof: "\u0192",
          circ: "\u02C6",
          tilde: "\u02DC",
          Alpha: "\u0391",
          Beta: "\u0392",
          Gamma: "\u0393",
          Delta: "\u0394",
          Epsilon: "\u0395",
          Zeta: "\u0396",
          Eta: "\u0397",
          Theta: "\u0398",
          Iota: "\u0399",
          Kappa: "\u039A",
          Lambda: "\u039B",
          Mu: "\u039C",
          Nu: "\u039D",
          Xi: "\u039E",
          Omicron: "\u039F",
          Pi: "\u03A0",
          Rho: "\u03A1",
          Sigma: "\u03A3",
          Tau: "\u03A4",
          Upsilon: "\u03A5",
          Phi: "\u03A6",
          Chi: "\u03A7",
          Psi: "\u03A8",
          Omega: "\u03A9",
          alpha: "\u03B1",
          beta: "\u03B2",
          gamma: "\u03B3",
          delta: "\u03B4",
          epsilon: "\u03B5",
          zeta: "\u03B6",
          eta: "\u03B7",
          theta: "\u03B8",
          iota: "\u03B9",
          kappa: "\u03BA",
          lambda: "\u03BB",
          mu: "\u03BC",
          nu: "\u03BD",
          xi: "\u03BE",
          omicron: "\u03BF",
          pi: "\u03C0",
          rho: "\u03C1",
          sigmaf: "\u03C2",
          sigma: "\u03C3",
          tau: "\u03C4",
          upsilon: "\u03C5",
          phi: "\u03C6",
          chi: "\u03C7",
          psi: "\u03C8",
          omega: "\u03C9",
          thetasym: "\u03D1",
          upsih: "\u03D2",
          piv: "\u03D6",
          ensp: "\u2002",
          emsp: "\u2003",
          thinsp: "\u2009",
          zwnj: "\u200C",
          zwj: "\u200D",
          lrm: "\u200E",
          rlm: "\u200F",
          ndash: "\u2013",
          mdash: "\u2014",
          lsquo: "\u2018",
          rsquo: "\u2019",
          sbquo: "\u201A",
          ldquo: "\u201C",
          rdquo: "\u201D",
          bdquo: "\u201E",
          dagger: "\u2020",
          Dagger: "\u2021",
          bull: "\u2022",
          hellip: "\u2026",
          permil: "\u2030",
          prime: "\u2032",
          Prime: "\u2033",
          lsaquo: "\u2039",
          rsaquo: "\u203A",
          oline: "\u203E",
          frasl: "\u2044",
          euro: "\u20AC",
          image: "\u2111",
          weierp: "\u2118",
          real: "\u211C",
          trade: "\u2122",
          alefsym: "\u2135",
          larr: "\u2190",
          uarr: "\u2191",
          rarr: "\u2192",
          darr: "\u2193",
          harr: "\u2194",
          crarr: "\u21B5",
          lArr: "\u21D0",
          uArr: "\u21D1",
          rArr: "\u21D2",
          dArr: "\u21D3",
          hArr: "\u21D4",
          forall: "\u2200",
          part: "\u2202",
          exist: "\u2203",
          empty: "\u2205",
          nabla: "\u2207",
          isin: "\u2208",
          notin: "\u2209",
          ni: "\u220B",
          prod: "\u220F",
          sum: "\u2211",
          minus: "\u2212",
          lowast: "\u2217",
          radic: "\u221A",
          prop: "\u221D",
          infin: "\u221E",
          ang: "\u2220",
          and: "\u2227",
          or: "\u2228",
          cap: "\u2229",
          cup: "\u222A",
          int: "\u222B",
          there4: "\u2234",
          sim: "\u223C",
          cong: "\u2245",
          asymp: "\u2248",
          ne: "\u2260",
          equiv: "\u2261",
          le: "\u2264",
          ge: "\u2265",
          sub: "\u2282",
          sup: "\u2283",
          nsub: "\u2284",
          sube: "\u2286",
          supe: "\u2287",
          oplus: "\u2295",
          otimes: "\u2297",
          perp: "\u22A5",
          sdot: "\u22C5",
          lceil: "\u2308",
          rceil: "\u2309",
          lfloor: "\u230A",
          rfloor: "\u230B",
          loz: "\u25CA",
          spades: "\u2660",
          clubs: "\u2663",
          hearts: "\u2665",
          diams: "\u2666",
          lang: "\u27E8",
          rang: "\u27E9"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var error_handler_1 = __webpack_require__(10);
        var scanner_1 = __webpack_require__(12);
        var token_1 = __webpack_require__(13);
        var Reader = function() {
          function Reader2() {
            this.values = [];
            this.curly = this.paren = -1;
          }
          Reader2.prototype.beforeFunctionExpression = function(t2) {
            return [
              "(",
              "{",
              "[",
              "in",
              "typeof",
              "instanceof",
              "new",
              "return",
              "case",
              "delete",
              "throw",
              "void",
              "=",
              "+=",
              "-=",
              "*=",
              "**=",
              "/=",
              "%=",
              "<<=",
              ">>=",
              ">>>=",
              "&=",
              "|=",
              "^=",
              ",",
              "+",
              "-",
              "*",
              "**",
              "/",
              "%",
              "++",
              "--",
              "<<",
              ">>",
              ">>>",
              "&",
              "|",
              "^",
              "!",
              "~",
              "&&",
              "||",
              "?",
              ":",
              "===",
              "==",
              ">=",
              "<=",
              "<",
              ">",
              "!=",
              "!=="
            ].indexOf(t2) >= 0;
          };
          Reader2.prototype.isRegexStart = function() {
            var previous = this.values[this.values.length - 1];
            var regex = previous !== null;
            switch (previous) {
              case "this":
              case "]":
                regex = false;
                break;
              case ")":
                var keyword = this.values[this.paren - 1];
                regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                break;
              case "}":
                regex = false;
                if (this.values[this.curly - 3] === "function") {
                  var check10 = this.values[this.curly - 4];
                  regex = check10 ? !this.beforeFunctionExpression(check10) : false;
                } else if (this.values[this.curly - 4] === "function") {
                  var check10 = this.values[this.curly - 5];
                  regex = check10 ? !this.beforeFunctionExpression(check10) : true;
                }
                break;
              default:
                break;
            }
            return regex;
          };
          Reader2.prototype.push = function(token) {
            if (token.type === 7 || token.type === 4) {
              if (token.value === "{") {
                this.curly = this.values.length;
              } else if (token.value === "(") {
                this.paren = this.values.length;
              }
              this.values.push(token.value);
            } else {
              this.values.push(null);
            }
          };
          return Reader2;
        }();
        var Tokenizer = function() {
          function Tokenizer2(code, config) {
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
            this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
            this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
            this.buffer = [];
            this.reader = new Reader;
          }
          Tokenizer2.prototype.errors = function() {
            return this.errorHandler.errors;
          };
          Tokenizer2.prototype.getNextToken = function() {
            if (this.buffer.length === 0) {
              var comments = this.scanner.scanComments();
              if (this.scanner.trackComment) {
                for (var i2 = 0;i2 < comments.length; ++i2) {
                  var e2 = comments[i2];
                  var value14 = this.scanner.source.slice(e2.slice[0], e2.slice[1]);
                  var comment = {
                    type: e2.multiLine ? "BlockComment" : "LineComment",
                    value: value14
                  };
                  if (this.trackRange) {
                    comment.range = e2.range;
                  }
                  if (this.trackLoc) {
                    comment.loc = e2.loc;
                  }
                  this.buffer.push(comment);
                }
              }
              if (!this.scanner.eof()) {
                var loc = undefined;
                if (this.trackLoc) {
                  loc = {
                    start: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    },
                    end: {}
                  };
                }
                var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                this.reader.push(token);
                var entry = {
                  type: token_1.TokenName[token.type],
                  value: this.scanner.source.slice(token.start, token.end)
                };
                if (this.trackRange) {
                  entry.range = [token.start, token.end];
                }
                if (this.trackLoc) {
                  loc.end = {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  };
                  entry.loc = loc;
                }
                if (token.type === 9) {
                  var pattern3 = token.pattern;
                  var flags = token.flags;
                  entry.regex = { pattern: pattern3, flags };
                }
                this.buffer.push(entry);
              }
            }
            return this.buffer.shift();
          };
          return Tokenizer2;
        }();
        exports2.Tokenizer = Tokenizer;
      }
    ]);
  });
});

// node_modules/@mikro-orm/core/utils/RawQueryFragment.js
var require_RawQueryFragment = __commonJS((exports) => {
  var raw = function(sql2, params) {
    if (sql2 instanceof RawQueryFragment) {
      return sql2;
    }
    if (sql2 instanceof Function) {
      sql2 = sql2(exports.ALIAS_REPLACEMENT);
    }
    if (sql2 === "??" && Array.isArray(params)) {
      return new RawQueryFragment(sql2, params);
    }
    if (Array.isArray(sql2)) {
      return Utils_1.Utils.getPrimaryKeyHash(sql2);
    }
    if (typeof params === "object" && !Array.isArray(params)) {
      const pairs = Object.entries(params);
      params = [];
      for (const [key, value14] of pairs) {
        sql2 = sql2.replace(":" + key, "?");
        params.push(value14);
      }
    }
    return new RawQueryFragment(sql2, params);
  };
  var sql = function(sql2, ...values) {
    return raw(sql2.reduce((query, queryPart, i2) => {
      const valueExists = i2 < values.length;
      const text = query + queryPart;
      return valueExists ? text + "?" : text;
    }, ""), values);
  };
  var createSqlFunction = function(func, key) {
    if (typeof key === "string") {
      return raw(`${func}(${key})`);
    }
    return raw((a2) => `${func}(${key(a2)})`);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createSqlFunction = exports.sql = exports.raw = exports.ALIAS_REPLACEMENT_RE = exports.ALIAS_REPLACEMENT = exports.RawQueryFragment = undefined;
  var util_1 = import.meta.require("util");
  var Utils_1 = require_Utils();

  class RawQueryFragment {
    sql;
    params;
    static #rawQueryCache = new Map;
    static #index = 0;
    static cloneRegistry;
    #assigned = false;
    #used = 0;
    #key;
    constructor(sql2, params = []) {
      this.sql = sql2;
      this.params = params;
      this.#key = `[raw]: ${this.sql}${this.params ? ` (#${RawQueryFragment.#index++})` : ""}`;
    }
    as(alias) {
      return new RawQueryFragment(`${this.sql} as ${alias}`, this.params);
    }
    valueOf() {
      throw new Error(`Trying to modify raw SQL fragment: '${this.sql}'`);
    }
    toJSON() {
      throw new Error(`Trying to serialize raw SQL fragment: '${this.sql}'`);
    }
    toString() {
      RawQueryFragment.#rawQueryCache.set(this.#key, this);
      this.#used++;
      return this.#key;
    }
    assign() {
      if (this.#assigned) {
        throw new Error(`Cannot reassign already used RawQueryFragment: '${this.sql}'`);
      }
      this.#assigned = true;
    }
    clone() {
      RawQueryFragment.cloneRegistry?.add(this.#key);
      return new RawQueryFragment(this.sql, this.params);
    }
    static checkCacheSize() {
      return this.#rawQueryCache.size;
    }
    static isKnownFragment(key) {
      if (key instanceof RawQueryFragment) {
        return true;
      }
      return this.#rawQueryCache.has(key);
    }
    static getKnownFragment(key, cleanup = true) {
      if (key instanceof RawQueryFragment) {
        return key;
      }
      const raw2 = this.#rawQueryCache.get(key);
      if (raw2 && cleanup) {
        this.remove(key);
      }
      return raw2;
    }
    static remove(key) {
      const raw2 = this.#rawQueryCache.get(key);
      if (!raw2) {
        return;
      }
      raw2.#used--;
      if (raw2.#used <= 0) {
        this.#rawQueryCache.delete(key);
      }
    }
    [util_1.inspect.custom]() {
      if (this.params) {
        return { sql: this.sql, params: this.params };
      }
      return { sql: this.sql };
    }
  }
  exports.RawQueryFragment = RawQueryFragment;
  Object.defineProperties(RawQueryFragment.prototype, {
    __raw: { value: true, enumerable: false }
  });
  exports.ALIAS_REPLACEMENT = "[::alias::]";
  exports.ALIAS_REPLACEMENT_RE = "\\[::alias::\\]";
  exports.raw = raw;
  exports.sql = sql;
  exports.createSqlFunction = createSqlFunction;
  sql.ref = (...keys) => raw("??", [keys.join(".")]);
  sql.now = (length) => raw("current_timestamp" + (length == null ? "" : `(${length})`));
  sql.lower = (key) => createSqlFunction("lower", key);
  sql.upper = (key) => createSqlFunction("upper", key);
});

// node_modules/@mikro-orm/core/utils/clone.js
var require_clone2 = __commonJS((exports) => {
  var clone11 = function(parent, respectCustomCloneMethod = true) {
    const allParents = [];
    const allChildren = [];
    function _clone(parent2) {
      if (parent2 === null) {
        return null;
      }
      const raw = RawQueryFragment_1.RawQueryFragment.getKnownFragment(parent2, false);
      if (raw) {
        return raw.clone();
      }
      if (typeof parent2 !== "object" || parent2 instanceof events_1.EventEmitter) {
        return parent2;
      }
      if (respectCustomCloneMethod && "clone" in parent2 && typeof parent2.clone === "function") {
        return parent2.clone();
      }
      let child;
      let proto;
      if (parent2 instanceof Map) {
        child = new Map;
      } else if (parent2 instanceof Set) {
        child = new Set;
      } else if (parent2 instanceof Promise) {
        child = new Promise((resolve, reject) => {
          parent2.then(resolve.bind(null, _clone), reject.bind(null, _clone));
        });
      } else if (Array.isArray(parent2)) {
        child = [];
      } else if (parent2 instanceof RegExp) {
        let flags = "";
        if (parent2.global) {
          flags += "g";
        }
        if (parent2.ignoreCase) {
          flags += "i";
        }
        if (parent2.multiline) {
          flags += "m";
        }
        child = new RegExp(parent2.source, flags);
        if (parent2.lastIndex) {
          child.lastIndex = parent2.lastIndex;
        }
      } else if (parent2 instanceof Date) {
        child = new Date(parent2.getTime());
      } else if (Buffer.isBuffer(parent2)) {
        child = Buffer.allocUnsafe(parent2.length);
        parent2.copy(child);
        return child;
      } else if (parent2 instanceof Error) {
        child = Object.create(parent2);
      } else {
        proto = Object.getPrototypeOf(parent2);
        child = Object.create(proto);
      }
      const index = allParents.indexOf(parent2);
      if (index !== -1) {
        return allChildren[index];
      }
      allParents.push(parent2);
      allChildren.push(child);
      if (parent2 instanceof Map) {
        parent2.forEach((value14, key) => {
          const keyChild = _clone(key);
          const valueChild = _clone(value14);
          child.set(keyChild, valueChild);
        });
      }
      if (parent2 instanceof Set) {
        parent2.forEach((value14) => {
          const entryChild = _clone(value14);
          child.add(entryChild);
        });
      }
      for (const i2 in parent2) {
        let attrs;
        if (proto) {
          attrs = Object.getOwnPropertyDescriptor(proto, i2);
        }
        if (attrs && attrs.set == null) {
          continue;
        }
        const raw2 = RawQueryFragment_1.RawQueryFragment.getKnownFragment(i2, false);
        if (raw2) {
          const i22 = raw2.clone().toString();
          child[i22] = _clone(parent2[i2]);
          continue;
        }
        child[i2] = _clone(parent2[i2]);
      }
      if (Object.getOwnPropertySymbols) {
        const symbols66 = Object.getOwnPropertySymbols(parent2);
        for (let i2 = 0;i2 < symbols66.length; i2++) {
          const symbol4 = symbols66[i2];
          const descriptor = Object.getOwnPropertyDescriptor(parent2, symbol4);
          if (descriptor && !descriptor.enumerable) {
            continue;
          }
          child[symbol4] = _clone(parent2[symbol4]);
        }
      }
      return child;
    }
    return _clone(parent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.clone = undefined;
  var events_1 = import.meta.require("events");
  var RawQueryFragment_1 = require_RawQueryFragment();
  exports.clone = clone11;
});

// node_modules/@mikro-orm/core/entity/wrap.js
var require_wrap = __commonJS((exports) => {
  var wrap = function(entity, preferHelper = false) {
    if (!entity) {
      return entity;
    }
    if (entity.__baseEntity && !preferHelper) {
      return entity;
    }
    return entity.__helper ?? entity;
  };
  var helper = function(entity) {
    return entity.__helper;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.helper = exports.wrap = undefined;
  exports.wrap = wrap;
  exports.helper = helper;
});

// node_modules/@mikro-orm/core/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@mikro-orm/core",
    version: "6.0.7",
    description: "TypeScript ORM for Node.js based on Data Mapper, Unit of Work and Identity Map patterns. Supports MongoDB, MySQL, PostgreSQL and SQLite databases as well as usage with vanilla JavaScript.",
    main: "index.js",
    module: "index.mjs",
    typings: "index.d.ts",
    exports: {
      "./package.json": "./package.json",
      ".": {
        import: {
          types: "./index.d.ts",
          default: "./index.mjs"
        },
        require: "./index.js"
      }
    },
    repository: {
      type: "git",
      url: "git+ssh://git@github.com/mikro-orm/mikro-orm.git"
    },
    funding: "https://github.com/sponsors/b4nan",
    keywords: [
      "orm",
      "mongo",
      "mongodb",
      "mysql",
      "mariadb",
      "postgresql",
      "sqlite",
      "sqlite3",
      "ts",
      "typescript",
      "js",
      "javascript",
      "entity",
      "ddd",
      "mikro-orm",
      "unit-of-work",
      "data-mapper",
      "identity-map"
    ],
    author: "Martin Ad\xE1mek",
    license: "MIT",
    bugs: {
      url: "https://github.com/mikro-orm/mikro-orm/issues"
    },
    homepage: "https://mikro-orm.io",
    engines: {
      node: ">= 18.12.0"
    },
    scripts: {
      build: "yarn clean && yarn compile && yarn copy && yarn run -T gen-esm-wrapper index.js index.mjs",
      clean: "yarn run -T rimraf ./dist",
      compile: "yarn run -T tsc -p tsconfig.build.json",
      copy: "node ../../scripts/copy.mjs"
    },
    publishConfig: {
      access: "public"
    },
    dependencies: {
      dataloader: "2.2.2",
      dotenv: "16.4.1",
      esprima: "4.0.1",
      "fs-extra": "11.2.0",
      globby: "11.1.0",
      "mikro-orm": "6.0.7",
      "reflect-metadata": "0.2.1"
    }
  };
});

// node_modules/@mikro-orm/core/utils/Utils.js
var require_Utils = __commonJS((exports) => {
  var compareConstructors = function(a2, b2) {
    if (a2.constructor === b2.constructor) {
      return true;
    }
    if (!a2.constructor) {
      return b2.constructor === Object;
    }
    if (!b2.constructor) {
      return a2.constructor === Object;
    }
    return false;
  };
  var compareObjects = function(a2, b2) {
    if (a2 === b2 || a2 == null && b2 == null) {
      return true;
    }
    if (!a2 || !b2 || typeof a2 !== "object" || typeof b2 !== "object" || !compareConstructors(a2, b2)) {
      return false;
    }
    if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function") {
      return a2.valueOf() === b2.valueOf();
    }
    if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function") {
      return a2.toString() === b2.toString();
    }
    const keys = Object.keys(a2);
    const length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (let i2 = length;i2-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (let i2 = length;i2-- !== 0; ) {
      const key = keys[i2];
      if (!equals(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  };
  var compareArrays = function(a2, b2) {
    const length = a2.length;
    if (length !== b2.length) {
      return false;
    }
    for (let i2 = length;i2-- !== 0; ) {
      if (!equals(a2[i2], b2[i2])) {
        return false;
      }
    }
    return true;
  };
  var compareBooleans = function(a2, b2) {
    a2 = typeof a2 === "number" ? Boolean(a2) : a2;
    b2 = typeof b2 === "number" ? Boolean(b2) : b2;
    return a2 === b2;
  };
  var compareBuffers = function(a2, b2) {
    const length = a2.length;
    if (length !== b2.length) {
      return false;
    }
    for (let i2 = length;i2-- !== 0; ) {
      if (a2[i2] !== b2[i2]) {
        return false;
      }
    }
    return true;
  };
  var equals = function(a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
      if (Array.isArray(a2)) {
        return compareArrays(a2, b2);
      }
      if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
        return compareBuffers(a2, b2);
      }
      return compareObjects(a2, b2);
    }
    return Number.isNaN(a2) && Number.isNaN(b2);
  };
  var parseJsonSafe = function(value14) {
    if (typeof value14 === "string") {
      try {
        return JSON.parse(value14);
      } catch {
      }
    }
    return value14;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Utils = exports.parseJsonSafe = exports.equals = exports.compareBuffers = exports.compareBooleans = exports.compareArrays = exports.compareObjects = exports.ObjectBindingPattern = undefined;
  var module_1 = import.meta.require("module");
  var globby_1 = __importDefault(require_globby());
  var path_1 = import.meta.require("path");
  var os_1 = import.meta.require("os");
  var url_1 = import.meta.require("url");
  var fs_extra_1 = require_lib4();
  var crypto_1 = import.meta.require("crypto");
  var esprima_1 = require_esprima();
  var clone_1 = require_clone2();
  var enums_1 = require_enums();
  var wrap_1 = require_wrap();
  exports.ObjectBindingPattern = Symbol("ObjectBindingPattern");
  exports.compareObjects = compareObjects;
  exports.compareArrays = compareArrays;
  exports.compareBooleans = compareBooleans;
  exports.compareBuffers = compareBuffers;
  exports.equals = equals;
  var equalsFn = equals;
  exports.parseJsonSafe = parseJsonSafe;

  class Utils {
    static PK_SEPARATOR = "~~~";
    static dynamicImportProvider = (id) => import(id);
    static isDefined(data) {
      return typeof data !== "undefined";
    }
    static isObject(o2) {
      return !!o2 && typeof o2 === "object" && !Array.isArray(o2);
    }
    static processDecoratorParameters(params) {
      const keys = Object.keys(params);
      const values = Object.values(params);
      if (!Utils.isPlainObject(values[0])) {
        const lastKey = keys[keys.length - 1];
        const last = params[lastKey];
        delete params[lastKey];
        return { ...last, ...params };
      }
      const empty = (v2) => v2 == null || Utils.isPlainObject(v2) && !Utils.hasObjectKeys(v2);
      if (values.slice(1).some((v2) => !empty(v2))) {
        throw new Error("Mixing first decorator parameter as options object with other parameters is forbidden. If you want to use the options parameter at first position, provide all options inside it.");
      }
      return values[0];
    }
    static isNotObject(o2, not3) {
      return this.isObject(o2) && !not3.some((cls) => o2 instanceof cls);
    }
    static dropUndefinedProperties(o2, value14, visited2 = new Set) {
      if (Array.isArray(o2)) {
        return o2.forEach((item) => Utils.dropUndefinedProperties(item, value14, visited2));
      }
      if (!Utils.isPlainObject(o2) || visited2.has(o2)) {
        return;
      }
      visited2.add(o2);
      Object.keys(o2).forEach((key) => {
        if (o2[key] === value14) {
          delete o2[key];
          return;
        }
        Utils.dropUndefinedProperties(o2[key], value14, visited2);
      });
    }
    static getObjectKeysSize(object12) {
      let size = 0;
      for (const key in object12) {
        if (Object.prototype.hasOwnProperty.call(object12, key)) {
          size++;
        }
      }
      return size;
    }
    static hasObjectKeys(object12) {
      for (const key in object12) {
        if (Object.prototype.hasOwnProperty.call(object12, key)) {
          return true;
        }
      }
      return false;
    }
    static isString(s2) {
      return typeof s2 === "string";
    }
    static isNumber(s2) {
      return typeof s2 === "number";
    }
    static equals(a2, b2) {
      return equalsFn(a2, b2);
    }
    static unique(items) {
      return [...new Set(items)];
    }
    static merge(target, ...sources) {
      return Utils._merge(target, sources, false);
    }
    static mergeConfig(target, ...sources) {
      return Utils._merge(target, sources, true);
    }
    static _merge(target, sources, ignoreUndefined) {
      if (!sources.length) {
        return target;
      }
      const source = sources.shift();
      if (Utils.isObject(target) && Utils.isPlainObject(source)) {
        Object.entries(source).forEach(([key, value14]) => {
          if (ignoreUndefined && typeof value14 === "undefined") {
            return;
          }
          if (Utils.isPlainObject(value14)) {
            if (!Utils.isObject(target[key])) {
              target[key] = Utils.copy(value14);
              return;
            }
            if (!(key in target)) {
              Object.assign(target, { [key]: {} });
            }
            Utils._merge(target[key], [value14], ignoreUndefined);
          } else {
            Object.assign(target, { [key]: value14 });
          }
        });
      }
      return Utils._merge(target, sources, ignoreUndefined);
    }
    static getRootEntity(metadata, meta) {
      const base = meta.extends && metadata.find(Utils.className(meta.extends));
      if (!base || base === meta) {
        return meta;
      }
      const root = Utils.getRootEntity(metadata, base);
      if (root.discriminatorColumn) {
        return root;
      }
      return meta;
    }
    static diff(a2, b2) {
      const ret = {};
      Object.keys(b2).forEach((k) => {
        if (Utils.equals(a2[k], b2[k])) {
          return;
        }
        ret[k] = b2[k];
      });
      return ret;
    }
    static copy(entity, respectCustomCloneMethod = true) {
      return (0, clone_1.clone)(entity, respectCustomCloneMethod);
    }
    static asArray(data, strict3 = false) {
      if (typeof data === "undefined" && !strict3) {
        return [];
      }
      if (this.isIterable(data)) {
        return Array.from(data);
      }
      return [data];
    }
    static isIterable(value14) {
      if (value14 == null || typeof value14 === "string" || ArrayBuffer.isView(value14)) {
        return false;
      }
      return typeof Object(value14)[Symbol.iterator] === "function";
    }
    static renameKey(payload, from, to) {
      if (Utils.isObject(payload) && from in payload && !(to in payload)) {
        Object.keys(payload).forEach((key) => {
          const value14 = payload[key];
          delete payload[key];
          payload[from === key ? to : key] = value14;
        }, payload);
      }
    }
    static tokenize(func) {
      if (Array.isArray(func)) {
        return func;
      }
      try {
        return (0, esprima_1.tokenize)(func.toString(), { tolerant: true });
      } catch {
        return [];
      }
    }
    static getParamNames(func, methodName) {
      const ret = [];
      const tokens = this.tokenize(func);
      let inside = 0;
      for (let i2 = 0;i2 < tokens.length; i2++) {
        const token = tokens[i2];
        if (token.type === "Identifier" && token.value === methodName) {
          inside = 1;
          continue;
        }
        if (inside === 1 && token.type === "Punctuator" && token.value === "(") {
          inside = 2;
          continue;
        }
        if (inside === 2 && token.type === "Punctuator" && token.value === ")") {
          break;
        }
        if (inside === 2 && token.type === "Punctuator" && token.value === "{") {
          ret.push(exports.ObjectBindingPattern);
          i2 = tokens.findIndex((t2, idx) => idx > i2 + 2 && t2.type === "Punctuator" && t2.value === "}");
          continue;
        }
        if (inside === 2 && token.type === "Identifier") {
          ret.push(token.value);
        }
      }
      return ret;
    }
    static isPrimaryKey(key, allowComposite = false) {
      if (allowComposite && Array.isArray(key) && key.every((v2) => Utils.isPrimaryKey(v2, true))) {
        return true;
      }
      if (Utils.isObject(key) && !Utils.isPlainObject(key) && !Utils.isEntity(key, true)) {
        return true;
      }
      return ["string", "number", "bigint"].includes(typeof key) || Utils.isObjectID(key) || key instanceof Date || key instanceof Buffer;
    }
    static extractPK(data, meta, strict3 = false) {
      if (Utils.isPrimaryKey(data)) {
        return data;
      }
      if (Utils.isEntity(data, true)) {
        return (0, wrap_1.helper)(data).getPrimaryKey();
      }
      if (strict3 && meta && Utils.getObjectKeysSize(data) !== meta.primaryKeys.length) {
        return null;
      }
      if (Utils.isPlainObject(data) && meta) {
        if (meta.compositePK) {
          return this.getCompositeKeyValue(data, meta);
        }
        return data[meta.primaryKeys[0]] || data[meta.serializedPrimaryKey] || null;
      }
      return null;
    }
    static getCompositeKeyValue(data, meta, convertCustomTypes = false, platform) {
      return meta.primaryKeys.map((pk, idx) => {
        const value14 = Array.isArray(data) ? data[idx] : data[pk];
        const prop = meta.properties[pk];
        if (prop.targetMeta && Utils.isPlainObject(value14)) {
          return this.getCompositeKeyValue(value14, prop.targetMeta);
        }
        if (prop.customType && platform && convertCustomTypes) {
          const method = typeof convertCustomTypes === "string" ? convertCustomTypes : "convertToJSValue";
          return prop.customType[method](value14, platform);
        }
        return value14;
      });
    }
    static getCompositeKeyHash(data, meta, convertCustomTypes = false, platform, flat = false) {
      let pks = this.getCompositeKeyValue(data, meta, convertCustomTypes, platform);
      if (flat) {
        pks = Utils.flatten(pks);
      }
      return Utils.getPrimaryKeyHash(pks);
    }
    static getPrimaryKeyHash(pks) {
      return pks.map((pk) => Buffer.isBuffer(pk) ? pk.toString("hex") : pk).join(this.PK_SEPARATOR);
    }
    static splitPrimaryKeys(key) {
      return key.split(this.PK_SEPARATOR);
    }
    static getPrimaryKeyValues(entity, primaryKeys, allowScalar = false, convertCustomTypes = false) {
      if (entity == null) {
        return entity;
      }
      function toArray(val) {
        if (Utils.isPlainObject(val)) {
          return Object.values(val).flatMap((v2) => toArray(v2));
        }
        return val;
      }
      const pk = Utils.isEntity(entity, true) ? (0, wrap_1.helper)(entity).getPrimaryKey(convertCustomTypes) : primaryKeys.reduce((o2, pk2) => {
        o2[pk2] = entity[pk2];
        return o2;
      }, {});
      if (primaryKeys.length > 1) {
        return toArray(pk);
      }
      if (allowScalar) {
        if (Utils.isPlainObject(pk)) {
          return pk[primaryKeys[0]];
        }
        return pk;
      }
      return [pk];
    }
    static getPrimaryKeyCond(entity, primaryKeys) {
      const cond = primaryKeys.reduce((o2, pk) => {
        o2[pk] = Utils.extractPK(entity[pk]);
        return o2;
      }, {});
      if (Object.values(cond).some((v2) => v2 === null)) {
        return null;
      }
      return cond;
    }
    static mapFlatCompositePrimaryKey(fk, prop, fieldNames = prop.fieldNames, idx = 0) {
      if (!prop.targetMeta) {
        return fk[idx++];
      }
      const parts = [];
      for (const pk of prop.targetMeta.getPrimaryProps()) {
        parts.push(this.mapFlatCompositePrimaryKey(fk, pk, fieldNames, idx));
        idx += pk.fieldNames.length;
      }
      if (parts.length < 2) {
        return parts[0];
      }
      return parts;
    }
    static getPrimaryKeyCondFromArray(pks, meta) {
      return meta.getPrimaryProps().reduce((o2, pk, idx) => {
        if (Array.isArray(pks[idx]) && pk.targetMeta) {
          o2[pk.name] = pks[idx];
        } else {
          o2[pk.name] = Utils.extractPK(pks[idx], meta);
        }
        return o2;
      }, {});
    }
    static getOrderedPrimaryKeys(id, meta) {
      const data = Utils.isPrimaryKey(id) ? { [meta.primaryKeys[0]]: id } : id;
      const pks = meta.primaryKeys.map((pk, idx) => {
        const prop = meta.properties[pk];
        let value14 = Array.isArray(data) ? data[idx] : data[pk] ?? data;
        if (prop.kind !== enums_1.ReferenceKind.SCALAR && prop.targetMeta) {
          const value22 = this.getOrderedPrimaryKeys(value14, prop.targetMeta);
          value14 = value22.length > 1 ? value22 : value22[0];
        }
        return value14;
      });
      return Utils.flatten(pks);
    }
    static isEntity(data, allowReference = false) {
      if (!Utils.isObject(data)) {
        return false;
      }
      if (allowReference && !!data.__reference) {
        return true;
      }
      return !!data.__entity;
    }
    static isScalarReference(data, allowReference = false) {
      return typeof data === "object" && data?.__scalarReference;
    }
    static isObjectID(key) {
      return Utils.isObject(key) && key.constructor && key.constructor.name.toLowerCase() === "objectid";
    }
    static isEmpty(data) {
      if (Array.isArray(data)) {
        return data.length === 0;
      }
      if (Utils.isObject(data)) {
        return !Utils.hasObjectKeys(data);
      }
      return !data;
    }
    static className(classOrName) {
      if (Utils.isString(classOrName)) {
        return classOrName;
      }
      return classOrName.name;
    }
    static extractChildElements(items, prefix, allSymbol) {
      return items.filter((field) => field === allSymbol || field.startsWith(`${prefix}.`)).map((field) => field === allSymbol ? allSymbol : field.substring(prefix.length + 1));
    }
    static detectTsNode() {
      return process.argv[0].endsWith("ts-node") || !!process[Symbol.for("ts-node.register.instance")] || !!process.env.TS_JEST || !!process.env.VITEST || process.argv.slice(1).some((arg) => arg.includes("ts-node")) || import.meta.require.extensions && !!import.meta.require.extensions[".ts"];
    }
    static lookupPathFromDecorator(name, stack) {
      stack = stack || new Error().stack.split("\n");
      let line = stack.findIndex((line2) => line2.includes("__decorate") || line2.includes("Reflect.decorate"));
      if (line === -1) {
        return name;
      }
      if (stack[line].includes("Reflect.decorate")) {
        line++;
      }
      if (Utils.normalizePath(stack[line]).includes("node_modules/tslib/tslib")) {
        line++;
      }
      try {
        const re = stack[line].match(/\(.+\)/i) ? /\((.*):\d+:\d+\)/ : /at\s*(.*):\d+:\d+$/;
        return Utils.normalizePath(stack[line].match(re)[1]);
      } catch {
        return name;
      }
    }
    static getObjectType(value14) {
      const simple = typeof value14;
      if (["string", "number", "boolean", "bigint"].includes(simple)) {
        return simple;
      }
      const objectType = Object.prototype.toString.call(value14);
      const type73 = objectType.match(/\[object (\w+)]/)[1];
      if (type73 === "Uint8Array") {
        return "Buffer";
      }
      return ["Date", "Buffer", "RegExp"].includes(type73) ? type73 : type73.toLowerCase();
    }
    static isPlainObject(value14) {
      return value14 !== null && typeof value14 === "object" && typeof value14.constructor === "function" && (value14.constructor.prototype.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(value14.constructor.prototype) === null) || value14 && Object.getPrototypeOf(value14) === null || value14 instanceof enums_1.PlainObject;
    }
    static async runSerial(items, cb) {
      const ret = [];
      for (const item of items) {
        ret.push(await cb(item));
      }
      return ret;
    }
    static isCollection(item) {
      return item?.__collection;
    }
    static fileURLToPath(url) {
      return (0, url_1.fileURLToPath)(url);
    }
    static normalizePath(...parts) {
      let start = 0;
      for (let i2 = 0;i2 < parts.length; i2++) {
        const part = parts[i2];
        if ((0, path_1.isAbsolute)(part)) {
          start = i2;
        } else if (part.startsWith("file:")) {
          start = i2;
          parts[i2] = Utils.fileURLToPath(part);
        }
      }
      if (start > 0) {
        parts = parts.slice(start);
      }
      let path = parts.join("/").replace(/\\/g, "/").replace(/\/$/, "");
      path = (0, path_1.normalize)(path).replace(/\\/g, "/");
      return path.match(/^[/.]|[a-zA-Z]:/) || path.startsWith("!") ? path : "./" + path;
    }
    static relativePath(path, relativeTo) {
      if (!path) {
        return path;
      }
      path = Utils.normalizePath(path);
      if (path.startsWith(".")) {
        return path;
      }
      path = (0, path_1.relative)(Utils.normalizePath(relativeTo), path);
      return Utils.normalizePath(path);
    }
    static absolutePath(path, baseDir = process.cwd()) {
      if (!path) {
        return Utils.normalizePath(baseDir);
      }
      if (!(0, path_1.isAbsolute)(path) && !path.startsWith("file://")) {
        path = baseDir + "/" + path;
      }
      return Utils.normalizePath(path);
    }
    static hash(data, length) {
      const hash6 = (0, crypto_1.createHash)("md5").update(data).digest("hex");
      if (length) {
        return hash6.substring(0, length);
      }
      return hash6;
    }
    static runIfNotEmpty(clause, data) {
      if (!Utils.isEmpty(data)) {
        clause();
      }
    }
    static defaultValue(prop, option, defaultValue) {
      prop[option] = option in prop ? prop[option] : defaultValue;
    }
    static findDuplicates(items) {
      return items.reduce((acc, v2, i2, arr) => {
        return arr.indexOf(v2) !== i2 && acc.indexOf(v2) === -1 ? acc.concat(v2) : acc;
      }, []);
    }
    static removeDuplicates(items) {
      const ret = [];
      const contains = (arr, val) => !!arr.find((v2) => equals(val, v2));
      for (const item of items) {
        if (!contains(ret, item)) {
          ret.push(item);
        }
      }
      return ret;
    }
    static randomInt(min, max) {
      return Math.round(Math.random() * (max - min)) + min;
    }
    static async pathExists(path, options = {}) {
      if (globby_1.default.hasMagic(path)) {
        const found = await (0, globby_1.default)(path, options);
        return found.length > 0;
      }
      return (0, fs_extra_1.pathExists)(path);
    }
    static extractEnumValues(target) {
      const keys = Object.keys(target);
      const values = Object.values(target);
      const numeric = !!values.find((v2) => typeof v2 === "number");
      const constEnum = values.length % 2 === 0 && values.slice(0, values.length / 2).every((v2) => typeof v2 === "string") && values.slice(values.length / 2).every((v2) => typeof v2 === "number") && this.equals(keys, values.slice(values.length / 2).concat(values.slice(0, values.length / 2)).map((v2) => "" + v2));
      if (numeric || constEnum) {
        return values.filter((val) => !keys.includes(val));
      }
      return values;
    }
    static flatten(arrays) {
      return [].concat.apply([], arrays);
    }
    static isOperator(key, includeGroupOperators = true) {
      if (!includeGroupOperators) {
        return key in enums_1.QueryOperator;
      }
      return key in enums_1.GroupOperator || key in enums_1.QueryOperator;
    }
    static isGroupOperator(key) {
      return key in enums_1.GroupOperator;
    }
    static isArrayOperator(key) {
      return enums_1.ARRAY_OPERATORS.includes(key);
    }
    static hasNestedKey(object12, key) {
      if (!object12) {
        return false;
      }
      if (Array.isArray(object12)) {
        return object12.some((o2) => this.hasNestedKey(o2, key));
      }
      if (typeof object12 === "object") {
        return Object.entries(object12).some(([k, v2]) => k === key || this.hasNestedKey(v2, key));
      }
      return false;
    }
    static getGlobalStorage(namespace) {
      const key = `mikro-orm-${namespace}`;
      globalThis[key] = globalThis[key] || {};
      return globalThis[key];
    }
    static requireFrom(id, from = process.cwd()) {
      if (!(0, path_1.extname)(from)) {
        from = (0, path_1.join)(from, "__fake.js");
      }
      return (0, module_1.createRequire)((0, path_1.resolve)(from))(id);
    }
    static async dynamicImport(id) {
      if (id.endsWith(".json") || process.env.TS_JEST) {
        return import.meta.require(id);
      }
      if ((0, os_1.platform)() === "win32") {
        try {
          id = (0, url_1.pathToFileURL)(id).toString();
        } catch {
        }
      }
      return this.dynamicImportProvider(id);
    }
    static setDynamicImportProvider(provider) {
      this.dynamicImportProvider = provider;
    }
    static getORMVersion() {
      try {
        return (()=>{throw new Error(`Cannot require module "../../package.json"`);})().version;
      } catch {
        return require_package2().version;
      }
    }
    static createFunction(context, code) {
      try {
        return new Function(...context.keys(), `'use strict';\n` + code)(...context.values());
      } catch (e2) {
        console.error(code);
        throw e2;
      }
    }
    static callCompiledFunction(fn, ...args) {
      try {
        return fn(...args);
      } catch (e2) {
        if ([SyntaxError, TypeError, EvalError, ReferenceError].some((t2) => e2 instanceof t2)) {
          const position = e2.stack.match(/<anonymous>:(\d+):(\d+)/);
          let code = fn.toString();
          if (position) {
            const lines = code.split("\n").map((line, idx) => {
              if (idx === +position[1] - 5) {
                return "> " + line;
              }
              return "  " + line;
            });
            lines.splice(+position[1] - 4, 0, " ".repeat(+position[2]) + "^");
            code = lines.join("\n");
          }
          console.error(`JIT runtime error: ${e2.message}\n\n${code}`);
        }
        throw e2;
      }
    }
    static propertyDecoratorReturnValue() {
      if (process.env.BABEL_DECORATORS_COMPAT) {
        return {};
      }
    }
    static unwrapProperty(entity, meta, prop, payload = false) {
      let p2 = prop;
      const path = [];
      function isObjectProperty(prop2) {
        return prop2.embedded ? prop2.object || prop2.array || isObjectProperty(meta.properties[prop2.embedded[0]]) : prop2.object || !!prop2.array;
      }
      if (!isObjectProperty(prop) && !prop.embedded) {
        return entity[prop.name] != null ? [[entity[prop.name], []]] : [];
      }
      while (p2.embedded) {
        const child = meta.properties[p2.embedded[0]];
        if (payload && !child.object && !child.array) {
          break;
        }
        path.shift();
        path.unshift(p2.embedded[0], p2.embedded[1]);
        p2 = child;
      }
      const ret = [];
      const follow = (t2, idx = 0, i2 = []) => {
        const k = path[idx];
        if (Array.isArray(t2)) {
          return t2.forEach((t3, ii) => follow(t3, idx, [...i2, ii]));
        }
        if (t2 == null) {
          return;
        }
        const target = t2[k];
        if (path[++idx]) {
          follow(target, idx, i2);
        } else if (target != null) {
          ret.push([target, i2]);
        }
      };
      follow(entity);
      return ret;
    }
    static setPayloadProperty(entity, meta, prop, value14, idx) {
      function isObjectProperty(prop2) {
        return prop2.embedded ? prop2.object || prop2.array || isObjectProperty(meta.properties[prop2.embedded[0]]) : prop2.object || !!prop2.array;
      }
      if (!isObjectProperty(prop)) {
        entity[prop.name] = value14;
        return;
      }
      let target = entity;
      let p2 = prop;
      const path = [];
      while (p2.embedded) {
        path.shift();
        path.unshift(p2.embedded[0], p2.embedded[1]);
        const prev = p2;
        p2 = meta.properties[p2.embedded[0]];
        if (!p2.object) {
          path.shift();
          path[0] = prev.name;
          break;
        }
      }
      let j = 0;
      path.forEach((k, i2) => {
        if (i2 === path.length - 1) {
          if (Array.isArray(target)) {
            target[idx[j++]][k] = value14;
          } else {
            target[k] = value14;
          }
        } else {
          if (Array.isArray(target)) {
            target = target[idx[j++]][k];
          } else {
            target = target[k];
          }
        }
      });
    }
    static tryRequire({ module: module2, from, allowError, warning }) {
      allowError ??= `Cannot find module '${module2}'`;
      from ??= process.cwd();
      try {
        return Utils.requireFrom(module2, from);
      } catch (err) {
        if (err.message.includes(allowError)) {
          console.warn(warning);
          return;
        }
        throw err;
      }
    }
    static stripRelativePath(str) {
      return str.replace(/^(?:\.\.\/|\.\/)+/, "/");
    }
    static parseArgs() {
      let lastKey;
      return process.argv.slice(2).reduce((args, arg) => {
        if (arg.includes("=")) {
          const [key, value14] = arg.split("=");
          args[key.substring(2)] = value14;
        } else if (lastKey) {
          args[lastKey] = arg;
          lastKey = undefined;
        } else if (arg.startsWith("--")) {
          lastKey = arg.substring(2);
        }
        return args;
      }, {});
    }
    static xor(a2, b2) {
      return (a2 || b2) && !(a2 && b2);
    }
    static keys(obj) {
      return Object.keys(obj);
    }
    static values(obj) {
      return Object.values(obj);
    }
    static entries(obj) {
      return Object.entries(obj);
    }
    static isRawSql(value14) {
      return typeof value14 === "object" && !!value14 && "__raw" in value14;
    }
    static primaryKeyToObject(meta, primaryKey) {
      const pks = meta.compositePK && Utils.isPlainObject(primaryKey) ? Object.values(primaryKey) : Utils.asArray(primaryKey);
      const pkProps = meta.getPrimaryProps();
      return meta.primaryKeys.reduce((o2, pk, idx) => {
        const pkProp = pkProps[idx];
        if (Utils.isPlainObject(pks[idx]) && pkProp.targetMeta) {
          o2[pk] = Utils.getOrderedPrimaryKeys(pks[idx], pkProp.targetMeta);
          return o2;
        }
        o2[pk] = pks[idx];
        return o2;
      }, {});
    }
  }
  exports.Utils = Utils;
});

// node_modules/@mikro-orm/core/entity/EntityRepository.js
var require_EntityRepository = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityRepository = undefined;
  var errors_1 = require_errors3();
  var Utils_1 = require_Utils();

  class EntityRepository {
    em;
    entityName;
    constructor(em, entityName) {
      this.em = em;
      this.entityName = entityName;
    }
    async findOne(where, options) {
      return this.getEntityManager().findOne(this.entityName, where, options);
    }
    async findOneOrFail(where, options) {
      return this.getEntityManager().findOneOrFail(this.entityName, where, options);
    }
    async upsert(entityOrData, options) {
      return this.getEntityManager().upsert(this.entityName, entityOrData, options);
    }
    async upsertMany(entitiesOrData, options) {
      return this.getEntityManager().upsertMany(this.entityName, entitiesOrData, options);
    }
    async find(where, options) {
      return this.getEntityManager().find(this.entityName, where, options);
    }
    async findAndCount(where, options) {
      return this.getEntityManager().findAndCount(this.entityName, where, options);
    }
    async findByCursor(where, options) {
      return this.getEntityManager().findByCursor(this.entityName, where, options);
    }
    async findAll(options) {
      return this.getEntityManager().findAll(this.entityName, options);
    }
    async insert(data, options) {
      return this.getEntityManager().insert(this.entityName, data, options);
    }
    async insertMany(data, options) {
      return this.getEntityManager().insertMany(this.entityName, data, options);
    }
    async nativeUpdate(where, data, options) {
      return this.getEntityManager().nativeUpdate(this.entityName, where, data, options);
    }
    async nativeDelete(where, options) {
      return this.getEntityManager().nativeDelete(this.entityName, where, options);
    }
    map(result, options) {
      return this.getEntityManager().map(this.entityName, result, options);
    }
    getReference(id, options) {
      return this.getEntityManager().getReference(this.entityName, id, options);
    }
    canPopulate(property) {
      return this.getEntityManager().canPopulate(this.entityName, property);
    }
    async populate(entities, populate, options) {
      this.validateRepositoryType(entities, "populate");
      return this.getEntityManager().populate(entities, populate, options);
    }
    create(data, options) {
      return this.getEntityManager().create(this.entityName, data, options);
    }
    assign(entity, data, options) {
      this.validateRepositoryType(entity, "assign");
      return this.getEntityManager().assign(entity, data, options);
    }
    merge(data, options) {
      return this.getEntityManager().merge(this.entityName, data, options);
    }
    async count(where = {}, options = {}) {
      return this.getEntityManager().count(this.entityName, where, options);
    }
    getEntityName() {
      return Utils_1.Utils.className(this.entityName);
    }
    getEntityManager() {
      return this.em;
    }
    validateRepositoryType(entities, method) {
      entities = Utils_1.Utils.asArray(entities);
      if (entities.length === 0) {
        return;
      }
      const entityName = entities[0].constructor.name;
      const repoType = Utils_1.Utils.className(this.entityName);
      if (entityName && repoType !== entityName) {
        throw errors_1.ValidationError.fromWrongRepositoryType(entityName, repoType, method);
      }
    }
  }
  exports.EntityRepository = EntityRepository;
});

// node_modules/@mikro-orm/core/entity/EntityIdentifier.js
var require_EntityIdentifier = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityIdentifier = undefined;

  class EntityIdentifier {
    value;
    constructor(value14) {
      this.value = value14;
    }
    setValue(value14) {
      this.value = value14;
    }
    getValue() {
      return this.value;
    }
  }
  exports.EntityIdentifier = EntityIdentifier;
});

// node_modules/@mikro-orm/core/entity/EntityValidator.js
var require_EntityValidator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityValidator = undefined;
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();
  var errors_1 = require_errors3();
  var wrap_1 = require_wrap();

  class EntityValidator {
    strict;
    constructor(strict3) {
      this.strict = strict3;
    }
    validate(entity, payload, meta) {
      meta.props.forEach((prop) => {
        if (prop.inherited) {
          return;
        }
        if ([enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind)) {
          this.validateCollection(entity, prop);
        }
        const SCALAR_TYPES = ["string", "number", "boolean", "Date"];
        if (prop.kind !== enums_1.ReferenceKind.SCALAR || !SCALAR_TYPES.includes(prop.type)) {
          return;
        }
        const newValue = this.validateProperty(prop, this.getValue(payload, prop), entity);
        if (this.getValue(payload, prop) === newValue) {
          return;
        }
        this.setValue(payload, prop, newValue);
        if (entity[prop.name]) {
          entity[prop.name] = payload[prop.name];
        }
      });
    }
    validateRequired(entity) {
      const wrapped = (0, wrap_1.helper)(entity);
      for (const prop of wrapped.__meta.props) {
        if (!prop.nullable && !prop.autoincrement && !prop.default && !prop.defaultRaw && !prop.onCreate && !prop.generated && !prop.embedded && ![enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind) && prop.name !== wrapped.__meta.root.discriminatorColumn && prop.type.toLowerCase() !== "objectid" && prop.persist !== false && entity[prop.name] == null) {
          throw errors_1.ValidationError.propertyRequired(entity, prop);
        }
      }
    }
    validateProperty(prop, givenValue, entity) {
      if (givenValue === null || givenValue === undefined) {
        return givenValue;
      }
      const expectedType = prop.runtimeType;
      let givenType = Utils_1.Utils.getObjectType(givenValue);
      let ret = givenValue;
      if (!this.strict) {
        ret = this.fixTypes(expectedType, givenType, givenValue);
        givenType = Utils_1.Utils.getObjectType(ret);
      }
      if (prop.enum && prop.items) {
        if (!prop.items.some((it) => it === givenValue)) {
          throw errors_1.ValidationError.fromWrongPropertyType(entity, prop.name, expectedType, givenType, givenValue);
        }
      } else {
        if (givenType !== expectedType) {
          throw errors_1.ValidationError.fromWrongPropertyType(entity, prop.name, expectedType, givenType, givenValue);
        }
      }
      return ret;
    }
    validateParams(params, type73 = "search condition", field) {
      if (Utils_1.Utils.isPrimaryKey(params) || Utils_1.Utils.isEntity(params)) {
        return;
      }
      if (Array.isArray(params)) {
        return params.forEach((item) => this.validateParams(item, type73, field));
      }
      if (Utils_1.Utils.isPlainObject(params)) {
        Object.keys(params).forEach((k) => {
          this.validateParams(params[k], type73, k);
        });
      }
    }
    validatePrimaryKey(entity, meta) {
      const pkExists = meta.primaryKeys.every((pk) => entity[pk] != null) || entity[meta.serializedPrimaryKey] != null;
      if (!entity || !pkExists) {
        throw errors_1.ValidationError.fromMergeWithoutPK(meta);
      }
    }
    validateEmptyWhere(where) {
      if (Utils_1.Utils.isEmpty(where)) {
        throw new Error(`You cannot call 'EntityManager.findOne()' with empty 'where' parameter`);
      }
    }
    getValue(o2, prop) {
      if (prop.embedded && prop.embedded[0] in o2) {
        return o2[prop.embedded[0]]?.[prop.embedded[1]];
      }
      return o2[prop.name];
    }
    setValue(o2, prop, v2) {
      if (prop.embedded && prop.embedded[0] in o2) {
        return o2[prop.embedded[0]][prop.embedded[1]] = v2;
      }
      o2[prop.name] = v2;
    }
    validateCollection(entity, prop) {
      if (prop.hydrate !== false && (0, wrap_1.helper)(entity).__initialized && !entity[prop.name]) {
        throw errors_1.ValidationError.fromCollectionNotInitialized(entity, prop);
      }
    }
    fixTypes(expectedType, givenType, givenValue) {
      if (expectedType === "Date" && ["string", "number"].includes(givenType)) {
        givenValue = this.fixDateType(givenValue);
      }
      if (expectedType === "number" && givenType === "string") {
        givenValue = this.fixNumberType(givenValue);
      }
      if (expectedType === "boolean" && givenType === "number") {
        givenValue = this.fixBooleanType(givenValue);
      }
      return givenValue;
    }
    fixDateType(givenValue) {
      let date4;
      if (Utils_1.Utils.isString(givenValue) && givenValue.match(/^-?\d+(\.\d+)?$/)) {
        date4 = new Date(+givenValue);
      } else {
        date4 = new Date(givenValue);
      }
      return date4.toString() !== "Invalid Date" ? date4 : givenValue;
    }
    fixNumberType(givenValue) {
      const num = +givenValue;
      return "" + num === givenValue ? num : givenValue;
    }
    fixBooleanType(givenValue) {
      const bool = !!givenValue;
      return +bool === givenValue ? bool : givenValue;
    }
  }
  exports.EntityValidator = EntityValidator;
});

// node_modules/@mikro-orm/core/cache/CacheAdapter.js
var require_CacheAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@mikro-orm/core/cache/NullCacheAdapter.js
var require_NullCacheAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NullCacheAdapter = undefined;

  class NullCacheAdapter {
    get(name) {
      return null;
    }
    set(name, data, origin) {
    }
    remove(name) {
    }
    clear() {
    }
  }
  exports.NullCacheAdapter = NullCacheAdapter;
});

// node_modules/@mikro-orm/core/cache/FileCacheAdapter.js
var require_FileCacheAdapter = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FileCacheAdapter = undefined;
  var globby_1 = __importDefault(require_globby());
  var fs_extra_1 = require_lib4();
  var Utils_1 = require_Utils();

  class FileCacheAdapter {
    options;
    baseDir;
    pretty;
    VERSION = Utils_1.Utils.getORMVersion();
    cache = {};
    constructor(options, baseDir, pretty = false) {
      this.options = options;
      this.baseDir = baseDir;
      this.pretty = pretty;
    }
    get(name) {
      const path = this.path(name);
      if (!(0, fs_extra_1.pathExistsSync)(path)) {
        return null;
      }
      const payload = (0, fs_extra_1.readJSONSync)(path);
      const hash6 = this.getHash(payload.origin);
      if (!hash6 || payload.hash !== hash6) {
        return null;
      }
      return payload.data;
    }
    set(name, data, origin) {
      if (this.options.combined) {
        this.cache[name.replace(/\.[jt]s$/, "")] = data;
        return;
      }
      const path = this.path(name);
      const hash6 = this.getHash(origin);
      const opts = this.pretty ? { spaces: 2 } : {};
      (0, fs_extra_1.writeJSONSync)(path, { data, origin, hash: hash6, version: this.VERSION }, opts);
    }
    remove(name) {
      const path = this.path(name);
      (0, fs_extra_1.unlinkSync)(path);
    }
    clear() {
      const path = this.path("*");
      const files = globby_1.default.sync(path);
      files.forEach((file) => (0, fs_extra_1.unlinkSync)(file));
      this.cache = {};
    }
    combine() {
      if (!this.options.combined) {
        return;
      }
      let path = typeof this.options.combined === "string" ? this.options.combined : "./metadata.json";
      path = Utils_1.Utils.normalizePath(this.options.cacheDir, path);
      this.options.combined = path;
      (0, fs_extra_1.writeJSONSync)(path, this.cache, { spaces: this.pretty ? 2 : undefined });
      return path;
    }
    path(name) {
      (0, fs_extra_1.ensureDirSync)(this.options.cacheDir);
      return `${this.options.cacheDir}/${name}.json`;
    }
    getHash(origin) {
      origin = Utils_1.Utils.absolutePath(origin, this.baseDir);
      if (!(0, fs_extra_1.pathExistsSync)(origin)) {
        return null;
      }
      const contents = (0, fs_extra_1.readFileSync)(origin);
      return Utils_1.Utils.hash(contents.toString() + this.VERSION);
    }
  }
  exports.FileCacheAdapter = FileCacheAdapter;
});

// node_modules/@mikro-orm/core/cache/MemoryCacheAdapter.js
var require_MemoryCacheAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MemoryCacheAdapter = undefined;

  class MemoryCacheAdapter {
    options;
    data = new Map;
    constructor(options) {
      this.options = options;
    }
    get(name) {
      const data = this.data.get(name);
      if (data) {
        if (data.expiration < Date.now()) {
          this.data.delete(name);
        } else {
          return data.data;
        }
      }
      return;
    }
    set(name, data, origin, expiration) {
      this.data.set(name, { data, expiration: Date.now() + (expiration ?? this.options.expiration) });
    }
    remove(name) {
      this.data.delete(name);
    }
    clear() {
      this.data.clear();
    }
  }
  exports.MemoryCacheAdapter = MemoryCacheAdapter;
});

// node_modules/@mikro-orm/core/cache/GeneratedCacheAdapter.js
var require_GeneratedCacheAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GeneratedCacheAdapter = undefined;

  class GeneratedCacheAdapter {
    options;
    data = new Map;
    constructor(options) {
      this.options = options;
      this.data = new Map(Object.entries(options.data));
    }
    get(name) {
      const key = name.replace(/\.[jt]s$/, "");
      const data = this.data.get(key);
      return data;
    }
    set(name, data, origin) {
      this.data.set(name, { data });
    }
    remove(name) {
      this.data.delete(name);
    }
    clear() {
      this.data.clear();
    }
  }
  exports.GeneratedCacheAdapter = GeneratedCacheAdapter;
});

// node_modules/@mikro-orm/core/cache/index.js
var require_cache2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_CacheAdapter(), exports);
  __exportStar(require_NullCacheAdapter(), exports);
  __exportStar(require_FileCacheAdapter(), exports);
  __exportStar(require_MemoryCacheAdapter(), exports);
  __exportStar(require_GeneratedCacheAdapter(), exports);
});

// node_modules/@mikro-orm/core/hydration/Hydrator.js
var require_Hydrator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hydrator = undefined;

  class Hydrator {
    metadata;
    platform;
    config;
    running = false;
    constructor(metadata, platform, config) {
      this.metadata = metadata;
      this.platform = platform;
      this.config = config;
    }
    hydrate(entity, meta, data, factory, type73, newEntity = false, convertCustomTypes = false, schema) {
      this.running = !newEntity;
      const props = this.getProperties(meta, type73);
      for (const prop of props) {
        this.hydrateProperty(entity, prop, data, factory, newEntity, convertCustomTypes);
      }
      this.running = false;
    }
    hydrateReference(entity, meta, data, factory, convertCustomTypes, schema) {
      this.running = true;
      meta.primaryKeys.forEach((pk) => {
        this.hydrateProperty(entity, meta.properties[pk], data, factory, false, convertCustomTypes);
      });
      this.running = false;
    }
    isRunning() {
      return this.running;
    }
    getProperties(meta, type73) {
      if (type73 === "reference") {
        return meta.primaryKeys.map((pk) => meta.properties[pk]);
      }
      return meta.hydrateProps;
    }
    hydrateProperty(entity, prop, data, factory, newEntity, convertCustomTypes) {
      entity[prop.name] = data[prop.name];
    }
  }
  exports.Hydrator = Hydrator;
});

// node_modules/@mikro-orm/core/hydration/ObjectHydrator.js
var require_ObjectHydrator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectHydrator = undefined;
  var Hydrator_1 = require_Hydrator();
  var Collection_1 = require_Collection();
  var Reference_1 = require_Reference();
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();

  class ObjectHydrator extends Hydrator_1.Hydrator {
    hydrators = {
      full: new Map,
      reference: new Map
    };
    tmpIndex = 0;
    hydrate(entity, meta, data, factory, type73, newEntity = false, convertCustomTypes = false, schema) {
      const hydrate = this.getEntityHydrator(meta, type73);
      const running = this.running;
      this.running = !newEntity;
      Utils_1.Utils.callCompiledFunction(hydrate, entity, data, factory, newEntity, convertCustomTypes, schema);
      this.running = running;
    }
    hydrateReference(entity, meta, data, factory, convertCustomTypes = false, schema) {
      const hydrate = this.getEntityHydrator(meta, "reference");
      const running = this.running;
      this.running = true;
      Utils_1.Utils.callCompiledFunction(hydrate, entity, data, factory, false, convertCustomTypes, schema);
      this.running = running;
    }
    getEntityHydrator(meta, type73) {
      const exists = this.hydrators[type73].get(meta.className);
      if (exists) {
        return exists;
      }
      const lines = [];
      const context = new Map;
      const props = this.getProperties(meta, type73);
      context.set("isPrimaryKey", Utils_1.Utils.isPrimaryKey);
      context.set("Collection", Collection_1.Collection);
      context.set("Reference", Reference_1.Reference);
      const hydrateScalar = (prop, object12, path, dataKey) => {
        const entityKey = path.map((k) => this.wrap(k)).join("");
        const tz = this.platform.getTimezone();
        const convertorKey = path.filter((k) => !k.match(/\[idx_\d+]/)).map((k) => this.safeKey(k)).join("_");
        const ret = [];
        const idx = this.tmpIndex++;
        const nullVal = this.config.get("forceUndefined") ? "undefined" : "null";
        if (prop.ref) {
          context.set("ScalarReference", Reference_1.ScalarReference);
          ret.push(`  const oldValue_${idx} = entity${entityKey};`);
        }
        ret.push(`  if (data${dataKey} === null) {`);
        ret.push(`    entity${entityKey} = ${nullVal};`);
        ret.push(`  } else if (typeof data${dataKey} !== 'undefined') {`);
        if (prop.customType) {
          context.set(`convertToJSValue_${convertorKey}`, (val) => prop.customType.convertToJSValue(val, this.platform));
          context.set(`convertToDatabaseValue_${convertorKey}`, (val) => prop.customType.convertToDatabaseValue(val, this.platform, { mode: "hydration" }));
          ret.push(`    if (convertCustomTypes) {`, `      const value = convertToJSValue_${convertorKey}(data${dataKey});`);
          if (prop.customType.ensureComparable(meta, prop)) {
            ret.push(`      data${dataKey} = convertToDatabaseValue_${convertorKey}(value);`);
          }
          ret.push(`      entity${entityKey} = value;`, `    } else {`, `      entity${entityKey} = data${dataKey};`, `    }`);
        } else if (prop.runtimeType === "boolean") {
          ret.push(`    entity${entityKey} = !!data${dataKey};`);
        } else if (prop.runtimeType === "Date") {
          ret.push(`    if (data${dataKey} instanceof Date) {`);
          ret.push(`      entity${entityKey} = data${dataKey};`);
          if (!tz || tz === "local") {
            ret.push(`    } else {`);
            ret.push(`      entity${entityKey} = new Date(data${dataKey});`);
          } else {
            ret.push(`    } else if (typeof data${dataKey} === 'number' || data${dataKey}.includes('+')) {`);
            ret.push(`      entity${entityKey} = new Date(data${dataKey});`);
            ret.push(`    } else {`);
            ret.push(`      entity${entityKey} = new Date(data${dataKey} + '${tz}');`);
          }
          ret.push(`    }`);
        } else {
          ret.push(`    entity${entityKey} = data${dataKey};`);
        }
        if (prop.ref) {
          ret.push(`    const value = entity${entityKey};`);
          ret.push(`    entity${entityKey} = oldValue_${idx} ?? new ScalarReference(value);`);
          ret.push(`    entity${entityKey}.bind(entity, '${prop.name}');`);
          ret.push(`    entity${entityKey}.set(value);`);
        }
        ret.push(`  }`);
        if (prop.ref) {
          ret.push(`  if (!entity${entityKey}) {`);
          ret.push(`    entity${entityKey} = new ScalarReference();`);
          ret.push(`    entity${entityKey}.bind(entity, '${prop.name}');`);
          ret.push(`  }`);
        }
        return ret;
      };
      const hydrateToOne = (prop, dataKey, entityKey) => {
        const ret = [];
        const method = type73 === "reference" ? "createReference" : "create";
        const nullVal = this.config.get("forceUndefined") ? "undefined" : "null";
        ret.push(`  if (data${dataKey} === null) {\n    entity${entityKey} = ${nullVal};`);
        ret.push(`  } else if (typeof data${dataKey} !== 'undefined') {`);
        ret.push(`    if (isPrimaryKey(data${dataKey}, true)) {`);
        if (prop.ref) {
          ret.push(`      entity${entityKey} = Reference.create(factory.createReference('${prop.type}', data${dataKey}, { merge: true, convertCustomTypes, schema }));`);
        } else {
          ret.push(`      entity${entityKey} = factory.createReference('${prop.type}', data${dataKey}, { merge: true, convertCustomTypes, schema });`);
        }
        ret.push(`    } else if (data${dataKey} && typeof data${dataKey} === 'object') {`);
        if (prop.ref) {
          ret.push(`      entity${entityKey} = Reference.create(factory.${method}('${prop.type}', data${dataKey}, { initialized: true, merge: true, newEntity, convertCustomTypes, schema }));`);
        } else {
          ret.push(`      entity${entityKey} = factory.${method}('${prop.type}', data${dataKey}, { initialized: true, merge: true, newEntity, convertCustomTypes, schema });`);
        }
        ret.push(`    }`);
        ret.push(`  }`);
        if (prop.kind === enums_1.ReferenceKind.ONE_TO_ONE) {
          const meta2 = this.metadata.get(prop.type);
          const prop2 = meta2.properties[prop.inversedBy || prop.mappedBy];
          if (prop2 && !prop2.mapToPk) {
            ret.push(`  if (data${dataKey} && entity${entityKey} && !entity${entityKey}.${this.safeKey(prop2.name)}) {`);
            ret.push(`    entity${entityKey}.${prop.ref ? "unwrap()." : ""}${this.safeKey(prop2.name)} = ${prop2.ref ? "Reference.create(entity)" : "entity"};`);
            ret.push(`  }`);
          }
        }
        if (prop.customType?.ensureComparable(meta, prop)) {
          context.set(`convertToDatabaseValue_${this.safeKey(prop.name)}`, (val) => prop.customType.convertToDatabaseValue(val, this.platform, { mode: "hydration" }));
          ret.push(`  if (data${dataKey} != null && convertCustomTypes) {`);
          ret.push(`    data${dataKey} = convertToDatabaseValue_${this.safeKey(prop.name)}(entity${entityKey}.__helper.getPrimaryKey());`);
          ret.push(`  }`);
        }
        return ret;
      };
      const hydrateToMany = (prop, dataKey, entityKey) => {
        const ret = [];
        ret.push(...this.createCollectionItemMapper(prop));
        ret.push(`  if (data${dataKey} && !Array.isArray(data${dataKey}) && typeof data${dataKey} === 'object') {`);
        ret.push(`    data${dataKey} = [data${dataKey}];`);
        ret.push(`  }`);
        ret.push(`  if (Array.isArray(data${dataKey})) {`);
        ret.push(`    const items = data${dataKey}.map(value => createCollectionItem_${this.safeKey(prop.name)}(value, entity));`);
        ret.push(`    const coll = Collection.create(entity, '${prop.name}', items, newEntity);`);
        ret.push(`    if (newEntity) {`);
        ret.push(`      coll.setDirty();`);
        ret.push(`    } else {`);
        ret.push(`      coll.takeSnapshot(true);`);
        ret.push(`    }`);
        ret.push(`  } else if (!entity${entityKey} && data${dataKey} instanceof Collection) {`);
        ret.push(`    entity${entityKey} = data${dataKey};`);
        ret.push(`  } else if (!entity${entityKey}) {`);
        const items = this.platform.usesPivotTable() || !prop.owner ? "undefined" : "[]";
        ret.push(`    const coll = Collection.create(entity, '${prop.name}', ${items}, !!data${dataKey} || newEntity);`);
        ret.push(`    coll.setDirty(false);`);
        ret.push(`  }`);
        return ret;
      };
      const registerEmbeddedPrototype = (prop, path) => {
        const convertorKey = path.filter((k) => !k.match(/\[idx_\d+]/)).map((k) => this.safeKey(k)).join("_");
        if (prop.targetMeta?.polymorphs) {
          prop.targetMeta.polymorphs.forEach((meta2) => {
            context.set(`prototype_${convertorKey}_${meta2.className}`, meta2.prototype);
          });
        } else {
          context.set(`prototype_${convertorKey}`, prop.embeddable.prototype);
        }
      };
      const parseObjectEmbeddable = (prop, dataKey, ret) => {
        if (!this.platform.convertsJsonAutomatically() && (prop.object || prop.array)) {
          context.set("parseJsonSafe", Utils_1.parseJsonSafe);
          ret.push(`  if (typeof data${dataKey} === 'string') {`, `    data${dataKey} = parseJsonSafe(data${dataKey});`, `  }`);
        }
      };
      const createCond = (prop, dataKey, cond) => {
        const conds = [];
        if (prop.object) {
          conds.push(`data${dataKey} ${cond ?? "!= null"}`);
        } else {
          const notNull = cond ?? (prop.nullable ? "!= null" : "!== undefined");
          meta.props.filter((p2) => p2.embedded?.[0] === prop.name).forEach((p2) => {
            if (p2.kind === enums_1.ReferenceKind.EMBEDDED && !p2.object && !p2.array) {
              conds.push(...createCond(p2, dataKey + this.wrap(p2.embedded[1]), cond));
              return;
            }
            conds.push(`data${this.wrap(p2.name)} ${notNull}`);
          });
        }
        return conds;
      };
      const hydrateEmbedded = (prop, path, dataKey) => {
        const entityKey = path.map((k) => this.wrap(k)).join("");
        const ret = [];
        registerEmbeddedPrototype(prop, path);
        parseObjectEmbeddable(prop, dataKey, ret);
        ret.push(`  if (${createCond(prop, dataKey).join(" || ")}) {`);
        if (prop.targetMeta?.polymorphs) {
          prop.targetMeta.polymorphs.forEach((meta2) => {
            const childProp = prop.embeddedProps[prop.targetMeta.discriminatorColumn];
            const childDataKey = prop.object ? dataKey + this.wrap(childProp.embedded[1]) : this.wrap(childProp.name);
            ret.push(`    if (data${childDataKey} == '${meta2.discriminatorValue}' && entity${entityKey} == null) {`);
            ret.push(`      entity${entityKey} = factory.createEmbeddable('${meta2.className}', data${prop.object ? dataKey : ""}, { newEntity, convertCustomTypes });`);
            ret.push(`    }`);
          });
        } else {
          ret.push(`    if (entity${entityKey} == null) {`);
          ret.push(`      entity${entityKey} = factory.createEmbeddable('${prop.targetMeta.className}', data${prop.object ? dataKey : ""}, { newEntity, convertCustomTypes });`);
          ret.push(`    }`);
        }
        meta.props.filter((p2) => p2.embedded?.[0] === prop.name).forEach((childProp) => {
          const childDataKey = prop.object ? dataKey + this.wrap(childProp.embedded[1]) : this.wrap(childProp.name);
          ret.push(...hydrateProperty(childProp, prop.object, [...path, childProp.embedded[1]], childDataKey).map((l) => "  " + l));
        });
        const nullVal = this.config.get("forceUndefined") ? "undefined" : "null";
        if (prop.object) {
          ret.push(`  } else if (data${dataKey} === null) {`);
        } else {
          ret.push(`  } else if (${createCond(prop, dataKey, "=== null").join(" && ")}) {`);
        }
        ret.push(`    entity${entityKey} = ${nullVal};`);
        ret.push(`  }`);
        return ret;
      };
      const hydrateEmbeddedArray = (prop, path, dataKey) => {
        const entityKey = path.map((k) => this.wrap(k)).join("");
        const ret = [];
        const idx = this.tmpIndex++;
        registerEmbeddedPrototype(prop, path);
        parseObjectEmbeddable(prop, dataKey, ret);
        ret.push(`  if (Array.isArray(data${dataKey})) {`);
        ret.push(`    entity${entityKey} = [];`);
        ret.push(`    data${dataKey}.forEach((_, idx_${idx}) => {`);
        ret.push(...hydrateEmbedded(prop, [...path, `[idx_${idx}]`], `${dataKey}[idx_${idx}]`).map((l) => "    " + l));
        ret.push(`    });`);
        ret.push(`  }`);
        return ret;
      };
      const hydrateProperty = (prop, object12 = prop.object, path = [prop.name], dataKey) => {
        const entityKey = path.map((k) => this.wrap(k)).join("");
        dataKey = dataKey ?? (object12 ? entityKey : this.wrap(prop.name));
        const ret = [];
        if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind) && !prop.mapToPk) {
          ret.push(...hydrateToOne(prop, dataKey, entityKey));
        } else if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY || prop.kind === enums_1.ReferenceKind.MANY_TO_MANY) {
          ret.push(...hydrateToMany(prop, dataKey, entityKey));
        } else if (prop.kind === enums_1.ReferenceKind.EMBEDDED) {
          if (prop.array) {
            ret.push(...hydrateEmbeddedArray(prop, path, dataKey));
          } else {
            ret.push(...hydrateEmbedded(prop, path, dataKey));
            if (!prop.object) {
              ret.push(...hydrateEmbedded({ ...prop, object: true }, path, dataKey));
            }
          }
        } else {
          ret.push(...hydrateScalar(prop, object12, path, dataKey));
        }
        if (this.config.get("forceUndefined")) {
          ret.push(`  if (data${dataKey} === null) entity${entityKey} = undefined;`);
        }
        return ret;
      };
      for (const prop of props) {
        lines.push(...hydrateProperty(prop));
      }
      const code = `// compiled hydrator for entity ${meta.className} (${type73})\n` + `return function(entity, data, factory, newEntity, convertCustomTypes, schema) {\n` + `${lines.join("\n")}\n}`;
      const hydrator = Utils_1.Utils.createFunction(context, code);
      this.hydrators[type73].set(meta.className, hydrator);
      return hydrator;
    }
    createCollectionItemMapper(prop) {
      const meta = this.metadata.get(prop.type);
      const lines = [];
      lines.push(`  const createCollectionItem_${this.safeKey(prop.name)} = (value, entity) => {`);
      const prop2 = prop.targetMeta?.properties[prop.mappedBy];
      if (prop2?.primary) {
        lines.push(`    if (typeof value === 'object' && value?.['${prop2.name}'] == null) {`);
        lines.push(`      value = { ...value, ['${prop2.name}']: Reference.wrapReference(entity, { ref: ${prop2.ref} }) };`);
        lines.push(`    }`);
      }
      lines.push(`    if (isPrimaryKey(value, ${meta.compositePK})) return factory.createReference('${prop.type}', value, { convertCustomTypes, schema, merge: true });`);
      lines.push(`    if (value && value.__entity) return value;`);
      if (prop2 && !prop2.primary) {
        lines.push(`    if (typeof value === 'object' && value?.['${prop2.name}'] == null) {`);
        lines.push(`      value = { ...value, ['${prop2.name}']: Reference.wrapReference(entity, { ref: ${prop2.ref} }) };`);
        lines.push(`    }`);
      }
      lines.push(`    return factory.create('${prop.type}', value, { newEntity, convertCustomTypes, schema, merge: true });`);
      lines.push(`  }`);
      return lines;
    }
    wrap(key) {
      if (key.match(/^\[.*]$/)) {
        return key;
      }
      return key.match(/^\w+$/) ? `.${key}` : `['${key}']`;
    }
    safeKey(key) {
      return key.replace(/\W/g, "_");
    }
  }
  exports.ObjectHydrator = ObjectHydrator;
});

// node_modules/@mikro-orm/core/hydration/index.js
var require_hydration = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_Hydrator(), exports);
  __exportStar(require_ObjectHydrator(), exports);
});

// node_modules/@mikro-orm/core/utils/NullHighlighter.js
var require_NullHighlighter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NullHighlighter = undefined;

  class NullHighlighter {
    highlight(text) {
      return text;
    }
  }
  exports.NullHighlighter = NullHighlighter;
});

// node_modules/@mikro-orm/core/logging/colors.js
var require_colors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.colors = undefined;
  var bool = (v2) => v2 && ["true", "t", "1"].includes(v2.toLowerCase());
  var boolIfDefined = (v2) => v2 != null ? bool(v2) : true;
  var enabled = () => !bool(process.env.NO_COLOR) && !bool(process.env.MIKRO_ORM_NO_COLOR) && boolIfDefined(process.env.FORCE_COLOR) && boolIfDefined(process.env.MIKRO_ORM_COLORS);
  var wrap = (fn) => (text) => enabled() ? fn(text) : text;
  exports.colors = {
    red: wrap((text) => `\x1B[31m${text}\x1B[39m`),
    green: wrap((text) => `\x1B[32m${text}\x1B[39m`),
    yellow: wrap((text) => `\x1B[33m${text}\x1B[39m`),
    grey: wrap((text) => `\x1B[90m${text}\x1B[39m`),
    cyan: wrap((text) => `\x1B[36m${text}\x1B[39m`),
    enabled
  };
});

// node_modules/@mikro-orm/core/logging/Logger.js
var require_Logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@mikro-orm/core/logging/DefaultLogger.js
var require_DefaultLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultLogger = undefined;
  var colors_1 = require_colors();

  class DefaultLogger {
    options;
    debugMode;
    writer;
    usesReplicas;
    highlighter;
    constructor(options) {
      this.options = options;
      this.debugMode = this.options.debugMode ?? false;
      this.writer = this.options.writer;
      this.usesReplicas = this.options.usesReplicas;
      this.highlighter = this.options.highlighter;
    }
    log(namespace, message, context) {
      if (!this.isEnabled(namespace, context)) {
        return;
      }
      message = message.replace(/\n/g, "").replace(/ +/g, " ").trim();
      if (context?.level === "error") {
        message = colors_1.colors.red(message);
      }
      if (context?.level === "warning") {
        message = colors_1.colors.yellow(message);
      }
      const label = context?.label ? colors_1.colors.cyan(`(${context.label}) `) : "";
      this.writer(colors_1.colors.grey(`[${namespace}] `) + label + message);
    }
    error(namespace, message, context) {
      this.log(namespace, message, { ...context, level: "error" });
    }
    warn(namespace, message, context) {
      this.log(namespace, message, { ...context, level: "warning" });
    }
    setDebugMode(debugMode) {
      this.debugMode = debugMode;
    }
    isEnabled(namespace, context) {
      if (context?.enabled !== undefined) {
        return context.enabled;
      }
      const debugMode = context?.debugMode ?? this.debugMode;
      return !!debugMode && (!Array.isArray(debugMode) || debugMode.includes(namespace));
    }
    logQuery(context) {
      if (!this.isEnabled("query", context)) {
        return;
      }
      let msg = this.highlighter?.highlight(context.query) ?? context.query;
      if (context.took != null) {
        const meta = [`took ${context.took} ms`];
        if (context.results != null) {
          meta.push(`${context.results} result${context.results === 0 || context.results > 1 ? "s" : ""}`);
        }
        if (context.affected != null) {
          meta.push(`${context.affected} row${context.affected === 0 || context.affected > 1 ? "s" : ""} affected`);
        }
        msg += colors_1.colors.grey(` [${meta.join(", ")}]`);
      }
      if (this.usesReplicas && context.connection) {
        msg += colors_1.colors.cyan(` (via ${context.connection.type} connection '${context.connection.name}')`);
      }
      return this.log("query", msg, context);
    }
  }
  exports.DefaultLogger = DefaultLogger;
});

// node_modules/@mikro-orm/core/logging/SimpleLogger.js
var require_SimpleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SimpleLogger = undefined;
  var DefaultLogger_1 = require_DefaultLogger();

  class SimpleLogger extends DefaultLogger_1.DefaultLogger {
    log(namespace, message, context) {
      if (!this.isEnabled(namespace, context)) {
        return;
      }
      message = message.replace(/\n/g, "").replace(/ +/g, " ").trim();
      const label = context?.label ? `(${context.label}) ` : "";
      this.writer(`[${namespace}] ${label}${message}`);
    }
    logQuery(context) {
      if (!this.isEnabled("query", context)) {
        return;
      }
      return this.log("query", context.query, context);
    }
  }
  exports.SimpleLogger = SimpleLogger;
});

// node_modules/@mikro-orm/core/logging/index.js
var require_logging = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_colors(), exports);
  __exportStar(require_Logger(), exports);
  __exportStar(require_DefaultLogger(), exports);
  __exportStar(require_SimpleLogger(), exports);
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS(() => {
  /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Reflect2;
  (function(Reflect3) {
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect !== "undefined") {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter, root);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      }
      function makeExporter(target, previous) {
        return function(key, value14) {
          Object.defineProperty(target, key, { configurable: true, writable: true, value: value14 });
          if (previous)
            previous(key, value14);
        };
      }
      function functionThis() {
        try {
          return Function("return this;")();
        } catch (_) {
        }
      }
      function indirectEvalThis() {
        try {
          return (undefined, eval)("(function() { return this; })()");
        } catch (_) {
        }
      }
      function sloppyModeThis() {
        return functionThis() || indirectEvalThis();
      }
    })(function(exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        create: supportsCreate ? function() {
          return MakeDictionary(Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map3, key) {
          return hasOwn.call(map3, key);
        } : function(map3, key) {
          return key in map3;
        },
        get: downLevel ? function(map3, key) {
          return hasOwn.call(map3, key) ? map3[key] : undefined;
        } : function(map3, key) {
          return map3[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
      var metadataRegistry = GetOrCreateMetadataRegistry();
      var metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined4(propertyKey)) {
          if (!IsArray4(decorators))
            throw new TypeError;
          if (!IsObject4(target))
            throw new TypeError;
          if (!IsObject4(attributes) && !IsUndefined4(attributes) && !IsNull4(attributes))
            throw new TypeError;
          if (IsNull4(attributes))
            attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray4(decorators))
            throw new TypeError;
          if (!IsConstructor2(target))
            throw new TypeError;
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject4(target))
            throw new TypeError;
          if (!IsUndefined4(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError;
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        if (!IsObject4(target))
          throw new TypeError;
        if (!IsUndefined4(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var provider = GetMetadataProvider(target, propertyKey, false);
        if (IsUndefined4(provider))
          return false;
        return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i2 = decorators.length - 1;i2 >= 0; --i2) {
          var decorator = decorators[i2];
          var decorated = decorator(target);
          if (!IsUndefined4(decorated) && !IsNull4(decorated)) {
            if (!IsConstructor2(decorated))
              throw new TypeError;
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i2 = decorators.length - 1;i2 >= 0; --i2) {
          var decorator = decorators[i2];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined4(decorated) && !IsNull4(decorated)) {
            if (!IsObject4(decorated))
              throw new TypeError;
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull4(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined4(provider))
          return false;
        return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull4(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P);
        return;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined4(provider))
          return;
        return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var provider = GetMetadataProvider(O, P, true);
        provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set2 = new _Set;
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys;_i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set2.has(key);
          if (!hasKey) {
            set2.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys;_a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set2.has(key);
          if (!hasKey) {
            set2.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (!provider) {
          return [];
        }
        return provider.OrdinaryOwnMetadataKeys(O, P);
      }
      function Type2(x) {
        if (x === null)
          return 1;
        switch (typeof x) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined4(x) {
        return x === undefined;
      }
      function IsNull4(x) {
        return x === null;
      }
      function IsSymbol4(x) {
        return typeof x === "symbol";
      }
      function IsObject4(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type2(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject4(result))
            throw new TypeError;
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject4(result))
              return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject4(result))
              return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject4(result))
              return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject4(result))
              return result;
          }
        }
        throw new TypeError;
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3);
        if (IsSymbol4(key))
          return key;
        return ToString(key);
      }
      function IsArray4(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      function IsCallable(argument) {
        return typeof argument === "function";
      }
      function IsConstructor2(argument) {
        return typeof argument === "function";
      }
      function IsPropertyKey(argument) {
        switch (Type2(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function SameValueZero(x, y2) {
        return x === y2 || x !== x && y2 !== y2;
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
          return;
        if (!IsCallable(func))
          throw new TypeError;
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError;
        var iterator4 = method.call(obj);
        if (!IsObject4(iterator4))
          throw new TypeError;
        return iterator4;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator4) {
        var result = iterator4.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator4) {
        var f = iterator4["return"];
        if (f)
          f.call(iterator4);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
          return proto;
        if (proto !== functionPrototype)
          return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto;
        var constructor4 = prototypeProto.constructor;
        if (typeof constructor4 !== "function")
          return proto;
        if (constructor4 === O)
          return proto;
        return constructor4;
      }
      function CreateMetadataRegistry() {
        var fallback;
        if (!IsUndefined4(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
          fallback = CreateFallbackProvider(root.Reflect);
        }
        var first;
        var second;
        var rest3;
        var targetProviderMap = new _WeakMap;
        var registry6 = {
          registerProvider,
          getProvider,
          setProvider
        };
        return registry6;
        function registerProvider(provider) {
          if (!Object.isExtensible(registry6)) {
            throw new Error("Cannot add provider to a frozen registry.");
          }
          switch (true) {
            case fallback === provider:
              break;
            case IsUndefined4(first):
              first = provider;
              break;
            case first === provider:
              break;
            case IsUndefined4(second):
              second = provider;
              break;
            case second === provider:
              break;
            default:
              if (rest3 === undefined)
                rest3 = new _Set;
              rest3.add(provider);
              break;
          }
        }
        function getProviderNoCache(O, P) {
          if (!IsUndefined4(first)) {
            if (first.isProviderFor(O, P))
              return first;
            if (!IsUndefined4(second)) {
              if (second.isProviderFor(O, P))
                return first;
              if (!IsUndefined4(rest3)) {
                var iterator4 = GetIterator(rest3);
                while (true) {
                  var next = IteratorStep(iterator4);
                  if (!next) {
                    return;
                  }
                  var provider = IteratorValue(next);
                  if (provider.isProviderFor(O, P)) {
                    IteratorClose(iterator4);
                    return provider;
                  }
                }
              }
            }
          }
          if (!IsUndefined4(fallback) && fallback.isProviderFor(O, P)) {
            return fallback;
          }
          return;
        }
        function getProvider(O, P) {
          var providerMap = targetProviderMap.get(O);
          var provider;
          if (!IsUndefined4(providerMap)) {
            provider = providerMap.get(P);
          }
          if (!IsUndefined4(provider)) {
            return provider;
          }
          provider = getProviderNoCache(O, P);
          if (!IsUndefined4(provider)) {
            if (IsUndefined4(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return provider;
        }
        function hasProvider(provider) {
          if (IsUndefined4(provider))
            throw new TypeError;
          return first === provider || second === provider || !IsUndefined4(rest3) && rest3.has(provider);
        }
        function setProvider(O, P, provider) {
          if (!hasProvider(provider)) {
            throw new Error("Metadata provider not registered.");
          }
          var existingProvider = getProvider(O, P);
          if (existingProvider !== provider) {
            if (!IsUndefined4(existingProvider)) {
              return false;
            }
            var providerMap = targetProviderMap.get(O);
            if (IsUndefined4(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return true;
        }
      }
      function GetOrCreateMetadataRegistry() {
        var metadataRegistry2;
        if (!IsUndefined4(registrySymbol) && IsObject4(root.Reflect) && Object.isExtensible(root.Reflect)) {
          metadataRegistry2 = root.Reflect[registrySymbol];
        }
        if (IsUndefined4(metadataRegistry2)) {
          metadataRegistry2 = CreateMetadataRegistry();
        }
        if (!IsUndefined4(registrySymbol) && IsObject4(root.Reflect) && Object.isExtensible(root.Reflect)) {
          Object.defineProperty(root.Reflect, registrySymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: metadataRegistry2
          });
        }
        return metadataRegistry2;
      }
      function CreateMetadataProvider(registry6) {
        var metadata2 = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var targetMetadata = metadata2.get(O);
            if (IsUndefined4(targetMetadata))
              return false;
            return targetMetadata.has(P);
          },
          OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
          OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
          OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
          OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
          OrdinaryDeleteMetadata
        };
        metadataRegistry.registerProvider(provider);
        return provider;
        function GetOrCreateMetadataMap(O, P, Create4) {
          var targetMetadata = metadata2.get(O);
          var createdTargetMetadata = false;
          if (IsUndefined4(targetMetadata)) {
            if (!Create4)
              return;
            targetMetadata = new _Map;
            metadata2.set(O, targetMetadata);
            createdTargetMetadata = true;
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined4(metadataMap)) {
            if (!Create4)
              return;
            metadataMap = new _Map;
            targetMetadata.set(P, metadataMap);
            if (!registry6.setProvider(O, P, provider)) {
              targetMetadata.delete(P);
              if (createdTargetMetadata) {
                metadata2.delete(O);
              }
              throw new Error("Wrong provider for target.");
            }
          }
          return metadataMap;
        }
        function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined4(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined4(metadataMap))
            return;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryOwnMetadataKeys2(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined4(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator4 = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator4);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e2) {
              try {
                IteratorClose(iterator4);
              } finally {
                throw e2;
              }
            }
            k++;
          }
        }
        function OrdinaryDeleteMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined4(metadataMap))
            return false;
          if (!metadataMap.delete(MetadataKey))
            return false;
          if (metadataMap.size === 0) {
            var targetMetadata = metadata2.get(O);
            if (!IsUndefined4(targetMetadata)) {
              targetMetadata.delete(P);
              if (targetMetadata.size === 0) {
                metadata2.delete(targetMetadata);
              }
            }
          }
          return true;
        }
      }
      function CreateFallbackProvider(reflect) {
        var { defineMetadata: defineMetadata2, hasOwnMetadata: hasOwnMetadata2, getOwnMetadata: getOwnMetadata2, getOwnMetadataKeys: getOwnMetadataKeys2, deleteMetadata: deleteMetadata2 } = reflect;
        var metadataOwner = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var metadataPropertySet = metadataOwner.get(O);
            if (!IsUndefined4(metadataPropertySet)) {
              return metadataPropertySet.has(P);
            }
            if (getOwnMetadataKeys2(O, P).length) {
              if (IsUndefined4(metadataPropertySet)) {
                metadataPropertySet = new _Set;
                metadataOwner.set(O, metadataPropertySet);
              }
              metadataPropertySet.add(P);
              return true;
            }
            return false;
          },
          OrdinaryDefineOwnMetadata: defineMetadata2,
          OrdinaryHasOwnMetadata: hasOwnMetadata2,
          OrdinaryGetOwnMetadata: getOwnMetadata2,
          OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
          OrdinaryDeleteMetadata: deleteMetadata2
        };
        return provider;
      }
      function GetMetadataProvider(O, P, Create4) {
        var registeredProvider = metadataRegistry.getProvider(O, P);
        if (!IsUndefined4(registeredProvider)) {
          return registeredProvider;
        }
        if (Create4) {
          if (metadataRegistry.setProvider(O, P, metadataProvider)) {
            return metadataProvider;
          }
          throw new Error("Illegal state.");
        }
        return;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: undefined, done: true };
          };
          MapIterator2.prototype.throw = function(error21) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error21;
          };
          MapIterator2.prototype.return = function(value14) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value: value14, done: true };
          };
          return MapIterator2;
        }();
        var Map2 = function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(key, false) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(key, false);
            return index >= 0 ? this._values[index] : undefined;
          };
          Map3.prototype.set = function(key, value14) {
            var index = this._find(key, true);
            this._values[index] = value14;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(key, false);
            if (index >= 0) {
              var size = this._keys.length;
              for (var i2 = index + 1;i2 < size; i2++) {
                this._keys[i2 - 1] = this._keys[i2];
                this._values[i2 - 1] = this._values[i2];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i2 = 0;i2 < this._keys.length; i2++) {
                if (SameValueZero(this._keys[i2], key)) {
                  this._cacheIndex = i2;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(undefined);
            }
            return this._cacheIndex;
          };
          return Map3;
        }();
        return Map2;
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value14) {
          return value14;
        }
        function getEntry(key, value14) {
          return [key, value14];
        }
      }
      function CreateSetPolyfill() {
        var Set5 = function() {
          function Set6() {
            this._map = new _Map;
          }
          Object.defineProperty(Set6.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set6.prototype.has = function(value14) {
            return this._map.has(value14);
          };
          Set6.prototype.add = function(value14) {
            return this._map.set(value14, value14), this;
          };
          Set6.prototype.delete = function(value14) {
            return this._map.delete(value14);
          };
          Set6.prototype.clear = function() {
            this._map.clear();
          };
          Set6.prototype.keys = function() {
            return this._map.keys();
          };
          Set6.prototype.values = function() {
            return this._map.keys();
          };
          Set6.prototype.entries = function() {
            return this._map.entries();
          };
          Set6.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set6.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set6;
        }();
        return Set5;
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.get(table, this._key) : undefined;
          };
          WeakMap2.prototype.set = function(target, value14) {
            var table = GetOrCreateWeakMapTable(target, true);
            table[this._key] = value14;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }();
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create4) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create4)
              return;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i2 = 0;i2 < size; ++i2)
            buffer[i2] = Math.random() * 255 | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            if (typeof crypto !== "undefined")
              return crypto.getRandomValues(new Uint8Array(size));
            if (typeof msCrypto !== "undefined")
              return msCrypto.getRandomValues(new Uint8Array(size));
            return FillRandomBytes(new Uint8Array(size), size);
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 79 | 64;
          data[8] = data[8] & 191 | 128;
          var result = "";
          for (var offset = 0;offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));
});

// node_modules/@mikro-orm/core/metadata/MetadataProvider.js
var require_MetadataProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetadataProvider = undefined;
  var Utils_1 = require_Utils();

  class MetadataProvider {
    config;
    constructor(config) {
      this.config = config;
    }
    loadFromCache(meta, cache) {
      Object.values(cache.properties).forEach((prop) => {
        const metaProp = meta.properties[prop.name];
        if (metaProp?.enum && Array.isArray(metaProp.items)) {
          delete prop.items;
        }
      });
      Utils_1.Utils.mergeConfig(meta, cache);
    }
    useCache() {
      return this.config.get("metadataCache").enabled ?? false;
    }
  }
  exports.MetadataProvider = MetadataProvider;
});

// node_modules/@mikro-orm/core/metadata/ReflectMetadataProvider.js
var require_ReflectMetadataProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectMetadataProvider = undefined;
  require_Reflect();
  var MetadataProvider_1 = require_MetadataProvider();
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();

  class ReflectMetadataProvider extends MetadataProvider_1.MetadataProvider {
    loadEntityMetadata(meta, name) {
      this.initProperties(meta);
    }
    initProperties(meta) {
      for (const prop of Object.values(meta.properties)) {
        if (Utils_1.Utils.isString(prop.entity)) {
          prop.type = prop.entity;
        } else if (prop.entity) {
          const tmp = prop.entity();
          prop.type = Array.isArray(tmp) ? tmp.map((t2) => Utils_1.Utils.className(t2)).sort().join(" | ") : Utils_1.Utils.className(tmp);
        } else {
          this.initPropertyType(meta, prop);
        }
      }
    }
    initPropertyType(meta, prop) {
      const type73 = Reflect.getMetadata("design:type", meta.prototype, prop.name);
      if (!prop.type && (!type73 || type73 === Object && prop.kind !== enums_1.ReferenceKind.SCALAR)) {
        throw new Error(`Please provide either 'type' or 'entity' attribute in ${meta.className}.${prop.name}. If you are using decorators, ensure you have 'emitDecoratorMetadata' enabled in your tsconfig.json.`);
      }
      if (prop.kind === enums_1.ReferenceKind.SCALAR && type73 === Object && !prop.columnTypes) {
        prop.type ??= "any";
        return;
      }
      let typeName = type73?.name;
      if (typeName && ["string", "number", "boolean", "array", "object"].includes(typeName.toLowerCase())) {
        typeName = typeName.toLowerCase();
      }
      prop.type ??= typeName;
      prop.runtimeType = typeName;
    }
  }
  exports.ReflectMetadataProvider = ReflectMetadataProvider;
});

// node_modules/@mikro-orm/core/utils/RequestContext.js
var require_RequestContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequestContext = undefined;
  var async_hooks_1 = import.meta.require("async_hooks");

  class RequestContext {
    map;
    static storage = new async_hooks_1.AsyncLocalStorage;
    static counter = 1;
    id = RequestContext.counter++;
    constructor(map3) {
      this.map = map3;
    }
    get em() {
      return this.map.get("default");
    }
    static create(em, next, options = {}) {
      const ctx = this.createContext(em, options);
      return this.storage.run(ctx, next);
    }
    static currentRequestContext() {
      return this.storage.getStore();
    }
    static getEntityManager(name = "default") {
      const context = RequestContext.currentRequestContext();
      return context ? context.map.get(name) : undefined;
    }
    static createContext(em, options = {}) {
      const forks = new Map;
      if (Array.isArray(em)) {
        em.forEach((em2) => forks.set(em2.name, em2.fork({ useContext: true, ...options })));
      } else {
        forks.set(em.name, em.fork({ useContext: true, ...options }));
      }
      return new RequestContext(forks);
    }
  }
  exports.RequestContext = RequestContext;
});

// node_modules/@mikro-orm/core/types/Type.js
var require_Type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = undefined;
  var util_1 = import.meta.require("util");

  class Type2 {
    static types = new Map;
    platform;
    meta;
    prop;
    convertToDatabaseValue(value14, platform, context) {
      return value14;
    }
    convertToJSValue(value14, platform) {
      return value14;
    }
    compareAsType() {
      return "any";
    }
    get runtimeType() {
      const compareType = this.compareAsType();
      return compareType === "any" ? "string" : compareType;
    }
    get name() {
      return this.constructor.name;
    }
    ensureComparable(meta, prop) {
      return true;
    }
    toJSON(value14, platform) {
      return value14;
    }
    getColumnType(prop, platform) {
      return prop.columnTypes?.[0] ?? platform.getTextTypeDeclarationSQL(prop);
    }
    static getType(cls) {
      const key = cls.name;
      if (!Type2.types.has(key)) {
        Type2.types.set(key, new cls);
      }
      return Type2.types.get(key);
    }
    static isMappedType(data) {
      return !!data?.__mappedType;
    }
    [util_1.inspect.custom](depth) {
      const object12 = { ...this };
      const hidden = ["prop", "platform", "meta"];
      hidden.forEach((k) => delete object12[k]);
      const ret = (0, util_1.inspect)(object12, { depth });
      const name = this.constructor.name;
      return ret === "[Object]" ? `[${name}]` : name + " " + ret;
    }
  }
  exports.Type = Type2;
  Object.defineProperties(Type2.prototype, {
    __mappedType: { value: true, enumerable: false, writable: false }
  });
});

// node_modules/@mikro-orm/core/types/JsonType.js
var require_JsonType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonType = undefined;
  var Type_1 = require_Type();

  class JsonType extends Type_1.Type {
    convertToDatabaseValue(value14, platform, context) {
      if (value14 == null) {
        return value14;
      }
      return platform.convertJsonToDatabaseValue(value14, context);
    }
    convertToJSValueSQL(key, platform) {
      return key + platform.castJsonValue(this.prop);
    }
    convertToDatabaseValueSQL(key, platform) {
      return key + platform.castColumn(this.prop);
    }
    convertToJSValue(value14, platform) {
      return platform.convertJsonToJSValue(value14);
    }
    getColumnType(prop, platform) {
      return platform.getJsonDeclarationSQL();
    }
    ensureComparable(meta, prop) {
      return !prop.embedded || !meta.properties[prop.embedded[0]].object;
    }
    compareAsType() {
      return "any";
    }
    get runtimeType() {
      return "object";
    }
  }
  exports.JsonType = JsonType;
});

// node_modules/@mikro-orm/core/utils/EntityComparator.js
var require_EntityComparator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityComparator = undefined;
  var clone_1 = require_clone2();
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();
  var JsonType_1 = require_JsonType();

  class EntityComparator {
    metadata;
    platform;
    comparators = new Map;
    mappers = new Map;
    snapshotGenerators = new Map;
    pkGetters = new Map;
    pkGettersConverted = new Map;
    pkSerializers = new Map;
    tmpIndex = 0;
    constructor(metadata, platform) {
      this.metadata = metadata;
      this.platform = platform;
    }
    diffEntities(entityName, a2, b2) {
      const comparator = this.getEntityComparator(entityName);
      return Utils_1.Utils.callCompiledFunction(comparator, a2, b2);
    }
    matching(entityName, a2, b2) {
      const diff = this.diffEntities(entityName, a2, b2);
      return Utils_1.Utils.getObjectKeysSize(diff) === 0;
    }
    prepareEntity(entity) {
      const generator = this.getSnapshotGenerator(entity.constructor.name);
      return Utils_1.Utils.callCompiledFunction(generator, entity);
    }
    mapResult(entityName, result) {
      const mapper = this.getResultMapper(entityName);
      return Utils_1.Utils.callCompiledFunction(mapper, result);
    }
    getPkGetter(meta) {
      const exists = this.pkGetters.get(meta.className);
      if (exists) {
        return exists;
      }
      const lines = [];
      const context = new Map;
      if (meta.primaryKeys.length > 1) {
        lines.push(`  const cond = {`);
        meta.primaryKeys.forEach((pk) => {
          if (meta.properties[pk].kind !== enums_1.ReferenceKind.SCALAR) {
            lines.push(`    ${pk}: (entity${this.wrap(pk)} != null && (entity${this.wrap(pk)}.__entity || entity${this.wrap(pk)}.__reference)) ? entity${this.wrap(pk)}.__helper.getPrimaryKey() : entity${this.wrap(pk)},`);
          } else {
            lines.push(`    ${pk}: entity${this.wrap(pk)},`);
          }
        });
        lines.push(`  };`);
        lines.push(`  if (${meta.primaryKeys.map((pk) => `cond.${pk} == null`).join(" || ")}) return null;`);
        lines.push(`  return cond;`);
      } else {
        const pk = meta.primaryKeys[0];
        if (meta.properties[pk].kind !== enums_1.ReferenceKind.SCALAR) {
          lines.push(`  if (entity${this.wrap(pk)} != null && (entity${this.wrap(pk)}.__entity || entity${this.wrap(pk)}.__reference)) return entity${this.wrap(pk)}.__helper.getPrimaryKey();`);
        }
        lines.push(`  return entity${this.wrap(pk)};`);
      }
      const code = `// compiled pk serializer for entity ${meta.className}\n` + `return function(entity) {\n${lines.join("\n")}\n}`;
      const pkSerializer = Utils_1.Utils.createFunction(context, code);
      this.pkGetters.set(meta.className, pkSerializer);
      return pkSerializer;
    }
    getPkGetterConverted(meta) {
      const exists = this.pkGettersConverted.get(meta.className);
      if (exists) {
        return exists;
      }
      const lines = [];
      const context = new Map;
      if (meta.primaryKeys.length > 1) {
        lines.push(`  const cond = {`);
        meta.primaryKeys.forEach((pk) => {
          if (meta.properties[pk].kind !== enums_1.ReferenceKind.SCALAR) {
            lines.push(`    ${pk}: (entity${this.wrap(pk)} != null && (entity${this.wrap(pk)}.__entity || entity${this.wrap(pk)}.__reference)) ? entity${this.wrap(pk)}.__helper.getPrimaryKey(true) : entity${this.wrap(pk)},`);
          } else {
            if (meta.properties[pk].customType) {
              const convertorKey = this.safeKey(pk);
              context.set(`convertToDatabaseValue_${convertorKey}`, (val) => meta.properties[pk].customType.convertToDatabaseValue(val, this.platform, { mode: "serialization" }));
              lines.push(`    ${pk}: convertToDatabaseValue_${convertorKey}(entity${this.wrap(pk)}),`);
            } else {
              lines.push(`    ${pk}: entity${this.wrap(pk)},`);
            }
          }
        });
        lines.push(`  };`);
        lines.push(`  if (${meta.primaryKeys.map((pk) => `cond.${pk} == null`).join(" || ")}) return null;`);
        lines.push(`  return cond;`);
      } else {
        const pk = meta.primaryKeys[0];
        if (meta.properties[pk].kind !== enums_1.ReferenceKind.SCALAR) {
          lines.push(`  if (entity${this.wrap(pk)} != null && (entity${this.wrap(pk)}.__entity || entity${this.wrap(pk)}.__reference)) return entity${this.wrap(pk)}.__helper.getPrimaryKey(true);`);
        }
        if (meta.properties[pk].customType) {
          const convertorKey = this.safeKey(pk);
          context.set(`convertToDatabaseValue_${convertorKey}`, (val) => meta.properties[pk].customType.convertToDatabaseValue(val, this.platform, { mode: "serialization" }));
          lines.push(`  return convertToDatabaseValue_${convertorKey}(entity${this.wrap(pk)});`);
        } else {
          lines.push(`  return entity${this.wrap(pk)};`);
        }
      }
      const code = `// compiled pk getter (with converted custom types) for entity ${meta.className}\n` + `return function(entity) {\n${lines.join("\n")}\n}`;
      const pkSerializer = Utils_1.Utils.createFunction(context, code);
      this.pkGettersConverted.set(meta.className, pkSerializer);
      return pkSerializer;
    }
    getPkSerializer(meta) {
      const exists = this.pkSerializers.get(meta.className);
      if (exists) {
        return exists;
      }
      const lines = [];
      const context = new Map;
      context.set("getCompositeKeyValue", (val) => Utils_1.Utils.flatten(Utils_1.Utils.getCompositeKeyValue(val, meta, true, this.platform)));
      if (meta.primaryKeys.length > 1) {
        lines.push(`  const pks = entity.__helper.__pk ? getCompositeKeyValue(entity.__helper.__pk) : [`);
        meta.primaryKeys.forEach((pk) => {
          if (meta.properties[pk].kind !== enums_1.ReferenceKind.SCALAR) {
            lines.push(`    (entity${this.wrap(pk)} != null && (entity${this.wrap(pk)}.__entity || entity${this.wrap(pk)}.__reference)) ? entity${this.wrap(pk)}.__helper.getSerializedPrimaryKey() : entity${this.wrap(pk)},`);
          } else {
            lines.push(`    entity${this.wrap(pk)},`);
          }
        });
        lines.push(`  ];`);
        lines.push(`  return pks.join('${Utils_1.Utils.PK_SEPARATOR}');`);
      } else {
        const pk = meta.primaryKeys[0];
        if (meta.properties[pk].kind !== enums_1.ReferenceKind.SCALAR) {
          lines.push(`  if (entity${this.wrap(pk)} != null && (entity${this.wrap(pk)}.__entity || entity${this.wrap(pk)}.__reference)) return entity${this.wrap(pk)}.__helper.getSerializedPrimaryKey();`);
        }
        const serializedPrimaryKey = meta.props.find((p2) => p2.serializedPrimaryKey);
        if (serializedPrimaryKey) {
          lines.push(`  return '' + entity.${serializedPrimaryKey.name};`);
        }
        lines.push(`  return '' + entity.${meta.primaryKeys[0]};`);
      }
      const code = `// compiled pk serializer for entity ${meta.className}\n` + `return function(entity) {\n${lines.join("\n")}\n}`;
      const pkSerializer = Utils_1.Utils.createFunction(context, code);
      this.pkSerializers.set(meta.className, pkSerializer);
      return pkSerializer;
    }
    getSnapshotGenerator(entityName) {
      const exists = this.snapshotGenerators.get(entityName);
      if (exists) {
        return exists;
      }
      const meta = this.metadata.find(entityName);
      const lines = [];
      const context = new Map;
      context.set("clone", clone_1.clone);
      context.set("cloneEmbeddable", (o2) => this.platform.cloneEmbeddable(o2));
      if (meta.discriminatorValue) {
        lines.push(`  ret${this.wrap(meta.root.discriminatorColumn)} = '${meta.discriminatorValue}'`);
      }
      const getRootProperty = (prop) => prop.embedded ? getRootProperty(meta.properties[prop.embedded[0]]) : prop;
      meta.comparableProps.filter((prop) => {
        const root = getRootProperty(prop);
        return prop === root || root.kind !== enums_1.ReferenceKind.EMBEDDED;
      }).forEach((prop) => lines.push(this.getPropertySnapshot(meta, prop, context, this.wrap(prop.name), this.wrap(prop.name), [prop.name])));
      const code = `return function(entity) {\n  const ret = {};\n${lines.join("\n")}\n  return ret;\n}`;
      const snapshotGenerator = Utils_1.Utils.createFunction(context, code);
      this.snapshotGenerators.set(entityName, snapshotGenerator);
      return snapshotGenerator;
    }
    getResultMapper(entityName) {
      const exists = this.mappers.get(entityName);
      if (exists) {
        return exists;
      }
      const meta = this.metadata.get(entityName);
      const lines = [];
      const context = new Map;
      const propName = (name, parent = "result") => parent + this.wrap(name);
      const createCompositeKeyArray = (prop, fieldNames = prop.fieldNames, idx = 0) => {
        if (!prop.targetMeta) {
          return propName(fieldNames[idx++]);
        }
        const parts = [];
        for (const pk of prop.targetMeta.getPrimaryProps()) {
          parts.push(createCompositeKeyArray(pk, fieldNames, idx));
          idx += pk.fieldNames.length;
        }
        if (parts.length < 2) {
          return parts[0];
        }
        return "[" + parts.join(", ") + "]";
      };
      const tz = this.platform.getTimezone();
      const parseDate = (key, value14, padding = "") => {
        lines.push(`${padding}    if (${value14} == null || ${value14} instanceof Date) {`);
        lines.push(`${padding}      ${key} = ${value14};`);
        if (!tz || tz === "local") {
          lines.push(`${padding}    } else {`);
          lines.push(`${padding}      ${key} = parseDate(${value14});`);
        } else {
          lines.push(`${padding}    } else if (typeof ${value14} === 'number' || ${value14}.includes('+')) {`);
          lines.push(`${padding}      ${key} = parseDate(${value14});`);
          lines.push(`${padding}    } else {`);
          lines.push(`${padding}      ${key} = parseDate(${value14} + '${tz}');`);
        }
        lines.push(`${padding}    }`);
      };
      lines.push(`  const mapped = {};`);
      meta.props.forEach((prop) => {
        if (!prop.fieldNames) {
          return;
        }
        if (prop.targetMeta && prop.fieldNames.length > 1) {
          lines.push(`  if (${prop.fieldNames.map((field) => `typeof ${propName(field)} === 'undefined'`).join(" && ")}) {`);
          lines.push(`  } else if (${prop.fieldNames.map((field) => `${propName(field)} != null`).join(" && ")}) {`);
          lines.push(`    ret${this.wrap(prop.name)} = ${createCompositeKeyArray(prop)};`);
          lines.push(...prop.fieldNames.map((field) => `    ${propName(field, "mapped")} = true;`));
          lines.push(`  } else if (${prop.fieldNames.map((field) => `${propName(field)} == null`).join(" && ")}) {\n    ret${this.wrap(prop.name)} = null;`);
          lines.push(...prop.fieldNames.map((field) => `    ${propName(field, "mapped")} = true;`), "  }");
          return;
        }
        if (prop.embedded && (meta.embeddable || meta.properties[prop.embedded[0]].object)) {
          return;
        }
        if (prop.runtimeType === "boolean") {
          lines.push(`  if (typeof ${propName(prop.fieldNames[0])} !== 'undefined') {`);
          lines.push(`    ret${this.wrap(prop.name)} = ${propName(prop.fieldNames[0])} == null ? ${propName(prop.fieldNames[0])} : !!${propName(prop.fieldNames[0])};`);
          lines.push(`    ${propName(prop.fieldNames[0], "mapped")} = true;`);
          lines.push(`  }`);
        } else if (prop.runtimeType === "Date") {
          lines.push(`  if (typeof ${propName(prop.fieldNames[0])} !== 'undefined') {`);
          context.set("parseDate", (value14) => this.platform.parseDate(value14));
          parseDate("ret" + this.wrap(prop.name), propName(prop.fieldNames[0]));
          lines.push(`    ${propName(prop.fieldNames[0], "mapped")} = true;`);
          lines.push(`  }`);
        } else if (prop.kind === enums_1.ReferenceKind.EMBEDDED && (prop.object || meta.embeddable)) {
          const idx = this.tmpIndex++;
          context.set(`mapEmbeddedResult_${idx}`, (data) => {
            const item = (0, Utils_1.parseJsonSafe)(data);
            if (Array.isArray(item)) {
              return item.map((row) => row == null ? row : this.getResultMapper(prop.type)(row));
            }
            return item == null ? item : this.getResultMapper(prop.type)(item);
          });
          lines.push(`  if (typeof ${propName(prop.fieldNames[0])} !== 'undefined') {`);
          lines.push(`    ret${this.wrap(prop.name)} = ${propName(prop.fieldNames[0])} == null ? ${propName(prop.fieldNames[0])} : mapEmbeddedResult_${idx}(${propName(prop.fieldNames[0])});`);
          lines.push(`    ${propName(prop.fieldNames[0], "mapped")} = true;`);
          lines.push(`  }`);
        } else {
          lines.push(`  if (typeof ${propName(prop.fieldNames[0])} !== 'undefined') {`);
          lines.push(`    ret${this.wrap(prop.name)} = ${propName(prop.fieldNames[0])};`);
          lines.push(`    ${propName(prop.fieldNames[0], "mapped")} = true;`);
          lines.push(`  }`);
        }
      });
      lines.push(`  for (let k in result) { if (result.hasOwnProperty(k) && !mapped[k]) ret[k] = result[k]; }`);
      const code = `// compiled mapper for entity ${meta.className}\n` + `return function(result) {\n  const ret = {};\n${lines.join("\n")}\n  return ret;\n}`;
      const resultMapper = Utils_1.Utils.createFunction(context, code);
      this.mappers.set(entityName, resultMapper);
      return resultMapper;
    }
    getPropertyCondition(path) {
      const parts = path.slice();
      if (parts.length > 1) {
        parts.pop();
      }
      let tail = "";
      return parts.map((k) => {
        if (k.match(/^\[idx_\d+]$/)) {
          tail += k;
          return "";
        }
        const mapped19 = `typeof entity${tail ? "." + tail : ""}${this.wrap(k)} !== 'undefined'`;
        tail += tail ? "." + k : k;
        return mapped19;
      }).filter((k) => k).join(" && ");
    }
    getEmbeddedArrayPropertySnapshot(meta, prop, context, level, path, dataKey) {
      const entityKey = path.map((k) => this.wrap(k)).join("");
      const ret = [];
      const padding = " ".repeat(level * 2);
      const idx = this.tmpIndex++;
      ret.push(`${padding}if (Array.isArray(entity${entityKey})) {`);
      ret.push(`${padding}  ret${dataKey} = [];`);
      ret.push(`${padding}  entity${entityKey}.forEach((_, idx_${idx}) => {`);
      ret.push(this.getEmbeddedPropertySnapshot(meta, prop, context, level + 2, [...path, `[idx_${idx}]`], `${dataKey}[idx_${idx}]`, true));
      ret.push(`${padding}  });`);
      if (this.shouldSerialize(prop, dataKey)) {
        ret.push(`${padding}  ret${dataKey} = cloneEmbeddable(ret${dataKey});`);
      }
      ret.push(`${padding}}`);
      return ret.join("\n");
    }
    shouldSerialize(prop, dataKey) {
      dataKey = dataKey.replace(/^\./, "");
      const contains = (str, re) => (str.match(re) || []).length > 0;
      const a2 = contains(dataKey, /\./g);
      const b2 = contains(dataKey, /\[/g);
      return !!prop.object && !(a2 || b2);
    }
    getEmbeddedPropertySnapshot(meta, prop, context, level, path, dataKey, object12 = prop.object) {
      const padding = " ".repeat(level * 2);
      let ret = `${level === 1 ? "" : "\n"}`;
      if (object12) {
        const nullCond = `entity${path.map((k) => this.wrap(k)).join("")} === null`;
        ret += `${padding}if (${nullCond}) ret${dataKey} = null;\n`;
      }
      const cond = `entity${path.map((k) => this.wrap(k)).join("")} != null`;
      ret += `${padding}if (${cond}) {\n`;
      if (object12) {
        ret += `${padding}  ret${dataKey} = {};\n`;
      }
      function shouldProcessCustomType(childProp) {
        if (!childProp.customType) {
          return false;
        }
        if (childProp.customType instanceof JsonType_1.JsonType) {
          return !prop.object;
        }
        return true;
      }
      ret += meta.props.filter((p2) => p2.embedded?.[0] === prop.name).map((childProp) => {
        const childDataKey = meta.embeddable || prop.object ? dataKey + this.wrap(childProp.embedded[1]) : this.wrap(childProp.name);
        const childEntityKey = [...path, childProp.embedded[1]].map((k) => this.wrap(k)).join("");
        const childCond = `typeof entity${childEntityKey} !== 'undefined'`;
        if (childProp.kind === enums_1.ReferenceKind.EMBEDDED) {
          return this.getPropertySnapshot(meta, childProp, context, childDataKey, childEntityKey, [...path, childProp.embedded[1]], level + 1, prop.object);
        }
        if (childProp.kind !== enums_1.ReferenceKind.SCALAR) {
          return this.getPropertySnapshot(meta, childProp, context, childDataKey, childEntityKey, [...path, childProp.embedded[1]], level, prop.object).split("\n").map((l) => padding + l).join("\n");
        }
        if (shouldProcessCustomType(childProp)) {
          const convertorKey = this.safeKey(childProp.name);
          context.set(`convertToDatabaseValue_${convertorKey}`, (val) => childProp.customType.convertToDatabaseValue(val, this.platform, { mode: "serialization" }));
          if (["number", "string", "boolean", "bigint"].includes(childProp.customType.compareAsType().toLowerCase())) {
            return `${padding}  if (${childCond}) ret${childDataKey} = convertToDatabaseValue_${convertorKey}(entity${childEntityKey});`;
          }
          return `${padding}  if (${childCond}) ret${childDataKey} = clone(convertToDatabaseValue_${convertorKey}(entity${childEntityKey}));`;
        }
        return `${padding}  if (${childCond}) ret${childDataKey} = clone(entity${childEntityKey});`;
      }).join("\n") + `\n`;
      if (this.shouldSerialize(prop, dataKey)) {
        return `${ret + padding}  ret${dataKey} = cloneEmbeddable(ret${dataKey});\n${padding}}`;
      }
      return `${ret}${padding}}`;
    }
    getPropertySnapshot(meta, prop, context, dataKey, entityKey, path, level = 1, object12) {
      const convertorKey = this.safeKey(prop.name);
      const unwrap = prop.ref ? "?.unwrap()" : "";
      let ret = `  if (${this.getPropertyCondition(path)}) {\n`;
      if (["number", "string", "boolean"].includes(prop.type.toLowerCase())) {
        return ret + `    ret${dataKey} = entity${entityKey}${unwrap};\n  }\n`;
      }
      if (prop.kind === enums_1.ReferenceKind.EMBEDDED) {
        if (prop.array) {
          return this.getEmbeddedArrayPropertySnapshot(meta, prop, context, level, path, dataKey) + "\n";
        }
        return this.getEmbeddedPropertySnapshot(meta, prop, context, level, path, dataKey, object12) + "\n";
      }
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_ONE || prop.kind === enums_1.ReferenceKind.MANY_TO_ONE) {
        if (prop.mapToPk) {
          if (prop.customType) {
            context.set(`convertToDatabaseValue_${convertorKey}`, (val) => prop.customType.convertToDatabaseValue(val, this.platform, { mode: "serialization" }));
            ret += `    ret${dataKey} = convertToDatabaseValue_${convertorKey}(entity${entityKey});\n`;
          } else {
            ret += `    ret${dataKey} = entity${entityKey};\n`;
          }
        } else {
          const toArray = (val) => {
            if (Utils_1.Utils.isPlainObject(val)) {
              return Object.values(val).map((v2) => toArray(v2));
            }
            return val;
          };
          context.set("toArray", toArray);
          ret += `    if (entity${entityKey} === null) {\n`;
          ret += `      ret${dataKey} = null;\n`;
          ret += `    } else if (typeof entity${entityKey} !== 'undefined') {\n`;
          ret += `      ret${dataKey} = toArray(entity${entityKey}.__helper.getPrimaryKey(true));\n`;
          ret += `    }\n`;
        }
        return ret + "  }\n";
      }
      if (prop.customType) {
        context.set(`convertToDatabaseValue_${convertorKey}`, (val) => prop.customType.convertToDatabaseValue(val, this.platform, { mode: "serialization" }));
        if (["number", "string", "boolean", "bigint"].includes(prop.customType.compareAsType().toLowerCase())) {
          return ret + `    ret${dataKey} = convertToDatabaseValue_${convertorKey}(entity${entityKey}${unwrap});\n  }\n`;
        }
        return ret + `    ret${dataKey} = clone(convertToDatabaseValue_${convertorKey}(entity${entityKey}${unwrap}));\n  }\n`;
      }
      if (prop.runtimeType === "Date") {
        context.set("processDateProperty", this.platform.processDateProperty.bind(this.platform));
        return ret + `    ret${dataKey} = clone(processDateProperty(entity${entityKey}${unwrap}));\n  }\n`;
      }
      return ret + `    ret${dataKey} = clone(entity${entityKey}${unwrap});\n  }\n`;
    }
    getEntityComparator(entityName) {
      const exists = this.comparators.get(entityName);
      if (exists) {
        return exists;
      }
      const meta = this.metadata.find(entityName);
      const lines = [];
      const context = new Map;
      context.set("compareArrays", Utils_1.compareArrays);
      context.set("compareBooleans", Utils_1.compareBooleans);
      context.set("compareBuffers", Utils_1.compareBuffers);
      context.set("compareObjects", Utils_1.compareObjects);
      context.set("equals", Utils_1.equals);
      meta.comparableProps.forEach((prop) => {
        lines.push(this.getPropertyComparator(prop, context));
      });
      const code = `// compiled comparator for entity ${meta.className}\n` + `return function(last, current) {\n  const diff = {};\n${lines.join("\n")}\n  return diff;\n}`;
      const comparator = Utils_1.Utils.createFunction(context, code);
      this.comparators.set(entityName, comparator);
      return comparator;
    }
    getGenericComparator(prop, cond) {
      return `  if (current${prop} == null && last${prop} == null) {\n\n` + `  } else if ((current${prop} != null && last${prop} == null) || (current${prop} == null && last${prop} != null)) {\n` + `    diff${prop} = current${prop};\n` + `  } else if (${cond}) {\n` + `    diff${prop} = current${prop};\n` + `  }\n`;
    }
    getPropertyComparator(prop, context) {
      let type73 = prop.type.toLowerCase();
      if (prop.kind !== enums_1.ReferenceKind.SCALAR && prop.kind !== enums_1.ReferenceKind.EMBEDDED) {
        const meta2 = this.metadata.find(prop.type);
        if (meta2.primaryKeys.length > 1) {
          type73 = "array";
        } else {
          type73 = meta2.properties[meta2.primaryKeys[0]].type.toLowerCase();
        }
      }
      if (prop.customType) {
        if (prop.customType.compareValues) {
          const idx = this.tmpIndex++;
          context.set(`compareValues_${idx}`, (a2, b2) => prop.customType.compareValues(a2, b2));
          return this.getGenericComparator(this.wrap(prop.name), `!compareValues_${idx}(last${this.wrap(prop.name)}, current${this.wrap(prop.name)})`);
        }
        type73 = prop.customType.compareAsType().toLowerCase();
      }
      if (type73.endsWith("[]")) {
        type73 = "array";
      }
      if (["string", "number", "bigint"].includes(type73)) {
        return this.getGenericComparator(this.wrap(prop.name), `last${this.wrap(prop.name)} !== current${this.wrap(prop.name)}`);
      }
      if (type73 === "boolean") {
        return this.getGenericComparator(this.wrap(prop.name), `!compareBooleans(last${this.wrap(prop.name)}, current${this.wrap(prop.name)})`);
      }
      if (["array"].includes(type73) || type73.endsWith("[]")) {
        return this.getGenericComparator(this.wrap(prop.name), `!compareArrays(last${this.wrap(prop.name)}, current${this.wrap(prop.name)})`);
      }
      if (["buffer", "uint8array"].includes(type73)) {
        return this.getGenericComparator(this.wrap(prop.name), `!compareBuffers(last${this.wrap(prop.name)}, current${this.wrap(prop.name)})`);
      }
      if (["date"].includes(type73)) {
        return this.getGenericComparator(this.wrap(prop.name), `last${this.wrap(prop.name)}.valueOf() !== current${this.wrap(prop.name)}.valueOf()`);
      }
      if (["objectid"].includes(type73)) {
        const cond = `last${this.wrap(prop.name)}.toHexString?.() !== current${this.wrap(prop.name)}.toHexString?.()`;
        return this.getGenericComparator(this.wrap(prop.name), cond);
      }
      return this.getGenericComparator(this.wrap(prop.name), `!equals(last${this.wrap(prop.name)}, current${this.wrap(prop.name)})`);
    }
    wrap(key) {
      if (key.match(/^\[.*]$/)) {
        return key;
      }
      return key.match(/^\w+$/) ? `.${key}` : `['${key}']`;
    }
    safeKey(key) {
      return key.replace(/\W/g, "_");
    }
    static isComparable(prop, root) {
      const virtual = prop.persist === false;
      const inverse = prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && !prop.owner;
      const discriminator = prop.name === root.discriminatorColumn;
      const collection = prop.kind === enums_1.ReferenceKind.ONE_TO_MANY || prop.kind === enums_1.ReferenceKind.MANY_TO_MANY;
      return !virtual && !collection && !inverse && !discriminator && !prop.version;
    }
  }
  exports.EntityComparator = EntityComparator;
});

// node_modules/@mikro-orm/core/utils/Configuration.js
var require_Configuration = __commonJS((exports) => {
  var defineConfig = function(options) {
    return options;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineConfig = exports.Configuration = undefined;
  var fs_extra_1 = require_lib4();
  var cache_1 = require_cache2();
  var hydration_1 = require_hydration();
  var NullHighlighter_1 = require_NullHighlighter();
  var logging_1 = require_logging();
  var Utils_1 = require_Utils();
  var ReflectMetadataProvider_1 = require_ReflectMetadataProvider();
  var errors_1 = require_errors3();
  var RequestContext_1 = require_RequestContext();
  var enums_1 = require_enums();
  var MemoryCacheAdapter_1 = require_MemoryCacheAdapter();
  var EntityComparator_1 = require_EntityComparator();

  class Configuration {
    static DEFAULTS = {
      pool: {},
      entities: [],
      entitiesTs: [],
      extensions: [],
      subscribers: [],
      filters: {},
      discovery: {
        warnWhenNoEntities: true,
        requireEntitiesArray: false,
        checkDuplicateTableNames: true,
        checkDuplicateFieldNames: true,
        alwaysAnalyseProperties: true,
        disableDynamicFileAccess: false,
        checkDuplicateEntities: true,
        inferDefaultValues: true
      },
      strict: false,
      validate: false,
      validateRequired: true,
      context: (name) => RequestContext_1.RequestContext.getEntityManager(name),
      contextName: "default",
      allowGlobalContext: false,
      logger: console.log.bind(console),
      colors: true,
      findOneOrFailHandler: (entityName, where) => errors_1.NotFoundError.findOneFailed(entityName, where),
      findExactlyOneOrFailHandler: (entityName, where) => errors_1.NotFoundError.findExactlyOneFailed(entityName, where),
      baseDir: process.cwd(),
      hydrator: hydration_1.ObjectHydrator,
      flushMode: enums_1.FlushMode.AUTO,
      loadStrategy: enums_1.LoadStrategy.JOINED,
      dataloader: enums_1.DataloaderType.NONE,
      populateWhere: enums_1.PopulateHint.ALL,
      connect: true,
      ignoreUndefinedInQuery: false,
      autoJoinOneToOneOwner: true,
      autoJoinRefsForFilters: true,
      propagationOnPrototype: true,
      populateAfterFlush: true,
      serialization: {
        includePrimaryKeys: true
      },
      persistOnCreate: true,
      forceEntityConstructor: false,
      forceUndefined: false,
      forceUtcTimezone: false,
      ensureDatabase: true,
      ensureIndexes: false,
      batchSize: 300,
      debug: false,
      verbose: false,
      driverOptions: {},
      migrations: {
        tableName: "mikro_orm_migrations",
        path: "./migrations",
        glob: "!(*.d).{js,ts,cjs}",
        silent: false,
        transactional: true,
        disableForeignKeys: true,
        allOrNothing: true,
        dropTables: true,
        safe: false,
        snapshot: true,
        emit: "ts",
        fileName: (timestamp, name) => `Migration${timestamp}${name ? "_" + name : ""}`
      },
      schemaGenerator: {
        disableForeignKeys: true,
        createForeignKeyConstraints: true,
        ignoreSchema: []
      },
      entityGenerator: {
        bidirectionalRelations: false,
        identifiedReferences: false,
        scalarTypeInDecorator: false,
        scalarPropertiesForRelations: "never",
        fileName: (className) => className,
        onlyPurePivotTables: false,
        readOnlyPivotTables: false
      },
      metadataCache: {
        pretty: false,
        adapter: cache_1.FileCacheAdapter,
        options: { cacheDir: process.cwd() + "/temp" }
      },
      resultCache: {
        adapter: MemoryCacheAdapter_1.MemoryCacheAdapter,
        expiration: 1000,
        options: {}
      },
      metadataProvider: ReflectMetadataProvider_1.ReflectMetadataProvider,
      highlighter: new NullHighlighter_1.NullHighlighter,
      seeder: {
        path: "./seeders",
        defaultSeeder: "DatabaseSeeder",
        glob: "!(*.d).{js,ts}",
        emit: "ts",
        fileName: (className) => className
      },
      preferReadReplicas: true,
      dynamicImportProvider: (id) => import(id)
    };
    options;
    logger;
    driver;
    platform;
    cache = new Map;
    extensions = new Map;
    constructor(options, validate = true) {
      if (options.dynamicImportProvider) {
        Utils_1.Utils.setDynamicImportProvider(options.dynamicImportProvider);
      }
      this.options = Utils_1.Utils.mergeConfig({}, Configuration.DEFAULTS, options);
      this.options.baseDir = Utils_1.Utils.absolutePath(this.options.baseDir);
      if (validate) {
        this.validateOptions();
      }
      this.options.loggerFactory ??= (options2) => new logging_1.DefaultLogger(options2);
      this.logger = this.options.loggerFactory({
        debugMode: this.options.debug,
        usesReplicas: (this.options.replicas?.length ?? 0) > 0,
        highlighter: this.options.highlighter,
        writer: this.options.logger
      });
      this.driver = new this.options.driver(this);
      this.platform = this.driver.getPlatform();
      this.platform.setConfig(this);
      this.detectSourceFolder(options);
      this.init();
    }
    get(key, defaultValue) {
      if (typeof this.options[key] !== "undefined") {
        return this.options[key];
      }
      return defaultValue;
    }
    getAll() {
      return this.options;
    }
    set(key, value14) {
      this.options[key] = value14;
      this.sync();
    }
    reset(key) {
      this.options[key] = Configuration.DEFAULTS[key];
    }
    getLogger() {
      return this.logger;
    }
    getClientUrl(hidePassword = false) {
      if (hidePassword) {
        return this.options.clientUrl.replace(/\/\/([^:]+):(.+)@/, "//$1:*****@");
      }
      return this.options.clientUrl;
    }
    getDriver() {
      return this.driver;
    }
    registerExtension(name, cb) {
      this.extensions.set(name, cb);
    }
    getExtension(name) {
      if (this.cache.has(name)) {
        return this.cache.get(name);
      }
      const ext = this.extensions.get(name);
      if (ext) {
        this.cache.set(name, ext());
        return this.cache.get(name);
      }
      return;
    }
    getNamingStrategy() {
      return this.getCachedService(this.options.namingStrategy || this.platform.getNamingStrategy());
    }
    getHydrator(metadata) {
      return this.getCachedService(this.options.hydrator, metadata, this.platform, this);
    }
    getComparator(metadata) {
      return this.getCachedService(EntityComparator_1.EntityComparator, metadata, this.platform);
    }
    getMetadataProvider() {
      return this.getCachedService(this.options.metadataProvider, this);
    }
    getMetadataCacheAdapter() {
      return this.getCachedService(this.options.metadataCache.adapter, this.options.metadataCache.options, this.options.baseDir, this.options.metadataCache.pretty);
    }
    getResultCacheAdapter() {
      return this.getCachedService(this.options.resultCache.adapter, { expiration: this.options.resultCache.expiration, ...this.options.resultCache.options });
    }
    getRepositoryClass(repository) {
      if (repository) {
        return repository();
      }
      if (this.options.entityRepository) {
        return this.options.entityRepository;
      }
      return this.platform.getRepositoryClass();
    }
    getCachedService(cls, ...args) {
      if (!this.cache.has(cls.name)) {
        const Class = cls;
        this.cache.set(cls.name, new Class(...args));
      }
      return this.cache.get(cls.name);
    }
    resetServiceCache() {
      this.cache.clear();
    }
    init() {
      if (!this.getMetadataProvider().useCache()) {
        this.options.metadataCache.adapter = cache_1.NullCacheAdapter;
      }
      if (!("enabled" in this.options.metadataCache)) {
        this.options.metadataCache.enabled = this.getMetadataProvider().useCache();
      }
      if (!this.options.clientUrl) {
        this.options.clientUrl = this.driver.getConnection().getDefaultClientUrl();
      }
      if (!("implicitTransactions" in this.options)) {
        this.options.implicitTransactions = this.platform.usesImplicitTransactions();
      }
      const url = this.getClientUrl().match(/:\/\/.*\/([^?]+)/);
      if (url) {
        this.options.dbName = this.get("dbName", decodeURIComponent(url[1]));
      }
      if (!this.options.charset) {
        this.options.charset = this.platform.getDefaultCharset();
      }
      Object.keys(this.options.filters).forEach((key) => {
        this.options.filters[key].default ??= true;
      });
      this.options.subscribers = Utils_1.Utils.unique(this.options.subscribers).map((subscriber) => {
        return subscriber.constructor.name === "Function" ? new subscriber : subscriber;
      });
      this.sync();
      if (!logging_1.colors.enabled()) {
        this.options.highlighter = new NullHighlighter_1.NullHighlighter;
      }
    }
    sync() {
      process.env.MIKRO_ORM_COLORS = "" + this.options.colors;
      this.logger.setDebugMode(this.options.debug);
    }
    detectSourceFolder(options) {
      if (!(0, fs_extra_1.pathExistsSync)(this.options.baseDir + "/src")) {
        return;
      }
      const migrationsPathExists = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + "/" + this.options.migrations.path);
      const seedersPathExists = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + "/" + this.options.seeder.path);
      const distDir = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + "/dist");
      const buildDir = (0, fs_extra_1.pathExistsSync)(this.options.baseDir + "/build");
      const path = distDir ? "./dist" : buildDir ? "./build" : "./src";
      if (!options.migrations?.path && !options.migrations?.pathTs && !migrationsPathExists) {
        this.options.migrations.path = `${path}/migrations`;
        this.options.migrations.pathTs = "./src/migrations";
      }
      if (!options.seeder?.path && !options.seeder?.pathTs && !seedersPathExists) {
        this.options.seeder.path = `${path}/seeders`;
        this.options.seeder.pathTs = "./src/seeders";
      }
    }
    validateOptions() {
      if ("type" in this.options) {
        throw new Error("The `type` option has been removed in v6, please fill in the `driver` option instead or use `defineConfig` helper (to define your ORM config) or `MikroORM` class (to call the `init` method) exported from the driver package (e.g. `import { defineConfig } from \'@mikro-orm/mysql\'; export default defineConfig({ ... })`).");
      }
      if (!this.options.driver) {
        throw new Error("No driver specified, please fill in the `driver` option or use `defineConfig` helper (to define your ORM config) or `MikroORM` class (to call the `init` method) exported from the driver package (e.g. `import { defineConfig } from \'@mikro-orm/mysql\'; export defineConfig({ ... })`).");
      }
      if (!this.options.dbName && !this.options.clientUrl) {
        throw new Error("No database specified, please fill in `dbName` or `clientUrl` option");
      }
      if (this.options.entities.length === 0 && this.options.discovery.warnWhenNoEntities) {
        throw new Error("No entities found, please use `entities` option");
      }
    }
  }
  exports.Configuration = Configuration;
  exports.defineConfig = defineConfig;
});

// node_modules/dotenv/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://github.com/motdotla/dotenv?sponsor=1",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var parse4 = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value14 = match[2] || "";
      value14 = value14.trim();
      const maybeQuote = value14[0];
      value14 = value14.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value14 = value14.replace(/\\n/g, "\n");
        value14 = value14.replace(/\\r/g, "\r");
      }
      obj[key] = value14;
    }
    return obj;
  };
  var _parseVault = function(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i2 = 0;i2 < length; i2++) {
      try {
        const key = keys[i2].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error21) {
        if (i2 + 1 >= length) {
          throw error21;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error21) {
      if (error21.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error21;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  };
  var configDotenv = function(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options) {
      if (options.path != null) {
        let envPath = options.path;
        if (Array.isArray(envPath)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              envPath = filepath;
              break;
            }
          }
        }
        dotenvPath = _resolveHome(envPath);
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
    }
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    } catch (e2) {
      if (debug) {
        _debug(`Failed to load ${dotenvPath} ${e2.message}`);
      }
      return { error: e2 };
    }
  };
  var config = function(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error21) {
      const isRange = error21 instanceof RangeError;
      const invalidKeyLength = error21.message === "Invalid key length";
      const decryptionFailed = error21.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error21;
      }
    }
  };
  var populate = function(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var os = import.meta.require("os");
  var crypto2 = import.meta.require("crypto");
  var packageJson = require_package3();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse4,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/@mikro-orm/core/utils/ConfigurationLoader.js
var require_ConfigurationLoader = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfigurationLoader = undefined;
  var dotenv_1 = __importDefault(require_main());
  var fs_extra_1 = require_lib4();
  var path_1 = import.meta.require("path");
  var os_1 = import.meta.require("os");
  var url_1 = import.meta.require("url");
  var Configuration_1 = require_Configuration();
  var Utils_1 = require_Utils();
  var colors_1 = require_colors();

  class ConfigurationLoader {
    static async getConfiguration(validate = true, options = {}) {
      await this.commonJSCompat(options);
      this.registerDotenv(options);
      const paths = await this.getConfigPaths();
      const env = this.loadEnvironmentVars();
      for (let path of paths) {
        path = Utils_1.Utils.absolutePath(path);
        path = Utils_1.Utils.normalizePath(path);
        if (await (0, fs_extra_1.pathExists)(path)) {
          const config = await Utils_1.Utils.dynamicImport(path);
          let tmp = config.default ?? config;
          if (tmp instanceof Function) {
            tmp = tmp();
          }
          if (tmp instanceof Promise) {
            tmp = await tmp;
          }
          const esmConfigOptions = await this.isESM() ? { entityGenerator: { esmImport: true } } : {};
          return new Configuration_1.Configuration(Utils_1.Utils.mergeConfig({}, esmConfigOptions, tmp, options, env), validate);
        }
      }
      if (Utils_1.Utils.hasObjectKeys(env)) {
        return new Configuration_1.Configuration(Utils_1.Utils.mergeConfig({}, options, env), validate);
      }
      throw new Error(`MikroORM config file not found in ['${paths.join(`', '`)}']`);
    }
    static async getPackageConfig(basePath = process.cwd()) {
      if (await (0, fs_extra_1.pathExists)(`${basePath}/package.json`)) {
        try {
          return await Utils_1.Utils.dynamicImport(`${basePath}/package.json`);
        } catch {
          return {};
        }
      }
      const parentFolder = await (0, fs_extra_1.realpath)(`${basePath}/..`);
      if (basePath === parentFolder) {
        return {};
      }
      return this.getPackageConfig(parentFolder);
    }
    static async getSettings() {
      const config = await ConfigurationLoader.getPackageConfig();
      const settings = { ...config["mikro-orm"] };
      const bool = (v2) => ["true", "t", "1"].includes(v2.toLowerCase());
      settings.useTsNode = process.env.MIKRO_ORM_CLI_USE_TS_NODE != null ? bool(process.env.MIKRO_ORM_CLI_USE_TS_NODE) : settings.useTsNode;
      settings.tsConfigPath = process.env.MIKRO_ORM_CLI_TS_CONFIG_PATH ?? settings.tsConfigPath;
      settings.alwaysAllowTs = process.env.MIKRO_ORM_CLI_ALWAYS_ALLOW_TS != null ? bool(process.env.MIKRO_ORM_CLI_ALWAYS_ALLOW_TS) : settings.alwaysAllowTs;
      settings.verbose = process.env.MIKRO_ORM_CLI_VERBOSE != null ? bool(process.env.MIKRO_ORM_CLI_VERBOSE) : settings.verbose;
      if (process.env.MIKRO_ORM_CLI_CONFIG?.endsWith(".ts")) {
        settings.useTsNode = true;
      }
      return settings;
    }
    static async getConfigPaths() {
      const options = Utils_1.Utils.parseArgs();
      if (options.config) {
        return [options.config];
      }
      const paths = [];
      const settings = await ConfigurationLoader.getSettings();
      if (process.env.MIKRO_ORM_CLI_CONFIG) {
        paths.push(process.env.MIKRO_ORM_CLI_CONFIG);
      }
      paths.push(...settings.configPaths || []);
      if (settings.useTsNode || settings.alwaysAllowTs) {
        paths.push("./src/mikro-orm.config.ts");
        paths.push("./mikro-orm.config.ts");
      }
      const distDir = (0, fs_extra_1.pathExistsSync)(process.cwd() + "/dist");
      const buildDir = (0, fs_extra_1.pathExistsSync)(process.cwd() + "/build");
      const path = distDir ? "dist" : buildDir ? "build" : "src";
      paths.push(`./${path}/mikro-orm.config.js`);
      paths.push("./mikro-orm.config.js");
      const tsNode = Utils_1.Utils.detectTsNode();
      return Utils_1.Utils.unique(paths).filter((p2) => p2.endsWith(".js") || tsNode || settings.alwaysAllowTs);
    }
    static async isESM() {
      const config = await ConfigurationLoader.getPackageConfig();
      const type73 = config?.type ?? "";
      return type73 === "module";
    }
    static async registerTsNode(configPath = "tsconfig.json") {
      const tsConfigPath = (0, path_1.isAbsolute)(configPath) ? configPath : (0, path_1.join)(process.cwd(), configPath);
      const tsNode = Utils_1.Utils.tryRequire({
        module: "ts-node",
        from: tsConfigPath,
        warning: "ts-node not installed, support for working with TS files might not work"
      });
      if (!tsNode) {
        return false;
      }
      const { options } = tsNode.register({
        project: tsConfigPath,
        transpileOnly: true,
        compilerOptions: {
          module: "commonjs"
        }
      }).config;
      if (Object.entries(options?.paths ?? {}).length > 0) {
        Utils_1.Utils.requireFrom("tsconfig-paths", tsConfigPath).register({
          baseUrl: options.baseUrl ?? ".",
          paths: options.paths
        });
      }
      return true;
    }
    static registerDotenv(options) {
      const baseDir = options instanceof Configuration_1.Configuration ? options.get("baseDir") : options?.baseDir;
      const path = process.env.MIKRO_ORM_ENV ?? (baseDir ?? process.cwd()) + "/.env";
      const env = {};
      dotenv_1.default.config({ path, processEnv: env });
      for (const key of Object.keys(env)) {
        if (key.startsWith("MIKRO_ORM_")) {
          process.env[key] = env[key];
        }
      }
    }
    static loadEnvironmentVars() {
      const ret = {};
      const PLATFORMS = {
        mongo: { className: "MongoDriver", module: "@mikro-orm/mongodb" },
        mysql: { className: "MySqlDriver", module: "@mikro-orm/mysql" },
        mariadb: { className: "MariaDbDriver", module: "@mikro-orm/mariadb" },
        postgresql: { className: "PostgreSqlDriver", module: "@mikro-orm/postgresql" },
        sqlite: { className: "SqliteDriver", module: "@mikro-orm/sqlite" },
        "better-sqlite": { className: "BetterSqliteDriver", module: "@mikro-orm/better-sqlite" }
      };
      const array4 = (v2) => v2.split(",").map((vv) => vv.trim());
      const bool = (v2) => ["true", "t", "1"].includes(v2.toLowerCase());
      const num = (v2) => +v2;
      const driver = (v2) => Utils_1.Utils.requireFrom(PLATFORMS[v2].module)[PLATFORMS[v2].className];
      const read = (o2, envKey, key, mapper = (v2) => v2) => {
        if (!(envKey in process.env)) {
          return;
        }
        const val = process.env[envKey];
        o2[key] = mapper(val);
      };
      const cleanup = (o2, k) => Utils_1.Utils.hasObjectKeys(o2[k]) ? {} : delete o2[k];
      read(ret, "MIKRO_ORM_BASE_DIR", "baseDir");
      read(ret, "MIKRO_ORM_TYPE", "driver", driver);
      read(ret, "MIKRO_ORM_ENTITIES", "entities", array4);
      read(ret, "MIKRO_ORM_ENTITIES_TS", "entitiesTs", array4);
      read(ret, "MIKRO_ORM_CLIENT_URL", "clientUrl");
      read(ret, "MIKRO_ORM_HOST", "host");
      read(ret, "MIKRO_ORM_PORT", "port", num);
      read(ret, "MIKRO_ORM_USER", "user");
      read(ret, "MIKRO_ORM_PASSWORD", "password");
      read(ret, "MIKRO_ORM_DB_NAME", "dbName");
      read(ret, "MIKRO_ORM_SCHEMA", "schema");
      read(ret, "MIKRO_ORM_LOAD_STRATEGY", "loadStrategy");
      read(ret, "MIKRO_ORM_BATCH_SIZE", "batchSize", num);
      read(ret, "MIKRO_ORM_USE_BATCH_INSERTS", "useBatchInserts", bool);
      read(ret, "MIKRO_ORM_USE_BATCH_UPDATES", "useBatchUpdates", bool);
      read(ret, "MIKRO_ORM_STRICT", "strict", bool);
      read(ret, "MIKRO_ORM_VALIDATE", "validate", bool);
      read(ret, "MIKRO_ORM_ALLOW_GLOBAL_CONTEXT", "allowGlobalContext", bool);
      read(ret, "MIKRO_ORM_AUTO_JOIN_ONE_TO_ONE_OWNER", "autoJoinOneToOneOwner", bool);
      read(ret, "MIKRO_ORM_POPULATE_AFTER_FLUSH", "populateAfterFlush", bool);
      read(ret, "MIKRO_ORM_FORCE_ENTITY_CONSTRUCTOR", "forceEntityConstructor", bool);
      read(ret, "MIKRO_ORM_FORCE_UNDEFINED", "forceUndefined", bool);
      read(ret, "MIKRO_ORM_FORCE_UTC_TIMEZONE", "forceUtcTimezone", bool);
      read(ret, "MIKRO_ORM_TIMEZONE", "timezone");
      read(ret, "MIKRO_ORM_ENSURE_INDEXES", "ensureIndexes", bool);
      read(ret, "MIKRO_ORM_IMPLICIT_TRANSACTIONS", "implicitTransactions", bool);
      read(ret, "MIKRO_ORM_DEBUG", "debug", bool);
      read(ret, "MIKRO_ORM_COLORS", "colors", bool);
      ret.discovery = {};
      read(ret.discovery, "MIKRO_ORM_DISCOVERY_WARN_WHEN_NO_ENTITIES", "warnWhenNoEntities", bool);
      read(ret.discovery, "MIKRO_ORM_DISCOVERY_REQUIRE_ENTITIES_ARRAY", "requireEntitiesArray", bool);
      read(ret.discovery, "MIKRO_ORM_DISCOVERY_ALWAYS_ANALYSE_PROPERTIES", "alwaysAnalyseProperties", bool);
      read(ret.discovery, "MIKRO_ORM_DISCOVERY_DISABLE_DYNAMIC_FILE_ACCESS", "disableDynamicFileAccess", bool);
      cleanup(ret, "discovery");
      ret.migrations = {};
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_TABLE_NAME", "tableName");
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_PATH", "path");
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_PATH_TS", "pathTs");
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_GLOB", "glob");
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_TRANSACTIONAL", "transactional", bool);
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_DISABLE_FOREIGN_KEYS", "disableForeignKeys", bool);
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_ALL_OR_NOTHING", "allOrNothing", bool);
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_DROP_TABLES", "dropTables", bool);
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_SAFE", "safe", bool);
      read(ret.migrations, "MIKRO_ORM_MIGRATIONS_EMIT", "emit");
      cleanup(ret, "migrations");
      ret.schemaGenerator = {};
      read(ret.schemaGenerator, "MIKRO_ORM_SCHEMA_GENERATOR_DISABLE_FOREIGN_KEYS", "disableForeignKeys", bool);
      read(ret.schemaGenerator, "MIKRO_ORM_SCHEMA_GENERATOR_CREATE_FOREIGN_KEY_CONSTRAINTS", "createForeignKeyConstraints", bool);
      cleanup(ret, "schemaGenerator");
      ret.seeder = {};
      read(ret.seeder, "MIKRO_ORM_SEEDER_PATH", "path");
      read(ret.seeder, "MIKRO_ORM_SEEDER_PATH_TS", "pathTs");
      read(ret.seeder, "MIKRO_ORM_SEEDER_GLOB", "glob");
      read(ret.seeder, "MIKRO_ORM_SEEDER_EMIT", "emit");
      read(ret.seeder, "MIKRO_ORM_SEEDER_DEFAULT_SEEDER", "defaultSeeder");
      cleanup(ret, "seeder");
      return ret;
    }
    static async getORMPackages() {
      const pkg = await this.getPackageConfig();
      return new Set([
        ...Object.keys(pkg.dependencies ?? {}),
        ...Object.keys(pkg.devDependencies ?? {})
      ]);
    }
    static async commonJSCompat(options) {
      if (await this.isESM()) {
        return;
      }
      options.dynamicImportProvider ??= (id) => {
        if ((0, os_1.platform)() === "win32") {
          try {
            id = (0, url_1.fileURLToPath)(id);
          } catch {
          }
        }
        return Utils_1.Utils.requireFrom(id);
      };
      Utils_1.Utils.setDynamicImportProvider(options.dynamicImportProvider);
    }
    static async getORMPackageVersion(name) {
      try {
        const pkg = Utils_1.Utils.requireFrom(`${name}/package.json`);
        return pkg?.version;
      } catch (e2) {
        return;
      }
    }
    static async checkPackageVersion() {
      const coreVersion = Utils_1.Utils.getORMVersion();
      if (process.env.MIKRO_ORM_ALLOW_VERSION_MISMATCH) {
        return coreVersion;
      }
      const deps = await this.getORMPackages();
      const exceptions = new Set(["nestjs", "sql-highlighter", "mongo-highlighter"]);
      const ormPackages = [...deps].filter((d2) => d2.startsWith("@mikro-orm/") && d2 !== "@mikro-orm/core" && !exceptions.has(d2.substring("@mikro-orm/".length)));
      for (const ormPackage of ormPackages) {
        const version = await this.getORMPackageVersion(ormPackage);
        if (version != null && version !== coreVersion) {
          throw new Error(`Bad ${colors_1.colors.cyan(ormPackage)} version ${colors_1.colors.yellow("" + version)}.\n` + `All official @mikro-orm/* packages need to have the exact same version as @mikro-orm/core (${colors_1.colors.green(coreVersion)}).\n` + `Only exceptions are packages that don't live in the 'mikro-orm' repository: ${[...exceptions].join(", ")}.\n` + `Maybe you want to check, or regenerate your yarn.lock or package-lock.json file?`);
        }
      }
      return coreVersion;
    }
  }
  exports.ConfigurationLoader = ConfigurationLoader;
});

// node_modules/@mikro-orm/core/utils/Cursor.js
var require_Cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cursor = undefined;
  var util_1 = import.meta.require("util");
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();
  var Reference_1 = require_Reference();
  var wrap_1 = require_wrap();
  var RawQueryFragment_1 = require_RawQueryFragment();
  var errors_1 = require_errors3();

  class Cursor {
    items;
    totalCount;
    hasPrevPage;
    hasNextPage;
    definition;
    constructor(items, totalCount, options, meta) {
      this.items = items;
      this.totalCount = totalCount;
      const { first, last, before, after, orderBy, overfetch } = options;
      const limit = first || last;
      const isLast = !first && !!last;
      const hasMorePages = !!overfetch && limit != null && items.length > limit;
      this.hasPrevPage = before || after ? true : isLast && hasMorePages;
      this.hasNextPage = !(isLast && !before && !after) && hasMorePages;
      if (hasMorePages) {
        if (isLast) {
          items.shift();
        } else {
          items.pop();
        }
      }
      this.definition = Cursor.getDefinition(meta, orderBy);
    }
    get startCursor() {
      if (this.items.length === 0) {
        return null;
      }
      return this.from(this.items[0]);
    }
    get endCursor() {
      if (this.items.length === 0) {
        return null;
      }
      return this.from(this.items[this.items.length - 1]);
    }
    from(entity) {
      const processEntity = (entity2, prop, direction, object12 = false) => {
        if (Utils_1.Utils.isPlainObject(direction)) {
          const value16 = Utils_1.Utils.keys(direction).reduce((o2, key) => {
            Object.assign(o2, processEntity(Reference_1.Reference.unwrapReference(entity2[prop]), key, direction[key], true));
            return o2;
          }, {});
          return { [prop]: value16 };
        }
        if (entity2[prop] == null) {
          throw errors_1.CursorError.entityNotPopulated(entity2, prop);
        }
        let value15 = entity2[prop];
        if (Utils_1.Utils.isEntity(value15, true)) {
          value15 = (0, wrap_1.helper)(value15).getPrimaryKey();
        }
        if (object12) {
          return { [prop]: value15 };
        }
        return value15;
      };
      const value14 = this.definition.map(([key, direction]) => processEntity(entity, key, direction));
      return Cursor.encode(value14);
    }
    *[Symbol.iterator]() {
      for (const item of this.items) {
        yield item;
      }
    }
    get length() {
      return this.items.length;
    }
    static for(meta, entity, orderBy) {
      const definition = this.getDefinition(meta, orderBy);
      return Cursor.encode(definition.map(([key]) => entity[key]));
    }
    static encode(value14) {
      return Buffer.from(JSON.stringify(value14)).toString("base64url");
    }
    static decode(value14) {
      return JSON.parse(Buffer.from(value14, "base64url").toString("utf8"));
    }
    static getDefinition(meta, orderBy) {
      return Utils_1.Utils.asArray(orderBy).flatMap((order) => {
        const ret = [];
        for (const key of Utils_1.Utils.keys(order)) {
          if (RawQueryFragment_1.RawQueryFragment.isKnownFragment(key)) {
            ret.push([key, order[key]]);
            continue;
          }
          const prop = meta.properties[key];
          if (!prop || !([enums_1.ReferenceKind.SCALAR, enums_1.ReferenceKind.EMBEDDED, enums_1.ReferenceKind.MANY_TO_ONE].includes(prop.kind) || prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && prop.owner)) {
            continue;
          }
          ret.push([prop.name, order[prop.name]]);
        }
        return ret;
      });
    }
    [util_1.inspect.custom]() {
      const type73 = this.items[0]?.constructor.name;
      const { items, startCursor, endCursor, hasPrevPage, hasNextPage, totalCount, length } = this;
      const options = (0, util_1.inspect)({ startCursor, endCursor, totalCount, hasPrevPage, hasNextPage, items, length }, { depth: 0 });
      return `Cursor${type73 ? `<${type73}>` : ""} ${options.replace("items: [Array]", "items: [...]")}`;
    }
  }
  exports.Cursor = Cursor;
});

// node_modules/@mikro-orm/core/utils/DataloaderUtils.js
var require_DataloaderUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataloaderUtils = undefined;
  var Collection_1 = require_Collection();
  var wrap_1 = require_wrap();
  var enums_1 = require_enums();

  class DataloaderUtils {
    static groupPrimaryKeysByEntityAndOpts(refsWithOpts) {
      const map3 = new Map;
      for (const [ref3, opts] of refsWithOpts) {
        const key = `${(0, wrap_1.helper)(ref3).__meta.className}|${JSON.stringify(opts ?? {})}`;
        let primaryKeysSet = map3.get(key);
        if (primaryKeysSet == null) {
          primaryKeysSet = new Set;
          map3.set(key, primaryKeysSet);
        }
        primaryKeysSet.add((0, wrap_1.helper)(ref3).getPrimaryKey());
      }
      return map3;
    }
    static getRefBatchLoadFn(em) {
      return async (refsWithOpts) => {
        const groupedIdsMap = DataloaderUtils.groupPrimaryKeysByEntityAndOpts(refsWithOpts);
        const promises = Array.from(groupedIdsMap).map(([key, idsSet]) => {
          const className = key.substring(0, key.indexOf("|"));
          const opts = JSON.parse(key.substring(key.indexOf("|") + 1));
          return em.find(className, Array.from(idsSet), opts);
        });
        await Promise.all(promises);
        return refsWithOpts.map(([ref3]) => ref3.unwrap());
      };
    }
    static groupInversedOrMappedKeysByEntityAndOpts(collsWithOpts) {
      const entitiesMap = new Map;
      for (const [col, opts] of collsWithOpts) {
        const key = `${col.property.targetMeta.className}|${JSON.stringify(opts ?? {})}`;
        let filterMap = entitiesMap.get(key);
        if (filterMap == null) {
          filterMap = new Map;
          entitiesMap.set(key, filterMap);
        }
        const inversedProp = col.property.inversedBy ?? col.property.mappedBy;
        let primaryKeys = filterMap.get(inversedProp);
        if (primaryKeys == null) {
          primaryKeys = new Set;
          filterMap.set(inversedProp, primaryKeys);
        }
        primaryKeys.add((0, wrap_1.helper)(col.owner).getPrimaryKey());
      }
      return entitiesMap;
    }
    static entitiesAndOptsMapToQueries(entitiesAndOptsMap, em) {
      return Array.from(entitiesAndOptsMap, async ([key, filterMap]) => {
        const className = key.substring(0, key.indexOf("|"));
        const opts = JSON.parse(key.substring(key.indexOf("|") + 1));
        const res = await em.find(className, opts?.where != null && Object.keys(opts.where).length > 0 ? {
          $and: [
            {
              $or: Array.from(filterMap.entries()).map(([prop, pks]) => {
                return { [prop]: Array.from(pks) };
              })
            },
            opts.where
          ]
        } : {
          $or: Array.from(filterMap.entries()).map(([prop, pks]) => {
            return { [prop]: Array.from(pks) };
          })
        }, {
          ...opts,
          populate: [
            ...opts.populate === false ? [] : opts.populate ?? [],
            ...opts.ref ? [":ref"] : [],
            ...Array.from(filterMap.keys()).filter((prop) => em.getMetadata(className).properties[prop]?.ref !== true)
          ]
        });
        return [key, res];
      });
    }
    static getColFilter(collection) {
      return (result) => {
        const refOrCol = result[collection.property.inversedBy ?? collection.property.mappedBy];
        if (refOrCol instanceof Collection_1.Collection) {
          for (const item of refOrCol.getItems()) {
            if ((0, wrap_1.helper)(item).getSerializedPrimaryKey() === (0, wrap_1.helper)(collection.owner).getSerializedPrimaryKey()) {
              return true;
            }
          }
        } else {
          return (0, wrap_1.helper)(refOrCol).getSerializedPrimaryKey() === (0, wrap_1.helper)(collection.owner).getSerializedPrimaryKey();
        }
        return false;
      };
    }
    static getColBatchLoadFn(em) {
      return async (collsWithOpts) => {
        const entitiesAndOptsMap = DataloaderUtils.groupInversedOrMappedKeysByEntityAndOpts(collsWithOpts);
        const promises = DataloaderUtils.entitiesAndOptsMapToQueries(entitiesAndOptsMap, em);
        const resultsMap = new Map(await Promise.all(promises));
        return collsWithOpts.map(([col, opts]) => {
          const key = `${col.property.targetMeta.className}|${JSON.stringify(opts ?? {})}`;
          const entities = resultsMap.get(key);
          if (entities == null) {
            throw new Error("Cannot match results");
          }
          return entities.filter(DataloaderUtils.getColFilter(col));
        });
      };
    }
    static getDataloaderType(dataloaderCfg) {
      switch (dataloaderCfg) {
        case true:
          return enums_1.DataloaderType.ALL;
        case false:
          return enums_1.DataloaderType.NONE;
        default:
          return dataloaderCfg;
      }
    }
  }
  exports.DataloaderUtils = DataloaderUtils;
});

// node_modules/@mikro-orm/core/utils/TransactionContext.js
var require_TransactionContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransactionContext = undefined;
  var async_hooks_1 = import.meta.require("async_hooks");

  class TransactionContext {
    em;
    static storage = new async_hooks_1.AsyncLocalStorage;
    id;
    constructor(em) {
      this.em = em;
      this.id = this.em._id;
    }
    static create(em, next) {
      const context = new TransactionContext(em);
      return this.storage.run(context, next);
    }
    static currentTransactionContext() {
      return this.storage.getStore();
    }
    static getEntityManager(name = "default") {
      const context = TransactionContext.currentTransactionContext();
      return context?.em.name === name ? context.em : undefined;
    }
  }
  exports.TransactionContext = TransactionContext;
});

// node_modules/@mikro-orm/core/utils/QueryHelper.js
var require_QueryHelper = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueryHelper = undefined;
  var Reference_1 = require_Reference();
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();
  var JsonType_1 = require_JsonType();
  var wrap_1 = require_wrap();

  class QueryHelper {
    static SUPPORTED_OPERATORS = [">", "<", "<=", ">=", "!", "!="];
    static processParams(params) {
      if (Reference_1.Reference.isReference(params)) {
        params = params.unwrap();
      }
      if (Utils_1.Utils.isEntity(params)) {
        if ((0, wrap_1.helper)(params).__meta.compositePK) {
          return (0, wrap_1.helper)(params).__primaryKeys;
        }
        return (0, wrap_1.helper)(params).getPrimaryKey();
      }
      if (params === undefined) {
        return null;
      }
      if (Array.isArray(params)) {
        return params.map((item) => QueryHelper.processParams(item));
      }
      if (Utils_1.Utils.isPlainObject(params)) {
        QueryHelper.processObjectParams(params);
      }
      return params;
    }
    static processObjectParams(params = {}) {
      Utils_1.Utils.keys(params).forEach((k) => {
        params[k] = QueryHelper.processParams(params[k]);
      });
      return params;
    }
    static inlinePrimaryKeyObjects(where, meta, metadata, key) {
      if (Array.isArray(where)) {
        where.forEach((item, i2) => {
          if (this.inlinePrimaryKeyObjects(item, meta, metadata, key)) {
            where[i2] = Utils_1.Utils.getPrimaryKeyValues(item, meta.primaryKeys, false);
          }
        });
      }
      if (!Utils_1.Utils.isPlainObject(where) || key && meta.properties[key]?.customType instanceof JsonType_1.JsonType) {
        return false;
      }
      if (meta.primaryKeys.every((pk) => (pk in where)) && Utils_1.Utils.getObjectKeysSize(where) === meta.primaryKeys.length) {
        return !!key && !enums_1.GroupOperator[key] && Object.keys(where).every((k) => !Utils_1.Utils.isPlainObject(where[k]) || Object.keys(where[k]).every((v2) => {
          if (Utils_1.Utils.isOperator(v2, false)) {
            return false;
          }
          if (meta.properties[k].primary && [enums_1.ReferenceKind.ONE_TO_ONE, enums_1.ReferenceKind.MANY_TO_ONE].includes(meta.properties[k].kind)) {
            return this.inlinePrimaryKeyObjects(where[k], meta.properties[k].targetMeta, metadata, v2);
          }
          return true;
        }));
      }
      Object.keys(where).forEach((k) => {
        const meta2 = metadata.find(meta.properties[k]?.type) || meta;
        if (this.inlinePrimaryKeyObjects(where[k], meta2, metadata, k)) {
          where[k] = Utils_1.Utils.getPrimaryKeyValues(where[k], meta2.primaryKeys, true);
        }
      });
      return false;
    }
    static processWhere(options) {
      let { where, entityName, metadata, platform, aliased = true, convertCustomTypes = true, root = true } = options;
      const meta = metadata.find(entityName);
      if (meta && root) {
        QueryHelper.inlinePrimaryKeyObjects(where, meta, metadata);
      }
      if (options.platform.getConfig().get("ignoreUndefinedInQuery") && where && typeof where === "object") {
        Utils_1.Utils.dropUndefinedProperties(where);
      }
      where = QueryHelper.processParams(where) ?? {};
      if (!root && Utils_1.Utils.isPrimaryKey(where)) {
        return where;
      }
      if (meta && Utils_1.Utils.isPrimaryKey(where, meta.compositePK)) {
        where = { [Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: where };
      }
      if (Array.isArray(where) && root) {
        const rootPrimaryKey = meta ? Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys) : entityName;
        let cond = { [rootPrimaryKey]: { $in: where } };
        if (meta && !where.every((c2) => Utils_1.Utils.isPrimaryKey(c2) || Array.isArray(c2) && c2.length === meta.primaryKeys.length && c2.every((i2) => Utils_1.Utils.isPrimaryKey(i2)))) {
          cond = { $or: where };
        }
        return QueryHelper.processWhere({ ...options, where: cond, root: false });
      }
      if (!Utils_1.Utils.isPlainObject(where)) {
        return where;
      }
      return Object.keys(where).reduce((o2, key) => {
        let value14 = where[key];
        const prop = this.findProperty(key, options);
        const keys = prop?.joinColumns?.length ?? 0;
        const composite4 = keys > 1;
        if (key in enums_1.GroupOperator) {
          o2[key] = value14.map((sub) => QueryHelper.processWhere({ ...options, where: sub, root }));
          return o2;
        }
        if (Utils_1.Utils.isOperator(key) && root && meta && !options.platform.isAllowedTopLevelOperator(key)) {
          const rootPrimaryKey = Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
          o2[rootPrimaryKey] = { [key]: QueryHelper.processWhere({ ...options, where: value14, root: false }) };
          return o2;
        }
        if (prop?.customType && convertCustomTypes && !platform.isRaw(value14)) {
          value14 = QueryHelper.processCustomType(prop, value14, platform, undefined, true);
        }
        const isJsonProperty = prop?.customType instanceof JsonType_1.JsonType && Utils_1.Utils.isPlainObject(value14) && !platform.isRaw(value14) && Object.keys(value14)[0] !== "$eq";
        if (isJsonProperty) {
          return this.processJsonCondition(o2, value14, [prop.fieldNames[0]], platform, aliased);
        }
        if (Array.isArray(value14) && !Utils_1.Utils.isOperator(key) && !QueryHelper.isSupportedOperator(key) && !key.includes("?") && options.type !== "orderBy") {
          if (platform.allowsComparingTuples()) {
            const op = !value14.every((v2) => Array.isArray(v2)) && composite4 ? "$eq" : "$in";
            o2[key] = { [op]: value14 };
          } else {
            if (!value14.every((v2) => Array.isArray(v2)) && composite4) {
              o2[key] = { $in: [value14] };
            } else {
              o2[key] = { $in: value14 };
            }
          }
          return o2;
        }
        if (Utils_1.Utils.isPlainObject(value14)) {
          o2[key] = QueryHelper.processWhere({
            ...options,
            where: value14,
            entityName: prop?.type ?? entityName,
            root: false
          });
        } else {
          o2[key] = value14;
        }
        return o2;
      }, {});
    }
    static getActiveFilters(entityName, options, filters) {
      if (options === false) {
        return [];
      }
      const opts = {};
      if (Array.isArray(options)) {
        options.forEach((filter) => opts[filter] = true);
      } else if (Utils_1.Utils.isPlainObject(options)) {
        Object.keys(options).forEach((filter) => opts[filter] = options[filter]);
      }
      return Object.keys(filters).filter((f) => QueryHelper.isFilterActive(entityName, f, filters[f], opts)).map((f) => {
        filters[f].name = f;
        return filters[f];
      });
    }
    static isFilterActive(entityName, filterName, filter, options) {
      if (filter.entity && !filter.entity.includes(entityName)) {
        return false;
      }
      if (options[filterName] === false) {
        return false;
      }
      return filter.default || filterName in options;
    }
    static processCustomType(prop, cond, platform, key, fromQuery) {
      if (Utils_1.Utils.isPlainObject(cond)) {
        return Utils_1.Utils.keys(cond).reduce((o2, k) => {
          if (Utils_1.Utils.isOperator(k, true) || prop.referencedPKs?.includes(k)) {
            o2[k] = QueryHelper.processCustomType(prop, cond[k], platform, k, fromQuery);
          } else {
            o2[k] = cond[k];
          }
          return o2;
        }, {});
      }
      if (Array.isArray(cond) && !(key && Utils_1.Utils.isArrayOperator(key))) {
        return cond.map((v2) => QueryHelper.processCustomType(prop, v2, platform, key, fromQuery));
      }
      if (platform.isRaw(cond)) {
        return cond;
      }
      return prop.customType.convertToDatabaseValue(cond, platform, { fromQuery, key, mode: "query" });
    }
    static isSupportedOperator(key) {
      return !!QueryHelper.SUPPORTED_OPERATORS.find((op) => key.includes(op));
    }
    static processJsonCondition(o2, value14, path, platform, alias) {
      if (Utils_1.Utils.isPlainObject(value14) && !Object.keys(value14).some((k2) => Utils_1.Utils.isOperator(k2))) {
        Utils_1.Utils.keys(value14).forEach((k2) => {
          this.processJsonCondition(o2, value14[k2], [...path, k2], platform, alias);
        });
        return o2;
      }
      if (path.length === 1) {
        o2[path[0]] = value14;
        return o2;
      }
      const operatorObject = Utils_1.Utils.isPlainObject(value14) && Object.keys(value14).every((k2) => Utils_1.Utils.isOperator(k2));
      const type73 = operatorObject ? typeof Object.values(value14)[0] : typeof value14;
      const k = platform.getSearchJsonPropertyKey(path, type73, alias, value14);
      o2[k] = value14;
      return o2;
    }
    static findProperty(fieldName, options) {
      const parts = fieldName.split(".");
      const propName = parts.pop();
      const alias = parts.length > 0 ? parts.join(".") : undefined;
      const entityName = alias ? options.aliasMap?.[alias] : options.entityName;
      const meta = entityName ? options.metadata.find(entityName) : undefined;
      return meta?.properties[propName];
    }
  }
  exports.QueryHelper = QueryHelper;
});

// node_modules/@mikro-orm/core/unit-of-work/CommitOrderCalculator.js
var require_CommitOrderCalculator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommitOrderCalculator = exports.NodeState = undefined;
  var enums_1 = require_enums();
  var NodeState;
  (function(NodeState2) {
    NodeState2[NodeState2["NOT_VISITED"] = 0] = "NOT_VISITED";
    NodeState2[NodeState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
    NodeState2[NodeState2["VISITED"] = 2] = "VISITED";
  })(NodeState || (exports.NodeState = NodeState = {}));

  class CommitOrderCalculator {
    nodes = {};
    sortedNodeList = [];
    hasNode(hash6) {
      return hash6 in this.nodes;
    }
    addNode(hash6) {
      this.nodes[hash6] = { hash: hash6, state: 0, dependencies: {} };
    }
    addDependency(from, to, weight) {
      this.nodes[from].dependencies[to] = { from, to, weight };
    }
    discoverProperty(prop, entityName) {
      const toOneOwner = prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && prop.owner || prop.kind === enums_1.ReferenceKind.MANY_TO_ONE;
      const toManyOwner = prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && prop.owner && !prop.pivotEntity;
      if (!toOneOwner && !toManyOwner) {
        return;
      }
      const propertyType = prop.targetMeta?.root.className;
      if (!propertyType || !this.hasNode(propertyType)) {
        return;
      }
      this.addDependency(propertyType, entityName, prop.nullable || prop.persist === false ? 0 : 1);
    }
    sort() {
      for (const vertex of Object.values(this.nodes)) {
        if (vertex.state !== 0) {
          continue;
        }
        this.visit(vertex);
      }
      const sortedList = this.sortedNodeList.reverse();
      this.nodes = {};
      this.sortedNodeList = [];
      return sortedList;
    }
    visit(node) {
      node.state = 1;
      for (const edge of Object.values(node.dependencies)) {
        const target = this.nodes[edge.to];
        switch (target.state) {
          case 2:
            break;
          case 1:
            this.visitOpenNode(node, target, edge);
            break;
          case 0:
            this.visit(target);
        }
      }
      if (node.state !== 2) {
        node.state = 2;
        this.sortedNodeList.push(node.hash);
      }
    }
    visitOpenNode(node, target, edge) {
      if (!target.dependencies[node.hash] || target.dependencies[node.hash].weight >= edge.weight) {
        return;
      }
      for (const edge2 of Object.values(target.dependencies)) {
        const targetNode = this.nodes[edge2.to];
        if (targetNode.state === 0) {
          this.visit(targetNode);
        }
      }
      target.state = 2;
      this.sortedNodeList.push(target.hash);
    }
  }
  exports.CommitOrderCalculator = CommitOrderCalculator;
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS((exports, module) => {
  var getCurrentBatch = function(loader) {
    var existingBatch = loader._batch;
    if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
      return existingBatch;
    }
    var newBatch = {
      hasDispatched: false,
      keys: [],
      callbacks: []
    };
    loader._batch = newBatch;
    loader._batchScheduleFn(function() {
      dispatchBatch(loader, newBatch);
    });
    return newBatch;
  };
  var dispatchBatch = function(loader, batch) {
    batch.hasDispatched = true;
    if (batch.keys.length === 0) {
      resolveCacheHits(batch);
      return;
    }
    var batchPromise;
    try {
      batchPromise = loader._batchLoadFn(batch.keys);
    } catch (e2) {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e2) + ".")));
    }
    if (!batchPromise || typeof batchPromise.then !== "function") {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
    }
    batchPromise.then(function(values) {
      if (!isArrayLike(values)) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
      }
      if (values.length !== batch.keys.length) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
      }
      resolveCacheHits(batch);
      for (var i2 = 0;i2 < batch.callbacks.length; i2++) {
        var value14 = values[i2];
        if (value14 instanceof Error) {
          batch.callbacks[i2].reject(value14);
        } else {
          batch.callbacks[i2].resolve(value14);
        }
      }
    })["catch"](function(error21) {
      failedDispatch(loader, batch, error21);
    });
  };
  var failedDispatch = function(loader, batch, error21) {
    resolveCacheHits(batch);
    for (var i2 = 0;i2 < batch.keys.length; i2++) {
      loader.clear(batch.keys[i2]);
      batch.callbacks[i2].reject(error21);
    }
  };
  var resolveCacheHits = function(batch) {
    if (batch.cacheHits) {
      for (var i2 = 0;i2 < batch.cacheHits.length; i2++) {
        batch.cacheHits[i2]();
      }
    }
  };
  var getValidMaxBatchSize = function(options) {
    var shouldBatch = !options || options.batch !== false;
    if (!shouldBatch) {
      return 1;
    }
    var maxBatchSize = options && options.maxBatchSize;
    if (maxBatchSize === undefined) {
      return Infinity;
    }
    if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
      throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
    }
    return maxBatchSize;
  };
  var getValidBatchScheduleFn = function(options) {
    var batchScheduleFn = options && options.batchScheduleFn;
    if (batchScheduleFn === undefined) {
      return enqueuePostPromiseJob;
    }
    if (typeof batchScheduleFn !== "function") {
      throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
    }
    return batchScheduleFn;
  };
  var getValidCacheKeyFn = function(options) {
    var cacheKeyFn = options && options.cacheKeyFn;
    if (cacheKeyFn === undefined) {
      return function(key) {
        return key;
      };
    }
    if (typeof cacheKeyFn !== "function") {
      throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
    }
    return cacheKeyFn;
  };
  var getValidCacheMap = function(options) {
    var shouldCache = !options || options.cache !== false;
    if (!shouldCache) {
      return null;
    }
    var cacheMap = options && options.cacheMap;
    if (cacheMap === undefined) {
      return new Map;
    }
    if (cacheMap !== null) {
      var cacheFunctions = ["get", "set", "delete", "clear"];
      var missingFunctions = cacheFunctions.filter(function(fnName) {
        return cacheMap && typeof cacheMap[fnName] !== "function";
      });
      if (missingFunctions.length !== 0) {
        throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
      }
    }
    return cacheMap;
  };
  var getValidName = function(options) {
    if (options && options.name) {
      return options.name;
    }
    return null;
  };
  var isArrayLike = function(x) {
    return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
  };
  var DataLoader = function() {
    function DataLoader2(batchLoadFn, options) {
      if (typeof batchLoadFn !== "function") {
        throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
      }
      this._batchLoadFn = batchLoadFn;
      this._maxBatchSize = getValidMaxBatchSize(options);
      this._batchScheduleFn = getValidBatchScheduleFn(options);
      this._cacheKeyFn = getValidCacheKeyFn(options);
      this._cacheMap = getValidCacheMap(options);
      this._batch = null;
      this.name = getValidName(options);
    }
    var _proto = DataLoader2.prototype;
    _proto.load = function load(key) {
      if (key === null || key === undefined) {
        throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
      }
      var batch = getCurrentBatch(this);
      var cacheMap = this._cacheMap;
      var cacheKey = this._cacheKeyFn(key);
      if (cacheMap) {
        var cachedPromise = cacheMap.get(cacheKey);
        if (cachedPromise) {
          var cacheHits = batch.cacheHits || (batch.cacheHits = []);
          return new Promise(function(resolve) {
            cacheHits.push(function() {
              resolve(cachedPromise);
            });
          });
        }
      }
      batch.keys.push(key);
      var promise4 = new Promise(function(resolve, reject) {
        batch.callbacks.push({
          resolve,
          reject
        });
      });
      if (cacheMap) {
        cacheMap.set(cacheKey, promise4);
      }
      return promise4;
    };
    _proto.loadMany = function loadMany(keys) {
      if (!isArrayLike(keys)) {
        throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
      }
      var loadPromises = [];
      for (var i2 = 0;i2 < keys.length; i2++) {
        loadPromises.push(this.load(keys[i2])["catch"](function(error21) {
          return error21;
        }));
      }
      return Promise.all(loadPromises);
    };
    _proto.clear = function clear(key) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key);
        cacheMap["delete"](cacheKey);
      }
      return this;
    };
    _proto.clearAll = function clearAll() {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        cacheMap.clear();
      }
      return this;
    };
    _proto.prime = function prime(key, value14) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap.get(cacheKey) === undefined) {
          var promise4;
          if (value14 instanceof Error) {
            promise4 = Promise.reject(value14);
            promise4["catch"](function() {
            });
          } else {
            promise4 = Promise.resolve(value14);
          }
          cacheMap.set(cacheKey, promise4);
        }
      }
      return this;
    };
    return DataLoader2;
  }();
  var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
    if (!resolvedPromise) {
      resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(function() {
      process.nextTick(fn);
    });
  } : typeof setImmediate === "function" ? function(fn) {
    setImmediate(fn);
  } : function(fn) {
    setTimeout(fn);
  };
  var resolvedPromise;
  module.exports = DataLoader;
});

// node_modules/@mikro-orm/core/unit-of-work/ChangeSet.js
var require_ChangeSet = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeSetType = exports.ChangeSet = undefined;
  var util_1 = import.meta.require("util");
  var wrap_1 = require_wrap();
  var Utils_1 = require_Utils();

  class ChangeSet {
    entity;
    type;
    payload;
    meta;
    primaryKey;
    serializedPrimaryKey;
    constructor(entity, type73, payload, meta) {
      this.entity = entity;
      this.type = type73;
      this.payload = payload;
      this.meta = meta;
      this.name = meta.className;
      this.rootName = meta.root.className;
      this.collection = meta.root.collection;
      this.schema = (0, wrap_1.helper)(entity).__schema ?? meta.root.schema;
    }
    getPrimaryKey(object12 = false) {
      if (!this.originalEntity) {
        this.primaryKey ??= (0, wrap_1.helper)(this.entity).getPrimaryKey(true);
      } else if (this.meta.compositePK) {
        this.primaryKey = this.meta.primaryKeys.map((pk) => this.originalEntity[pk]);
      } else {
        this.primaryKey = this.originalEntity[this.meta.primaryKeys[0]];
      }
      if (object12 && this.primaryKey != null) {
        return Utils_1.Utils.primaryKeyToObject(this.meta, this.primaryKey);
      }
      return this.primaryKey ?? null;
    }
    getSerializedPrimaryKey() {
      this.serializedPrimaryKey ??= (0, wrap_1.helper)(this.entity).getSerializedPrimaryKey();
      return this.serializedPrimaryKey;
    }
    [util_1.inspect.custom](depth) {
      const object12 = { ...this };
      const hidden = ["meta", "serializedPrimaryKey"];
      hidden.forEach((k) => delete object12[k]);
      const ret = (0, util_1.inspect)(object12, { depth });
      const name = `${this.constructor.name}<${this.meta.className}>`;
      return ret === "[Object]" ? `[${name}]` : name + " " + ret;
    }
  }
  exports.ChangeSet = ChangeSet;
  var ChangeSetType;
  (function(ChangeSetType2) {
    ChangeSetType2["CREATE"] = "create";
    ChangeSetType2["UPDATE"] = "update";
    ChangeSetType2["DELETE"] = "delete";
    ChangeSetType2["UPDATE_EARLY"] = "update_early";
    ChangeSetType2["DELETE_EARLY"] = "delete_early";
  })(ChangeSetType || (exports.ChangeSetType = ChangeSetType = {}));
});

// node_modules/@mikro-orm/core/unit-of-work/ChangeSetComputer.js
var require_ChangeSetComputer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeSetComputer = undefined;
  var utils_1 = require_utils10();
  var ChangeSet_1 = require_ChangeSet();
  var entity_1 = require_entity();
  var enums_1 = require_enums();

  class ChangeSetComputer {
    validator;
    collectionUpdates;
    metadata;
    platform;
    config;
    comparator;
    constructor(validator, collectionUpdates, metadata, platform, config) {
      this.validator = validator;
      this.collectionUpdates = collectionUpdates;
      this.metadata = metadata;
      this.platform = platform;
      this.config = config;
      this.comparator = this.config.getComparator(this.metadata);
    }
    computeChangeSet(entity) {
      const meta = this.metadata.get(entity.constructor.name);
      if (meta.readonly) {
        return null;
      }
      const wrapped = (0, entity_1.helper)(entity);
      const type73 = wrapped.__originalEntityData ? ChangeSet_1.ChangeSetType.UPDATE : ChangeSet_1.ChangeSetType.CREATE;
      const map3 = new Map;
      if (type73 === ChangeSet_1.ChangeSetType.CREATE) {
        for (const prop of meta.hydrateProps) {
          this.processPropertyInitializers(entity, prop, type73, map3);
        }
      }
      if (type73 === ChangeSet_1.ChangeSetType.UPDATE && !wrapped.__initialized && !wrapped.isTouched()) {
        return null;
      }
      const changeSet = new ChangeSet_1.ChangeSet(entity, type73, this.computePayload(entity), meta);
      changeSet.originalEntity = wrapped.__originalEntityData;
      if (this.config.get("validate")) {
        this.validator.validate(changeSet.entity, changeSet.payload, meta);
      }
      for (const prop of meta.relations.filter((prop2) => prop2.persist !== false || prop2.userDefined === false)) {
        this.processProperty(changeSet, prop);
      }
      if (changeSet.type === ChangeSet_1.ChangeSetType.UPDATE && !utils_1.Utils.hasObjectKeys(changeSet.payload)) {
        return null;
      }
      if (type73 === ChangeSet_1.ChangeSetType.UPDATE) {
        for (const prop of meta.hydrateProps) {
          this.processPropertyInitializers(entity, prop, type73, map3);
        }
      }
      if (map3.size > 0) {
        for (const [entity2, pairs] of map3) {
          for (const [prop, value14] of pairs) {
            entity2[prop] = value14;
          }
        }
        const diff = this.computePayload(entity, true);
        utils_1.Utils.merge(changeSet.payload, diff);
      }
      return changeSet;
    }
    processPropertyInitializers(entity, prop, type73, map3, nested) {
      if (prop.onCreate && type73 === ChangeSet_1.ChangeSetType.CREATE && entity[prop.name] == null) {
        entity[prop.name] = prop.onCreate(entity);
      }
      if (prop.onUpdate && type73 === ChangeSet_1.ChangeSetType.UPDATE) {
        const pairs = map3.get(entity) ?? [];
        pairs.push([prop.name, prop.onUpdate(entity)]);
        map3.set(entity, pairs);
      }
      if (prop.kind === enums_1.ReferenceKind.EMBEDDED && entity[prop.name]) {
        for (const embeddedProp of prop.targetMeta.hydrateProps) {
          this.processPropertyInitializers(entity[prop.name], embeddedProp, type73, map3, nested || prop.object);
        }
      }
    }
    computePayload(entity, ignoreUndefined = false) {
      const data = this.comparator.prepareEntity(entity);
      const entityName = (0, entity_1.helper)(entity).__meta.className;
      const originalEntityData = (0, entity_1.helper)(entity).__originalEntityData;
      if (originalEntityData) {
        const comparator = this.comparator.getEntityComparator(entityName);
        const diff = comparator(originalEntityData, data);
        if (ignoreUndefined) {
          utils_1.Utils.keys(diff).filter((k) => diff[k] === undefined).forEach((k) => delete diff[k]);
        }
        return diff;
      }
      return data;
    }
    processProperty(changeSet, prop, target) {
      if (!target) {
        const targets = utils_1.Utils.unwrapProperty(changeSet.entity, changeSet.meta, prop);
        targets.forEach(([t2]) => this.processProperty(changeSet, prop, t2));
        return;
      }
      if (utils_1.Utils.isCollection(target)) {
        this.processToMany(prop, changeSet);
      }
      if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind)) {
        this.processToOne(prop, changeSet);
      }
    }
    processToOne(prop, changeSet) {
      const isToOneOwner = prop.kind === enums_1.ReferenceKind.MANY_TO_ONE || prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && prop.owner;
      if (!isToOneOwner || prop.mapToPk) {
        return;
      }
      const targets = utils_1.Utils.unwrapProperty(changeSet.entity, changeSet.meta, prop);
      targets.forEach(([target, idx]) => {
        if (!target.__helper.hasPrimaryKey()) {
          utils_1.Utils.setPayloadProperty(changeSet.payload, this.metadata.find(changeSet.name), prop, target.__helper.__identifier, idx);
        }
      });
    }
    processToMany(prop, changeSet) {
      const target = changeSet.entity[prop.name];
      if (!target.isDirty()) {
        return;
      }
      if (prop.owner || target.getItems(false).filter((item) => !item.__helper.__initialized).length > 0) {
        if (this.platform.usesPivotTable()) {
          this.collectionUpdates.add(target);
        } else {
          changeSet.payload[prop.name] = target.getItems(false).map((item) => item.__helper.__identifier ?? item.__helper.getPrimaryKey());
        }
      } else if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY && target.getSnapshot() === undefined) {
        this.collectionUpdates.add(target);
      } else if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && !prop.owner) {
        this.collectionUpdates.add(target);
      }
    }
  }
  exports.ChangeSetComputer = ChangeSetComputer;
});

// node_modules/@mikro-orm/core/unit-of-work/ChangeSetPersister.js
var require_ChangeSetPersister = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeSetPersister = undefined;
  var entity_1 = require_entity();
  var ChangeSet_1 = require_ChangeSet();
  var utils_1 = require_utils10();
  var errors_1 = require_errors3();
  var enums_1 = require_enums();

  class ChangeSetPersister {
    driver;
    metadata;
    hydrator;
    factory;
    validator;
    config;
    platform;
    comparator;
    constructor(driver, metadata, hydrator, factory, validator, config) {
      this.driver = driver;
      this.metadata = metadata;
      this.hydrator = hydrator;
      this.factory = factory;
      this.validator = validator;
      this.config = config;
      this.platform = this.driver.getPlatform();
      this.comparator = this.config.getComparator(this.metadata);
    }
    async executeInserts(changeSets, options, withSchema) {
      if (!withSchema) {
        return this.runForEachSchema(changeSets, "executeInserts", options);
      }
      const meta = this.metadata.find(changeSets[0].name);
      changeSets.forEach((changeSet) => this.processProperties(changeSet));
      if (changeSets.length > 1 && this.config.get("useBatchInserts", this.platform.usesBatchInserts())) {
        return this.persistNewEntities(meta, changeSets, options);
      }
      for (const changeSet of changeSets) {
        await this.persistNewEntity(meta, changeSet, options);
      }
    }
    async executeUpdates(changeSets, batched, options, withSchema) {
      if (!withSchema) {
        return this.runForEachSchema(changeSets, "executeUpdates", options, batched);
      }
      const meta = this.metadata.find(changeSets[0].name);
      changeSets.forEach((changeSet) => this.processProperties(changeSet));
      if (batched && changeSets.length > 1 && this.config.get("useBatchUpdates", this.platform.usesBatchUpdates())) {
        return this.persistManagedEntities(meta, changeSets, options);
      }
      for (const changeSet of changeSets) {
        await this.persistManagedEntity(changeSet, options);
      }
    }
    async executeDeletes(changeSets, options, withSchema) {
      if (!withSchema) {
        return this.runForEachSchema(changeSets, "executeDeletes", options);
      }
      const size = this.config.get("batchSize");
      const meta = changeSets[0].meta;
      const pk = utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
      for (let i2 = 0;i2 < changeSets.length; i2 += size) {
        const chunk = changeSets.slice(i2, i2 + size);
        const pks = chunk.map((cs) => cs.getPrimaryKey());
        options = this.propagateSchemaFromMetadata(meta, options);
        await this.driver.nativeDelete(meta.className, { [pk]: { $in: pks } }, options);
      }
    }
    async runForEachSchema(changeSets, method, options, ...args) {
      const groups = new Map;
      changeSets.forEach((cs) => {
        const group = groups.get(cs.schema) ?? [];
        group.push(cs);
        groups.set(cs.schema, group);
      });
      for (const [key, group] of groups.entries()) {
        options = { ...options, schema: key };
        await this[method](group, ...args, options, true);
      }
    }
    processProperties(changeSet) {
      const meta = this.metadata.find(changeSet.name);
      for (const prop of meta.relations) {
        this.processProperty(changeSet, prop);
      }
      if (changeSet.type === ChangeSet_1.ChangeSetType.CREATE && this.config.get("validateRequired")) {
        this.validator.validateRequired(changeSet.entity);
      }
    }
    async persistNewEntity(meta, changeSet, options) {
      const wrapped = (0, entity_1.helper)(changeSet.entity);
      options = this.propagateSchemaFromMetadata(meta, options, {
        convertCustomTypes: false
      });
      const res = await this.driver.nativeInsertMany(meta.className, [changeSet.payload], options);
      if (!wrapped.hasPrimaryKey()) {
        this.mapPrimaryKey(meta, res.insertId, changeSet);
      }
      this.mapReturnedValues(changeSet.entity, changeSet.payload, res.row, meta);
      this.markAsPopulated(changeSet, meta);
      wrapped.__initialized = true;
      wrapped.__managed = true;
      if (!this.platform.usesReturningStatement()) {
        await this.reloadVersionValues(meta, [changeSet], options);
      }
      changeSet.persisted = true;
    }
    async persistNewEntities(meta, changeSets, options) {
      const size = this.config.get("batchSize");
      for (let i2 = 0;i2 < changeSets.length; i2 += size) {
        const chunk = changeSets.slice(i2, i2 + size);
        await this.persistNewEntitiesBatch(meta, chunk, options);
        if (!this.platform.usesReturningStatement()) {
          await this.reloadVersionValues(meta, chunk, options);
        }
      }
    }
    propagateSchemaFromMetadata(meta, options, additionalOptions) {
      return {
        ...options,
        ...additionalOptions,
        schema: options?.schema ?? meta.schema
      };
    }
    async persistNewEntitiesBatch(meta, changeSets, options) {
      options = this.propagateSchemaFromMetadata(meta, options, {
        convertCustomTypes: false,
        processCollections: false
      });
      const res = await this.driver.nativeInsertMany(meta.className, changeSets.map((cs) => cs.payload), options);
      for (let i2 = 0;i2 < changeSets.length; i2++) {
        const changeSet = changeSets[i2];
        const wrapped = (0, entity_1.helper)(changeSet.entity);
        if (!wrapped.hasPrimaryKey()) {
          const field = meta.getPrimaryProps()[0].fieldNames[0];
          this.mapPrimaryKey(meta, res.rows[i2][field], changeSet);
        }
        if (res.rows) {
          this.mapReturnedValues(changeSet.entity, changeSet.payload, res.rows[i2], meta);
        }
        this.markAsPopulated(changeSet, meta);
        wrapped.__initialized = true;
        wrapped.__managed = true;
        changeSet.persisted = true;
      }
    }
    async persistManagedEntity(changeSet, options) {
      const meta = this.metadata.find(changeSet.name);
      const res = await this.updateEntity(meta, changeSet, options);
      this.checkOptimisticLock(meta, changeSet, res);
      this.mapReturnedValues(changeSet.entity, changeSet.payload, res.row, meta);
      await this.reloadVersionValues(meta, [changeSet], options);
      changeSet.persisted = true;
    }
    async persistManagedEntities(meta, changeSets, options) {
      const size = this.config.get("batchSize");
      for (let i2 = 0;i2 < changeSets.length; i2 += size) {
        const chunk = changeSets.slice(i2, i2 + size);
        await this.persistManagedEntitiesBatch(meta, chunk, options);
        await this.reloadVersionValues(meta, chunk, options);
      }
    }
    checkConcurrencyKeys(meta, changeSet, cond) {
      const tmp = [];
      cond = utils_1.Utils.isPlainObject(cond) ? cond : { [meta.primaryKeys[0]]: cond };
      for (const key of meta.concurrencyCheckKeys) {
        cond[key] = changeSet.originalEntity[key];
        if (changeSet.payload[key]) {
          tmp.push(key);
        }
      }
      if (tmp.length === 0 && meta.concurrencyCheckKeys.size > 0) {
        throw errors_1.OptimisticLockError.lockFailed(changeSet.entity);
      }
    }
    async persistManagedEntitiesBatch(meta, changeSets, options) {
      await this.checkOptimisticLocks(meta, changeSets, options);
      options = this.propagateSchemaFromMetadata(meta, options, {
        convertCustomTypes: false,
        processCollections: false
      });
      const cond = changeSets.map((cs) => cs.getPrimaryKey(true));
      changeSets.forEach((changeSet, idx) => {
        this.checkConcurrencyKeys(meta, changeSet, cond[idx]);
      });
      const res = await this.driver.nativeUpdateMany(meta.className, cond, changeSets.map((cs) => cs.payload), options);
      changeSets.forEach((changeSet, idx) => {
        if (res.rows) {
          this.mapReturnedValues(changeSet.entity, changeSet.payload, res.rows[idx], meta);
        }
        changeSet.persisted = true;
      });
    }
    mapPrimaryKey(meta, value14, changeSet) {
      const prop = meta.properties[meta.primaryKeys[0]];
      const insertId = prop.customType ? prop.customType.convertToJSValue(value14, this.platform) : value14;
      const wrapped = (0, entity_1.helper)(changeSet.entity);
      if (!wrapped.hasPrimaryKey()) {
        wrapped.setPrimaryKey(insertId);
      }
      value14 = prop.customType ? prop.customType.convertToDatabaseValue(insertId, this.platform, { mode: "serialization" }) : value14;
      changeSet.payload[wrapped.__meta.primaryKeys[0]] = value14;
      wrapped.__identifier?.setValue(value14);
    }
    markAsPopulated(changeSet, meta) {
      (0, entity_1.helper)(changeSet.entity).__schema = this.driver.getSchemaName(meta, changeSet);
      if (!this.config.get("populateAfterFlush")) {
        return;
      }
      (0, entity_1.helper)(changeSet.entity).populated();
      meta.relations.forEach((prop) => {
        const value14 = changeSet.entity[prop.name];
        if (utils_1.Utils.isEntity(value14, true)) {
          value14.__helper.populated();
        } else if (utils_1.Utils.isCollection(value14)) {
          value14.populated();
        }
      });
    }
    async updateEntity(meta, changeSet, options) {
      const cond = changeSet.getPrimaryKey(true);
      options = this.propagateSchemaFromMetadata(meta, options, {
        convertCustomTypes: false
      });
      if (meta.concurrencyCheckKeys.size === 0 && (!meta.versionProperty || changeSet.entity[meta.versionProperty] == null)) {
        return this.driver.nativeUpdate(changeSet.name, cond, changeSet.payload, options);
      }
      if (meta.versionProperty) {
        cond[meta.versionProperty] = this.platform.quoteVersionValue(changeSet.entity[meta.versionProperty], meta.properties[meta.versionProperty]);
      }
      this.checkConcurrencyKeys(meta, changeSet, cond);
      return this.driver.nativeUpdate(changeSet.name, cond, changeSet.payload, options);
    }
    async checkOptimisticLocks(meta, changeSets, options) {
      if (meta.concurrencyCheckKeys.size === 0 && (!meta.versionProperty || changeSets.every((cs) => cs.entity[meta.versionProperty] == null))) {
        return;
      }
      changeSets = changeSets.filter((cs) => (0, entity_1.helper)(cs.entity).__initialized);
      const $or = changeSets.map((cs) => {
        const cond = utils_1.Utils.getPrimaryKeyCond(cs.originalEntity, meta.primaryKeys.concat(...meta.concurrencyCheckKeys));
        if (meta.versionProperty) {
          cond[meta.versionProperty] = this.platform.quoteVersionValue(cs.entity[meta.versionProperty], meta.properties[meta.versionProperty]);
        }
        return cond;
      });
      const primaryKeys = meta.primaryKeys.concat(...meta.concurrencyCheckKeys);
      options = this.propagateSchemaFromMetadata(meta, options, {
        fields: primaryKeys
      });
      const res = await this.driver.find(meta.className, { $or }, options);
      if (res.length !== changeSets.length) {
        const compare = (a2, b2, keys) => keys.every((k) => a2[k] === b2[k]);
        const entity = changeSets.find((cs) => {
          return !res.some((row) => compare(utils_1.Utils.getPrimaryKeyCond(cs.entity, primaryKeys), row, primaryKeys));
        }).entity;
        throw errors_1.OptimisticLockError.lockFailed(entity);
      }
    }
    checkOptimisticLock(meta, changeSet, res) {
      if ((meta.versionProperty || meta.concurrencyCheckKeys.size > 0) && res && !res.affectedRows) {
        throw errors_1.OptimisticLockError.lockFailed(changeSet.entity);
      }
    }
    async reloadVersionValues(meta, changeSets, options) {
      const reloadProps = meta.versionProperty && !this.platform.usesReturningStatement() ? [meta.properties[meta.versionProperty]] : [];
      if (changeSets[0].type === ChangeSet_1.ChangeSetType.CREATE) {
        meta.props.filter((prop) => prop.persist !== false && (prop.autoincrement || prop.generated || prop.defaultRaw)).filter((prop) => changeSets[0].entity[prop.name] == null && prop.defaultRaw !== "null" || utils_1.Utils.isRawSql(changeSets[0].entity[prop.name])).forEach((prop) => reloadProps.push(prop));
      }
      if (changeSets[0].type === ChangeSet_1.ChangeSetType.UPDATE) {
        const returning = new Set;
        changeSets.forEach((cs) => {
          utils_1.Utils.keys(cs.payload).forEach((k) => {
            if (utils_1.Utils.isRawSql(cs.payload[k]) && utils_1.Utils.isRawSql(cs.entity[k])) {
              returning.add(meta.properties[k]);
            }
          });
        });
        if (!this.platform.usesReturningStatement()) {
          meta.props.filter((prop) => prop.generated && !prop.primary).forEach((prop) => reloadProps.push(prop));
          reloadProps.push(...returning);
        }
      }
      if (reloadProps.length === 0) {
        return;
      }
      reloadProps.unshift(...meta.getPrimaryProps());
      const pk = utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
      const pks = changeSets.map((cs) => {
        const val = (0, entity_1.helper)(cs.entity).getPrimaryKey(true);
        if (utils_1.Utils.isPlainObject(val)) {
          return utils_1.Utils.getCompositeKeyValue(val, meta, false, this.platform);
        }
        return val;
      });
      options = this.propagateSchemaFromMetadata(meta, options, {
        fields: utils_1.Utils.unique(reloadProps.map((prop) => prop.name))
      });
      const data = await this.driver.find(meta.name, { [pk]: { $in: pks } }, options);
      const map3 = new Map;
      data.forEach((item) => map3.set(utils_1.Utils.getCompositeKeyHash(item, meta, true, this.platform, true), item));
      for (const changeSet of changeSets) {
        const data2 = map3.get((0, entity_1.helper)(changeSet.entity).getSerializedPrimaryKey());
        this.hydrator.hydrate(changeSet.entity, meta, data2, this.factory, "full", false, true);
        Object.assign(changeSet.payload, data2);
      }
    }
    processProperty(changeSet, prop) {
      const meta = this.metadata.find(changeSet.name);
      const value14 = changeSet.payload[prop.name];
      if (value14 instanceof entity_1.EntityIdentifier) {
        changeSet.payload[prop.name] = value14.getValue();
        return;
      }
      if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && Array.isArray(value14)) {
        changeSet.payload[prop.name] = value14.map((val) => val instanceof entity_1.EntityIdentifier ? val.getValue() : val);
        return;
      }
      if (prop.name in changeSet.payload) {
        return;
      }
      const values = utils_1.Utils.unwrapProperty(changeSet.payload, meta, prop, true);
      values.forEach(([value15, indexes]) => {
        if (value15 instanceof entity_1.EntityIdentifier) {
          utils_1.Utils.setPayloadProperty(changeSet.payload, meta, prop, value15.getValue(), indexes);
        }
      });
    }
    mapReturnedValues(entity, payload, row, meta) {
      if (this.platform.usesReturningStatement() && row && utils_1.Utils.hasObjectKeys(row)) {
        const mapped19 = this.comparator.mapResult(meta.className, row);
        this.hydrator.hydrate(entity, meta, mapped19, this.factory, "full", false, true);
        Object.assign(payload, mapped19);
      }
    }
  }
  exports.ChangeSetPersister = ChangeSetPersister;
});

// node_modules/@mikro-orm/core/events/EventSubscriber.js
var require_EventSubscriber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@mikro-orm/core/events/EventManager.js
var require_EventManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventManager = undefined;
  var utils_1 = require_utils10();
  var enums_1 = require_enums();

  class EventManager {
    listeners = {};
    entities = new Map;
    cache = new Map;
    subscribers = [];
    constructor(subscribers) {
      subscribers.forEach((subscriber) => this.registerSubscriber(subscriber));
    }
    registerSubscriber(subscriber) {
      this.subscribers.push(subscriber);
      this.entities.set(subscriber, this.getSubscribedEntities(subscriber));
      this.cache.clear();
      utils_1.Utils.keys(enums_1.EventType).filter((event) => (event in subscriber)).forEach((event) => {
        this.listeners[event] ??= [];
        this.listeners[event].push(subscriber);
      });
    }
    dispatchEvent(event, args, meta) {
      const listeners = [];
      const entity = args.entity;
      meta ??= entity?.__meta;
      const hooks = meta?.hooks[event] || [];
      listeners.push(...hooks.map((hook) => {
        const prototypeHook = meta?.prototype[hook];
        const handler = typeof hook === "function" ? hook : entity[hook] ?? prototypeHook;
        return handler.bind(entity);
      }));
      for (const listener of this.listeners[event] || []) {
        const entities = this.entities.get(listener);
        if (entities.length === 0 || !entity || entities.includes(entity.constructor.name)) {
          listeners.push(listener[event].bind(listener));
        }
      }
      if (event === enums_1.EventType.onInit) {
        return listeners.forEach((listener) => listener(args));
      }
      return utils_1.Utils.runSerial(listeners, (listener) => listener(args));
    }
    hasListeners(event, meta) {
      const cacheKey = meta._id + enums_1.EventTypeMap[event];
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey);
      }
      const hasHooks = meta.hooks[event]?.length;
      if (hasHooks) {
        this.cache.set(cacheKey, true);
        return true;
      }
      for (const listener of this.listeners[event] ?? []) {
        const entities = this.entities.get(listener);
        if (entities.length === 0 || entities.includes(meta.className)) {
          this.cache.set(cacheKey, true);
          return true;
        }
      }
      this.cache.set(cacheKey, false);
      return false;
    }
    clone() {
      return new EventManager(this.subscribers);
    }
    getSubscribedEntities(listener) {
      if (!listener.getSubscribedEntities) {
        return [];
      }
      return listener.getSubscribedEntities().map((name) => utils_1.Utils.className(name));
    }
  }
  exports.EventManager = EventManager;
});

// node_modules/@mikro-orm/core/events/TransactionEventBroadcaster.js
var require_TransactionEventBroadcaster = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransactionEventBroadcaster = undefined;

  class TransactionEventBroadcaster {
    em;
    uow;
    eventManager;
    constructor(em, uow) {
      this.em = em;
      this.uow = uow;
      this.eventManager = this.em.getEventManager();
    }
    async dispatchEvent(event, transaction) {
      await this.eventManager.dispatchEvent(event, { em: this.em, transaction, uow: this.uow });
    }
  }
  exports.TransactionEventBroadcaster = TransactionEventBroadcaster;
});

// node_modules/@mikro-orm/core/events/index.js
var require_events2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_EventSubscriber(), exports);
  __exportStar(require_EventManager(), exports);
  __exportStar(require_TransactionEventBroadcaster(), exports);
});

// node_modules/@mikro-orm/core/unit-of-work/IdentityMap.js
var require_IdentityMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IdentityMap = undefined;
  var Utils_1 = require_Utils();

  class IdentityMap {
    registry = new Map;
    store(item) {
      this.getStore(item.__meta.root).set(this.getPkHash(item), item);
    }
    delete(item) {
      this.getStore(item.__meta.root).delete(this.getPkHash(item));
    }
    getByHash(meta, hash6) {
      const store = this.getStore(meta);
      return store.has(hash6) ? store.get(hash6) : undefined;
    }
    getStore(meta) {
      const store = this.registry.get(meta.class);
      if (store) {
        return store;
      }
      const newStore = new Map;
      this.registry.set(meta.class, newStore);
      return newStore;
    }
    clear() {
      this.registry.clear();
    }
    values() {
      const ret = [];
      for (const store of this.registry.values()) {
        ret.push(...store.values());
      }
      return ret;
    }
    *[Symbol.iterator]() {
      for (const store of this.registry.values()) {
        for (const item of store.values()) {
          yield item;
        }
      }
    }
    keys() {
      const ret = [];
      for (const [cls, store] of this.registry) {
        ret.push(...[...store.keys()].map((hash6) => `${cls.name}-${hash6}`));
      }
      return ret;
    }
    get(hash6) {
      const [name, id] = hash6.split("-", 2);
      const cls = [...this.registry.keys()].find((k) => k.name === name);
      if (!cls) {
        return;
      }
      const store = this.registry.get(cls);
      return store.has(id) ? store.get(id) : undefined;
    }
    getPkHash(item) {
      const wrapped = item.__helper;
      const meta = wrapped.__meta;
      const pk = wrapped.getPrimaryKey(true);
      if (pk == null) {
        return pk;
      }
      let hash6;
      if (meta.simplePK) {
        hash6 = "" + item[meta.primaryKeys[0]];
      } else {
        const pks = Utils_1.Utils.getOrderedPrimaryKeys(pk, meta);
        hash6 = Utils_1.Utils.getPrimaryKeyHash(pks);
      }
      const schema = wrapped.__schema || meta.root.schema;
      if (schema) {
        return schema + ":" + hash6;
      }
      return hash6;
    }
  }
  exports.IdentityMap = IdentityMap;
});

// node_modules/@mikro-orm/core/unit-of-work/UnitOfWork.js
var require_UnitOfWork = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnitOfWork = undefined;
  var async_hooks_1 = import.meta.require("async_hooks");
  var entity_1 = require_entity();
  var ChangeSet_1 = require_ChangeSet();
  var ChangeSetComputer_1 = require_ChangeSetComputer();
  var ChangeSetPersister_1 = require_ChangeSetPersister();
  var CommitOrderCalculator_1 = require_CommitOrderCalculator();
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();
  var errors_1 = require_errors3();
  var events_1 = require_events2();
  var IdentityMap_1 = require_IdentityMap();
  var insideFlush = new async_hooks_1.AsyncLocalStorage;

  class UnitOfWork {
    em;
    identityMap = new IdentityMap_1.IdentityMap;
    persistStack = new Set;
    removeStack = new Set;
    orphanRemoveStack = new Set;
    changeSets = new Map;
    collectionUpdates = new Set;
    extraUpdates = new Set;
    metadata;
    platform;
    eventManager;
    comparator;
    changeSetComputer;
    changeSetPersister;
    queuedActions = new Set;
    loadedEntities = new Set;
    flushQueue = [];
    working = false;
    constructor(em) {
      this.em = em;
      this.metadata = this.em.getMetadata();
      this.platform = this.em.getPlatform();
      this.eventManager = this.em.getEventManager();
      this.comparator = this.em.getComparator();
      this.changeSetComputer = new ChangeSetComputer_1.ChangeSetComputer(this.em.getValidator(), this.collectionUpdates, this.metadata, this.platform, this.em.config);
      this.changeSetPersister = new ChangeSetPersister_1.ChangeSetPersister(this.em.getDriver(), this.metadata, this.em.config.getHydrator(this.metadata), this.em.getEntityFactory(), this.em.getValidator(), this.em.config);
    }
    merge(entity, visited2) {
      const wrapped = (0, entity_1.helper)(entity);
      wrapped.__em = this.em;
      if (!wrapped.hasPrimaryKey()) {
        return;
      }
      if (!wrapped.__managed && visited2) {
        return;
      }
      this.identityMap.store(entity);
      if (wrapped.__initialized && (!visited2 || !wrapped.__originalEntityData)) {
        wrapped.__originalEntityData = this.comparator.prepareEntity(entity);
        wrapped.__touched = false;
      }
      this.cascade(entity, enums_1.Cascade.MERGE, visited2 ?? new Set);
    }
    register(entity, data, options) {
      this.identityMap.store(entity);
      entity_1.EntityHelper.ensurePropagation(entity);
      if (options?.newEntity) {
        return entity;
      }
      const wrapped = (0, entity_1.helper)(entity);
      if (options?.loaded && wrapped.__initialized && !wrapped.__onLoadFired) {
        this.loadedEntities.add(entity);
      }
      wrapped.__em ??= this.em;
      wrapped.__managed = true;
      if (data && (options?.refresh || !wrapped.__originalEntityData)) {
        Object.keys(data).forEach((key) => wrapped.__loadedProperties.add(key));
        wrapped.__meta.relations.forEach((prop) => {
          if (Utils_1.Utils.isPlainObject(data[prop.name])) {
            data[prop.name] = Utils_1.Utils.getPrimaryKeyValues(data[prop.name], prop.targetMeta.primaryKeys, true);
          }
        });
        wrapped.__meta.props.forEach((prop) => {
          if (prop.kind === enums_1.ReferenceKind.EMBEDDED && !prop.object && Utils_1.Utils.isPlainObject(data[prop.name])) {
            prop.targetMeta?.props.forEach((p2) => {
              const prefix = prop.prefix === false ? "" : prop.prefix === true ? prop.name + "_" : prop.prefix;
              data[prefix + p2.name] = data[prop.name][p2.name];
            });
            data[prop.name] = Utils_1.Utils.getPrimaryKeyValues(data[prop.name], prop.targetMeta.primaryKeys, true);
          }
        });
        if (this.em.config.get("forceUndefined")) {
          Utils_1.Utils.keys(data).forEach((key) => {
            if (data[key] === null) {
              data[key] = undefined;
            }
          });
        }
        wrapped.__originalEntityData = data;
        wrapped.__touched = false;
      }
      return entity;
    }
    async dispatchOnLoadEvent() {
      for (const entity of this.loadedEntities) {
        if (this.eventManager.hasListeners(enums_1.EventType.onLoad, entity.__meta)) {
          await this.eventManager.dispatchEvent(enums_1.EventType.onLoad, { entity, meta: entity.__meta, em: this.em });
          (0, entity_1.helper)(entity).__onLoadFired = true;
        }
      }
      this.loadedEntities.clear();
    }
    getById(entityName, id, schema) {
      if (id == null || Array.isArray(id) && id.length === 0) {
        return;
      }
      const meta = this.metadata.find(entityName).root;
      let hash6;
      if (meta.simplePK) {
        hash6 = "" + id;
      } else {
        const keys = Array.isArray(id) ? Utils_1.Utils.flatten(id) : [id];
        hash6 = Utils_1.Utils.getPrimaryKeyHash(keys);
      }
      schema ??= meta.schema ?? this.em.config.get("schema");
      if (schema) {
        hash6 = `${schema}:${hash6}`;
      }
      return this.identityMap.getByHash(meta, hash6);
    }
    tryGetById(entityName, where, schema, strict3 = true) {
      const pk = Utils_1.Utils.extractPK(where, this.metadata.find(entityName), strict3);
      if (!pk) {
        return null;
      }
      return this.getById(entityName, pk, schema);
    }
    getIdentityMap() {
      return this.identityMap;
    }
    getOriginalEntityData(entity) {
      return (0, entity_1.helper)(entity).__originalEntityData;
    }
    getPersistStack() {
      return this.persistStack;
    }
    getRemoveStack() {
      return this.removeStack;
    }
    getChangeSets() {
      return [...this.changeSets.values()];
    }
    getCollectionUpdates() {
      return [...this.collectionUpdates];
    }
    getExtraUpdates() {
      return this.extraUpdates;
    }
    shouldAutoFlush(meta) {
      if (insideFlush.getStore()) {
        return false;
      }
      if (this.queuedActions.has(meta.className) || this.queuedActions.has(meta.root.className)) {
        return true;
      }
      for (const entity of this.identityMap.getStore(meta).values()) {
        if ((0, entity_1.helper)(entity).__initialized && (0, entity_1.helper)(entity).isTouched()) {
          return true;
        }
      }
      return false;
    }
    clearActionsQueue() {
      this.queuedActions.clear();
    }
    computeChangeSet(entity, type73) {
      const wrapped = (0, entity_1.helper)(entity);
      if (type73) {
        this.changeSets.set(entity, new ChangeSet_1.ChangeSet(entity, type73, {}, wrapped.__meta));
        return;
      }
      const cs = this.changeSetComputer.computeChangeSet(entity);
      if (!cs || this.checkUniqueProps(cs)) {
        return;
      }
      this.initIdentifier(entity);
      this.changeSets.set(entity, cs);
      this.persistStack.delete(entity);
      wrapped.__originalEntityData = this.comparator.prepareEntity(entity);
      wrapped.__touched = false;
    }
    recomputeSingleChangeSet(entity) {
      const changeSet = this.changeSets.get(entity);
      if (!changeSet) {
        return;
      }
      const cs = this.changeSetComputer.computeChangeSet(entity);
      if (cs && !this.checkUniqueProps(cs)) {
        Object.assign(changeSet.payload, cs.payload);
        (0, entity_1.helper)(entity).__originalEntityData = this.comparator.prepareEntity(entity);
        (0, entity_1.helper)(entity).__touched = false;
      }
    }
    persist(entity, visited2, options = {}) {
      entity_1.EntityHelper.ensurePropagation(entity);
      if (options.checkRemoveStack && this.removeStack.has(entity)) {
        return;
      }
      const wrapped = (0, entity_1.helper)(entity);
      this.persistStack.add(entity);
      this.queuedActions.add(wrapped.__meta.className);
      this.removeStack.delete(entity);
      if (!wrapped.__managed && wrapped.hasPrimaryKey()) {
        this.identityMap.store(entity);
      }
      if (options.cascade ?? true) {
        this.cascade(entity, enums_1.Cascade.PERSIST, visited2, options);
      }
    }
    remove(entity, visited2, options = {}) {
      if ((0, entity_1.helper)(entity).__managed || !this.persistStack.has(entity)) {
        this.removeStack.add(entity);
        this.queuedActions.add((0, entity_1.helper)(entity).__meta.className);
      } else {
        this.persistStack.delete(entity);
        this.identityMap.delete(entity);
      }
      for (const prop of (0, entity_1.helper)(entity).__meta.bidirectionalRelations) {
        const inverseProp = prop.mappedBy || prop.inversedBy;
        const relation = entity_1.Reference.unwrapReference(entity[prop.name]);
        const prop2 = prop.targetMeta.properties[inverseProp];
        if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY && prop2.nullable && Utils_1.Utils.isCollection(relation)) {
          relation.getItems(false).forEach((item) => delete item[inverseProp]);
          continue;
        }
        const target = relation && relation[inverseProp];
        if (relation && Utils_1.Utils.isCollection(target)) {
          target.removeWithoutPropagation(entity);
        }
      }
      if (options.cascade ?? true) {
        this.cascade(entity, enums_1.Cascade.REMOVE, visited2);
      }
    }
    async commit() {
      if (this.working) {
        if (insideFlush.getStore()) {
          throw errors_1.ValidationError.cannotCommit();
        }
        return new Promise((resolve, reject) => {
          this.flushQueue.push(() => {
            return insideFlush.run(true, () => {
              return this.doCommit().then(resolve, reject);
            });
          });
        });
      }
      try {
        this.working = true;
        await insideFlush.run(true, () => this.doCommit());
        while (this.flushQueue.length) {
          await this.flushQueue.shift()();
        }
      } finally {
        this.postCommitCleanup();
        this.working = false;
      }
    }
    async doCommit() {
      const oldTx = this.em.getTransactionContext();
      try {
        await this.eventManager.dispatchEvent(enums_1.EventType.beforeFlush, { em: this.em, uow: this });
        this.computeChangeSets();
        this.changeSets.forEach((cs) => {
          cs.entity.__helper.__processing = true;
        });
        await this.eventManager.dispatchEvent(enums_1.EventType.onFlush, { em: this.em, uow: this });
        if (this.changeSets.size === 0 && this.collectionUpdates.size === 0 && this.extraUpdates.size === 0) {
          return void await this.eventManager.dispatchEvent(enums_1.EventType.afterFlush, { em: this.em, uow: this });
        }
        const groups = this.getChangeSetGroups();
        const platform = this.em.getPlatform();
        const runInTransaction = !this.em.isInTransaction() && platform.supportsTransactions() && this.em.config.get("implicitTransactions");
        if (runInTransaction) {
          await this.em.getConnection("write").transactional((trx) => this.persistToDatabase(groups, trx), {
            ctx: oldTx,
            eventBroadcaster: new events_1.TransactionEventBroadcaster(this.em, this)
          });
        } else {
          await this.persistToDatabase(groups, this.em.getTransactionContext());
        }
        this.resetTransaction(oldTx);
        this.changeSets.forEach((cs) => {
          cs.entity.__helper.__processing = false;
        });
        await this.eventManager.dispatchEvent(enums_1.EventType.afterFlush, { em: this.em, uow: this });
      } finally {
        this.resetTransaction(oldTx);
      }
    }
    async lock(entity, options) {
      if (!this.getById(entity.constructor.name, (0, entity_1.helper)(entity).__primaryKeys, (0, entity_1.helper)(entity).__schema)) {
        throw errors_1.ValidationError.entityNotManaged(entity);
      }
      const meta = this.metadata.find(entity.constructor.name);
      if (options.lockMode === enums_1.LockMode.OPTIMISTIC) {
        await this.lockOptimistic(entity, meta, options.lockVersion);
      } else if (options.lockMode != null) {
        await this.lockPessimistic(entity, options);
      }
    }
    clear() {
      this.identityMap.clear();
      this.loadedEntities.clear();
      this.postCommitCleanup();
    }
    unsetIdentity(entity) {
      this.identityMap.delete(entity);
      const wrapped = (0, entity_1.helper)(entity);
      for (const { meta, prop } of wrapped.__meta.referencingProperties) {
        for (const referrer of this.identityMap.getStore(meta).values()) {
          const rel = entity_1.Reference.unwrapReference(referrer[prop.name]);
          if (Utils_1.Utils.isCollection(rel)) {
            rel.removeWithoutPropagation(entity);
          } else if (rel === entity) {
            delete (0, entity_1.helper)(referrer).__data[prop.name];
          }
        }
      }
      delete wrapped.__identifier;
      delete wrapped.__originalEntityData;
      wrapped.__touched = false;
      wrapped.__managed = false;
    }
    computeChangeSets() {
      this.changeSets.clear();
      const visited2 = new Set;
      for (const entity of this.removeStack) {
        this.cascade(entity, enums_1.Cascade.REMOVE, visited2);
      }
      visited2.clear();
      for (const entity of this.persistStack) {
        this.cascade(entity, enums_1.Cascade.PERSIST, visited2, { checkRemoveStack: true });
      }
      for (const entity of this.identityMap) {
        if (!this.removeStack.has(entity) && !this.persistStack.has(entity) && !this.orphanRemoveStack.has(entity)) {
          this.persistStack.add(entity);
          this.cascade(entity, enums_1.Cascade.PERSIST, visited2, { checkRemoveStack: true });
        }
      }
      visited2.clear();
      for (const entity of this.persistStack) {
        this.findNewEntities(entity, visited2);
      }
      for (const entity of this.orphanRemoveStack) {
        if (!(0, entity_1.helper)(entity).__processing) {
          this.removeStack.add(entity);
        }
      }
      const inserts = {};
      for (const cs of this.changeSets.values()) {
        if (cs.type === ChangeSet_1.ChangeSetType.CREATE) {
          inserts[cs.meta.className] ??= [];
          inserts[cs.meta.className].push(cs);
        }
      }
      for (const cs of this.changeSets.values()) {
        if (cs.type === ChangeSet_1.ChangeSetType.UPDATE) {
          this.findEarlyUpdates(cs, inserts[cs.meta.className]);
        }
      }
      for (const entity of this.removeStack) {
        const wrapped = (0, entity_1.helper)(entity);
        if (wrapped.__processing) {
          continue;
        }
        const deletePkHash = [wrapped.getSerializedPrimaryKey(), ...this.expandUniqueProps(entity)];
        let type73 = ChangeSet_1.ChangeSetType.DELETE;
        for (const cs of inserts[wrapped.__meta.className] ?? []) {
          if (deletePkHash.some((hash6) => hash6 === cs.getSerializedPrimaryKey() || this.expandUniqueProps(cs.entity).find((child) => hash6 === child))) {
            type73 = ChangeSet_1.ChangeSetType.DELETE_EARLY;
          }
        }
        this.computeChangeSet(entity, type73);
      }
    }
    scheduleExtraUpdate(changeSet, props) {
      if (props.length === 0) {
        return;
      }
      this.extraUpdates.add([changeSet.entity, props.map((p2) => p2.name), props.map((p2) => changeSet.entity[p2.name]), changeSet]);
      props.forEach((p2) => delete changeSet.entity[p2.name]);
      props.forEach((p2) => delete changeSet.payload[p2.name]);
    }
    scheduleOrphanRemoval(entity, visited2) {
      if (entity) {
        this.orphanRemoveStack.add(entity);
        this.queuedActions.add(entity.__meta.className);
        this.cascade(entity, enums_1.Cascade.SCHEDULE_ORPHAN_REMOVAL, visited2);
      }
    }
    cancelOrphanRemoval(entity, visited2) {
      this.orphanRemoveStack.delete(entity);
      this.cascade(entity, enums_1.Cascade.CANCEL_ORPHAN_REMOVAL, visited2);
    }
    getOrphanRemoveStack() {
      return this.orphanRemoveStack;
    }
    getChangeSetPersister() {
      return this.changeSetPersister;
    }
    findNewEntities(entity, visited2, idx = 0, processed = new Set) {
      if (visited2.has(entity)) {
        return;
      }
      visited2.add(entity);
      processed.add(entity);
      const wrapped = (0, entity_1.helper)(entity);
      if (wrapped.__processing || this.removeStack.has(entity) || this.orphanRemoveStack.has(entity)) {
        return;
      }
      wrapped.__schema ??= this.em.schema;
      this.initIdentifier(entity);
      for (const prop of (0, entity_1.helper)(entity).__meta.relations) {
        const targets = Utils_1.Utils.unwrapProperty(entity, (0, entity_1.helper)(entity).__meta, prop);
        targets.forEach(([target]) => {
          const kind = entity_1.Reference.unwrapReference(target);
          this.processReference(entity, prop, kind, visited2, processed, idx);
        });
      }
      const changeSet = this.changeSetComputer.computeChangeSet(entity);
      if (changeSet && !this.checkUniqueProps(changeSet)) {
        this.changeSets.set(entity, changeSet);
      }
    }
    checkUniqueProps(changeSet) {
      if (this.platform.allowsUniqueBatchUpdates() || changeSet.type !== ChangeSet_1.ChangeSetType.UPDATE) {
        return false;
      }
      const uniqueProps = changeSet.meta.uniqueProps.filter((prop) => prop.nullable && changeSet.payload[prop.name] != null);
      this.scheduleExtraUpdate(changeSet, uniqueProps);
      return changeSet.type === ChangeSet_1.ChangeSetType.UPDATE && !Utils_1.Utils.hasObjectKeys(changeSet.payload);
    }
    expandUniqueProps(entity) {
      const wrapped = (0, entity_1.helper)(entity);
      if (!wrapped.__meta.hasUniqueProps) {
        return [];
      }
      const simpleUniqueHashes = wrapped.__meta.uniqueProps.map((prop) => {
        if (entity[prop.name] != null) {
          return prop.kind === enums_1.ReferenceKind.SCALAR || prop.mapToPk ? entity[prop.name] : (0, entity_1.helper)(entity[prop.name]).getSerializedPrimaryKey();
        }
        if (wrapped.__originalEntityData?.[prop.name] != null) {
          return Utils_1.Utils.getPrimaryKeyHash(Utils_1.Utils.asArray(wrapped.__originalEntityData[prop.name]));
        }
        return;
      }).filter((i2) => i2);
      const compoundUniqueHashes = wrapped.__meta.uniques.map((unique) => {
        const props = Utils_1.Utils.asArray(unique.properties);
        if (props.every((prop) => entity[prop] != null)) {
          return Utils_1.Utils.getPrimaryKeyHash(props.map((p2) => {
            const prop = wrapped.__meta.properties[p2];
            return prop.kind === enums_1.ReferenceKind.SCALAR || prop.mapToPk ? entity[prop.name] : (0, entity_1.helper)(entity[prop.name]).getSerializedPrimaryKey();
          }));
        }
        return;
      }).filter((i2) => i2);
      return simpleUniqueHashes.concat(compoundUniqueHashes);
    }
    initIdentifier(entity) {
      const wrapped = entity && (0, entity_1.helper)(entity);
      if (!wrapped || wrapped.__identifier || wrapped.hasPrimaryKey()) {
        return;
      }
      const pk = wrapped.__meta.getPrimaryProps()[0];
      if (pk.kind === enums_1.ReferenceKind.SCALAR) {
        wrapped.__identifier = new entity_1.EntityIdentifier;
      } else if (entity[pk.name]) {
        this.initIdentifier(entity[pk.name]);
        wrapped.__identifier = (0, entity_1.helper)(entity[pk.name])?.__identifier;
      }
    }
    processReference(parent, prop, kind, visited2, processed, idx) {
      const isToOne = prop.kind === enums_1.ReferenceKind.MANY_TO_ONE || prop.kind === enums_1.ReferenceKind.ONE_TO_ONE;
      if (isToOne && Utils_1.Utils.isEntity(kind)) {
        return this.processToOneReference(kind, visited2, processed, idx);
      }
      if (Utils_1.Utils.isCollection(kind)) {
        kind.getItems(false).filter((item) => !item.__helper.__originalEntityData).forEach((item) => {
          item.__helper.__schema ??= (0, entity_1.helper)(parent).__schema;
        });
        if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && kind.isDirty()) {
          this.processToManyReference(kind, visited2, processed, parent, prop);
        }
      }
    }
    processToOneReference(kind, visited2, processed, idx) {
      if (!kind.__helper.__managed) {
        this.findNewEntities(kind, visited2, idx, processed);
      }
    }
    processToManyReference(collection, visited2, processed, parent, prop) {
      if (this.isCollectionSelfReferenced(collection, processed)) {
        this.extraUpdates.add([parent, prop.name, collection, undefined]);
        const coll = new entity_1.Collection(parent);
        coll.property = prop;
        parent[prop.name] = coll;
        return;
      }
      collection.getItems(false).filter((item) => !item.__helper.__originalEntityData).forEach((item) => this.findNewEntities(item, visited2, 0, processed));
    }
    async runHooks(type73, changeSet, sync = false) {
      const meta = changeSet.meta;
      if (!this.eventManager.hasListeners(type73, meta)) {
        return;
      }
      if (!sync) {
        await this.eventManager.dispatchEvent(type73, { entity: changeSet.entity, meta, em: this.em, changeSet });
        return;
      }
      const copy = this.comparator.prepareEntity(changeSet.entity);
      await this.eventManager.dispatchEvent(type73, { entity: changeSet.entity, meta, em: this.em, changeSet });
      const current = this.comparator.prepareEntity(changeSet.entity);
      const diff = this.comparator.diffEntities(changeSet.name, copy, current);
      Object.assign(changeSet.payload, diff);
      const wrapped = (0, entity_1.helper)(changeSet.entity);
      if (wrapped.__identifier && diff[wrapped.__meta.primaryKeys[0]]) {
        wrapped.__identifier.setValue(diff[wrapped.__meta.primaryKeys[0]]);
      }
    }
    postCommitCleanup() {
      this.changeSets.forEach((cs) => {
        const wrapped = (0, entity_1.helper)(cs.entity);
        wrapped.__processing = false;
        delete wrapped.__pk;
      });
      this.persistStack.clear();
      this.removeStack.clear();
      this.orphanRemoveStack.clear();
      this.changeSets.clear();
      this.collectionUpdates.clear();
      this.extraUpdates.clear();
      this.queuedActions.clear();
      this.working = false;
    }
    cascade(entity, type73, visited2 = new Set, options = {}) {
      if (visited2.has(entity)) {
        return;
      }
      visited2.add(entity);
      switch (type73) {
        case enums_1.Cascade.PERSIST:
          this.persist(entity, visited2, options);
          break;
        case enums_1.Cascade.MERGE:
          this.merge(entity, visited2);
          break;
        case enums_1.Cascade.REMOVE:
          this.remove(entity, visited2, options);
          break;
        case enums_1.Cascade.SCHEDULE_ORPHAN_REMOVAL:
          this.scheduleOrphanRemoval(entity, visited2);
          break;
        case enums_1.Cascade.CANCEL_ORPHAN_REMOVAL:
          this.cancelOrphanRemoval(entity, visited2);
          break;
      }
      for (const prop of (0, entity_1.helper)(entity).__meta.relations) {
        this.cascadeReference(entity, prop, type73, visited2, options);
      }
    }
    cascadeReference(entity, prop, type73, visited2, options) {
      this.fixMissingReference(entity, prop);
      if (!this.shouldCascade(prop, type73)) {
        return;
      }
      const kind = entity_1.Reference.unwrapReference(entity[prop.name]);
      if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind) && Utils_1.Utils.isEntity(kind)) {
        return this.cascade(kind, type73, visited2, options);
      }
      const collection = kind;
      if ([enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind) && collection) {
        collection.getItems(false).forEach((item) => this.cascade(item, type73, visited2, options));
      }
    }
    isCollectionSelfReferenced(collection, processed) {
      const filtered = collection.getItems(false).filter((item) => !(0, entity_1.helper)(item).__originalEntityData);
      return filtered.some((items) => processed.has(items));
    }
    shouldCascade(prop, type73) {
      if ([enums_1.Cascade.REMOVE, enums_1.Cascade.SCHEDULE_ORPHAN_REMOVAL, enums_1.Cascade.CANCEL_ORPHAN_REMOVAL, enums_1.Cascade.ALL].includes(type73) && prop.orphanRemoval) {
        return true;
      }
      if (type73 === enums_1.Cascade.MERGE) {
        return true;
      }
      return prop.cascade && (prop.cascade.includes(type73) || prop.cascade.includes(enums_1.Cascade.ALL));
    }
    async lockPessimistic(entity, options) {
      if (!this.em.isInTransaction()) {
        throw errors_1.ValidationError.transactionRequired();
      }
      await this.em.getDriver().lockPessimistic(entity, { ctx: this.em.getTransactionContext(), ...options });
    }
    async lockOptimistic(entity, meta, version) {
      if (!meta.versionProperty) {
        throw errors_1.OptimisticLockError.notVersioned(meta);
      }
      if (!Utils_1.Utils.isDefined(version)) {
        return;
      }
      const wrapped = (0, entity_1.helper)(entity);
      if (!wrapped.__initialized) {
        await wrapped.init();
      }
      const previousVersion = entity[meta.versionProperty];
      if (previousVersion !== version) {
        throw errors_1.OptimisticLockError.lockFailedVersionMismatch(entity, version, previousVersion);
      }
    }
    fixMissingReference(entity, prop) {
      const reference = entity[prop.name];
      const kind = entity_1.Reference.unwrapReference(reference);
      if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind) && kind && !prop.mapToPk) {
        if (!Utils_1.Utils.isEntity(kind)) {
          entity[prop.name] = this.em.getReference(prop.type, kind, { wrapped: !!prop.ref });
        } else if (!(0, entity_1.helper)(kind).__initialized && !(0, entity_1.helper)(kind).__em) {
          const pk = (0, entity_1.helper)(kind).getPrimaryKey();
          entity[prop.name] = this.em.getReference(prop.type, pk, { wrapped: !!prop.ref });
        }
      }
      if (Utils_1.Utils.isCollection(kind)) {
        kind.property = prop;
      }
      const isCollection = [enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind);
      if (isCollection && Array.isArray(kind)) {
        const collection = new entity_1.Collection(entity);
        collection.property = prop;
        entity[prop.name] = collection;
        collection.set(kind);
      }
    }
    async persistToDatabase(groups, ctx) {
      if (ctx) {
        this.em.setTransactionContext(ctx);
      }
      const commitOrder = this.getCommitOrder();
      const commitOrderReversed = [...commitOrder].reverse();
      for (const name of commitOrderReversed) {
        await this.commitDeleteChangeSets(groups[ChangeSet_1.ChangeSetType.DELETE_EARLY].get(name) ?? [], ctx);
      }
      for (const name of commitOrder) {
        await this.commitUpdateChangeSets(groups[ChangeSet_1.ChangeSetType.UPDATE_EARLY].get(name) ?? [], ctx);
      }
      for (const name of commitOrder) {
        await this.commitCreateChangeSets(groups[ChangeSet_1.ChangeSetType.CREATE].get(name) ?? [], ctx);
      }
      for (const name of commitOrder) {
        await this.commitUpdateChangeSets(groups[ChangeSet_1.ChangeSetType.UPDATE].get(name) ?? [], ctx);
      }
      await this.commitExtraUpdates(ctx);
      await this.em.getDriver().syncCollections(this.collectionUpdates, { ctx });
      for (const coll of this.collectionUpdates) {
        coll.takeSnapshot();
      }
      for (const name of commitOrderReversed) {
        await this.commitDeleteChangeSets(groups[ChangeSet_1.ChangeSetType.DELETE].get(name) ?? [], ctx);
      }
      const visited2 = new Set;
      for (const changeSet of this.changeSets.values()) {
        this.takeCollectionSnapshots(changeSet.entity, visited2);
      }
    }
    async commitCreateChangeSets(changeSets, ctx) {
      if (changeSets.length === 0) {
        return;
      }
      const props = changeSets[0].meta.root.relations.filter((prop) => {
        return prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && prop.owner || prop.kind === enums_1.ReferenceKind.MANY_TO_ONE || prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && prop.owner && !this.platform.usesPivotTable();
      });
      for (const changeSet of changeSets) {
        this.findExtraUpdates(changeSet, props);
        await this.runHooks(enums_1.EventType.beforeCreate, changeSet, true);
      }
      await this.changeSetPersister.executeInserts(changeSets, { ctx });
      for (const changeSet of changeSets) {
        this.register(changeSet.entity, changeSet.payload, { refresh: true });
        await this.runHooks(enums_1.EventType.afterCreate, changeSet);
      }
    }
    findExtraUpdates(changeSet, props) {
      for (const prop of props) {
        const ref3 = changeSet.entity[prop.name];
        if (!ref3) {
          continue;
        }
        if (Utils_1.Utils.isCollection(ref3)) {
          ref3.getItems(false).some((item) => {
            const cs2 = this.changeSets.get(entity_1.Reference.unwrapReference(item));
            const isScheduledForInsert2 = cs2 && cs2.type === ChangeSet_1.ChangeSetType.CREATE && !cs2.persisted;
            if (isScheduledForInsert2) {
              this.scheduleExtraUpdate(changeSet, [prop]);
              return true;
            }
            return false;
          });
        }
        const cs = this.changeSets.get(entity_1.Reference.unwrapReference(ref3));
        const isScheduledForInsert = cs && cs.type === ChangeSet_1.ChangeSetType.CREATE && !cs.persisted;
        if (isScheduledForInsert) {
          this.scheduleExtraUpdate(changeSet, [prop]);
        }
      }
    }
    findEarlyUpdates(changeSet, inserts = []) {
      const props = changeSet.meta.uniqueProps;
      for (const prop of props) {
        const insert = inserts.find((c2) => Utils_1.Utils.equals(c2.payload[prop.name], changeSet.originalEntity[prop.name]));
        const propEmpty = changeSet.payload[prop.name] === null || changeSet.payload[prop.name] === undefined;
        if (prop.name in changeSet.payload && insert && propEmpty) {
          changeSet.type = ChangeSet_1.ChangeSetType.UPDATE_EARLY;
        }
      }
    }
    async commitUpdateChangeSets(changeSets, ctx, batched = true) {
      if (changeSets.length === 0) {
        return;
      }
      for (const changeSet of changeSets) {
        await this.runHooks(enums_1.EventType.beforeUpdate, changeSet, true);
      }
      await this.changeSetPersister.executeUpdates(changeSets, batched, { ctx });
      for (const changeSet of changeSets) {
        (0, entity_1.helper)(changeSet.entity).__originalEntityData = this.comparator.prepareEntity(changeSet.entity);
        (0, entity_1.helper)(changeSet.entity).__touched = false;
        (0, entity_1.helper)(changeSet.entity).__initialized = true;
        await this.runHooks(enums_1.EventType.afterUpdate, changeSet);
      }
    }
    async commitDeleteChangeSets(changeSets, ctx) {
      if (changeSets.length === 0) {
        return;
      }
      for (const changeSet of changeSets) {
        await this.runHooks(enums_1.EventType.beforeDelete, changeSet, true);
      }
      await this.changeSetPersister.executeDeletes(changeSets, { ctx });
      for (const changeSet of changeSets) {
        this.unsetIdentity(changeSet.entity);
        await this.runHooks(enums_1.EventType.afterDelete, changeSet);
      }
    }
    async commitExtraUpdates(ctx) {
      const extraUpdates = [];
      for (const extraUpdate of this.extraUpdates) {
        if (Array.isArray(extraUpdate[1])) {
          extraUpdate[1].forEach((p2, i2) => extraUpdate[0][p2] = extraUpdate[2][i2]);
        } else {
          extraUpdate[0][extraUpdate[1]] = extraUpdate[2];
        }
        const changeSet = this.changeSetComputer.computeChangeSet(extraUpdate[0]);
        if (changeSet) {
          extraUpdates.push([changeSet, extraUpdate[3]]);
        }
      }
      await this.commitUpdateChangeSets(extraUpdates.map((u2) => u2[0]), ctx, false);
      for (const extraUpdate of extraUpdates) {
        if (extraUpdate[1]) {
          Object.assign(extraUpdate[1].payload, extraUpdate[0].payload);
        }
      }
    }
    getChangeSetGroups() {
      const groups = {
        [ChangeSet_1.ChangeSetType.CREATE]: new Map,
        [ChangeSet_1.ChangeSetType.UPDATE]: new Map,
        [ChangeSet_1.ChangeSetType.DELETE]: new Map,
        [ChangeSet_1.ChangeSetType.UPDATE_EARLY]: new Map,
        [ChangeSet_1.ChangeSetType.DELETE_EARLY]: new Map
      };
      this.changeSets.forEach((cs) => {
        const group = groups[cs.type];
        const classGroup = group.get(cs.rootName) ?? [];
        classGroup.push(cs);
        if (!group.has(cs.rootName)) {
          group.set(cs.rootName, classGroup);
        }
      });
      return groups;
    }
    getCommitOrder() {
      const calc = new CommitOrderCalculator_1.CommitOrderCalculator;
      const set2 = new Set;
      this.changeSets.forEach((cs) => set2.add(cs.rootName));
      set2.forEach((entityName) => calc.addNode(entityName));
      for (const entityName of set2) {
        for (const prop of this.metadata.find(entityName).props) {
          calc.discoverProperty(prop, entityName);
        }
      }
      return calc.sort();
    }
    resetTransaction(oldTx) {
      if (oldTx) {
        this.em.setTransactionContext(oldTx);
      } else {
        this.em.resetTransactionContext();
      }
    }
    takeCollectionSnapshots(entity, visited2) {
      if (visited2.has(entity)) {
        return;
      }
      visited2.add(entity);
      (0, entity_1.helper)(entity)?.__meta.relations.forEach((prop) => {
        const value14 = entity[prop.name];
        if (Utils_1.Utils.isCollection(value14)) {
          value14.takeSnapshot();
        }
        if (prop.kind === enums_1.ReferenceKind.MANY_TO_ONE && value14) {
          this.takeCollectionSnapshots(entity_1.Reference.unwrapReference(value14), visited2);
        }
      });
    }
  }
  exports.UnitOfWork = UnitOfWork;
});

// node_modules/@mikro-orm/core/unit-of-work/index.js
var require_unit_of_work = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ChangeSet(), exports);
  __exportStar(require_ChangeSetComputer(), exports);
  __exportStar(require_ChangeSetPersister(), exports);
  __exportStar(require_CommitOrderCalculator(), exports);
  __exportStar(require_UnitOfWork(), exports);
  __exportStar(require_IdentityMap(), exports);
});

// node_modules/@mikro-orm/core/EntityManager.js
var require_EntityManager = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityManager = undefined;
  var util_1 = import.meta.require("util");
  var dataloader_1 = __importDefault(require_dataloader());
  var utils_1 = require_utils10();
  var entity_1 = require_entity();
  var unit_of_work_1 = require_unit_of_work();
  var enums_1 = require_enums();
  var events_1 = require_events2();
  var errors_1 = require_errors3();

  class EntityManager {
    config;
    driver;
    metadata;
    useContext;
    eventManager;
    static counter = 1;
    _id = EntityManager.counter++;
    global = false;
    name;
    refLoader = new dataloader_1.default(utils_1.DataloaderUtils.getRefBatchLoadFn(this));
    colLoader = new dataloader_1.default(utils_1.DataloaderUtils.getColBatchLoadFn(this));
    validator;
    repositoryMap = {};
    entityLoader;
    comparator;
    entityFactory;
    unitOfWork;
    resultCache;
    filters = {};
    filterParams = {};
    loggerContext;
    transactionContext;
    disableTransactions;
    flushMode;
    _schema;
    constructor(config, driver, metadata, useContext = true, eventManager = new events_1.EventManager(config.get("subscribers"))) {
      this.config = config;
      this.driver = driver;
      this.metadata = metadata;
      this.useContext = useContext;
      this.eventManager = eventManager;
      this.entityLoader = new entity_1.EntityLoader(this);
      this.name = this.config.get("contextName");
      this.validator = new entity_1.EntityValidator(this.config.get("strict"));
      this.comparator = this.config.getComparator(this.metadata);
      this.resultCache = this.config.getResultCacheAdapter();
      this.disableTransactions = this.config.get("disableTransactions");
      this.entityFactory = new entity_1.EntityFactory(this);
      this.unitOfWork = new unit_of_work_1.UnitOfWork(this);
    }
    getDriver() {
      return this.driver;
    }
    getConnection(type73) {
      return this.driver.getConnection(type73);
    }
    getPlatform() {
      return this.driver.getPlatform();
    }
    getRepository(entityName) {
      entityName = utils_1.Utils.className(entityName);
      if (!this.repositoryMap[entityName]) {
        const meta = this.metadata.get(entityName);
        const RepositoryClass = this.config.getRepositoryClass(meta.repository);
        this.repositoryMap[entityName] = new RepositoryClass(this.getContext(false), entityName);
      }
      return this.repositoryMap[entityName];
    }
    repo(entityName) {
      return this.getRepository(entityName);
    }
    getValidator() {
      return this.validator;
    }
    async find(entityName, where, options = {}) {
      if (options.disableIdentityMap ?? this.config.get("disableIdentityMap")) {
        const em2 = this.getContext(false);
        const fork = em2.fork();
        const ret2 = await fork.find(entityName, where, { ...options, disableIdentityMap: false });
        fork.clear();
        return ret2;
      }
      const em = this.getContext();
      em.prepareOptions(options);
      await em.tryFlush(entityName, options);
      entityName = utils_1.Utils.className(entityName);
      where = await em.processWhere(entityName, where, options, "read");
      em.validator.validateParams(where);
      options.orderBy = options.orderBy || {};
      options.populate = await em.preparePopulate(entityName, options);
      const populate = options.populate;
      const cacheKey = em.cacheKey(entityName, options, "em.find", where);
      const cached = await em.tryCache(entityName, options.cache, cacheKey, options.refresh, true);
      if (cached?.data) {
        await em.entityLoader.populate(entityName, cached.data, populate, {
          ...options,
          ...em.getPopulateWhere(where, options),
          convertCustomTypes: false,
          ignoreLazyScalarProperties: true,
          lookup: false
        });
        return cached.data;
      }
      const meta = this.metadata.get(entityName);
      options = { ...options };
      options._populateWhere = options.populateWhere ?? this.config.get("populateWhere");
      options.populateWhere = await this.applyJoinedFilters(meta, { ...where }, options);
      const results = await em.driver.find(entityName, where, { ctx: em.transactionContext, ...options });
      if (results.length === 0) {
        await em.storeCache(options.cache, cached, []);
        return [];
      }
      const ret = [];
      for (const data of results) {
        const entity = em.entityFactory.create(entityName, data, {
          merge: true,
          refresh: options.refresh,
          schema: options.schema,
          convertCustomTypes: true
        });
        ret.push(entity);
      }
      const unique = utils_1.Utils.unique(ret);
      await em.entityLoader.populate(entityName, unique, populate, {
        ...options,
        ...em.getPopulateWhere(where, options),
        convertCustomTypes: false,
        ignoreLazyScalarProperties: true,
        lookup: false
      });
      await em.unitOfWork.dispatchOnLoadEvent();
      if (meta.virtual) {
        await em.storeCache(options.cache, cached, () => ret);
      } else {
        await em.storeCache(options.cache, cached, () => unique.map((e2) => (0, entity_1.helper)(e2).toPOJO()));
      }
      return unique;
    }
    async findAll(entityName, options) {
      return this.find(entityName, options?.where ?? {}, options);
    }
    getPopulateWhere(where, options) {
      if (options.populateWhere === undefined) {
        options.populateWhere = this.config.get("populateWhere");
      }
      if (options.populateWhere === enums_1.PopulateHint.ALL) {
        return { where: {}, populateWhere: options.populateWhere };
      }
      if (options.populateWhere === enums_1.PopulateHint.INFER) {
        return { where, populateWhere: options.populateWhere };
      }
      return { where: options.populateWhere };
    }
    addFilter(name, cond, entityName, enabled = true) {
      const options = { name, cond, default: enabled };
      if (entityName) {
        options.entity = utils_1.Utils.asArray(entityName).map((n2) => utils_1.Utils.className(n2));
      }
      this.getContext(false).filters[name] = options;
    }
    setFilterParams(name, args) {
      this.getContext().filterParams[name] = args;
    }
    getFilterParams(name) {
      return this.getContext().filterParams[name];
    }
    setLoggerContext(context) {
      this.getContext().loggerContext = context;
    }
    getLoggerContext() {
      const em = this.getContext();
      em.loggerContext ??= {};
      return em.loggerContext;
    }
    setFlushMode(flushMode) {
      this.getContext(false).flushMode = flushMode;
    }
    async processWhere(entityName, where, options, type73) {
      where = utils_1.QueryHelper.processWhere({
        where,
        entityName,
        metadata: this.metadata,
        platform: this.driver.getPlatform(),
        convertCustomTypes: options.convertCustomTypes,
        aliased: type73 === "read"
      });
      where = await this.applyFilters(entityName, where, options.filters ?? {}, type73, options);
      where = await this.applyDiscriminatorCondition(entityName, where);
      return where;
    }
    applyDiscriminatorCondition(entityName, where) {
      const meta = this.metadata.find(entityName);
      if (!meta?.discriminatorValue) {
        return where;
      }
      const types = Object.values(meta.root.discriminatorMap).map((cls) => this.metadata.find(cls));
      const children = [];
      const lookUpChildren = (ret, type73) => {
        const children2 = types.filter((meta2) => meta2.extends === type73);
        children2.forEach((m2) => lookUpChildren(ret, m2.className));
        ret.push(...children2.filter((c2) => c2.discriminatorValue));
        return children2;
      };
      lookUpChildren(children, meta.className);
      where[meta.root.discriminatorColumn] = children.length > 0 ? { $in: [meta.discriminatorValue, ...children.map((c2) => c2.discriminatorValue)] } : meta.discriminatorValue;
      return where;
    }
    async applyJoinedFilters(meta, cond, options) {
      const ret = {};
      const populateWhere = options.populateWhere ?? this.config.get("populateWhere");
      if (populateWhere === enums_1.PopulateHint.INFER) {
        utils_1.Utils.merge(ret, cond);
      } else if (typeof populateWhere === "object") {
        utils_1.Utils.merge(ret, populateWhere);
      }
      if (options.populate) {
        for (const hint of options.populate) {
          const field = hint.field.split(":")[0];
          const prop = meta.properties[field];
          const joined = (prop.strategy || options.strategy || hint.strategy || this.config.get("loadStrategy")) === enums_1.LoadStrategy.JOINED && prop.kind !== enums_1.ReferenceKind.SCALAR;
          if (!joined && !hint.filter) {
            continue;
          }
          const where = await this.applyFilters(prop.type, {}, options.filters ?? {}, "read", { ...options, populate: hint.children });
          const where2 = await this.applyJoinedFilters(prop.targetMeta, {}, { ...options, populate: hint.children, populateWhere: enums_1.PopulateHint.ALL });
          if (utils_1.Utils.hasObjectKeys(where)) {
            ret[field] = ret[field] ? { $and: [where, ret[field]] } : where;
          }
          if (utils_1.Utils.hasObjectKeys(where2)) {
            if (ret[field]) {
              utils_1.Utils.merge(ret[field], where2);
            } else {
              ret[field] = where2;
            }
          }
        }
      }
      return ret;
    }
    async autoJoinRefsForFilters(meta, options) {
      if (!meta || !this.config.get("autoJoinRefsForFilters")) {
        return;
      }
      const props = meta.relations.filter((prop) => {
        return [enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind) && ((options.fields?.length ?? 0) === 0 || options.fields?.some((f) => prop.name === f || prop.name.startsWith(`${String(f)}.`)));
      });
      const ret = options.populate;
      for (const prop of props) {
        const cond = await this.applyFilters(prop.type, {}, options.filters ?? {}, "read", options);
        if (!utils_1.Utils.isEmpty(cond)) {
          const populated = options.populate.filter(({ field }) => field.split(":")[0] === prop.name);
          if (populated.length > 0) {
            populated.forEach((hint) => hint.filter = true);
          } else {
            ret.push({ field: `${prop.name}:ref`, strategy: enums_1.LoadStrategy.JOINED, filter: true });
          }
        }
      }
    }
    async applyFilters(entityName, where, options, type73, findOptions) {
      const meta = this.metadata.find(entityName);
      const filters = [];
      const ret = [];
      if (!meta) {
        return where;
      }
      const active = new Set;
      const push = (source) => {
        const activeFilters = utils_1.QueryHelper.getActiveFilters(entityName, options, source).filter((f) => !active.has(f.name));
        filters.push(...activeFilters);
        activeFilters.forEach((f) => active.add(f.name));
      };
      push(this.config.get("filters"));
      push(this.filters);
      push(meta.filters);
      if (filters.length === 0) {
        return where;
      }
      for (const filter of filters) {
        let cond;
        if (filter.cond instanceof Function) {
          const args = utils_1.Utils.isPlainObject(options[filter.name]) ? options[filter.name] : this.getContext().filterParams[filter.name];
          if (!args && filter.cond.length > 0 && filter.args !== false) {
            throw new Error(`No arguments provided for filter '${filter.name}'`);
          }
          cond = await filter.cond(args, type73, this, findOptions);
        } else {
          cond = filter.cond;
        }
        ret.push(utils_1.QueryHelper.processWhere({
          where: cond,
          entityName,
          metadata: this.metadata,
          platform: this.driver.getPlatform(),
          aliased: type73 === "read"
        }));
      }
      const conds = [...ret, where].filter((c2) => utils_1.Utils.hasObjectKeys(c2));
      return conds.length > 1 ? { $and: conds } : conds[0];
    }
    async findAndCount(entityName, where, options = {}) {
      const em = this.getContext(false);
      const copy = utils_1.Utils.copy(where);
      const [entities, count] = await Promise.all([
        em.find(entityName, where, options),
        em.count(entityName, copy, options)
      ]);
      return [entities, count];
    }
    async findByCursor(entityName, where, options) {
      const em = this.getContext(false);
      entityName = utils_1.Utils.className(entityName);
      options.overfetch ??= true;
      if (utils_1.Utils.isEmpty(options.orderBy)) {
        throw new Error("Explicit `orderBy` option required");
      }
      const [entities, count] = await em.findAndCount(entityName, where, options);
      return new utils_1.Cursor(entities, count, options, this.metadata.get(entityName));
    }
    async refreshOrFail(entity, options = {}) {
      const ret = await this.refresh(entity, options);
      if (!ret) {
        options.failHandler ??= this.config.get("findOneOrFailHandler");
        const entityName = entity.constructor.name;
        const where = (0, entity_1.helper)(entity).getPrimaryKey();
        throw options.failHandler(entityName, where);
      }
      return ret;
    }
    async refresh(entity, options = {}) {
      const fork = this.fork();
      const entityName = entity.constructor.name;
      const reloaded = await fork.findOne(entityName, entity, {
        schema: (0, entity_1.helper)(entity).__schema,
        ...options,
        flushMode: enums_1.FlushMode.COMMIT
      });
      if (reloaded) {
        this.config.getHydrator(this.metadata).hydrate(entity, (0, entity_1.helper)(entity).__meta, (0, entity_1.helper)(reloaded).toPOJO(), this.getEntityFactory(), "full");
      } else {
        this.getUnitOfWork().unsetIdentity(entity);
      }
      return reloaded ? entity : reloaded;
    }
    async findOne(entityName, where, options = {}) {
      if (options.disableIdentityMap ?? this.config.get("disableIdentityMap")) {
        const em2 = this.getContext(false);
        const fork = em2.fork();
        const ret = await fork.findOne(entityName, where, { ...options, disableIdentityMap: false });
        fork.clear();
        return ret;
      }
      const em = this.getContext();
      entityName = utils_1.Utils.className(entityName);
      em.prepareOptions(options);
      let entity = em.unitOfWork.tryGetById(entityName, where, options.schema);
      if (entity && !(0, entity_1.helper)(entity).__managed) {
        return entity;
      }
      await em.tryFlush(entityName, options);
      const meta = em.metadata.get(entityName);
      where = await em.processWhere(entityName, where, options, "read");
      em.validator.validateEmptyWhere(where);
      em.checkLockRequirements(options.lockMode, meta);
      entity = em.unitOfWork.tryGetById(entityName, where, options.schema);
      const isOptimisticLocking = !utils_1.Utils.isDefined(options.lockMode) || options.lockMode === enums_1.LockMode.OPTIMISTIC;
      if (entity && !em.shouldRefresh(meta, entity, options) && isOptimisticLocking) {
        return em.lockAndPopulate(meta, entity, where, options);
      }
      em.validator.validateParams(where);
      options.populate = await em.preparePopulate(entityName, options);
      const cacheKey = em.cacheKey(entityName, options, "em.findOne", where);
      const cached = await em.tryCache(entityName, options.cache, cacheKey, options.refresh, true);
      if (cached?.data) {
        await em.entityLoader.populate(entityName, [cached.data], options.populate, {
          ...options,
          ...em.getPopulateWhere(where, options),
          convertCustomTypes: false,
          ignoreLazyScalarProperties: true,
          lookup: false
        });
        return cached.data;
      }
      options = { ...options };
      options._populateWhere = options.populateWhere ?? this.config.get("populateWhere");
      options.populateWhere = await this.applyJoinedFilters(meta, { ...where }, options);
      const data = await em.driver.findOne(entityName, where, {
        ctx: em.transactionContext,
        ...options
      });
      if (!data) {
        await em.storeCache(options.cache, cached, null);
        return null;
      }
      entity = em.entityFactory.create(entityName, data, {
        merge: true,
        refresh: options.refresh,
        schema: options.schema,
        convertCustomTypes: true
      });
      await em.lockAndPopulate(meta, entity, where, options);
      await em.unitOfWork.dispatchOnLoadEvent();
      await em.storeCache(options.cache, cached, () => (0, entity_1.helper)(entity).toPOJO());
      return entity;
    }
    async findOneOrFail(entityName, where, options = {}) {
      let entity;
      let isStrictViolation = false;
      if (options.strict) {
        const ret = await this.find(entityName, where, { ...options, limit: 2 });
        isStrictViolation = ret.length !== 1;
        entity = ret[0];
      } else {
        entity = await this.findOne(entityName, where, options);
      }
      if (!entity || isStrictViolation) {
        const key = options.strict ? "findExactlyOneOrFailHandler" : "findOneOrFailHandler";
        options.failHandler ??= this.config.get(key);
        entityName = utils_1.Utils.className(entityName);
        where = utils_1.Utils.isEntity(where) ? (0, entity_1.helper)(where).getPrimaryKey() : where;
        throw options.failHandler(entityName, where);
      }
      return entity;
    }
    async upsert(entityNameOrEntity, data, options = {}) {
      const em = this.getContext(false);
      em.prepareOptions(options);
      let entityName;
      let where;
      let entity;
      if (data === undefined) {
        entityName = entityNameOrEntity.constructor.name;
        data = entityNameOrEntity;
      } else {
        entityName = utils_1.Utils.className(entityNameOrEntity);
      }
      const meta = this.metadata.get(entityName);
      const convertCustomTypes = !utils_1.Utils.isEntity(data);
      if (utils_1.Utils.isEntity(data)) {
        entity = data;
        if ((0, entity_1.helper)(entity).__managed && (0, entity_1.helper)(entity).__em === em) {
          em.entityFactory.mergeData(meta, entity, data, { initialized: true });
          return entity;
        }
        where = (0, entity_1.helper)(entity).getPrimaryKey();
        data = em.comparator.prepareEntity(entity);
      } else {
        data = utils_1.Utils.copy(data);
        where = utils_1.Utils.extractPK(data, meta);
        if (where) {
          const exists = em.unitOfWork.getById(entityName, where, options.schema);
          if (exists) {
            return em.assign(exists, data);
          }
        }
      }
      const unique = options.onConflictFields ?? meta.props.filter((p2) => p2.unique).map((p2) => p2.name);
      const propIndex = unique.findIndex((p2) => data[p2] != null);
      if (options.onConflictFields || where == null) {
        if (propIndex >= 0) {
          where = { [unique[propIndex]]: data[unique[propIndex]] };
        } else if (meta.uniques.length > 0) {
          for (const u2 of meta.uniques) {
            if (utils_1.Utils.asArray(u2.properties).every((p2) => data[p2] != null)) {
              where = utils_1.Utils.asArray(u2.properties).reduce((o2, key) => {
                o2[key] = data[key];
                return o2;
              }, {});
              break;
            }
          }
        }
      }
      if (where == null) {
        const compositeUniqueProps = meta.uniques.map((u2) => utils_1.Utils.asArray(u2.properties).join(" + "));
        const uniqueProps = meta.primaryKeys.concat(...unique).concat(compositeUniqueProps);
        throw new Error(`Unique property value required for upsert, provide one of: ${uniqueProps.join(", ")}`);
      }
      data = utils_1.QueryHelper.processObjectParams(data);
      em.validator.validateParams(data, "insert data");
      if (em.eventManager.hasListeners(enums_1.EventType.beforeUpsert, meta)) {
        await em.eventManager.dispatchEvent(enums_1.EventType.beforeUpsert, { entity: data, em, meta }, meta);
      }
      const ret = await em.driver.nativeUpdate(entityName, where, data, {
        ctx: em.transactionContext,
        upsert: true,
        convertCustomTypes,
        ...options
      });
      entity ??= em.entityFactory.create(entityName, data, {
        refresh: true,
        initialized: true,
        schema: options.schema,
        convertCustomTypes: true
      });
      em.unitOfWork.getChangeSetPersister().mapReturnedValues(entity, data, ret.row, meta);
      const uniqueFields = options.onConflictFields ?? (utils_1.Utils.isPlainObject(where) ? Object.keys(where) : meta.primaryKeys);
      const returning = (0, utils_1.getOnConflictReturningFields)(meta, data, uniqueFields, options);
      if (options.onConflictAction === "ignore" || !(0, entity_1.helper)(entity).hasPrimaryKey() || returning.length > 0 && !(this.getPlatform().usesReturningStatement() && ret.row)) {
        const where2 = {};
        uniqueFields.forEach((prop) => where2[prop] = data[prop]);
        const data2 = await this.driver.findOne(meta.className, where2, {
          fields: returning,
          ctx: em.transactionContext,
          convertCustomTypes: true,
          connectionType: "write"
        });
        em.getHydrator().hydrate(entity, meta, data2, em.entityFactory, "full");
      }
      const snapshot = this.comparator.prepareEntity(entity);
      em.unitOfWork.register(entity, snapshot, { refresh: true });
      if (em.eventManager.hasListeners(enums_1.EventType.afterUpsert, meta)) {
        await em.eventManager.dispatchEvent(enums_1.EventType.afterUpsert, { entity, em, meta }, meta);
      }
      return entity;
    }
    async upsertMany(entityNameOrEntity, data, options = {}) {
      const em = this.getContext(false);
      em.prepareOptions(options);
      let entityName;
      let propIndex;
      if (data === undefined) {
        entityName = entityNameOrEntity[0].constructor.name;
        data = entityNameOrEntity;
      } else {
        entityName = utils_1.Utils.className(entityNameOrEntity);
      }
      const batchSize = options.batchSize ?? this.config.get("batchSize");
      if (data.length > batchSize) {
        const ret = [];
        for (let i2 = 0;i2 < data.length; i2 += batchSize) {
          const chunk = data.slice(i2, i2 + batchSize);
          ret.push(...await this.upsertMany(entityName, chunk));
        }
        return ret;
      }
      const meta = this.metadata.get(entityName);
      const convertCustomTypes = !utils_1.Utils.isEntity(data[0]);
      const allData = [];
      const allWhere = [];
      const entities = new Map;
      const entitiesByData = new Map;
      for (let i2 = 0;i2 < data.length; i2++) {
        let row = data[i2];
        let where;
        if (utils_1.Utils.isEntity(row)) {
          const entity = row;
          if ((0, entity_1.helper)(entity).__managed && (0, entity_1.helper)(entity).__em === em) {
            em.entityFactory.mergeData(meta, entity, row, { initialized: true });
            entities.set(entity, row);
            entitiesByData.set(row, entity);
            continue;
          }
          where = (0, entity_1.helper)(entity).getPrimaryKey();
          row = em.comparator.prepareEntity(entity);
        } else {
          row = data[i2] = utils_1.Utils.copy(row);
          where = utils_1.Utils.extractPK(row, meta);
          if (where) {
            const exists = em.unitOfWork.getById(entityName, where, options.schema);
            if (exists) {
              em.assign(exists, row);
              entities.set(exists, row);
              entitiesByData.set(row, exists);
              continue;
            }
          }
        }
        const unique = meta.props.filter((p2) => p2.unique).map((p2) => p2.name);
        propIndex = unique.findIndex((p2) => row[p2] != null);
        if (options.onConflictFields || where == null) {
          if (propIndex >= 0) {
            where = { [unique[propIndex]]: row[unique[propIndex]] };
          } else if (meta.uniques.length > 0) {
            for (const u2 of meta.uniques) {
              if (utils_1.Utils.asArray(u2.properties).every((p2) => row[p2] != null)) {
                where = utils_1.Utils.asArray(u2.properties).reduce((o2, key) => {
                  o2[key] = row[key];
                  return o2;
                }, {});
                break;
              }
            }
          }
        }
        if (where == null) {
          const compositeUniqueProps = meta.uniques.map((u2) => utils_1.Utils.asArray(u2.properties).join(" + "));
          const uniqueProps = meta.primaryKeys.concat(...unique).concat(compositeUniqueProps);
          throw new Error(`Unique property value required for upsert, provide one of: ${uniqueProps.join(", ")}`);
        }
        row = utils_1.QueryHelper.processObjectParams(row);
        where = utils_1.QueryHelper.processWhere({
          where,
          entityName,
          metadata: this.metadata,
          platform: this.getPlatform()
        });
        em.validator.validateParams(row, "insert data");
        allData.push(row);
        allWhere.push(where);
      }
      if (entities.size === data.length) {
        return [...entities.keys()];
      }
      if (em.eventManager.hasListeners(enums_1.EventType.beforeUpsert, meta)) {
        for (const dto of data) {
          const entity = entitiesByData.get(dto) ?? dto;
          await em.eventManager.dispatchEvent(enums_1.EventType.beforeUpsert, { entity, em, meta }, meta);
        }
      }
      const res = await em.driver.nativeUpdateMany(entityName, allWhere, allData, {
        ctx: em.transactionContext,
        upsert: true,
        convertCustomTypes,
        ...options
      });
      entities.clear();
      entitiesByData.clear();
      const loadPK = new Map;
      allData.forEach((row, i2) => {
        const entity = utils_1.Utils.isEntity(data[i2]) ? data[i2] : em.entityFactory.create(entityName, row, {
          refresh: true,
          initialized: true,
          schema: options.schema,
          convertCustomTypes: true
        });
        em.unitOfWork.getChangeSetPersister().mapReturnedValues(entity, utils_1.Utils.isEntity(data[i2]) ? {} : data[i2], res.rows?.[i2], meta);
        if (!(0, entity_1.helper)(entity).hasPrimaryKey()) {
          loadPK.set(entity, allWhere[i2]);
        }
        entities.set(entity, row);
        entitiesByData.set(row, entity);
      });
      const uniqueFields = options.onConflictFields ?? (utils_1.Utils.isPlainObject(allWhere[0]) ? Object.keys(allWhere[0]).flatMap((key) => utils_1.Utils.splitPrimaryKeys(key)) : meta.primaryKeys);
      const returning = (0, utils_1.getOnConflictReturningFields)(meta, data[0], uniqueFields, options);
      const reloadFields = returning.length > 0 && !(this.getPlatform().usesReturningStatement() && res.rows?.length);
      if (options.onConflictAction === "ignore" || !res.rows?.length && loadPK.size > 0 || reloadFields) {
        const unique = meta.hydrateProps.filter((p2) => !p2.lazy).map((p2) => p2.name);
        const add = new Set(propIndex >= 0 ? [unique[propIndex]] : []);
        for (const cond of loadPK.values()) {
          utils_1.Utils.keys(cond).forEach((key) => add.add(key));
        }
        const where = { $or: [] };
        data.forEach((item, idx) => {
          where.$or[idx] = {};
          uniqueFields.forEach((prop) => {
            where.$or[idx][prop] = item[prop];
          });
        });
        const data2 = await this.driver.find(meta.className, where, {
          fields: returning.concat(...add).concat(...uniqueFields),
          ctx: em.transactionContext,
          convertCustomTypes: true,
          connectionType: "write"
        });
        for (const [entity, cond] of loadPK.entries()) {
          const row = data2.find((row2) => {
            const tmp = {};
            add.forEach((k) => {
              if (!meta.properties[k]?.primary) {
                tmp[k] = row2[k];
              }
            });
            return this.comparator.matching(entityName, cond, tmp);
          });
          if (!row) {
            throw new Error(`Cannot find matching entity for condition ${JSON.stringify(cond)}`);
          }
          em.getHydrator().hydrate(entity, meta, row, em.entityFactory, "full");
        }
        if (loadPK.size !== data2.length) {
          for (let i2 = 0;i2 < allData.length; i2++) {
            const data3 = allData[i2];
            const cond = uniqueFields.reduce((a2, b2) => {
              a2[b2] = data3[b2];
              return a2;
            }, {});
            const entity = entitiesByData.get(data3);
            const row = data2.find((item) => {
              const pk = uniqueFields.reduce((a2, b2) => {
                a2[b2] = item[b2];
                return a2;
              }, {});
              return this.comparator.matching(entityName, cond, pk);
            });
            if (!row) {
              throw new Error(`Cannot find matching entity for condition ${JSON.stringify(cond)}`);
            }
            em.getHydrator().hydrate(entity, meta, row, em.entityFactory, "full");
          }
        }
      }
      for (const [entity] of entities) {
        const snapshot = this.comparator.prepareEntity(entity);
        em.unitOfWork.register(entity, snapshot, { refresh: true });
      }
      if (em.eventManager.hasListeners(enums_1.EventType.afterUpsert, meta)) {
        for (const [entity] of entities) {
          await em.eventManager.dispatchEvent(enums_1.EventType.afterUpsert, { entity, em, meta }, meta);
        }
      }
      return [...entities.keys()];
    }
    async transactional(cb, options = {}) {
      const em = this.getContext(false);
      if (this.disableTransactions) {
        return cb(em);
      }
      const fork = em.fork({
        clear: options.clear ?? false,
        flushMode: options.flushMode,
        cloneEventManager: true,
        disableTransactions: options.ignoreNestedTransactions,
        loggerContext: options.loggerContext
      });
      options.ctx ??= em.transactionContext;
      return utils_1.TransactionContext.create(fork, async () => {
        return fork.getConnection().transactional(async (trx) => {
          fork.transactionContext = trx;
          fork.eventManager.registerSubscriber({
            afterFlush(args) {
              args.uow.getChangeSets().filter((cs) => [unit_of_work_1.ChangeSetType.DELETE, unit_of_work_1.ChangeSetType.DELETE_EARLY].includes(cs.type)).forEach((cs) => em.unitOfWork.unsetIdentity(cs.entity));
            }
          });
          const ret = await cb(fork);
          await fork.flush();
          for (const entity of fork.unitOfWork.getIdentityMap()) {
            em.unitOfWork.register(entity);
            entity.__helper.__em = em;
          }
          return ret;
        }, { ...options, eventBroadcaster: new events_1.TransactionEventBroadcaster(fork) });
      });
    }
    async begin(options = {}) {
      if (this.disableTransactions) {
        return;
      }
      const em = this.getContext(false);
      em.transactionContext = await em.getConnection("write").begin({
        ...options,
        eventBroadcaster: new events_1.TransactionEventBroadcaster(em)
      });
    }
    async commit() {
      const em = this.getContext(false);
      if (this.disableTransactions) {
        await em.flush();
        return;
      }
      if (!em.transactionContext) {
        throw errors_1.ValidationError.transactionRequired();
      }
      await em.flush();
      await em.getConnection("write").commit(em.transactionContext, new events_1.TransactionEventBroadcaster(em));
      delete em.transactionContext;
    }
    async rollback() {
      if (this.disableTransactions) {
        return;
      }
      const em = this.getContext(false);
      if (!em.transactionContext) {
        throw errors_1.ValidationError.transactionRequired();
      }
      await em.getConnection("write").rollback(em.transactionContext, new events_1.TransactionEventBroadcaster(em));
      delete em.transactionContext;
      em.unitOfWork.clearActionsQueue();
    }
    async lock(entity, lockMode, options = {}) {
      options = utils_1.Utils.isPlainObject(options) ? options : { lockVersion: options };
      await this.getUnitOfWork().lock(entity, { lockMode, ...options });
    }
    async insert(entityNameOrEntity, data, options = {}) {
      const em = this.getContext(false);
      em.prepareOptions(options);
      let entityName;
      if (data === undefined) {
        entityName = entityNameOrEntity.constructor.name;
        data = entityNameOrEntity;
      } else {
        entityName = utils_1.Utils.className(entityNameOrEntity);
      }
      if (utils_1.Utils.isEntity(data)) {
        if (options.schema && (0, entity_1.helper)(data).getSchema() == null) {
          (0, entity_1.helper)(data).setSchema(options.schema);
        }
        if (!(0, entity_1.helper)(data).__managed) {
          em.unitOfWork.getPersistStack().delete(data);
          em.unitOfWork.unsetIdentity(data);
        }
        const meta = (0, entity_1.helper)(data).__meta;
        const payload = em.comparator.prepareEntity(data);
        const cs = new unit_of_work_1.ChangeSet(data, unit_of_work_1.ChangeSetType.CREATE, payload, meta);
        await em.unitOfWork.getChangeSetPersister().executeInserts([cs], { ctx: em.transactionContext, ...options });
        return cs.getPrimaryKey();
      }
      data = utils_1.QueryHelper.processObjectParams(data);
      em.validator.validateParams(data, "insert data");
      const res = await em.driver.nativeInsert(entityName, data, { ctx: em.transactionContext, ...options });
      return res.insertId;
    }
    async insertMany(entityNameOrEntities, data, options = {}) {
      const em = this.getContext(false);
      em.prepareOptions(options);
      let entityName;
      if (data === undefined) {
        entityName = entityNameOrEntities[0].constructor.name;
        data = entityNameOrEntities;
      } else {
        entityName = utils_1.Utils.className(entityNameOrEntities);
      }
      if (data.length === 0) {
        return [];
      }
      if (utils_1.Utils.isEntity(data[0])) {
        const meta = (0, entity_1.helper)(data[0]).__meta;
        const css = data.map((row) => {
          if (options.schema && (0, entity_1.helper)(row).getSchema() == null) {
            (0, entity_1.helper)(row).setSchema(options.schema);
          }
          if (!(0, entity_1.helper)(row).__managed) {
            em.unitOfWork.getPersistStack().delete(row);
            em.unitOfWork.unsetIdentity(row);
          }
          const payload = em.comparator.prepareEntity(row);
          return new unit_of_work_1.ChangeSet(row, unit_of_work_1.ChangeSetType.CREATE, payload, meta);
        });
        await em.unitOfWork.getChangeSetPersister().executeInserts(css, { ctx: em.transactionContext, ...options });
        return css.map((cs) => cs.getPrimaryKey());
      }
      data = data.map((row) => utils_1.QueryHelper.processObjectParams(row));
      data.forEach((row) => em.validator.validateParams(row, "insert data"));
      const res = await em.driver.nativeInsertMany(entityName, data, { ctx: em.transactionContext, ...options });
      if (res.insertedIds) {
        return res.insertedIds;
      }
      return [res.insertId];
    }
    async nativeUpdate(entityName, where, data, options = {}) {
      const em = this.getContext(false);
      em.prepareOptions(options);
      entityName = utils_1.Utils.className(entityName);
      data = utils_1.QueryHelper.processObjectParams(data);
      where = await em.processWhere(entityName, where, options, "update");
      em.validator.validateParams(data, "update data");
      em.validator.validateParams(where, "update condition");
      const res = await em.driver.nativeUpdate(entityName, where, data, { ctx: em.transactionContext, ...options });
      return res.affectedRows;
    }
    async nativeDelete(entityName, where, options = {}) {
      const em = this.getContext(false);
      em.prepareOptions(options);
      entityName = utils_1.Utils.className(entityName);
      where = await em.processWhere(entityName, where, options, "delete");
      em.validator.validateParams(where, "delete condition");
      const res = await em.driver.nativeDelete(entityName, where, { ctx: em.transactionContext, ...options });
      return res.affectedRows;
    }
    map(entityName, result, options = {}) {
      entityName = utils_1.Utils.className(entityName);
      const meta = this.metadata.get(entityName);
      const data = this.driver.mapResult(result, meta);
      Object.keys(data).forEach((k) => {
        const prop = meta.properties[k];
        if (prop && prop.kind === enums_1.ReferenceKind.SCALAR && enums_1.SCALAR_TYPES.includes(prop.runtimeType) && !prop.customType && (prop.setter || !prop.getter)) {
          data[k] = this.validator.validateProperty(prop, data[k], data);
        }
      });
      return this.merge(entityName, data, {
        convertCustomTypes: true,
        refresh: true,
        ...options
      });
    }
    merge(entityName, data, options = {}) {
      const em = this.getContext();
      if (utils_1.Utils.isEntity(entityName)) {
        return em.merge(entityName.constructor.name, entityName, data);
      }
      options.schema ??= em._schema;
      entityName = utils_1.Utils.className(entityName);
      em.validator.validatePrimaryKey(data, em.metadata.get(entityName));
      let entity = em.unitOfWork.tryGetById(entityName, data, options.schema, false);
      if (entity && (0, entity_1.helper)(entity).__managed && (0, entity_1.helper)(entity).__initialized && !options.refresh) {
        return entity;
      }
      const meta = em.metadata.find(entityName);
      const childMeta = em.metadata.getByDiscriminatorColumn(meta, data);
      entity = utils_1.Utils.isEntity(data) ? data : em.entityFactory.create(entityName, data, { merge: true, ...options });
      em.validator.validate(entity, data, childMeta ?? meta);
      em.unitOfWork.merge(entity);
      return entity;
    }
    create(entityName, data, options = {}) {
      const em = this.getContext();
      options.schema ??= em._schema;
      const entity = em.entityFactory.create(entityName, data, {
        ...options,
        newEntity: !options.managed,
        merge: options.managed
      });
      options.persist ??= em.config.get("persistOnCreate");
      if (options.persist) {
        em.persist(entity);
      }
      return entity;
    }
    assign(entity, data, options = {}) {
      return entity_1.EntityAssigner.assign(entity, data, { em: this.getContext(), ...options });
    }
    getReference(entityName, id, options = {}) {
      options.schema ??= this.schema;
      options.convertCustomTypes ??= false;
      const meta = this.metadata.get(utils_1.Utils.className(entityName));
      if (utils_1.Utils.isPrimaryKey(id)) {
        if (meta.compositePK) {
          throw errors_1.ValidationError.invalidCompositeIdentifier(meta);
        }
        id = [id];
      }
      const entity = this.getEntityFactory().createReference(entityName, id, { merge: true, ...options });
      if (options.wrapped) {
        return entity_1.Reference.create(entity);
      }
      return entity;
    }
    async count(entityName, where = {}, options = {}) {
      const em = this.getContext(false);
      options = {
        schema: em._schema,
        ...options
      };
      entityName = utils_1.Utils.className(entityName);
      where = await em.processWhere(entityName, where, options, "read");
      options.populate = await em.preparePopulate(entityName, options);
      em.validator.validateParams(where);
      delete options.orderBy;
      const cacheKey = em.cacheKey(entityName, options, "em.count", where);
      const cached = await em.tryCache(entityName, options.cache, cacheKey);
      if (cached?.data) {
        return cached.data;
      }
      const count = await em.driver.count(entityName, where, { ctx: em.transactionContext, ...options });
      await em.storeCache(options.cache, cached, () => +count);
      return +count;
    }
    persist(entity) {
      const em = this.getContext();
      if (utils_1.Utils.isEntity(entity)) {
        em.unitOfWork.persist(entity, undefined, { cascade: false });
        return em;
      }
      const entities = utils_1.Utils.asArray(entity);
      for (const ent of entities) {
        if (!utils_1.Utils.isEntity(ent, true)) {
          const meta = typeof ent === "object" ? em.metadata.find(ent.constructor.name) : undefined;
          throw errors_1.ValidationError.notDiscoveredEntity(ent, meta);
        }
        em.unitOfWork.persist(entity_1.Reference.unwrapReference(ent), undefined, { cascade: false });
      }
      return this;
    }
    async persistAndFlush(entity) {
      await this.persist(entity).flush();
    }
    remove(entity) {
      const em = this.getContext();
      if (utils_1.Utils.isEntity(entity)) {
        em.unitOfWork.remove(entity, undefined, { cascade: false });
        return em;
      }
      const entities = utils_1.Utils.asArray(entity, true);
      for (const ent of entities) {
        if (!utils_1.Utils.isEntity(ent, true)) {
          throw new Error(`You need to pass entity instance or reference to 'em.remove()'. To remove entities by condition, use 'em.nativeDelete()'.`);
        }
        em.unitOfWork.remove(entity_1.Reference.unwrapReference(ent), undefined, { cascade: false });
      }
      return em;
    }
    async removeAndFlush(entity) {
      await this.remove(entity).flush();
    }
    async flush() {
      await this.getUnitOfWork().commit();
    }
    async tryFlush(entityName, options) {
      const em = this.getContext();
      const flushMode = options.flushMode ?? em.flushMode ?? em.config.get("flushMode");
      entityName = utils_1.Utils.className(entityName);
      const meta = em.metadata.get(entityName);
      if (flushMode === enums_1.FlushMode.COMMIT) {
        return;
      }
      if (flushMode === enums_1.FlushMode.ALWAYS || em.getUnitOfWork().shouldAutoFlush(meta)) {
        await em.flush();
      }
    }
    clear() {
      this.getContext().unitOfWork.clear();
    }
    canPopulate(entityName, property) {
      entityName = utils_1.Utils.className(entityName);
      let [p2, ...parts] = property.split(".");
      const meta = this.metadata.find(entityName);
      if (!meta) {
        return true;
      }
      if (p2.includes(":")) {
        p2 = p2.split(":", 2)[0];
      }
      const ret = p2 in meta.root.properties;
      if (!ret) {
        return !!this.metadata.find(property)?.pivotTable;
      }
      if (parts.length > 0) {
        return this.canPopulate(meta.root.properties[p2].type, parts.join("."));
      }
      return ret;
    }
    async populate(entities, populate, options = {}) {
      const arr = utils_1.Utils.asArray(entities);
      if (arr.length === 0) {
        return entities;
      }
      const em = this.getContext();
      em.prepareOptions(options);
      const entityName = arr[0].constructor.name;
      const preparedPopulate = await em.preparePopulate(entityName, { populate }, options.validate);
      await em.entityLoader.populate(entityName, arr, preparedPopulate, options);
      return entities;
    }
    fork(options = {}) {
      const em = options.disableContextResolution ? this : this.getContext(false);
      options.clear ??= true;
      options.useContext ??= false;
      options.freshEventManager ??= false;
      options.cloneEventManager ??= false;
      const eventManager = options.freshEventManager ? new events_1.EventManager(em.config.get("subscribers")) : options.cloneEventManager ? em.eventManager.clone() : em.eventManager;
      const allowGlobalContext = em.config.get("allowGlobalContext");
      em.config.set("allowGlobalContext", true);
      const fork = new em.constructor(em.config, em.driver, em.metadata, options.useContext, eventManager);
      fork.setFlushMode(options.flushMode ?? em.flushMode);
      fork.disableTransactions = options.disableTransactions ?? this.disableTransactions ?? this.config.get("disableTransactions");
      em.config.set("allowGlobalContext", allowGlobalContext);
      fork.filters = { ...em.filters };
      fork.filterParams = utils_1.Utils.copy(em.filterParams);
      fork.loggerContext = utils_1.Utils.merge({}, em.loggerContext, options.loggerContext);
      fork._schema = options.schema ?? em._schema;
      if (!options.clear) {
        for (const entity of em.unitOfWork.getIdentityMap()) {
          fork.unitOfWork.register(entity);
        }
        for (const entity of em.unitOfWork.getOrphanRemoveStack()) {
          fork.unitOfWork.getOrphanRemoveStack().add(entity);
        }
      }
      return fork;
    }
    getUnitOfWork(useContext = true) {
      if (!useContext) {
        return this.unitOfWork;
      }
      return this.getContext().unitOfWork;
    }
    getEntityFactory() {
      return this.getContext().entityFactory;
    }
    getHydrator() {
      return this.config.getHydrator(this.getMetadata());
    }
    getContext(validate = true) {
      if (!this.useContext) {
        return this;
      }
      let em = utils_1.TransactionContext.getEntityManager(this.name);
      if (em) {
        return em;
      }
      em = this.config.get("context")(this.name) ?? this;
      if (validate && !this.config.get("allowGlobalContext") && em.global) {
        throw errors_1.ValidationError.cannotUseGlobalContext();
      }
      return em;
    }
    getEventManager() {
      return this.eventManager;
    }
    isInTransaction() {
      return !!this.transactionContext;
    }
    getTransactionContext() {
      return this.transactionContext;
    }
    setTransactionContext(ctx) {
      this.transactionContext = ctx;
    }
    resetTransactionContext() {
      delete this.transactionContext;
    }
    getMetadata(entityName) {
      if (entityName) {
        entityName = utils_1.Utils.className(entityName);
        return this.metadata.get(entityName);
      }
      return this.metadata;
    }
    getComparator() {
      return this.comparator;
    }
    checkLockRequirements(mode, meta) {
      if (!mode) {
        return;
      }
      if (mode === enums_1.LockMode.OPTIMISTIC && !meta.versionProperty) {
        throw errors_1.OptimisticLockError.notVersioned(meta);
      }
      if ([enums_1.LockMode.PESSIMISTIC_READ, enums_1.LockMode.PESSIMISTIC_WRITE].includes(mode) && !this.isInTransaction()) {
        throw errors_1.ValidationError.transactionRequired();
      }
    }
    async lockAndPopulate(meta, entity, where, options) {
      if (!meta.virtual && options.lockMode === enums_1.LockMode.OPTIMISTIC) {
        await this.lock(entity, options.lockMode, {
          lockVersion: options.lockVersion,
          lockTableAliases: options.lockTableAliases
        });
      }
      const preparedPopulate = await this.preparePopulate(meta.className, options);
      await this.entityLoader.populate(meta.className, [entity], preparedPopulate, {
        ...options,
        ...this.getPopulateWhere(where, options),
        convertCustomTypes: false,
        ignoreLazyScalarProperties: true,
        lookup: false
      });
      return entity;
    }
    buildFields(fields) {
      return fields.reduce((ret, f) => {
        if (utils_1.Utils.isPlainObject(f)) {
          utils_1.Utils.keys(f).forEach((ff) => ret.push(...this.buildFields(f[ff]).map((field) => `${ff}.${field}`)));
        } else {
          ret.push(f);
        }
        return ret;
      }, []);
    }
    async preparePopulate(entityName, options, validate = true) {
      if (options.populate === false) {
        return [];
      }
      const meta = this.metadata.find(entityName);
      if (!options.populate && options.fields) {
        const pruneToOneRelations = (meta2, fields) => {
          const ret = [];
          for (const field of fields) {
            if (field === "*" || field.startsWith("*.")) {
              ret.push(...meta2.props.filter((prop2) => prop2.lazy || [enums_1.ReferenceKind.SCALAR, enums_1.ReferenceKind.EMBEDDED].includes(prop2.kind)).map((prop2) => prop2.name));
              continue;
            }
            if (!field.includes(".") && ![enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(meta2.properties[field].kind)) {
              ret.push(field);
              continue;
            }
            const parts = field.split(".");
            const key = parts.shift();
            if (parts.length === 0) {
              continue;
            }
            const prop = meta2.properties[key];
            const inner = pruneToOneRelations(prop.targetMeta, [parts.join(".")]);
            if (inner.length > 0) {
              ret.push(...inner.map((c2) => `${key}.${c2}`));
            }
          }
          return utils_1.Utils.unique(ret);
        };
        options.populate = pruneToOneRelations(meta, this.buildFields(options.fields));
      }
      if (!options.populate) {
        const populate2 = this.entityLoader.normalizePopulate(entityName, [], options.strategy);
        await this.autoJoinRefsForFilters(meta, { ...options, populate: populate2 });
        return populate2;
      }
      if (typeof options.populate !== "boolean") {
        options.populate = utils_1.Utils.asArray(options.populate).map((field) => {
          if (typeof field === "boolean") {
            return [{ field: meta.primaryKeys[0], strategy: options.strategy, all: field }];
          }
          if (field === "$infer") {
            options.flags ??= [];
            options.flags.push(enums_1.QueryFlag.INFER_POPULATE);
            return [];
          }
          if (utils_1.Utils.isString(field)) {
            return [{ field, strategy: options.strategy }];
          }
          return [field];
        }).flat();
      }
      const populate = this.entityLoader.normalizePopulate(entityName, options.populate, options.strategy);
      const invalid = populate.find(({ field }) => !this.canPopulate(entityName, field));
      if (validate && invalid) {
        throw errors_1.ValidationError.invalidPropertyName(entityName, invalid.field);
      }
      await this.autoJoinRefsForFilters(meta, { ...options, populate });
      return populate.map((field) => {
        const all = field.all ?? (Array.isArray(options.populate) && options.populate.includes("*"));
        field.strategy = all ? enums_1.LoadStrategy.SELECT_IN : options.strategy ?? field.strategy;
        return field;
      });
    }
    shouldRefresh(meta, entity, options) {
      if (!(0, entity_1.helper)(entity).__initialized || options.refresh) {
        return true;
      }
      let autoRefresh;
      if (options.fields) {
        autoRefresh = options.fields.some((field) => !(0, entity_1.helper)(entity).__loadedProperties.has(field));
      } else {
        autoRefresh = meta.comparableProps.some((prop) => {
          const inlineEmbedded = prop.kind === enums_1.ReferenceKind.EMBEDDED && !prop.object;
          return !inlineEmbedded && !prop.lazy && !(0, entity_1.helper)(entity).__loadedProperties.has(prop.name);
        });
      }
      if (autoRefresh) {
        return true;
      }
      if (Array.isArray(options.populate)) {
        return options.populate.some((field) => !(0, entity_1.helper)(entity).__loadedProperties.has(field));
      }
      return !!options.populate;
    }
    prepareOptions(options) {
      if (!utils_1.Utils.isEmpty(options.fields) && !utils_1.Utils.isEmpty(options.exclude)) {
        throw new errors_1.ValidationError(`Cannot combine 'fields' and 'exclude' option.`);
      }
      options.schema ??= this._schema;
      options.logging = utils_1.Utils.merge({ id: this.id }, this.loggerContext, options.loggerContext, options.logging);
    }
    cacheKey(entityName, options, method, where) {
      const { ...opts } = options;
      for (const k of ["ctx", "strategy", "flushMode", "logging", "loggerContext"]) {
        delete opts[k];
      }
      return [entityName, method, opts, where];
    }
    async tryCache(entityName, config, key, refresh, merge) {
      config ??= this.config.get("resultCache").global;
      if (!config) {
        return;
      }
      const em = this.getContext();
      const cacheKey = Array.isArray(config) ? config[0] : JSON.stringify(key);
      const cached = await em.resultCache.get(cacheKey);
      if (cached) {
        let data;
        if (Array.isArray(cached) && merge) {
          data = cached.map((item) => em.entityFactory.create(entityName, item, {
            merge: true,
            convertCustomTypes: true,
            refresh,
            recomputeSnapshot: true
          }));
        } else if (utils_1.Utils.isObject(cached) && merge) {
          data = em.entityFactory.create(entityName, cached, {
            merge: true,
            convertCustomTypes: true,
            refresh,
            recomputeSnapshot: true
          });
        } else {
          data = cached;
        }
        await em.unitOfWork.dispatchOnLoadEvent();
        return { key: cacheKey, data };
      }
      return { key: cacheKey };
    }
    async storeCache(config, key, data) {
      config ??= this.config.get("resultCache").global;
      if (config) {
        const em = this.getContext();
        const expiration = Array.isArray(config) ? config[1] : utils_1.Utils.isNumber(config) ? config : undefined;
        await em.resultCache.set(key.key, data instanceof Function ? data() : data, "", expiration);
      }
    }
    async clearCache(cacheKey) {
      await this.getContext().resultCache.remove(cacheKey);
    }
    get schema() {
      return this.getContext(false)._schema;
    }
    set schema(schema) {
      this.getContext(false)._schema = schema ?? undefined;
    }
    get id() {
      return this.getContext(false)._id;
    }
    [util_1.inspect.custom]() {
      return `[EntityManager<${this.id}>]`;
    }
  }
  exports.EntityManager = EntityManager;
});

// node_modules/@mikro-orm/core/utils/AbstractSchemaGenerator.js
var require_AbstractSchemaGenerator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractSchemaGenerator = undefined;
  var CommitOrderCalculator_1 = require_CommitOrderCalculator();
  var EntityManager_1 = require_EntityManager();

  class AbstractSchemaGenerator {
    em;
    driver;
    config;
    metadata;
    platform;
    connection;
    constructor(em) {
      this.em = em instanceof EntityManager_1.EntityManager ? em : undefined;
      this.driver = em instanceof EntityManager_1.EntityManager ? em.getDriver() : em;
      this.config = this.driver.config;
      this.metadata = this.driver.getMetadata();
      this.platform = this.driver.getPlatform();
      this.connection = this.driver.getConnection();
    }
    async createSchema(options) {
      this.notImplemented();
    }
    async ensureDatabase(options) {
      this.notImplemented();
    }
    async refreshDatabase(options) {
      await this.ensureDatabase();
      await this.dropSchema();
      await this.createSchema(options);
    }
    async clearDatabase(options) {
      for (const meta of this.getOrderedMetadata(options?.schema).reverse()) {
        await this.driver.nativeDelete(meta.className, {}, options);
      }
      if (this.em) {
        const allowGlobalContext = this.config.get("allowGlobalContext");
        this.config.set("allowGlobalContext", true);
        this.em.clear();
        this.config.set("allowGlobalContext", allowGlobalContext);
      }
    }
    async getCreateSchemaSQL(options) {
      this.notImplemented();
    }
    async dropSchema(options) {
      this.notImplemented();
    }
    async getDropSchemaSQL(options) {
      this.notImplemented();
    }
    async updateSchema(options) {
      this.notImplemented();
    }
    async getUpdateSchemaSQL(options) {
      this.notImplemented();
    }
    async getUpdateSchemaMigrationSQL(options) {
      this.notImplemented();
    }
    async createDatabase(name) {
      this.notImplemented();
    }
    async dropDatabase(name) {
      this.notImplemented();
    }
    async execute(query) {
      this.notImplemented();
    }
    async ensureIndexes() {
      this.notImplemented();
    }
    getOrderedMetadata(schema) {
      const metadata = Object.values(this.metadata.getAll()).filter((meta2) => {
        const isRootEntity = meta2.root.className === meta2.className;
        return isRootEntity && !meta2.embeddable && !meta2.virtual;
      });
      const calc = new CommitOrderCalculator_1.CommitOrderCalculator;
      metadata.forEach((meta2) => calc.addNode(meta2.root.className));
      let meta = metadata.pop();
      while (meta) {
        for (const prop of meta.props) {
          calc.discoverProperty(prop, meta.root.className);
        }
        meta = metadata.pop();
      }
      return calc.sort().map((cls) => this.metadata.find(cls)).filter((meta2) => schema ? [schema, "*"].includes(meta2.schema) : meta2.schema !== "*");
    }
    notImplemented() {
      throw new Error(`This method is not supported by ${this.driver.constructor.name} driver`);
    }
  }
  exports.AbstractSchemaGenerator = AbstractSchemaGenerator;
});

// node_modules/@mikro-orm/core/utils/upsert-utils.js
var require_upsert_utils = __commonJS((exports) => {
  var getOnConflictFields = function(data, uniqueFields, options) {
    if (options.onConflictMergeFields) {
      return options.onConflictMergeFields;
    }
    const keys = Object.keys(data).filter((f) => !uniqueFields.includes(f));
    if (options.onConflictExcludeFields) {
      return keys.filter((f) => !options.onConflictExcludeFields.includes(f));
    }
    return keys;
  };
  var getOnConflictReturningFields = function(meta, data, uniqueFields, options) {
    if (!meta) {
      return "*";
    }
    const keys = meta.comparableProps.filter((p2) => !p2.lazy && !p2.embeddable && !uniqueFields.includes(p2.name)).map((p2) => p2.name);
    if (options.onConflictAction === "ignore") {
      return keys;
    }
    if (options.onConflictMergeFields) {
      return keys.filter((key) => !options.onConflictMergeFields.includes(key));
    }
    if (options.onConflictExcludeFields) {
      return [...new Set(keys.concat(...options.onConflictExcludeFields))];
    }
    return keys.filter((key) => !(key in data));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOnConflictReturningFields = exports.getOnConflictFields = undefined;
  exports.getOnConflictFields = getOnConflictFields;
  exports.getOnConflictReturningFields = getOnConflictReturningFields;
});

// node_modules/@mikro-orm/core/utils/index.js
var require_utils10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_Configuration(), exports);
  __exportStar(require_ConfigurationLoader(), exports);
  __exportStar(require_Cursor(), exports);
  __exportStar(require_DataloaderUtils(), exports);
  __exportStar(require_Utils(), exports);
  __exportStar(require_RequestContext(), exports);
  __exportStar(require_TransactionContext(), exports);
  __exportStar(require_QueryHelper(), exports);
  __exportStar(require_NullHighlighter(), exports);
  __exportStar(require_EntityComparator(), exports);
  __exportStar(require_AbstractSchemaGenerator(), exports);
  __exportStar(require_RawQueryFragment(), exports);
  __exportStar(require_upsert_utils(), exports);
});

// node_modules/@mikro-orm/core/entity/Reference.js
var require_Reference = __commonJS((exports) => {
  var ref3 = function(entityOrType, pk) {
    if (entityOrType == null) {
      return entityOrType;
    }
    if (utils_1.Utils.isEntity(entityOrType, true)) {
      return (0, wrap_1.helper)(entityOrType).toReference();
    }
    if (utils_1.Utils.isEntity(pk, true)) {
      return (0, wrap_1.helper)(pk).toReference();
    }
    if (arguments.length === 1) {
      return new ScalarReference(entityOrType, true);
    }
    if (pk == null) {
      return pk;
    }
    return Reference.createFromPK(entityOrType, pk);
  };
  var rel = function(entityType, pk) {
    if (pk == null || utils_1.Utils.isEntity(pk)) {
      return pk;
    }
    return Reference.createNakedFromPK(entityType, pk);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ref = exports.rel = exports.ref = exports.ScalarReference = exports.Reference = undefined;
  var util_1 = import.meta.require("util");
  var enums_1 = require_enums();
  var wrap_1 = require_wrap();
  var utils_1 = require_utils10();

  class Reference {
    entity;
    constructor(entity) {
      this.entity = entity;
      this.set(entity);
      const meta = (0, wrap_1.helper)(this.entity).__meta;
      meta.primaryKeys.forEach((primaryKey) => {
        Object.defineProperty(this, primaryKey, {
          get() {
            return this.entity[primaryKey];
          }
        });
      });
      if (meta.serializedPrimaryKey && meta.primaryKeys[0] !== meta.serializedPrimaryKey) {
        Object.defineProperty(this, meta.serializedPrimaryKey, {
          get() {
            return (0, wrap_1.helper)(this.entity).getSerializedPrimaryKey();
          }
        });
      }
    }
    static create(entity) {
      const unwrapped = Reference.unwrapReference(entity);
      const ref4 = (0, wrap_1.helper)(entity).toReference();
      if (unwrapped !== ref4.unwrap()) {
        ref4.set(unwrapped);
      }
      return ref4;
    }
    static createFromPK(entityType, pk, options) {
      const ref4 = this.createNakedFromPK(entityType, pk, options);
      return (0, wrap_1.helper)(ref4).toReference();
    }
    static createNakedFromPK(entityType, pk, options) {
      const factory = entityType.prototype.__factory;
      const entity = factory.createReference(entityType, pk, {
        merge: false,
        convertCustomTypes: false,
        ...options
      });
      const wrapped = (0, wrap_1.helper)(entity);
      wrapped.__meta.primaryKeys.forEach((key) => wrapped.__loadedProperties.add(key));
      wrapped.__originalEntityData = factory.getComparator().prepareEntity(entity);
      return entity;
    }
    static isReference(data) {
      return data && !!data.__reference;
    }
    static wrapReference(entity, prop) {
      if (entity && prop.ref && !Reference.isReference(entity)) {
        return Reference.create(entity);
      }
      return entity;
    }
    static unwrapReference(ref4) {
      return Reference.isReference(ref4) ? ref4.unwrap() : ref4;
    }
    async load(options = {}) {
      if (!this.isInitialized() || options.refresh) {
        const wrapped = (0, wrap_1.helper)(this.entity);
        if (!wrapped.__em) {
          return this.entity;
        }
        if (options.dataloader ?? [enums_1.DataloaderType.ALL, enums_1.DataloaderType.REFERENCE].includes(utils_1.DataloaderUtils.getDataloaderType(wrapped.__em.config.get("dataloader")))) {
          return wrapped.__em.refLoader.load([this, options]);
        }
        return wrapped.init(options);
      }
      return this.entity;
    }
    async loadOrFail(options = {}) {
      const ret = await this.load(options);
      if (!ret) {
        const wrapped = (0, wrap_1.helper)(this.entity);
        options.failHandler ??= wrapped.__em.config.get("findOneOrFailHandler");
        const entityName = this.entity.constructor.name;
        const where = wrapped.getPrimaryKey();
        throw options.failHandler(entityName, where);
      }
      return ret;
    }
    set(entity) {
      this.entity = Reference.unwrapReference(entity);
      delete (0, wrap_1.helper)(this.entity).__reference;
    }
    unwrap() {
      return this.entity;
    }
    getEntity() {
      if (!this.isInitialized()) {
        throw new Error(`Reference<${(0, wrap_1.helper)(this.entity).__meta.name}> ${(0, wrap_1.helper)(this.entity).getPrimaryKey()} not initialized`);
      }
      return this.entity;
    }
    getProperty(prop) {
      return this.getEntity()[prop];
    }
    async loadProperty(prop, options) {
      await this.loadOrFail(options);
      return this.getEntity()[prop];
    }
    isInitialized() {
      return (0, wrap_1.helper)(this.entity).__initialized;
    }
    populated(populated) {
      (0, wrap_1.helper)(this.entity).populated(populated);
    }
    toJSON(...args) {
      return (0, wrap_1.wrap)(this.entity).toJSON(...args);
    }
    [util_1.inspect.custom](depth) {
      const object12 = { ...this };
      const hidden = ["meta"];
      hidden.forEach((k) => delete object12[k]);
      const ret = (0, util_1.inspect)(object12, { depth });
      const wrapped = (0, wrap_1.helper)(this.entity);
      const meta = wrapped.__meta;
      const pk = wrapped.hasPrimaryKey() ? "<" + wrapped.getSerializedPrimaryKey() + ">" : "";
      const name = `Ref<${meta.className}${pk}>`;
      return ret === "[Object]" ? `[${name}]` : name + " " + ret;
    }
  }
  exports.Reference = Reference;
  exports.Ref = Reference;

  class ScalarReference {
    value;
    initialized;
    entity;
    property;
    constructor(value14, initialized = value14 != null) {
      this.value = value14;
      this.initialized = initialized;
    }
    async load(options) {
      const opts = typeof options === "object" ? options : { prop: options };
      if (!this.initialized || opts.refresh) {
        if (this.entity == null || this.property == null) {
          throw new Error("Cannot load scalar reference that is not bound to an entity property.");
        }
        await (0, wrap_1.helper)(this.entity).populate([this.property], opts);
      }
      return this.value;
    }
    set(value14) {
      this.value = value14;
      this.initialized = true;
    }
    bind(entity, property) {
      this.entity = entity;
      this.property = property;
      Object.defineProperty(this, "entity", { enumerable: false, value: entity });
    }
    unwrap() {
      return this.value;
    }
    isInitialized() {
      return this.initialized;
    }
    [util_1.inspect.custom]() {
      return this.initialized ? `Ref<${(0, util_1.inspect)(this.value)}>` : `Ref<?>`;
    }
  }
  exports.ScalarReference = ScalarReference;
  Object.defineProperties(Reference.prototype, {
    __reference: { value: true, enumerable: false },
    __meta: { get() {
      return this.entity.__meta;
    } },
    __platform: { get() {
      return this.entity.__platform;
    } },
    __helper: { get() {
      return this.entity.__helper;
    } },
    $: { get() {
      return this.entity;
    } },
    get: { get() {
      return () => this.entity;
    } }
  });
  Object.defineProperties(ScalarReference.prototype, {
    __scalarReference: { value: true, enumerable: false },
    $: { get() {
      return this.value;
    } },
    get: { get() {
      return () => this.value;
    } }
  });
  exports.ref = ref3;
  exports.rel = rel;
});

// node_modules/@mikro-orm/core/entity/ArrayCollection.js
var require_ArrayCollection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArrayCollection = undefined;
  var util_1 = import.meta.require("util");
  var Reference_1 = require_Reference();
  var wrap_1 = require_wrap();
  var errors_1 = require_errors3();
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();

  class ArrayCollection {
    owner;
    items = new Set;
    initialized = true;
    dirty = false;
    snapshot = [];
    _count;
    _property;
    constructor(owner, items) {
      this.owner = owner;
      if (items) {
        let i2 = 0;
        this.items = new Set(items);
        this.items.forEach((item) => this[i2++] = item);
      }
    }
    async loadCount() {
      return this.items.size;
    }
    getItems() {
      return [...this.items];
    }
    toArray() {
      if (this.items.size === 0) {
        return [];
      }
      const meta = this.property.targetMeta;
      const args = [...meta.toJsonParams.map(() => {
        return;
      })];
      return this.map((item) => (0, wrap_1.wrap)(item).toJSON(...args));
    }
    toJSON() {
      return this.toArray();
    }
    getIdentifiers(field) {
      const items = this.getItems();
      if (items.length === 0) {
        return [];
      }
      field ??= this.property.targetMeta.serializedPrimaryKey;
      return items.map((i2) => {
        if (Utils_1.Utils.isEntity(i2[field], true)) {
          return (0, wrap_1.wrap)(i2[field], true).getPrimaryKey();
        }
        return i2[field];
      });
    }
    add(entity, ...entities) {
      entities = Utils_1.Utils.asArray(entity).concat(entities);
      for (const item of entities) {
        const entity2 = Reference_1.Reference.unwrapReference(item);
        if (!this.contains(entity2, false)) {
          this.incrementCount(1);
          this[this.items.size] = entity2;
          this.items.add(entity2);
          this.propagate(entity2, "add");
        }
      }
    }
    set(items) {
      if (!this.initialized) {
        this.initialized = true;
        this.snapshot = undefined;
      }
      if (this.compare(Utils_1.Utils.asArray(items).map((item) => Reference_1.Reference.unwrapReference(item)))) {
        return;
      }
      this.remove(this.items);
      this.add(items);
    }
    compare(items) {
      if (items.length !== this.items.size) {
        return false;
      }
      let idx = 0;
      for (const item of this.items) {
        if (item !== items[idx++]) {
          return false;
        }
      }
      return true;
    }
    hydrate(items, forcePropagate) {
      for (let i2 = 0;i2 < this.items.size; i2++) {
        delete this[i2];
      }
      this.initialized = true;
      this.items.clear();
      this._count = 0;
      this.add(items);
      this.takeSnapshot(forcePropagate);
    }
    remove(entity, ...entities) {
      entities = Utils_1.Utils.asArray(entity).concat(entities);
      let modified = false;
      for (const item of entities) {
        if (!item) {
          continue;
        }
        const entity2 = Reference_1.Reference.unwrapReference(item);
        if (this.items.delete(entity2)) {
          this.incrementCount(-1);
          delete this[this.items.size];
          this.propagate(entity2, "remove");
          modified = true;
        }
      }
      if (modified) {
        Object.assign(this, [...this.items]);
      }
    }
    removeAll() {
      if (!this.initialized) {
        this.initialized = true;
        this.snapshot = undefined;
      }
      this.remove(this.items);
    }
    removeWithoutPropagation(entity) {
      if (!this.items.delete(entity)) {
        return;
      }
      this.incrementCount(-1);
      delete this[this.items.size];
      Object.assign(this, [...this.items]);
    }
    contains(item, check10) {
      const entity = Reference_1.Reference.unwrapReference(item);
      return this.items.has(entity);
    }
    slice(start = 0, end) {
      let index = 0;
      end ??= this.items.size;
      const items = [];
      for (const item of this.items) {
        if (index === end) {
          break;
        }
        if (index >= start && index < end) {
          items.push(item);
        }
        index++;
      }
      return items;
    }
    exists(cb) {
      for (const item of this.items) {
        if (cb(item)) {
          return true;
        }
      }
      return false;
    }
    find(cb) {
      let index = 0;
      for (const item of this.items) {
        if (cb(item, index++)) {
          return item;
        }
      }
      return;
    }
    filter(cb) {
      const items = [];
      let index = 0;
      for (const item of this.items) {
        if (cb(item, index++)) {
          items.push(item);
        }
      }
      return items;
    }
    map(mapper) {
      const items = [];
      let index = 0;
      for (const item of this.items) {
        items.push(mapper(item, index++));
      }
      return items;
    }
    reduce(cb, initial = {}) {
      let index = 0;
      for (const item of this.items) {
        initial = cb(initial, item, index++);
      }
      return initial;
    }
    indexBy(key, valueKey) {
      return this.reduce((obj, item) => {
        obj[item[key]] ??= valueKey ? item[valueKey] : item;
        return obj;
      }, {});
    }
    count() {
      return this.items.size;
    }
    isInitialized(fully = false) {
      if (!this.initialized || !fully) {
        return this.initialized;
      }
      for (const item of this.items) {
        if (!(0, wrap_1.helper)(item).__initialized) {
          return false;
        }
      }
      return true;
    }
    isDirty() {
      return this.dirty;
    }
    isEmpty() {
      return this.count() === 0;
    }
    setDirty(dirty = true) {
      this.dirty = dirty;
    }
    get length() {
      return this.count();
    }
    *[Symbol.iterator]() {
      for (const item of this.getItems()) {
        yield item;
      }
    }
    takeSnapshot(forcePropagate) {
      this.snapshot = [...this.items];
      this.setDirty(false);
      if (this.property.owner || forcePropagate) {
        this.items.forEach((item) => {
          this.propagate(item, "takeSnapshot");
        });
      }
    }
    getSnapshot() {
      return this.snapshot;
    }
    get property() {
      if (!this._property) {
        const meta = (0, wrap_1.helper)(this.owner).__meta;
        if (!meta) {
          throw errors_1.MetadataError.fromUnknownEntity(this.owner.constructor.name, "Collection.property getter, maybe you just forgot to initialize the ORM?");
        }
        this._property = meta.relations.find((prop) => this.owner[prop.name] === this);
      }
      return this._property;
    }
    set property(prop) {
      this._property = prop;
    }
    propagate(item, method) {
      if (this.property.owner && this.property.inversedBy) {
        this.propagateToInverseSide(item, method);
      } else if (!this.property.owner && this.property.mappedBy) {
        this.propagateToOwningSide(item, method);
      }
    }
    propagateToInverseSide(item, method) {
      const collection = item[this.property.inversedBy];
      if (this.shouldPropagateToCollection(collection, method)) {
        collection[method](this.owner);
      }
    }
    propagateToOwningSide(item, method) {
      const mappedBy = this.property.mappedBy;
      const collection = item[mappedBy];
      if (this.property.kind === enums_1.ReferenceKind.MANY_TO_MANY) {
        if (this.shouldPropagateToCollection(collection, method)) {
          collection[method](this.owner);
        }
      } else if (this.property.kind === enums_1.ReferenceKind.ONE_TO_MANY && method !== "takeSnapshot") {
        const prop2 = this.property.targetMeta.properties[mappedBy];
        const owner = prop2.mapToPk ? (0, wrap_1.helper)(this.owner).getPrimaryKey() : this.owner;
        const value14 = method === "add" ? owner : null;
        if (this.property.orphanRemoval && method === "remove") {
          (0, wrap_1.helper)(item).__pk = (0, wrap_1.helper)(item).getPrimaryKey();
        }
        if (!prop2.nullable && prop2.updateRule !== "cascade" && method === "remove") {
          if (!this.property.orphanRemoval) {
            throw errors_1.ValidationError.cannotRemoveFromCollectionWithoutOrphanRemoval(this.owner, this.property);
          }
          return;
        }
        if (Reference_1.Reference.unwrapReference(item[mappedBy]) !== value14) {
          item[mappedBy] = value14;
        }
      }
    }
    shouldPropagateToCollection(collection, method) {
      if (!collection) {
        return false;
      }
      switch (method) {
        case "add":
          return !collection.contains(this.owner, false);
        case "remove":
          return collection.isInitialized() && collection.contains(this.owner, false);
        case "takeSnapshot":
          return collection.isDirty();
      }
    }
    incrementCount(value14) {
      if (typeof this._count === "number" && this.initialized) {
        this._count += value14;
      }
    }
    [util_1.inspect.custom](depth) {
      const object12 = { ...this };
      const hidden = ["items", "owner", "_property", "_count", "snapshot", "_populated", "_snapshot", "_lazyInitialized", "_em", "readonly"];
      hidden.forEach((k) => delete object12[k]);
      const ret = (0, util_1.inspect)(object12, { depth });
      const name = `${this.constructor.name}<${this.property?.type ?? "unknown"}>`;
      return ret === "[Object]" ? `[${name}]` : name + " " + ret;
    }
  }
  exports.ArrayCollection = ArrayCollection;
  Object.defineProperties(ArrayCollection.prototype, {
    __collection: { value: true, enumerable: false, writable: false }
  });
});

// node_modules/@mikro-orm/core/entity/Collection.js
var require_Collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Collection = undefined;
  var ArrayCollection_1 = require_ArrayCollection();
  var utils_1 = require_utils10();
  var errors_1 = require_errors3();
  var enums_1 = require_enums();
  var Reference_1 = require_Reference();
  var wrap_1 = require_wrap();

  class Collection extends ArrayCollection_1.ArrayCollection {
    readonly;
    _populated;
    _em;
    _snapshot;
    constructor(owner, items, initialized = true) {
      super(owner, items);
      this.initialized = !!items || initialized;
    }
    static create(owner, prop, items, initialized) {
      const coll = new Collection(owner, undefined, initialized);
      coll.property = (0, wrap_1.helper)(owner).__meta.properties[prop];
      owner[prop] = coll;
      if (items) {
        coll.set(items);
      }
      return coll;
    }
    async load(options = {}) {
      if (this.isInitialized(true) && !options.refresh) {
        const em = this.getEntityManager(this.items, false);
        await em?.populate(this.items, options.populate, options);
      } else {
        await this.init(options);
      }
      return this;
    }
    async loadItems(options) {
      await this.load(options);
      return super.getItems();
    }
    async loadCount(options = {}) {
      options = typeof options === "boolean" ? { refresh: options } : options;
      const { refresh, where, ...countOptions } = options;
      if (!refresh && !where && utils_1.Utils.isDefined(this._count)) {
        return this._count;
      }
      const em = this.getEntityManager();
      if (!em.getPlatform().usesPivotTable() && this.property.kind === enums_1.ReferenceKind.MANY_TO_MANY && this.property.owner) {
        return this._count = this.length;
      }
      const cond = this.createLoadCountCondition(where ?? {});
      const count = await em.count(this.property.type, cond, countOptions);
      if (!where) {
        this._count = count;
      }
      return count;
    }
    async matching(options) {
      const em = this.getEntityManager();
      const { where, ctx, ...opts } = options;
      opts.orderBy = this.createOrderBy(opts.orderBy);
      let items;
      if (this.property.kind === enums_1.ReferenceKind.MANY_TO_MANY && em.getPlatform().usesPivotTable()) {
        const cond = await em.applyFilters(this.property.type, where, options.filters ?? {}, "read");
        const map3 = await em.getDriver().loadFromPivotTable(this.property, [(0, wrap_1.helper)(this.owner).__primaryKeys], cond, opts.orderBy, ctx, options);
        items = map3[(0, wrap_1.helper)(this.owner).getSerializedPrimaryKey()].map((item) => em.merge(this.property.type, item, { convertCustomTypes: true }));
      } else {
        items = await em.find(this.property.type, this.createCondition(where), opts);
      }
      if (options.store) {
        this.hydrate(items, true);
        this.populated();
        this.readonly = true;
      }
      return items;
    }
    getItems(check10 = true) {
      if (check10) {
        this.checkInitialized();
      }
      return super.getItems();
    }
    toJSON() {
      if (!this.isInitialized()) {
        return [];
      }
      return super.toJSON();
    }
    add(entity, ...entities) {
      entities = utils_1.Utils.asArray(entity).concat(entities);
      const unwrapped = entities.map((i2) => Reference_1.Reference.unwrapReference(i2));
      unwrapped.forEach((entity2) => this.validateItemType(entity2));
      this.modify("add", unwrapped);
      this.cancelOrphanRemoval(unwrapped);
    }
    remove(entity, ...entities) {
      if (entity instanceof Function) {
        for (const item of this.items) {
          if (entity(item)) {
            this.remove(item);
          }
        }
        return;
      }
      entities = utils_1.Utils.asArray(entity).concat(entities);
      const unwrapped = entities.map((i2) => Reference_1.Reference.unwrapReference(i2));
      this.modify("remove", unwrapped);
      const em = this.getEntityManager(unwrapped, false);
      if (this.property.orphanRemoval && em) {
        for (const item of unwrapped) {
          em.getUnitOfWork().scheduleOrphanRemoval(item);
        }
      }
    }
    contains(item, check10 = true) {
      if (check10) {
        this.checkInitialized();
      }
      return super.contains(item);
    }
    count() {
      this.checkInitialized();
      return super.count();
    }
    isEmpty() {
      this.checkInitialized();
      return super.isEmpty();
    }
    slice(start, end) {
      this.checkInitialized();
      return super.slice(start, end);
    }
    exists(cb) {
      this.checkInitialized();
      return super.exists(cb);
    }
    find(cb) {
      this.checkInitialized();
      return super.find(cb);
    }
    filter(cb) {
      this.checkInitialized();
      return super.filter(cb);
    }
    map(mapper) {
      this.checkInitialized();
      return super.map(mapper);
    }
    indexBy(key, valueKey) {
      this.checkInitialized();
      return super.indexBy(key, valueKey);
    }
    shouldPopulate(populated) {
      if (!this.isInitialized(true)) {
        return false;
      }
      if (this._populated != null) {
        return this._populated;
      }
      return !!populated;
    }
    populated(populated = true) {
      this._populated = populated;
    }
    async init(options = {}) {
      if (this.dirty) {
        const items = [...this.items];
        this.dirty = false;
        await this.init(options);
        items.forEach((i2) => this.add(i2));
        return this;
      }
      const em = this.getEntityManager();
      if (options.dataloader ?? [enums_1.DataloaderType.ALL, enums_1.DataloaderType.COLLECTION].includes(utils_1.DataloaderUtils.getDataloaderType(em.config.get("dataloader")))) {
        const order = [...this.items];
        const customOrder = !!options.orderBy;
        const items = await em.colLoader.load([this, options]);
        if (!customOrder) {
          this.reorderItems(items, order);
        }
        this.items.clear();
        let i2 = 0;
        for (const item of items) {
          this.items.add(item);
          this[i2++] = item;
        }
        this.initialized = true;
        this.dirty = false;
        return this;
      }
      const populate = Array.isArray(options.populate) ? options.populate.map((f) => f === "*" ? f : `${this.property.name}.${f}`) : [`${this.property.name}${options.ref ? ":ref" : ""}`];
      const schema = this.property.targetMeta.schema === "*" ? (0, wrap_1.helper)(this.owner).__schema : undefined;
      await em.populate(this.owner, populate, {
        ...options,
        refresh: true,
        connectionType: options.connectionType,
        schema,
        where: { [this.property.name]: options.where },
        orderBy: { [this.property.name]: options.orderBy }
      });
      return this;
    }
    getEntityManager(items = [], required4 = true) {
      let em = this._em ?? (0, wrap_1.helper)(this.owner).__em;
      if (!em) {
        for (const i2 of this.items) {
          if (i2 && (0, wrap_1.helper)(i2).__em) {
            em = (0, wrap_1.helper)(i2).__em;
            break;
          }
        }
        for (const i2 of items) {
          if (i2 && (0, wrap_1.helper)(i2).__em) {
            em = (0, wrap_1.helper)(i2).__em;
            break;
          }
        }
      }
      if (em) {
        Object.defineProperty(this, "_em", { value: em });
      }
      if (!em && required4) {
        throw errors_1.ValidationError.entityNotManaged(this.owner);
      }
      return em;
    }
    createCondition(cond = {}) {
      if (this.property.kind === enums_1.ReferenceKind.ONE_TO_MANY) {
        cond[this.property.mappedBy] = (0, wrap_1.helper)(this.owner).getPrimaryKey();
      } else {
        this.createManyToManyCondition(cond);
      }
      return cond;
    }
    createOrderBy(orderBy = []) {
      if (utils_1.Utils.isEmpty(orderBy) && this.property.orderBy) {
        orderBy = this.property.orderBy;
      }
      return utils_1.Utils.asArray(orderBy);
    }
    createManyToManyCondition(cond) {
      const dict = cond;
      if (this.property.owner || this.property.pivotTable) {
        const pk = this.property.targetMeta.primaryKeys[0];
        dict[pk] = { $in: [] };
        this.items.forEach((item) => dict[pk].$in.push((0, wrap_1.helper)(item).getPrimaryKey()));
      } else {
        dict[this.property.mappedBy] = (0, wrap_1.helper)(this.owner).getPrimaryKey();
      }
    }
    createLoadCountCondition(cond) {
      const wrapped = (0, wrap_1.helper)(this.owner);
      const val = wrapped.__meta.compositePK ? { $in: wrapped.__primaryKeys } : wrapped.getPrimaryKey();
      const dict = cond;
      if (this.property.kind === enums_1.ReferenceKind.ONE_TO_MANY) {
        dict[this.property.mappedBy] = val;
      } else {
        const key = this.property.owner ? this.property.inversedBy : this.property.mappedBy;
        dict[key] = val;
      }
      return cond;
    }
    modify(method, items) {
      if (method === "remove") {
        this.checkInitialized();
      }
      this.validateModification(items);
      super[method](items);
      this.setDirty();
    }
    checkInitialized() {
      if (!this.isInitialized()) {
        throw new Error(`Collection<${this.property.type}> of entity ${this.owner.constructor.name}[${(0, wrap_1.helper)(this.owner).getSerializedPrimaryKey()}] not initialized`);
      }
    }
    reorderItems(items, order) {
      if (this.property.kind === enums_1.ReferenceKind.MANY_TO_MANY && this.property.owner) {
        items.sort((a2, b2) => order.indexOf(a2) - order.indexOf(b2));
      }
    }
    cancelOrphanRemoval(items) {
      const em = this.getEntityManager(items, false);
      if (!em) {
        return;
      }
      for (const item of items) {
        em.getUnitOfWork().cancelOrphanRemoval(item);
      }
    }
    validateItemType(item) {
      if (!utils_1.Utils.isEntity(item)) {
        throw errors_1.ValidationError.notEntity(this.owner, this.property, item);
      }
    }
    validateModification(items) {
      if (this.readonly) {
        throw errors_1.ValidationError.cannotModifyReadonlyCollection(this.owner, this.property);
      }
      if (this.property.pivotTable || !this.property.mappedBy) {
        return;
      }
      const check10 = (item) => {
        if (!item || (0, wrap_1.helper)(item).__initialized) {
          return false;
        }
        return !item[this.property.mappedBy] && this.property.kind === enums_1.ReferenceKind.MANY_TO_MANY;
      };
      if (items.find((item) => check10(item))) {
        throw errors_1.ValidationError.cannotModifyInverseCollection(this.owner, this.property);
      }
    }
  }
  exports.Collection = Collection;
  Object.defineProperties(Collection.prototype, {
    $: { get() {
      return this;
    } },
    get: { get() {
      return () => this;
    } }
  });
});

// node_modules/@mikro-orm/core/serialization/SerializationContext.js
var require_SerializationContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SerializationContext = undefined;
  var Utils_1 = require_Utils();
  var wrap_1 = require_wrap();

  class SerializationContext {
    config;
    populate;
    fields;
    exclude;
    path = [];
    visited = new Set;
    entities = new Set;
    constructor(config, populate = [], fields, exclude5) {
      this.config = config;
      this.populate = populate;
      this.fields = fields;
      this.exclude = exclude5;
    }
    visit(entityName, prop) {
      if (!this.path.find(([cls, item]) => entityName === cls && prop === item)) {
        this.path.push([entityName, prop]);
        return false;
      }
      if (!this.isMarkedAsPopulated(entityName, prop)) {
        return true;
      }
      this.path.push([entityName, prop]);
      return false;
    }
    leave(entityName, prop) {
      const last = this.path.pop();
      if (!last || last[0] !== entityName || last[1] !== prop) {
        throw new Error(`Trying to leave wrong property: ${entityName}.${prop} instead of ${last?.join(".")}`);
      }
    }
    close() {
      this.entities.forEach((entity) => {
        delete (0, wrap_1.helper)(entity).__serializationContext.root;
      });
    }
    static propagate(root, entity, isVisible) {
      root.register(entity);
      const meta = (0, wrap_1.helper)(entity).__meta;
      const items = [];
      Object.keys(entity).filter((key) => isVisible(meta, key)).forEach((key) => {
        if (Utils_1.Utils.isEntity(entity[key], true)) {
          items.push(entity[key]);
        } else if (Utils_1.Utils.isCollection(entity[key])) {
          items.push(...entity[key].getItems(false));
        }
      });
      items.filter((item) => !item.__helper.__serializationContext.root).forEach((item) => this.propagate(root, item, isVisible));
    }
    isMarkedAsPopulated(entityName, prop) {
      let populate = this.populate;
      for (const segment of this.path) {
        if (!populate) {
          return false;
        }
        const exists = populate.find((p2) => p2.field === segment[1]);
        if (exists) {
          if (exists.all) {
            return !this.path.find(([cls, item]) => entityName === cls && prop === item);
          }
          populate = exists.children;
        }
      }
      return !!populate?.some((p2) => p2.field === prop);
    }
    isPartiallyLoaded(entityName, prop) {
      if (!this.fields) {
        return true;
      }
      let fields = [...this.fields];
      for (const segment of this.path) {
        if (fields.length === 0) {
          return true;
        }
        fields = fields.filter((field) => field.startsWith(`${segment[1]}.`) || field === "*").map((field) => field === "*" ? field : field.substring(segment[1].length + 1));
      }
      return fields.some((p2) => p2 === prop || p2 === "*");
    }
    register(entity) {
      (0, wrap_1.helper)(entity).__serializationContext.root = this;
      this.entities.add(entity);
    }
  }
  exports.SerializationContext = SerializationContext;
});

// node_modules/@mikro-orm/core/serialization/EntityTransformer.js
var require_EntityTransformer = __commonJS((exports) => {
  var isVisible = function(meta, propName, ignoreFields = []) {
    const prop = meta.properties[propName];
    const visible = prop && !prop.hidden;
    const prefixed = prop && !prop.primary && propName.startsWith("_");
    return visible && !prefixed && !ignoreFields.includes(propName);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityTransformer = undefined;
  var wrap_1 = require_wrap();
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();
  var SerializationContext_1 = require_SerializationContext();

  class EntityTransformer {
    static toObject(entity, ignoreFields = [], raw = false) {
      if (!Array.isArray(ignoreFields)) {
        ignoreFields = [];
      }
      const wrapped = (0, wrap_1.helper)(entity);
      let contextCreated = false;
      if (!wrapped.__serializationContext.root) {
        const root2 = new SerializationContext_1.SerializationContext(wrapped.__config, wrapped.__serializationContext.populate, wrapped.__serializationContext.fields, wrapped.__serializationContext.exclude);
        SerializationContext_1.SerializationContext.propagate(root2, entity, isVisible);
        contextCreated = true;
      }
      const root = wrapped.__serializationContext.root;
      const meta = wrapped.__meta;
      const ret = {};
      const keys = new Set;
      if (meta.serializedPrimaryKey && !meta.compositePK) {
        keys.add(meta.serializedPrimaryKey);
      } else {
        meta.primaryKeys.forEach((pk) => keys.add(pk));
      }
      if (wrapped.isInitialized() || !wrapped.hasPrimaryKey()) {
        Utils_1.Utils.keys(entity).forEach((prop) => keys.add(prop));
      }
      const visited2 = root.visited.has(entity);
      if (!visited2) {
        root.visited.add(entity);
      }
      [...keys].filter((prop) => raw ? meta.properties[prop] : isVisible(meta, prop, ignoreFields)).map((prop) => {
        const populated = root.isMarkedAsPopulated(meta.className, prop);
        const partiallyLoaded = root.isPartiallyLoaded(meta.className, prop);
        const isPrimary = wrapped.__config.get("serialization").includePrimaryKeys && meta.properties[prop].primary;
        if (!partiallyLoaded && !populated && !isPrimary) {
          return [prop, undefined];
        }
        const cycle = root.visit(meta.className, prop);
        if (cycle && visited2) {
          return [prop, undefined];
        }
        const val = EntityTransformer.processProperty(prop, entity, raw, populated);
        if (!cycle) {
          root.leave(meta.className, prop);
        }
        return [prop, val];
      }).filter(([, value14]) => typeof value14 !== "undefined").forEach(([prop, value14]) => ret[this.propertyName(meta, prop, wrapped.__platform)] = value14);
      if (!visited2) {
        root.visited.delete(entity);
      }
      if (!wrapped.isInitialized() && wrapped.hasPrimaryKey()) {
        return ret;
      }
      meta.props.filter((prop) => prop.getter && prop.getterName === undefined && !prop.hidden && typeof entity[prop.name] !== "undefined").forEach((prop) => ret[this.propertyName(meta, prop.name, wrapped.__platform)] = this.processProperty(prop.name, entity, raw));
      meta.props.filter((prop) => prop.getterName && !prop.hidden && entity[prop.getterName] instanceof Function).forEach((prop) => ret[this.propertyName(meta, prop.name, wrapped.__platform)] = this.processProperty(prop.getterName, entity, raw));
      if (contextCreated) {
        root.close();
      }
      return ret;
    }
    static propertyName(meta, prop, platform) {
      if (meta.properties[prop].serializedName) {
        return meta.properties[prop].serializedName;
      }
      if (meta.properties[prop].primary && platform) {
        return platform.getSerializedPrimaryKeyField(prop);
      }
      return prop;
    }
    static processProperty(prop, entity, raw, populated) {
      const wrapped = (0, wrap_1.helper)(entity);
      const property = wrapped.__meta.properties[prop];
      const serializer = property?.serializer;
      const value14 = entity[prop];
      if (entity[prop] instanceof Function) {
        const returnValue = entity[prop]();
        if (serializer) {
          return serializer(returnValue);
        }
        return returnValue;
      }
      if (serializer) {
        return serializer(value14);
      }
      if (Utils_1.Utils.isCollection(value14)) {
        return EntityTransformer.processCollection(prop, entity, raw, populated);
      }
      if (Utils_1.Utils.isEntity(value14, true)) {
        return EntityTransformer.processEntity(prop, entity, wrapped.__platform, raw, populated);
      }
      if (Utils_1.Utils.isScalarReference(value14)) {
        return value14.unwrap();
      }
      if (property.kind === enums_1.ReferenceKind.EMBEDDED) {
        if (Array.isArray(value14)) {
          return value14.map((item) => {
            const wrapped3 = item && (0, wrap_1.helper)(item);
            return wrapped3 ? wrapped3.toJSON() : item;
          });
        }
        const wrapped2 = value14 && (0, wrap_1.helper)(value14);
        return wrapped2 ? wrapped2.toJSON() : value14;
      }
      const customType = property?.customType;
      if (customType) {
        return customType.toJSON(value14, wrapped.__platform);
      }
      if (property?.primary) {
        return wrapped.__platform.normalizePrimaryKey(value14);
      }
      return value14;
    }
    static processEntity(prop, entity, platform, raw, populated) {
      const child = entity[prop];
      const wrapped = (0, wrap_1.helper)(child);
      if (raw && wrapped.isInitialized() && child !== entity) {
        return wrapped.toPOJO();
      }
      function isPopulated() {
        if (wrapped.__populated != null) {
          return wrapped.__populated;
        }
        if (populated) {
          return true;
        }
        return !wrapped.__managed;
      }
      if (wrapped.isInitialized() && isPopulated() && child !== entity) {
        return (0, wrap_1.wrap)(child).toJSON();
      }
      if (wrapped.__config.get("serialization").forceObject) {
        return Utils_1.Utils.primaryKeyToObject(wrapped.__meta, wrapped.getPrimaryKey(true));
      }
      return platform.normalizePrimaryKey(wrapped.getPrimaryKey(true));
    }
    static processCollection(prop, entity, raw, populated) {
      const col = entity[prop];
      if (raw && col.isInitialized(true)) {
        return col.map((item) => (0, wrap_1.helper)(item).toPOJO());
      }
      if (col.shouldPopulate(populated)) {
        return col.toArray();
      }
      if (col.isInitialized()) {
        const wrapped = (0, wrap_1.helper)(entity);
        if (wrapped.__config.get("serialization").forceObject) {
          return col.map((item) => {
            const wrapped2 = (0, wrap_1.helper)(item);
            return Utils_1.Utils.primaryKeyToObject(wrapped2.__meta, wrapped2.getPrimaryKey(true));
          });
        }
        return col.map((i2) => (0, wrap_1.helper)(i2).getPrimaryKey(true));
      }
      return;
    }
  }
  exports.EntityTransformer = EntityTransformer;
});

// node_modules/@mikro-orm/core/serialization/EntitySerializer.js
var require_EntitySerializer = __commonJS((exports) => {
  var isVisible = function(meta, propName, options) {
    if (Array.isArray(options.populate) && options.populate?.find((item) => item === propName || item.startsWith(propName + ".") || item === "*")) {
      return true;
    }
    if (options.exclude?.find((item) => item === propName)) {
      return false;
    }
    const prop = meta.properties[propName];
    const visible = prop && !prop.hidden;
    const prefixed = prop && !prop.primary && propName.startsWith("_");
    return visible && !prefixed;
  };
  var isPopulated = function(propName, options) {
    if (typeof options.populate !== "boolean" && options.populate?.find((item) => item === propName || item.startsWith(propName + ".") || item === "*")) {
      return true;
    }
    if (typeof options.populate === "boolean") {
      return options.populate;
    }
    return false;
  };
  var serialize = function(entities, options) {
    if (Array.isArray(entities)) {
      return entities.map((e2) => EntitySerializer.serialize(e2, options));
    }
    return EntitySerializer.serialize(entities, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = exports.EntitySerializer = undefined;
  var wrap_1 = require_wrap();
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();
  var Reference_1 = require_Reference();
  var SerializationContext_1 = require_SerializationContext();

  class EntitySerializer {
    static serialize(entity, options = {}) {
      const wrapped = (0, wrap_1.helper)(entity);
      const meta = wrapped.__meta;
      let contextCreated = false;
      if (!wrapped.__serializationContext.root) {
        const root2 = new SerializationContext_1.SerializationContext(wrapped.__config);
        SerializationContext_1.SerializationContext.propagate(root2, entity, (meta2, prop) => meta2.properties[prop]?.kind !== enums_1.ReferenceKind.SCALAR);
        options.populate = options.populate ? Utils_1.Utils.asArray(options.populate) : options.populate;
        contextCreated = true;
      }
      const root = wrapped.__serializationContext.root;
      const ret = {};
      const keys = new Set(meta.primaryKeys);
      Utils_1.Utils.keys(entity).forEach((prop) => keys.add(prop));
      const visited2 = root.visited.has(entity);
      if (!visited2) {
        root.visited.add(entity);
      }
      [...keys].filter((prop) => isVisible(meta, prop, options)).map((prop) => {
        const cycle = root.visit(meta.className, prop);
        if (cycle && visited2) {
          return [prop, undefined];
        }
        const val = this.processProperty(prop, entity, options);
        if (!cycle) {
          root.leave(meta.className, prop);
        }
        if (options.skipNull && Utils_1.Utils.isPlainObject(val)) {
          Utils_1.Utils.dropUndefinedProperties(val, null);
        }
        return [prop, val];
      }).filter(([, value14]) => typeof value14 !== "undefined" && !(value14 === null && options.skipNull)).forEach(([prop, value14]) => ret[this.propertyName(meta, prop, wrapped.__platform)] = value14);
      if (contextCreated) {
        root.close();
      }
      if (!wrapped.isInitialized()) {
        return ret;
      }
      meta.props.filter((prop) => prop.getter && prop.getterName === undefined && typeof entity[prop.name] !== "undefined" && isVisible(meta, prop.name, options)).forEach((prop) => ret[this.propertyName(meta, prop.name, wrapped.__platform)] = this.processProperty(prop.name, entity, options));
      meta.props.filter((prop) => prop.getterName && entity[prop.getterName] instanceof Function && isVisible(meta, prop.name, options)).forEach((prop) => ret[this.propertyName(meta, prop.name, wrapped.__platform)] = this.processProperty(prop.getterName, entity, options));
      return ret;
    }
    static propertyName(meta, prop, platform) {
      if (meta.properties[prop]?.serializedName) {
        return meta.properties[prop].serializedName;
      }
      if (meta.properties[prop]?.primary && platform) {
        return platform.getSerializedPrimaryKeyField(prop);
      }
      return prop;
    }
    static processProperty(prop, entity, options) {
      const parts = prop.split(".");
      prop = parts[0];
      const wrapped = (0, wrap_1.helper)(entity);
      const property = wrapped.__meta.properties[prop];
      const serializer = property?.serializer;
      const value14 = entity[prop];
      if (entity[prop] instanceof Function) {
        const returnValue = entity[prop]();
        if (!options.ignoreSerializers && serializer) {
          return serializer(returnValue);
        }
        return returnValue;
      }
      if (!options.ignoreSerializers && serializer) {
        return serializer(value14);
      }
      if (Utils_1.Utils.isCollection(value14)) {
        return this.processCollection(prop, entity, options);
      }
      if (Utils_1.Utils.isEntity(value14, true)) {
        return this.processEntity(prop, entity, wrapped.__platform, options);
      }
      if (Utils_1.Utils.isScalarReference(value14)) {
        return value14.unwrap();
      }
      if (property?.kind === enums_1.ReferenceKind.EMBEDDED) {
        if (Array.isArray(value14)) {
          return value14.map((item) => (0, wrap_1.helper)(item).toJSON());
        }
        if (Utils_1.Utils.isObject(value14)) {
          return (0, wrap_1.helper)(value14).toJSON();
        }
      }
      const customType = property?.customType;
      if (customType) {
        return customType.toJSON(value14, wrapped.__platform);
      }
      return wrapped.__platform.normalizePrimaryKey(value14);
    }
    static extractChildOptions(options, prop) {
      return {
        ...options,
        populate: Array.isArray(options.populate) ? Utils_1.Utils.extractChildElements(options.populate, prop, "*") : options.populate,
        exclude: Array.isArray(options.exclude) ? Utils_1.Utils.extractChildElements(options.exclude, prop) : options.exclude
      };
    }
    static processEntity(prop, entity, platform, options) {
      const child = Reference_1.Reference.unwrapReference(entity[prop]);
      const wrapped = (0, wrap_1.helper)(child);
      const populated = isPopulated(prop, options) && wrapped.isInitialized();
      const expand = populated || !wrapped.__managed;
      if (expand) {
        return this.serialize(child, this.extractChildOptions(options, prop));
      }
      if (options.forceObject || wrapped.__config.get("serialization").forceObject) {
        return Utils_1.Utils.primaryKeyToObject(wrapped.__meta, wrapped.getPrimaryKey(true));
      }
      return platform.normalizePrimaryKey(wrapped.getPrimaryKey());
    }
    static processCollection(prop, entity, options) {
      const col = entity[prop];
      if (!col.isInitialized()) {
        return;
      }
      return col.getItems(false).map((item) => {
        const populated = isPopulated(prop, options);
        const wrapped = (0, wrap_1.helper)(item);
        if (populated || !wrapped.__managed) {
          return this.serialize(item, this.extractChildOptions(options, prop));
        }
        if (options.forceObject || wrapped.__config.get("serialization").forceObject) {
          return Utils_1.Utils.primaryKeyToObject(wrapped.__meta, wrapped.getPrimaryKey(true));
        }
        return (0, wrap_1.helper)(item).getPrimaryKey();
      });
    }
  }
  exports.EntitySerializer = EntitySerializer;
  exports.serialize = serialize;
});

// node_modules/@mikro-orm/core/entity/WrappedEntity.js
var require_WrappedEntity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WrappedEntity = undefined;
  var util_1 = import.meta.require("util");
  var Reference_1 = require_Reference();
  var EntityTransformer_1 = require_EntityTransformer();
  var EntityAssigner_1 = require_EntityAssigner();
  var Utils_1 = require_Utils();
  var errors_1 = require_errors3();
  var wrap_1 = require_wrap();
  var EntitySerializer_1 = require_EntitySerializer();

  class WrappedEntity {
    constructor(entity, hydrator, pkGetter, pkSerializer, pkGetterConverted) {
      this.entity = entity;
      this.hydrator = hydrator;
      this.pkGetter = pkGetter;
      this.pkSerializer = pkSerializer;
      this.pkGetterConverted = pkGetterConverted;
      this.__initialized = true;
      this.__touched = false;
      this.__serializationContext = {};
      this.__loadedProperties = new Set;
      this.__data = {};
      this.__processing = false;
    }
    isInitialized() {
      return this.__initialized;
    }
    isTouched() {
      return this.__touched;
    }
    isManaged() {
      return !!this.__managed;
    }
    populated(populated = true) {
      this.__populated = populated;
    }
    toReference() {
      this.__reference ??= new Reference_1.Reference(this.entity);
      return this.__reference;
    }
    toObject(ignoreFields) {
      return EntityTransformer_1.EntityTransformer.toObject(this.entity, ignoreFields);
    }
    serialize(options) {
      return EntitySerializer_1.EntitySerializer.serialize(this.entity, options);
    }
    toPOJO() {
      return EntityTransformer_1.EntityTransformer.toObject(this.entity, [], true);
    }
    toJSON(...args) {
      return this.entity.toJSON(...args);
    }
    assign(data, options) {
      if ("assign" in this.entity) {
        return this.entity.assign(data, options);
      }
      return EntityAssigner_1.EntityAssigner.assign(this.entity, data, options);
    }
    async init(options) {
      if (!this.__em) {
        throw errors_1.ValidationError.entityNotManaged(this.entity);
      }
      return this.__em.findOne(this.entity.constructor.name, this.entity, { ...options, refresh: true, schema: this.__schema });
    }
    async populate(populate, options = {}) {
      if (!this.__em) {
        throw errors_1.ValidationError.entityNotManaged(this.entity);
      }
      await this.__em.populate(this.entity, populate, options);
      return this.entity;
    }
    hasPrimaryKey() {
      const pk = this.getPrimaryKey();
      return pk != null;
    }
    getPrimaryKey(convertCustomTypes = false) {
      const prop = this.__meta.getPrimaryProps()[0];
      if (!prop) {
        return null;
      }
      if (this.__pk != null && this.__meta.compositePK) {
        return Utils_1.Utils.getCompositeKeyValue(this.__pk, this.__meta, convertCustomTypes ? "convertToDatabaseValue" : false, this.__platform);
      }
      if (convertCustomTypes && this.__pk != null && prop.customType) {
        return prop.customType.convertToDatabaseValue(this.__pk, this.__platform);
      }
      if (convertCustomTypes) {
        return this.__pk ?? this.pkGetterConverted(this.entity);
      }
      return this.__pk ?? this.pkGetter(this.entity);
    }
    getPrimaryKeys(convertCustomTypes = false) {
      const pk = this.getPrimaryKey(convertCustomTypes);
      if (pk == null) {
        return null;
      }
      if (this.__meta.compositePK) {
        return this.__meta.primaryKeys.reduce((ret, pk2) => {
          const child = this.entity[pk2];
          if (Utils_1.Utils.isEntity(child, true)) {
            const childPk = (0, wrap_1.helper)(child).getPrimaryKeys(convertCustomTypes);
            ret.push(...childPk);
          } else {
            ret.push(child);
          }
          return ret;
        }, []);
      }
      return [pk];
    }
    getSchema() {
      return this.__schema;
    }
    setSchema(schema) {
      this.__schema = schema;
    }
    setPrimaryKey(id) {
      this.entity[this.__meta.primaryKeys[0]] = id;
      this.__pk = id;
    }
    getSerializedPrimaryKey() {
      return this.pkSerializer(this.entity);
    }
    get __meta() {
      return this.entity.__meta;
    }
    get __platform() {
      return this.entity.__platform;
    }
    get __config() {
      return this.__em?.config ?? this.entity.__config;
    }
    get __primaryKeys() {
      return Utils_1.Utils.getPrimaryKeyValues(this.entity, this.__meta.primaryKeys);
    }
    [util_1.inspect.custom]() {
      return `[WrappedEntity<${this.__meta.className}>]`;
    }
  }
  exports.WrappedEntity = WrappedEntity;
});

// node_modules/@mikro-orm/core/entity/EntityHelper.js
var require_EntityHelper = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityHelper = undefined;
  var util_1 = import.meta.require("util");
  var typings_1 = require_typings();
  var EntityTransformer_1 = require_EntityTransformer();
  var Reference_1 = require_Reference();
  var Utils_1 = require_Utils();
  var WrappedEntity_1 = require_WrappedEntity();
  var enums_1 = require_enums();
  var wrap_1 = require_wrap();

  class EntityHelper {
    static decorate(meta, em) {
      const fork = em.fork();
      const serializedPrimaryKey = meta.props.find((p2) => p2.serializedPrimaryKey);
      if (serializedPrimaryKey) {
        Object.defineProperty(meta.prototype, serializedPrimaryKey.name, {
          get() {
            return this._id ? em.getPlatform().normalizePrimaryKey(this._id) : null;
          },
          set(id) {
            this._id = id ? em.getPlatform().denormalizePrimaryKey(id) : null;
          },
          configurable: true
        });
      }
      EntityHelper.defineBaseProperties(meta, meta.prototype, fork);
      EntityHelper.defineCustomInspect(meta);
      if (em.config.get("propagationOnPrototype") && !meta.embeddable && !meta.virtual) {
        EntityHelper.defineProperties(meta, fork);
      }
      const prototype = meta.prototype;
      if (!prototype.toJSON) {
        prototype.toJSON = function(...args) {
          return EntityTransformer_1.EntityTransformer.toObject(this, ...args.slice(meta.toJsonParams.length));
        };
      }
    }
    static defineBaseProperties(meta, prototype, em) {
      const helperParams = meta.embeddable || meta.virtual ? [] : [em.getComparator().getPkGetter(meta), em.getComparator().getPkSerializer(meta), em.getComparator().getPkGetterConverted(meta)];
      Object.defineProperties(prototype, {
        __entity: { value: !meta.embeddable, configurable: true },
        __meta: { value: meta, configurable: true },
        __config: { value: em.config, configurable: true },
        __platform: { value: em.getPlatform(), configurable: true },
        __factory: { value: em.getEntityFactory(), configurable: true },
        __helper: {
          get() {
            Object.defineProperty(this, "__helper", {
              value: new WrappedEntity_1.WrappedEntity(this, em.getHydrator(), ...helperParams),
              enumerable: false,
              configurable: true
            });
            return this.__helper;
          },
          configurable: true
        }
      });
    }
    static defineProperties(meta, em) {
      Object.values(meta.properties).forEach((prop) => {
        const isCollection = [enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind);
        const isReference = [enums_1.ReferenceKind.ONE_TO_ONE, enums_1.ReferenceKind.MANY_TO_ONE].includes(prop.kind) && (prop.inversedBy || prop.mappedBy) && !prop.mapToPk;
        if (isReference) {
          Object.defineProperty(meta.prototype, prop.name, {
            set(val) {
              EntityHelper.defineReferenceProperty(meta, prop, this, em.getHydrator());
              this[prop.name] = val;
            },
            configurable: true
          });
          return;
        }
        if (prop.inherited || prop.primary || prop.persist === false || prop.trackChanges === false || prop.embedded || isCollection) {
          return;
        }
        Object.defineProperty(meta.prototype, prop.name, {
          set(val) {
            Object.defineProperty(this, prop.name, {
              get() {
                return this.__helper?.__data[prop.name];
              },
              set(val2) {
                this.__helper.__data[prop.name] = val2;
                this.__helper.__touched = !this.__helper.hydrator.isRunning();
              },
              enumerable: true,
              configurable: true
            });
            this.__helper.__data[prop.name] = val;
            this.__helper.__touched = !this.__helper.hydrator.isRunning();
          },
          configurable: true
        });
      });
    }
    static defineCustomInspect(meta) {
      meta.prototype[util_1.inspect.custom] ??= function(depth) {
        const object12 = { ...this };
        [typings_1.OptionalProps, typings_1.EntityRepositoryType, typings_1.PrimaryKeyProp, typings_1.EagerProps, typings_1.HiddenProps].forEach((sym) => delete object12[sym]);
        meta.props.filter((prop) => object12[prop.name] === undefined).forEach((prop) => delete object12[prop.name]);
        const ret = (0, util_1.inspect)(object12, { depth });
        let name = this.constructor.name;
        const showEM = ["true", "t", "1"].includes(process.env.MIKRO_ORM_LOG_EM_ID?.toString().toLowerCase() ?? "");
        if (showEM) {
          if ((0, wrap_1.helper)(this).__em) {
            name += ` [managed by ${(0, wrap_1.helper)(this).__em.id}]`;
          } else {
            name += ` [not managed]`;
          }
        }
        if (!(0, wrap_1.helper)(this).__initialized) {
          name = `(${name})`;
        }
        return ret === "[Object]" ? `[${name}]` : name + " " + ret;
      };
    }
    static defineReferenceProperty(meta, prop, ref3, hydrator) {
      const wrapped = (0, wrap_1.helper)(ref3);
      Object.defineProperty(ref3, prop.name, {
        get() {
          return (0, wrap_1.helper)(ref3).__data[prop.name];
        },
        set(val) {
          const entity = Reference_1.Reference.unwrapReference(val ?? wrapped.__data[prop.name]);
          const old = Reference_1.Reference.unwrapReference(wrapped.__data[prop.name]);
          wrapped.__data[prop.name] = Reference_1.Reference.wrapReference(val, prop);
          if (val && hydrator.isRunning() && wrapped.__originalEntityData && prop.owner) {
            wrapped.__originalEntityData[prop.name] = Utils_1.Utils.getPrimaryKeyValues(wrapped.__data[prop.name], prop.targetMeta.primaryKeys, true);
          } else {
            wrapped.__touched = !hydrator.isRunning();
          }
          EntityHelper.propagate(meta, entity, this, prop, Reference_1.Reference.unwrapReference(val), old);
        },
        enumerable: true,
        configurable: true
      });
    }
    static propagate(meta, entity, owner, prop, value14, old) {
      const inverseProps = prop.targetMeta.bidirectionalRelations.filter((prop2) => (prop2.inversedBy || prop2.mappedBy) === prop.name).filter((prop2) => {
        const meta2 = prop2.targetMeta;
        return meta2.abstract ? meta2.root.className === meta.root.className : meta2.className === meta.className;
      });
      for (const prop2 of inverseProps) {
        const inverse = value14?.[prop2.name];
        if (prop.kind === enums_1.ReferenceKind.MANY_TO_ONE && Utils_1.Utils.isCollection(inverse) && inverse.isInitialized()) {
          inverse.add(owner);
        }
        if (prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && entity && (!prop.owner || (0, wrap_1.helper)(entity).__initialized)) {
          if (value14 != null && Reference_1.Reference.unwrapReference(inverse) !== owner || value14 == null && entity[prop2.name] != null) {
            EntityHelper.propagateOneToOne(entity, owner, prop, prop2, value14, old);
          }
        }
      }
    }
    static propagateOneToOne(entity, owner, prop, prop2, value14, old) {
      (0, wrap_1.helper)(entity).__pk = (0, wrap_1.helper)(entity).getPrimaryKey();
      if (!prop.primary && !prop2.mapToPk && value14?.[prop2.name] != null && Reference_1.Reference.unwrapReference(value14[prop2.name]) !== entity) {
        const other = Reference_1.Reference.unwrapReference(value14[prop2.name]);
        delete (0, wrap_1.helper)(other).__data[prop.name];
        if (prop2.orphanRemoval) {
          (0, wrap_1.helper)(other).__em?.getUnitOfWork().scheduleOrphanRemoval(other);
        }
      }
      if (value14 == null) {
        entity[prop2.name] = value14;
      } else if (prop2.mapToPk) {
        entity[prop2.name] = (0, wrap_1.helper)(owner).getPrimaryKey();
      } else {
        entity[prop2.name] = Reference_1.Reference.wrapReference(owner, prop);
      }
      if (old && prop.orphanRemoval) {
        (0, wrap_1.helper)(old).__em?.getUnitOfWork().scheduleOrphanRemoval(old);
      }
      if (old?.[prop2.name] != null) {
        delete (0, wrap_1.helper)(old).__data[prop2.name];
      }
    }
    static ensurePropagation(entity) {
      if (entity.__gettersDefined) {
        return;
      }
      const wrapped = (0, wrap_1.helper)(entity);
      const meta = wrapped.__meta;
      const platform = wrapped.__platform;
      const serializedPrimaryKey = meta.props.find((p2) => p2.serializedPrimaryKey);
      const values = [];
      if (serializedPrimaryKey) {
        const pk = meta.getPrimaryProps()[0];
        const val = entity[serializedPrimaryKey.name];
        delete entity[serializedPrimaryKey.name];
        Object.defineProperty(entity, serializedPrimaryKey.name, {
          get() {
            return this[pk.name] ? platform.normalizePrimaryKey(this[pk.name]) : null;
          },
          set(id) {
            this[pk.name] = id ? platform.denormalizePrimaryKey(id) : null;
          },
          configurable: true
        });
        if (entity[pk.name] == null && val != null) {
          values.push([serializedPrimaryKey.name, val]);
        }
      }
      meta.trackingProps.forEach((prop) => {
        if (entity[prop.name] !== undefined) {
          values.push([prop.name, entity[prop.name]]);
        }
      });
      meta.trackingProps.forEach((prop) => {
        delete entity[prop.name];
      });
      Object.defineProperties(entity, meta.definedProperties);
      values.forEach((val) => entity[val[0]] = val[1]);
    }
  }
  exports.EntityHelper = EntityHelper;
});

// node_modules/@mikro-orm/core/entity/EntityAssigner.js
var require_EntityAssigner = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assign = exports.EntityAssigner = undefined;
  var util_1 = import.meta.require("util");
  var Collection_1 = require_Collection();
  var Utils_1 = require_Utils();
  var Reference_1 = require_Reference();
  var enums_1 = require_enums();
  var EntityValidator_1 = require_EntityValidator();
  var wrap_1 = require_wrap();
  var EntityHelper_1 = require_EntityHelper();
  var validator = new EntityValidator_1.EntityValidator(false);

  class EntityAssigner {
    static assign(entity, data, options = {}) {
      let opts = options;
      if (opts.visited?.has(entity)) {
        return entity;
      }
      EntityHelper_1.EntityHelper.ensurePropagation(entity);
      opts.visited ??= new Set;
      opts.visited.add(entity);
      const wrapped = (0, wrap_1.helper)(entity);
      opts = {
        updateNestedEntities: true,
        updateByPrimaryKey: true,
        mergeObjectProperties: true,
        schema: wrapped.__schema,
        ...opts
      };
      const meta = wrapped.__meta;
      const props = meta.properties;
      Object.keys(data).forEach((prop) => {
        return EntityAssigner.assignProperty(entity, prop, props, data, {
          ...opts,
          em: opts.em || wrapped.__em,
          platform: wrapped.__platform
        });
      });
      return entity;
    }
    static assignProperty(entity, propName, props, data, options) {
      if (options.onlyProperties && !(propName in props)) {
        return;
      }
      let value14 = data[propName];
      const prop = { ...props[propName], name: propName };
      if (propName in props && !prop.nullable && value14 == null) {
        throw new Error(`You must pass a non-${value14} value to the property ${propName} of entity ${entity.constructor.name}.`);
      }
      if ([enums_1.ReferenceKind.MANY_TO_MANY, enums_1.ReferenceKind.ONE_TO_MANY].includes(prop?.kind) && entity[prop.name] == null) {
        entity[prop.name] = Collection_1.Collection.create(entity, prop.name, undefined, (0, wrap_1.helper)(entity).isInitialized());
      }
      if (prop && Utils_1.Utils.isCollection(entity[prop.name])) {
        return EntityAssigner.assignCollection(entity, entity[prop.name], value14, prop, options.em, options);
      }
      const customType = prop?.customType;
      if (options.convertCustomTypes && customType && prop.kind === enums_1.ReferenceKind.SCALAR && !Utils_1.Utils.isEntity(data)) {
        value14 = customType.convertToJSValue(value14, options.platform);
      }
      if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop?.kind) && value14 != null) {
        if (options.updateNestedEntities && entity.hasOwnProperty(propName) && Utils_1.Utils.isEntity(entity[propName], true) && Utils_1.Utils.isPlainObject(value14)) {
          const unwrappedEntity = Reference_1.Reference.unwrapReference(entity[propName]);
          const wrapped = (0, wrap_1.helper)(unwrappedEntity);
          if (options.updateByPrimaryKey) {
            const pk = Utils_1.Utils.extractPK(value14, prop.targetMeta);
            if (pk) {
              const ref3 = options.em.getReference(prop.type, pk, options);
              const wrappedChild = (0, wrap_1.helper)(ref3);
              const sameTarget = wrappedChild.getSerializedPrimaryKey() === wrapped.getSerializedPrimaryKey();
              if (wrappedChild.__managed && wrappedChild.isInitialized() && sameTarget) {
                return EntityAssigner.assign(ref3, value14, options);
              }
            }
            return EntityAssigner.assignReference(entity, value14, prop, options.em, options);
          }
          if (wrapped.__managed && (0, wrap_1.wrap)(unwrappedEntity).isInitialized()) {
            return EntityAssigner.assign(unwrappedEntity, value14, options);
          }
        }
        return EntityAssigner.assignReference(entity, value14, prop, options.em, options);
      }
      if (prop.kind === enums_1.ReferenceKind.SCALAR && enums_1.SCALAR_TYPES.includes(prop.runtimeType) && (prop.setter || !prop.getter)) {
        return entity[prop.name] = validator.validateProperty(prop, value14, entity);
      }
      if (prop.kind === enums_1.ReferenceKind.EMBEDDED && EntityAssigner.validateEM(options.em)) {
        return EntityAssigner.assignEmbeddable(entity, value14, prop, options.em, options);
      }
      if (options.mergeObjectProperties && Utils_1.Utils.isPlainObject(entity[propName]) && Utils_1.Utils.isPlainObject(value14)) {
        entity[propName] ??= {};
        entity[propName] = Utils_1.Utils.merge({}, entity[propName], value14);
      } else if (!prop || prop.setter || !prop.getter) {
        entity[propName] = value14;
      }
    }
    static autoWireOneToOne(prop, entity) {
      const ref3 = entity[prop.name];
      if (prop.kind !== enums_1.ReferenceKind.ONE_TO_ONE || !Utils_1.Utils.isEntity(ref3)) {
        return;
      }
      const meta2 = (0, wrap_1.helper)(ref3).__meta;
      const prop2 = meta2.properties[prop.inversedBy || prop.mappedBy];
      if (prop2 && !ref3[prop2.name]) {
        if (Reference_1.Reference.isReference(ref3)) {
          ref3.unwrap()[prop2.name] = Reference_1.Reference.wrapReference(entity, prop2);
        } else {
          ref3[prop2.name] = Reference_1.Reference.wrapReference(entity, prop2);
        }
      }
    }
    static validateEM(em) {
      if (!em) {
        throw new Error(`To use assign() on not managed entities, explicitly provide EM instance: wrap(entity).assign(data, { em: orm.em })`);
      }
      return true;
    }
    static assignReference(entity, value14, prop, em, options) {
      if (Utils_1.Utils.isEntity(value14, true)) {
        entity[prop.name] = Reference_1.Reference.wrapReference(value14, prop);
      } else if (Utils_1.Utils.isPrimaryKey(value14, true) && EntityAssigner.validateEM(em)) {
        entity[prop.name] = prop.mapToPk ? value14 : Reference_1.Reference.wrapReference(em.getReference(prop.type, value14, options), prop);
      } else if (Utils_1.Utils.isPlainObject(value14) && options.merge && EntityAssigner.validateEM(em)) {
        entity[prop.name] = Reference_1.Reference.wrapReference(em.merge(prop.type, value14, options), prop);
      } else if (Utils_1.Utils.isPlainObject(value14) && EntityAssigner.validateEM(em)) {
        entity[prop.name] = Reference_1.Reference.wrapReference(em.create(prop.type, value14, options), prop);
      } else {
        const name = entity.constructor.name;
        throw new Error(`Invalid reference value provided for '${name}.${prop.name}' in ${name}.assign(): ${JSON.stringify(value14)}`);
      }
      EntityAssigner.autoWireOneToOne(prop, entity);
    }
    static assignCollection(entity, collection, value14, prop, em, options) {
      const invalid = [];
      const items = Utils_1.Utils.asArray(value14).map((item, idx) => {
        const prop2 = prop.targetMeta?.properties[prop.mappedBy];
        if (Utils_1.Utils.isPlainObject(item) && prop2 && item[prop2.name] == null) {
          item = { ...item, [prop2.name]: Reference_1.Reference.wrapReference(entity, prop2) };
        }
        if (options.updateNestedEntities && options.updateByPrimaryKey && Utils_1.Utils.isPlainObject(item)) {
          const pk = Utils_1.Utils.extractPK(item, prop.targetMeta);
          if (pk && EntityAssigner.validateEM(em)) {
            const ref3 = em.getUnitOfWork().getById(prop.type, pk, options.schema);
            if (ref3) {
              return EntityAssigner.assign(ref3, item, options);
            }
          }
          return this.createCollectionItem(item, em, prop, invalid, options);
        }
        if (options.updateNestedEntities && !options.updateByPrimaryKey && collection[idx] && (0, wrap_1.helper)(collection[idx])?.isInitialized()) {
          return EntityAssigner.assign(collection[idx], item, options);
        }
        return this.createCollectionItem(item, em, prop, invalid, options);
      });
      if (invalid.length > 0) {
        const name = entity.constructor.name;
        throw new Error(`Invalid collection values provided for '${name}.${prop.name}' in ${name}.assign(): ${(0, util_1.inspect)(invalid)}`);
      }
      if (Array.isArray(value14)) {
        collection.set(items);
      } else {
        collection.add(items);
      }
    }
    static assignEmbeddable(entity, value14, prop, em, options) {
      const propName = prop.embedded ? prop.embedded[1] : prop.name;
      if (value14 == null) {
        entity[propName] = value14;
        return;
      }
      if (prop.array && (Array.isArray(value14) || entity[propName] == null)) {
        entity[propName] = [];
      }
      if (prop.array) {
        return Utils_1.Utils.asArray(value14).forEach((item) => {
          const tmp = {};
          this.assignEmbeddable(tmp, item, { ...prop, array: false }, em, options);
          entity[propName].push(...Object.values(tmp));
        });
      }
      const create4 = () => EntityAssigner.validateEM(em) && em.getEntityFactory().createEmbeddable(prop.type, value14, {
        convertCustomTypes: options.convertCustomTypes,
        newEntity: options.mergeObjectProperties ? !("propName" in entity) : true
      });
      entity[propName] = options.mergeObjectProperties ? entity[propName] || create4() : create4();
      Object.keys(value14).forEach((key) => {
        EntityAssigner.assignProperty(entity[propName], key, prop.embeddedProps, value14, options);
      });
    }
    static createCollectionItem(item, em, prop, invalid, options) {
      if (Utils_1.Utils.isEntity(item)) {
        return item;
      }
      if (Utils_1.Utils.isPrimaryKey(item) && EntityAssigner.validateEM(em)) {
        return em.getReference(prop.type, item, options);
      }
      if (Utils_1.Utils.isPlainObject(item) && options.merge && EntityAssigner.validateEM(em)) {
        return em.merge(prop.type, item, options);
      }
      if (Utils_1.Utils.isPlainObject(item) && EntityAssigner.validateEM(em)) {
        return em.create(prop.type, item, options);
      }
      invalid.push(item);
      return item;
    }
  }
  exports.EntityAssigner = EntityAssigner;
  exports.assign = EntityAssigner.assign;
});

// node_modules/@mikro-orm/core/entity/EntityFactory.js
var require_EntityFactory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityFactory = undefined;
  var Utils_1 = require_Utils();
  var QueryHelper_1 = require_QueryHelper();
  var enums_1 = require_enums();
  var Reference_1 = require_Reference();
  var wrap_1 = require_wrap();
  var EntityHelper_1 = require_EntityHelper();

  class EntityFactory {
    em;
    driver;
    platform;
    config;
    metadata;
    hydrator;
    eventManager;
    comparator;
    constructor(em) {
      this.em = em;
      this.driver = this.em.getDriver();
      this.platform = this.driver.getPlatform();
      this.config = this.em.config;
      this.metadata = this.em.getMetadata();
      this.hydrator = this.config.getHydrator(this.metadata);
      this.eventManager = this.em.getEventManager();
      this.comparator = this.em.getComparator();
    }
    create(entityName, data, options = {}) {
      data = Reference_1.Reference.unwrapReference(data);
      options.initialized ??= true;
      if (data.__entity) {
        return data;
      }
      entityName = Utils_1.Utils.className(entityName);
      const meta = this.metadata.get(entityName);
      if (meta.virtual) {
        data = { ...data };
        const entity2 = this.createEntity(data, meta, options);
        this.hydrate(entity2, meta, data, options);
        return entity2;
      }
      if (this.platform.usesDifferentSerializedPrimaryKey()) {
        meta.primaryKeys.forEach((pk) => this.denormalizePrimaryKey(data, pk, meta.properties[pk]));
      }
      const meta2 = this.processDiscriminatorColumn(meta, data);
      const exists = this.findEntity(data, meta2, options);
      let wrapped = exists && (0, wrap_1.helper)(exists);
      if (wrapped && !options.refresh) {
        wrapped.__processing = true;
        this.mergeData(meta2, exists, data, options);
        wrapped.__processing = false;
        if (wrapped.isInitialized()) {
          return exists;
        }
      }
      data = { ...data };
      const entity = exists ?? this.createEntity(data, meta2, options);
      wrapped = (0, wrap_1.helper)(entity);
      wrapped.__processing = true;
      wrapped.__initialized = options.initialized;
      if (options.newEntity || meta.forceConstructor || meta.virtual) {
        const tmp = { ...data };
        meta.constructorParams.forEach((prop) => delete tmp[prop]);
        this.hydrate(entity, meta2, tmp, options);
      } else {
        this.hydrate(entity, meta2, data, options);
      }
      wrapped.__touched = false;
      if (exists && meta.discriminatorColumn && !(entity instanceof meta2.class)) {
        Object.setPrototypeOf(entity, meta2.prototype);
      }
      if (options.merge && wrapped.hasPrimaryKey()) {
        this.unitOfWork.register(entity, data, {
          refresh: options.refresh && options.initialized,
          newEntity: options.newEntity,
          loaded: options.initialized
        });
        if (options.recomputeSnapshot) {
          wrapped.__originalEntityData = this.comparator.prepareEntity(entity);
        }
      }
      if (this.eventManager.hasListeners(enums_1.EventType.onInit, meta2)) {
        this.eventManager.dispatchEvent(enums_1.EventType.onInit, { entity, meta: meta2, em: this.em });
      }
      wrapped.__processing = false;
      return entity;
    }
    mergeData(meta, entity, data, options = {}) {
      data = QueryHelper_1.QueryHelper.processParams(data);
      const existsData = this.comparator.prepareEntity(entity);
      const originalEntityData = (0, wrap_1.helper)(entity).__originalEntityData ?? {};
      const diff = this.comparator.diffEntities(meta.className, originalEntityData, existsData);
      if (meta.versionProperty && data[meta.versionProperty] && data[meta.versionProperty] !== originalEntityData[meta.versionProperty]) {
        diff[meta.versionProperty] = data[meta.versionProperty];
      }
      const diff2 = this.comparator.diffEntities(meta.className, existsData, data);
      Utils_1.Utils.keys(diff).forEach((key) => delete diff2[key]);
      Utils_1.Utils.keys(diff2).filter((key) => {
        if (existsData[key] != null) {
          return diff2[key] == null;
        }
        return diff2[key] === undefined;
      }).forEach((key) => delete diff2[key]);
      Utils_1.Utils.keys(data).filter((key) => meta.properties[key]?.formula || [enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(meta.properties[key]?.kind)).forEach((key) => diff2[key] = data[key]);
      this.hydrate(entity, meta, diff2, options);
      const nullVal = this.config.get("forceUndefined") ? undefined : null;
      Utils_1.Utils.keys(diff2).forEach((key) => {
        const prop = meta.properties[key];
        if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind) && Utils_1.Utils.isPlainObject(data[prop.name])) {
          diff2[key] = entity[prop.name] ? (0, wrap_1.helper)(entity[prop.name]).getPrimaryKey(options.convertCustomTypes) : null;
        }
        originalEntityData[key] = diff2[key] === null ? nullVal : diff2[key];
        (0, wrap_1.helper)(entity).__loadedProperties.add(key);
      });
      meta.relations.forEach((prop) => {
        if ([enums_1.ReferenceKind.MANY_TO_MANY, enums_1.ReferenceKind.ONE_TO_MANY].includes(prop.kind) && Array.isArray(data[prop.name])) {
          data[prop.name].filter((child) => Utils_1.Utils.isPlainObject(child)).forEach((child) => this.create(prop.type, child, options));
          return;
        }
        if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind) && Utils_1.Utils.isPlainObject(data[prop.name]) && entity[prop.name] && (0, wrap_1.helper)(entity[prop.name]).__initialized) {
          this.create(prop.type, data[prop.name], options);
        }
      });
      (0, wrap_1.helper)(entity).__touched = false;
    }
    createReference(entityName, id, options = {}) {
      options.convertCustomTypes ??= true;
      entityName = Utils_1.Utils.className(entityName);
      const meta = this.metadata.get(entityName);
      const schema = this.driver.getSchemaName(meta, options);
      if (Array.isArray(id)) {
        id = Utils_1.Utils.getPrimaryKeyCondFromArray(id, meta);
      }
      const pks = Utils_1.Utils.getOrderedPrimaryKeys(id, meta);
      const exists = this.unitOfWork.getById(entityName, pks, schema);
      if (exists) {
        return exists;
      }
      if (Utils_1.Utils.isPrimaryKey(id)) {
        id = { [meta.primaryKeys[0]]: id };
      }
      return this.create(entityName, id, { ...options, initialized: false });
    }
    createEmbeddable(entityName, data, options = {}) {
      entityName = Utils_1.Utils.className(entityName);
      data = { ...data };
      const meta = this.metadata.get(entityName);
      const meta2 = this.processDiscriminatorColumn(meta, data);
      return this.createEntity(data, meta2, options);
    }
    getComparator() {
      return this.comparator;
    }
    createEntity(data, meta, options) {
      if (options.newEntity || meta.forceConstructor || meta.virtual) {
        if (!meta.class) {
          throw new Error(`Cannot create entity ${meta.className}, class prototype is unknown`);
        }
        options.initialized = options.newEntity || options.initialized;
        const params = this.extractConstructorParams(meta, data, options);
        const Entity = meta.class;
        const entity2 = new Entity(...params);
        if (!options.initialized && this.config.get("forceEntityConstructor")) {
          meta.props.filter((prop) => prop.persist !== false && !prop.primary && data[prop.name] === undefined).forEach((prop) => delete entity2[prop.name]);
        }
        if (meta.virtual) {
          return entity2;
        }
        (0, wrap_1.helper)(entity2).__schema = this.driver.getSchemaName(meta, options);
        if (options.initialized) {
          EntityHelper_1.EntityHelper.ensurePropagation(entity2);
        }
        return entity2;
      }
      const entity = Object.create(meta.class.prototype);
      (0, wrap_1.helper)(entity).__managed = true;
      (0, wrap_1.helper)(entity).__processing = !meta.embeddable && !meta.virtual;
      (0, wrap_1.helper)(entity).__schema = this.driver.getSchemaName(meta, options);
      if (options.merge && !options.newEntity) {
        this.hydrator.hydrateReference(entity, meta, data, this, options.convertCustomTypes, this.driver.getSchemaName(meta, options));
        this.unitOfWork.register(entity);
      }
      if (options.initialized) {
        EntityHelper_1.EntityHelper.ensurePropagation(entity);
      }
      return entity;
    }
    hydrate(entity, meta, data, options) {
      if (options.initialized) {
        this.hydrator.hydrate(entity, meta, data, this, "full", options.newEntity, options.convertCustomTypes, this.driver.getSchemaName(meta, options));
      } else {
        this.hydrator.hydrateReference(entity, meta, data, this, options.convertCustomTypes, this.driver.getSchemaName(meta, options));
      }
      Utils_1.Utils.keys(data).forEach((key) => {
        (0, wrap_1.helper)(entity)?.__loadedProperties.add(key);
        (0, wrap_1.helper)(entity)?.__serializationContext.fields?.add(key);
      });
    }
    findEntity(data, meta, options) {
      const schema = this.driver.getSchemaName(meta, options);
      if (meta.simplePK) {
        return this.unitOfWork.getById(meta.name, data[meta.primaryKeys[0]], schema);
      }
      if (!Array.isArray(data) && meta.primaryKeys.some((pk) => data[pk] == null)) {
        return;
      }
      const pks = Utils_1.Utils.getOrderedPrimaryKeys(data, meta);
      return this.unitOfWork.getById(meta.name, pks, schema);
    }
    processDiscriminatorColumn(meta, data) {
      if (!meta.root.discriminatorColumn) {
        return meta;
      }
      const prop = meta.properties[meta.root.discriminatorColumn];
      const value14 = data[prop.name];
      const type73 = meta.root.discriminatorMap[value14];
      meta = type73 ? this.metadata.find(type73) : meta;
      if (prop.userDefined === false) {
        delete data[prop.name];
      }
      return meta;
    }
    denormalizePrimaryKey(data, primaryKey, prop) {
      const pk = this.platform.getSerializedPrimaryKeyField(primaryKey);
      if (data[pk] != null || data[primaryKey] != null) {
        let id = data[pk] || data[primaryKey];
        if (prop.type.toLowerCase() === "objectid") {
          id = this.platform.denormalizePrimaryKey(id);
        }
        delete data[pk];
        data[primaryKey] = id;
      }
    }
    extractConstructorParams(meta, data, options) {
      return meta.constructorParams.map((k) => {
        if (meta.properties[k] && [enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(meta.properties[k].kind) && data[k]) {
          const entity = this.unitOfWork.getById(meta.properties[k].type, data[k], options.schema);
          if (entity) {
            return entity;
          }
          if (Utils_1.Utils.isEntity(data[k])) {
            return data[k];
          }
          if (Utils_1.Utils.isObject(data[k]) && !Utils_1.Utils.extractPK(data[k], meta.properties[k].targetMeta, true)) {
            return this.create(meta.properties[k].type, data[k], options);
          }
          const { newEntity, initialized, ...rest3 } = options;
          return this.createReference(meta.properties[k].type, data[k], rest3);
        }
        if (meta.properties[k]?.kind === enums_1.ReferenceKind.EMBEDDED && data[k]) {
          if (Utils_1.Utils.isEntity(data[k])) {
            return data[k];
          }
          return this.createEmbeddable(meta.properties[k].type, data[k], options);
        }
        if (!meta.properties[k]) {
          const tmp = { ...data };
          for (const prop of meta.props) {
            if (options.convertCustomTypes && prop.customType && tmp[prop.name] != null) {
              tmp[prop.name] = prop.customType.convertToJSValue(tmp[prop.name], this.platform);
            }
          }
          return tmp;
        }
        if (options.convertCustomTypes && meta.properties[k].customType && data[k] != null) {
          return meta.properties[k].customType.convertToJSValue(data[k], this.platform);
        }
        return data[k];
      });
    }
    get unitOfWork() {
      return this.em.getUnitOfWork(false);
    }
  }
  exports.EntityFactory = EntityFactory;
});

// node_modules/@mikro-orm/core/entity/EntityLoader.js
var require_EntityLoader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityLoader = undefined;
  var QueryHelper_1 = require_QueryHelper();
  var Utils_1 = require_Utils();
  var errors_1 = require_errors3();
  var enums_1 = require_enums();
  var Reference_1 = require_Reference();
  var wrap_1 = require_wrap();

  class EntityLoader {
    em;
    metadata;
    driver;
    constructor(em) {
      this.em = em;
      this.metadata = this.em.getMetadata();
      this.driver = this.em.getDriver();
    }
    async populate(entityName, entities, populate, options) {
      if (entities.length === 0 || Utils_1.Utils.isEmpty(populate)) {
        return;
      }
      if (entities.some((e2) => !e2.__helper)) {
        const entity = entities.find((e2) => !Utils_1.Utils.isEntity(e2));
        const meta = this.metadata.find(entityName);
        throw errors_1.ValidationError.notDiscoveredEntity(entity, meta, "populate");
      }
      const visited2 = options.visited ??= new Set;
      options.where ??= {};
      options.orderBy ??= {};
      options.filters ??= {};
      options.lookup ??= true;
      options.validate ??= true;
      options.refresh ??= false;
      options.convertCustomTypes ??= true;
      populate = this.normalizePopulate(entityName, populate, options.strategy, options.lookup);
      const exclude5 = options.exclude ?? [];
      const invalid = populate.find(({ field }) => !this.em.canPopulate(entityName, field));
      if (options.validate && invalid) {
        throw errors_1.ValidationError.invalidPropertyName(entityName, invalid.field);
      }
      for (const entity of entities) {
        const context = (0, wrap_1.helper)(entity).__serializationContext;
        context.populate = context.populate ? context.populate.concat(populate) : populate;
        if (context.fields && options.fields) {
          options.fields.forEach((f) => context.fields.add(f));
        } else if (options.fields) {
          context.fields = new Set(options.fields);
        }
        context.exclude = context.exclude ? context.exclude.concat(exclude5) : exclude5;
        visited2.add(entity);
      }
      for (const pop of populate) {
        await this.populateField(entityName, entities, pop, options);
      }
    }
    normalizePopulate(entityName, populate, strategy, lookup = true) {
      const meta = this.metadata.find(entityName);
      let normalized = Utils_1.Utils.asArray(populate).map((field) => {
        return typeof field === "boolean" || field.field === "*" ? { all: !!field, field: meta.primaryKeys[0] } : field;
      });
      if (normalized.some((p2) => p2.all)) {
        normalized = this.lookupAllRelationships(entityName);
      }
      this.expandDotPaths(normalized, meta);
      if (lookup && populate !== false) {
        normalized = this.lookupEagerLoadedRelationships(entityName, normalized, strategy);
        this.expandDotPaths(normalized, meta);
      }
      return this.mergeNestedPopulate(normalized);
    }
    expandDotPaths(normalized, meta) {
      normalized.forEach((p2) => {
        if (!p2.field.includes(".")) {
          return;
        }
        const [f, ...parts] = p2.field.split(".");
        p2.field = f;
        p2.children = p2.children || [];
        const prop = meta.properties[f];
        p2.strategy ??= prop.strategy;
        p2.children.push(this.expandNestedPopulate(prop.type, parts, p2.strategy, p2.all));
      });
    }
    mergeNestedPopulate(populate) {
      const tmp = populate.reduce((ret, item) => {
        if (item.field === "*") {
          return ret;
        }
        if (!ret[item.field]) {
          ret[item.field] = item;
          return ret;
        }
        if (!ret[item.field].children && item.children) {
          ret[item.field].children = item.children;
        } else if (ret[item.field].children && item.children) {
          ret[item.field].children.push(...item.children);
        }
        return ret;
      }, {});
      return Object.values(tmp).map((item) => {
        if (item.children) {
          item.children = this.mergeNestedPopulate(item.children);
        }
        return item;
      });
    }
    expandNestedPopulate(entityName, parts, strategy, all) {
      const meta = this.metadata.find(entityName);
      const field = parts.shift();
      const prop = meta.properties[field];
      const ret = { field, strategy, all };
      if (parts.length > 0) {
        ret.children = [this.expandNestedPopulate(prop.type, parts, strategy)];
      }
      return ret;
    }
    async populateMany(entityName, entities, populate, options) {
      const [field, ref3] = populate.field.split(":", 2);
      const meta = this.metadata.find(entityName);
      const prop = meta.properties[field];
      if (prop.kind === enums_1.ReferenceKind.SCALAR && prop.lazy) {
        const filtered2 = entities.filter((e2) => options.refresh || (prop.ref ? !e2[prop.name]?.isInitialized() : e2[prop.name] === undefined));
        if (options.ignoreLazyScalarProperties || filtered2.length === 0) {
          return entities;
        }
        const pk = Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
        const ids = Utils_1.Utils.unique(filtered2.map((e2) => Utils_1.Utils.getPrimaryKeyValues(e2, meta.primaryKeys, true)));
        const where2 = this.mergePrimaryCondition(ids, pk, options, meta, this.metadata, this.driver.getPlatform());
        const { filters, convertCustomTypes, lockMode, strategy, populateWhere, connectionType, logging } = options;
        await this.em.find(meta.className, where2, {
          filters,
          convertCustomTypes,
          lockMode,
          strategy,
          populateWhere,
          connectionType,
          logging,
          fields: [prop.name],
          populate: []
        });
        return entities;
      }
      if (prop.kind === enums_1.ReferenceKind.EMBEDDED) {
        return [];
      }
      const filtered = this.filterCollections(entities, field, options, ref3);
      const innerOrderBy = Utils_1.Utils.asArray(options.orderBy).filter((orderBy) => Array.isArray(orderBy[prop.name]) && orderBy[prop.name].length > 0 || Utils_1.Utils.isObject(orderBy[prop.name])).flatMap((orderBy) => orderBy[prop.name]);
      if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && this.driver.getPlatform().usesPivotTable()) {
        return this.findChildrenFromPivotTable(filtered, prop, options, innerOrderBy, populate, !!ref3);
      }
      const where = await this.extractChildCondition(options, prop);
      const data = await this.findChildren(entities, prop, populate, { ...options, where, orderBy: innerOrderBy }, !!ref3);
      this.initializeCollections(filtered, prop, field, data, innerOrderBy.length > 0);
      return data;
    }
    initializeCollections(filtered, prop, field, children, customOrder) {
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY) {
        this.initializeOneToMany(filtered, children, prop, field);
      }
      if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && !this.driver.getPlatform().usesPivotTable()) {
        this.initializeManyToMany(filtered, children, prop, field, customOrder);
      }
    }
    initializeOneToMany(filtered, children, prop, field) {
      const mapToPk = prop.targetMeta.properties[prop.mappedBy].mapToPk;
      const map3 = {};
      filtered.forEach((entity) => {
        const key = (0, wrap_1.helper)(entity).getSerializedPrimaryKey();
        return map3[key] = [];
      });
      if (mapToPk) {
        children.forEach((child) => {
          const pk = child.__helper.__data[prop.mappedBy] ?? child[prop.mappedBy];
          if (pk) {
            const key = (0, wrap_1.helper)(this.em.getReference(prop.type, pk)).getSerializedPrimaryKey();
            map3[key]?.push(child);
          }
        });
      } else {
        children.forEach((child) => {
          const entity = child.__helper.__data[prop.mappedBy] ?? child[prop.mappedBy];
          if (entity) {
            const key = (0, wrap_1.helper)(entity).getSerializedPrimaryKey();
            map3[key]?.push(child);
          }
        });
      }
      filtered.forEach((entity) => {
        const key = (0, wrap_1.helper)(entity).getSerializedPrimaryKey();
        entity[field].hydrate(map3[key]);
      });
    }
    initializeManyToMany(filtered, children, prop, field, customOrder) {
      if (prop.mappedBy) {
        for (const entity of filtered) {
          const items = children.filter((child) => child[prop.mappedBy].contains(entity, false));
          entity[field].hydrate(items, true);
        }
      } else {
        for (const entity of filtered) {
          const order = !customOrder ? [...entity[prop.name].getItems(false)] : [];
          const items = children.filter((child) => entity[prop.name].contains(child, false));
          if (!customOrder) {
            items.sort((a2, b2) => order.indexOf(a2) - order.indexOf(b2));
          }
          entity[field].hydrate(items, true);
        }
      }
    }
    async findChildren(entities, prop, populate, options, ref3) {
      const children = this.getChildReferences(entities, prop, options, ref3);
      const meta = prop.targetMeta;
      let fk = Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
      let schema = options.schema;
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY || prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && !prop.owner) {
        fk = meta.properties[prop.mappedBy].name;
      }
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && !prop.owner && populate.strategy !== enums_1.LoadStrategy.JOINED && !this.em.config.get("autoJoinOneToOneOwner")) {
        children.length = 0;
        fk = meta.properties[prop.mappedBy].name;
        children.push(...this.filterByReferences(entities, prop.name, options.refresh));
      }
      if (children.length === 0) {
        return [];
      }
      if (!schema && [enums_1.ReferenceKind.ONE_TO_ONE, enums_1.ReferenceKind.MANY_TO_ONE].includes(prop.kind)) {
        schema = children.find((e2) => e2.__helper.__schema)?.__helper.__schema;
      }
      const ids = Utils_1.Utils.unique(children.map((e2) => e2.__helper.getPrimaryKey()));
      const where = this.mergePrimaryCondition(ids, fk, options, meta, this.metadata, this.driver.getPlatform());
      const fields = this.buildFields(options.fields, prop, ref3);
      let { refresh, filters, convertCustomTypes, lockMode, strategy, populateWhere, connectionType, logging } = options;
      if (typeof populateWhere === "object") {
        populateWhere = await this.extractChildCondition({ where: populateWhere }, prop);
      }
      const items = await this.em.find(prop.type, where, {
        filters,
        convertCustomTypes,
        lockMode,
        populateWhere,
        logging,
        orderBy: [...Utils_1.Utils.asArray(options.orderBy), ...Utils_1.Utils.asArray(prop.orderBy)],
        populate: populate.children ?? populate.all ?? [],
        exclude: Array.isArray(options.exclude) ? Utils_1.Utils.extractChildElements(options.exclude, prop.name) : options.exclude,
        strategy,
        fields,
        schema,
        connectionType,
        refresh: refresh && !children.every((item) => options.visited.has(item)),
        visited: options.visited
      });
      for (const item of items) {
        if (ref3 && !(0, wrap_1.helper)(item).__onLoadFired) {
          (0, wrap_1.helper)(item).__initialized = false;
          this.em.getUnitOfWork()["loadedEntities"].delete(item);
        }
      }
      return items;
    }
    mergePrimaryCondition(ids, pk, options, meta, metadata, platform) {
      const cond1 = QueryHelper_1.QueryHelper.processWhere({ where: { [pk]: { $in: ids } }, entityName: meta.name, metadata, platform, convertCustomTypes: !options.convertCustomTypes });
      return options.where[pk] ? { $and: [cond1, options.where] } : { ...cond1, ...options.where };
    }
    async populateField(entityName, entities, populate, options) {
      const field = populate.field.split(":")[0];
      const prop = this.metadata.find(entityName).properties[field];
      if (prop.kind === enums_1.ReferenceKind.SCALAR && !prop.lazy) {
        return;
      }
      const populated = await this.populateMany(entityName, entities, populate, options);
      if (!populate.children && !populate.all) {
        return;
      }
      const children = [];
      for (const entity of entities) {
        const ref3 = entity[field];
        if (Utils_1.Utils.isEntity(ref3)) {
          children.push(ref3);
        } else if (Reference_1.Reference.isReference(ref3)) {
          children.push(ref3.unwrap());
        } else if (Utils_1.Utils.isCollection(ref3)) {
          children.push(...ref3.getItems());
        } else if (ref3 && prop.kind === enums_1.ReferenceKind.EMBEDDED) {
          children.push(...Utils_1.Utils.asArray(ref3));
        }
      }
      if (populated.length === 0 && !populate.children) {
        return;
      }
      const fields = this.buildFields(options.fields, prop);
      const innerOrderBy = Utils_1.Utils.asArray(options.orderBy).filter((orderBy) => Utils_1.Utils.isObject(orderBy[prop.name])).map((orderBy) => orderBy[prop.name]);
      const { refresh, filters, ignoreLazyScalarProperties, populateWhere, connectionType, logging } = options;
      const exclude5 = Array.isArray(options.exclude) ? Utils_1.Utils.extractChildElements(options.exclude, prop.name) : options.exclude;
      const filtered = Utils_1.Utils.unique(children.filter((e2) => !options.visited.has(e2)));
      await this.populate(prop.type, filtered, populate.children ?? populate.all, {
        where: await this.extractChildCondition(options, prop, false),
        orderBy: innerOrderBy,
        fields,
        exclude: exclude5,
        validate: false,
        lookup: false,
        filters,
        ignoreLazyScalarProperties,
        populateWhere,
        connectionType,
        logging,
        refresh: refresh && !filtered.every((item) => options.visited.has(item)),
        visited: options.visited
      });
    }
    async findChildrenFromPivotTable(filtered, prop, options, orderBy, populate, pivotJoin) {
      const ids = filtered.map((e2) => e2.__helper.__primaryKeys);
      const refresh = options.refresh;
      const where = await this.extractChildCondition(options, prop, true);
      const fields = this.buildFields(options.fields, prop);
      const exclude5 = Array.isArray(options.exclude) ? Utils_1.Utils.extractChildElements(options.exclude, prop.name) : options.exclude;
      const options2 = { ...options };
      delete options2.limit;
      delete options2.offset;
      options2.fields = fields;
      options2.exclude = exclude5;
      options2.populate = populate?.children ?? [];
      if (prop.customType) {
        ids.forEach((id, idx) => ids[idx] = QueryHelper_1.QueryHelper.processCustomType(prop, id, this.driver.getPlatform()));
      }
      const map3 = await this.driver.loadFromPivotTable(prop, ids, where, orderBy, this.em.getTransactionContext(), options2, pivotJoin);
      const children = [];
      for (const entity of filtered) {
        const items = map3[entity.__helper.getSerializedPrimaryKey()].map((item) => {
          if (pivotJoin) {
            return this.em.getReference(prop.type, item, {
              convertCustomTypes: true,
              schema: options.schema ?? this.em.config.get("schema")
            });
          }
          const entity2 = this.em.getEntityFactory().create(prop.type, item, {
            refresh,
            merge: true,
            convertCustomTypes: true,
            schema: options.schema ?? this.em.config.get("schema")
          });
          return this.em.getUnitOfWork().register(entity2, item, { refresh, loaded: true });
        });
        entity[prop.name].hydrate(items, true);
        children.push(...items);
      }
      return children;
    }
    async extractChildCondition(options, prop, filters = false) {
      const where = options.where;
      const subCond = Utils_1.Utils.isPlainObject(where[prop.name]) ? where[prop.name] : {};
      const meta2 = this.metadata.find(prop.type);
      const pk = Utils_1.Utils.getPrimaryKeyHash(meta2.primaryKeys);
      ["$and", "$or"].forEach((op) => {
        if (where[op]) {
          const child = where[op].map((cond) => cond[prop.name]).filter((sub) => sub != null && !(Utils_1.Utils.isPlainObject(sub) && Object.keys(sub).every((key) => Utils_1.Utils.isOperator(key, false)))).map((cond) => {
            if (Utils_1.Utils.isPrimaryKey(cond)) {
              return { [pk]: cond };
            }
            return cond;
          });
          if (child.length > 0) {
            subCond[op] = child;
          }
        }
      });
      const operators = Object.keys(subCond).filter((key) => Utils_1.Utils.isOperator(key, false));
      if (operators.length > 0) {
        operators.forEach((op) => {
          subCond[pk] ??= {};
          subCond[pk][op] = subCond[op];
          delete subCond[op];
        });
      }
      if (filters) {
        return this.em.applyFilters(prop.type, subCond, options.filters, "read", options);
      }
      return subCond;
    }
    buildFields(fields = [], prop, ref3) {
      if (ref3) {
        fields = prop.targetMeta.primaryKeys.map((targetPkName) => `${prop.name}.${targetPkName}`);
      }
      const ret = fields.reduce((ret2, f) => {
        if (Utils_1.Utils.isPlainObject(f)) {
          Utils_1.Utils.keys(f).filter((ff) => ff === prop.name).forEach((ff) => ret2.push(...f[ff]));
        } else if (f.toString().includes(".")) {
          const parts = f.toString().split(".");
          const propName = parts.shift();
          const childPropName = parts.join(".");
          if (propName === prop.name) {
            ret2.push(childPropName);
          }
        }
        return ret2;
      }, []);
      if (ret.length === 0) {
        return;
      }
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY || prop.kind === enums_1.ReferenceKind.MANY_TO_MANY) {
        const owner = prop.targetMeta.properties[prop.mappedBy];
        if (owner && !ret.includes(owner.name)) {
          ret.push(owner.name);
        }
      }
      return ret;
    }
    getChildReferences(entities, prop, options, ref3) {
      const filtered = this.filterCollections(entities, prop.name, options, ref3);
      const children = [];
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY) {
        children.push(...filtered.map((e2) => e2[prop.name].owner));
      } else if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && prop.owner) {
        children.push(...filtered.reduce((a2, b2) => [...a2, ...b2[prop.name].getItems()], []));
      } else if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY) {
        children.push(...filtered);
      } else {
        children.push(...this.filterReferences(entities, prop.name, options, ref3));
      }
      return children;
    }
    filterCollections(entities, field, options, ref3) {
      if (options.refresh) {
        return entities.filter((e2) => e2[field]);
      }
      return entities.filter((e2) => Utils_1.Utils.isCollection(e2[field]) && !e2[field].isInitialized(!ref3));
    }
    filterReferences(entities, field, options, ref3) {
      if (ref3) {
        return [];
      }
      const children = entities.filter((e2) => Utils_1.Utils.isEntity(e2[field], true));
      if (options.refresh) {
        return children.map((e2) => Reference_1.Reference.unwrapReference(e2[field]));
      }
      if (options.fields) {
        return children.filter((e2) => {
          const wrapped = (0, wrap_1.helper)(e2[field]);
          const childFields = options.fields.filter((f) => f.startsWith(`${field}.`)).map((f) => f.substring(field.length + 1));
          return !wrapped.__initialized || !childFields.every((field2) => wrapped.__loadedProperties.has(field2));
        }).map((e2) => Reference_1.Reference.unwrapReference(e2[field]));
      }
      return children.filter((e2) => !e2[field].__helper.__initialized).map((e2) => Reference_1.Reference.unwrapReference(e2[field]));
    }
    filterByReferences(entities, field, refresh) {
      if (refresh) {
        return entities;
      }
      return entities.filter((e2) => !e2[field]?.__helper?.__initialized);
    }
    lookupAllRelationships(entityName) {
      const ret = [];
      const meta = this.metadata.find(entityName);
      meta.relations.forEach((prop) => {
        ret.push({
          field: this.getRelationName(meta, prop),
          strategy: enums_1.LoadStrategy.SELECT_IN,
          all: true
        });
      });
      return ret;
    }
    getRelationName(meta, prop) {
      if (!prop.embedded) {
        return prop.name;
      }
      return `${this.getRelationName(meta, meta.properties[prop.embedded[0]])}.${prop.embedded[1]}`;
    }
    lookupEagerLoadedRelationships(entityName, populate, strategy, prefix = "", visited2 = []) {
      const meta = this.metadata.find(entityName);
      if (!meta && !prefix) {
        return populate;
      }
      if (visited2.includes(entityName) || !meta) {
        return [];
      }
      visited2.push(entityName);
      const ret = prefix === "" ? [...populate] : [];
      meta.relations.filter((prop) => {
        const eager = prop.eager && !populate.some((p2) => p2.field === `${prop.name}:ref`);
        const populated = populate.some((p2) => p2.field === prop.name);
        const disabled = populate.some((p2) => p2.field === prop.name && p2.all === false);
        return !disabled && (eager || populated);
      }).forEach((prop) => {
        const field = this.getRelationName(meta, prop);
        const prefixed = prefix ? `${prefix}.${field}` : field;
        const nestedPopulate = populate.filter((p2) => p2.field === prop.name).flatMap((p2) => p2.children).filter(Boolean);
        const nested = this.lookupEagerLoadedRelationships(prop.type, nestedPopulate, strategy, prefixed, visited2.slice());
        if (nested.length > 0) {
          ret.push(...nested);
        } else {
          const selfReferencing = [meta.className, meta.root.className, ...visited2].includes(prop.type) && prop.eager;
          ret.push({
            field: prefixed,
            strategy: selfReferencing ? enums_1.LoadStrategy.SELECT_IN : strategy ?? prop.strategy
          });
        }
      });
      return ret;
    }
  }
  exports.EntityLoader = EntityLoader;
});

// node_modules/@mikro-orm/core/entity/BaseEntity.js
var require_BaseEntity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseEntity = undefined;
  var Reference_1 = require_Reference();
  var EntityAssigner_1 = require_EntityAssigner();
  var EntitySerializer_1 = require_EntitySerializer();
  var wrap_1 = require_wrap();

  class BaseEntity {
    isInitialized() {
      return (0, wrap_1.helper)(this).__initialized;
    }
    isTouched() {
      return (0, wrap_1.helper)(this).__touched;
    }
    populated(populated = true) {
      (0, wrap_1.helper)(this).populated(populated);
    }
    async populate(populate, options = {}) {
      return (0, wrap_1.helper)(this).populate(populate, options);
    }
    toReference() {
      return Reference_1.Reference.create(this);
    }
    toObject(ignoreFields) {
      return (0, wrap_1.helper)(this).toObject(ignoreFields);
    }
    toPOJO() {
      return (0, wrap_1.helper)(this).toPOJO();
    }
    serialize(options) {
      return EntitySerializer_1.EntitySerializer.serialize(this, options);
    }
    assign(data, options = {}) {
      return EntityAssigner_1.EntityAssigner.assign(this, data, options);
    }
    init(options) {
      return (0, wrap_1.helper)(this).init(options);
    }
    getSchema() {
      return (0, wrap_1.helper)(this).getSchema();
    }
    setSchema(schema) {
      (0, wrap_1.helper)(this).setSchema(schema);
    }
  }
  exports.BaseEntity = BaseEntity;
  Object.defineProperty(BaseEntity.prototype, "__baseEntity", { value: true, writable: false, enumerable: false });
});

// node_modules/@mikro-orm/core/entity/index.js
var require_entity = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_EntityRepository(), exports);
  __exportStar(require_EntityIdentifier(), exports);
  __exportStar(require_EntityValidator(), exports);
  __exportStar(require_EntityAssigner(), exports);
  __exportStar(require_EntityHelper(), exports);
  __exportStar(require_EntityFactory(), exports);
  __exportStar(require_ArrayCollection(), exports);
  __exportStar(require_Collection(), exports);
  __exportStar(require_EntityLoader(), exports);
  __exportStar(require_Reference(), exports);
  __exportStar(require_BaseEntity(), exports);
  __exportStar(require_WrappedEntity(), exports);
  __exportStar(require_wrap(), exports);
});

// node_modules/@mikro-orm/core/typings.js
var require_typings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityMetadata = exports.Config = exports.HiddenProps = exports.EagerProps = exports.OptionalProps = exports.PrimaryKeyProp = exports.EntityRepositoryType = undefined;
  var enums_1 = require_enums();
  var entity_1 = require_entity();
  var Utils_1 = require_Utils();
  var EntityComparator_1 = require_EntityComparator();
  exports.EntityRepositoryType = Symbol("EntityRepositoryType");
  exports.PrimaryKeyProp = Symbol("PrimaryKeyProp");
  exports.OptionalProps = Symbol("OptionalProps");
  exports.EagerProps = Symbol("EagerProps");
  exports.HiddenProps = Symbol("HiddenProps");
  exports.Config = Symbol("Config");

  class EntityMetadata {
    static counter = 0;
    _id = 1000 * EntityMetadata.counter++;
    propertyOrder = new Map;
    constructor(meta = {}) {
      this.properties = {};
      this.props = [];
      this.primaryKeys = [];
      this.filters = {};
      this.hooks = {};
      this.indexes = [];
      this.uniques = [];
      this.checks = [];
      this.referencingProperties = [];
      this.concurrencyCheckKeys = new Set;
      Object.assign(this, meta);
    }
    addProperty(prop, sync = true) {
      if (prop.pivotTable && !prop.pivotEntity) {
        prop.pivotEntity = prop.pivotTable;
      }
      this.properties[prop.name] = prop;
      this.propertyOrder.set(prop.name, this.props.length);
      if (sync) {
        this.sync();
      }
    }
    removeProperty(name, sync = true) {
      delete this.properties[name];
      this.propertyOrder.delete(name);
      if (sync) {
        this.sync();
      }
    }
    getPrimaryProps() {
      return this.primaryKeys.map((pk) => this.properties[pk]);
    }
    get tableName() {
      return this.collection;
    }
    set tableName(name) {
      this.collection = name;
    }
    sync(initIndexes = false) {
      this.root ??= this;
      const props = Object.values(this.properties).sort((a2, b2) => this.propertyOrder.get(a2.name) - this.propertyOrder.get(b2.name));
      this.props = [...props.filter((p2) => p2.primary), ...props.filter((p2) => !p2.primary)];
      this.relations = this.props.filter((prop) => prop.kind !== enums_1.ReferenceKind.SCALAR && prop.kind !== enums_1.ReferenceKind.EMBEDDED);
      this.bidirectionalRelations = this.relations.filter((prop) => prop.mappedBy || prop.inversedBy);
      this.uniqueProps = this.props.filter((prop) => prop.unique);
      this.comparableProps = this.props.filter((prop) => EntityComparator_1.EntityComparator.isComparable(prop, this));
      this.hydrateProps = this.props.filter((prop) => {
        const discriminator = this.root.discriminatorColumn === prop.name && prop.userDefined === false;
        const onlyGetter = prop.getter && !prop.setter;
        return !prop.inherited && prop.hydrate !== false && !discriminator && !prop.embedded && !onlyGetter;
      });
      this.trackingProps = this.hydrateProps.filter((prop) => !prop.getter && !prop.setter).filter((prop) => ![enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind)).filter((prop) => !prop.serializedPrimaryKey);
      this.selfReferencing = this.relations.some((prop) => [this.className, this.root.className].includes(prop.type));
      this.hasUniqueProps = this.uniques.length + this.uniqueProps.length > 0;
      this.virtual = !!this.expression;
      this.checks = Utils_1.Utils.removeDuplicates(this.checks);
      this.indexes = Utils_1.Utils.removeDuplicates(this.indexes);
      this.uniques = Utils_1.Utils.removeDuplicates(this.uniques);
      for (const hook of Utils_1.Utils.keys(this.hooks)) {
        this.hooks[hook] = Utils_1.Utils.removeDuplicates(this.hooks[hook]);
      }
      if (this.virtual) {
        this.readonly = true;
      }
      if (initIndexes && this.name) {
        this.props.forEach((prop) => this.initIndexes(prop));
      }
      this.definedProperties = this.trackingProps.reduce((o2, prop) => {
        const isCollection = [enums_1.ReferenceKind.ONE_TO_MANY, enums_1.ReferenceKind.MANY_TO_MANY].includes(prop.kind);
        const isReference = [enums_1.ReferenceKind.ONE_TO_ONE, enums_1.ReferenceKind.MANY_TO_ONE].includes(prop.kind) && (prop.inversedBy || prop.mappedBy) && !prop.mapToPk;
        if (isReference) {
          const meta = this;
          o2[prop.name] = {
            get() {
              return this.__helper.__data[prop.name];
            },
            set(val) {
              const wrapped = this.__helper;
              const hydrator = wrapped.hydrator;
              const entity = entity_1.Reference.unwrapReference(val ?? wrapped.__data[prop.name]);
              const old = entity_1.Reference.unwrapReference(wrapped.__data[prop.name]);
              wrapped.__data[prop.name] = entity_1.Reference.wrapReference(val, prop);
              if (val && hydrator.isRunning() && wrapped.__originalEntityData && prop.owner) {
                wrapped.__originalEntityData[prop.name] = Utils_1.Utils.getPrimaryKeyValues(val, prop.targetMeta.primaryKeys, true);
              } else {
                wrapped.__touched = !hydrator.isRunning();
              }
              entity_1.EntityHelper.propagate(meta, entity, this, prop, entity_1.Reference.unwrapReference(val), old);
            },
            enumerable: true,
            configurable: true
          };
        }
        if (prop.inherited || prop.primary || isCollection || prop.persist === false || prop.trackChanges === false || isReference || prop.embedded) {
          return o2;
        }
        o2[prop.name] = {
          get() {
            return this.__helper.__data[prop.name];
          },
          set(val) {
            if (typeof val === "object" && !!val && "__raw" in val) {
              val.assign();
            }
            this.__helper.__data[prop.name] = val;
            this.__helper.__touched = !this.__helper.hydrator.isRunning();
          },
          enumerable: true,
          configurable: true
        };
        return o2;
      }, { __gettersDefined: { value: true, enumerable: false } });
    }
    initIndexes(prop) {
      const simpleIndex = this.indexes.find((index) => index.properties === prop.name && !index.options && !index.type && !index.expression);
      const simpleUnique = this.uniques.find((index) => index.properties === prop.name && !index.options);
      const owner = prop.kind === enums_1.ReferenceKind.MANY_TO_ONE;
      if (!prop.index && simpleIndex) {
        Utils_1.Utils.defaultValue(simpleIndex, "name", true);
        prop.index = simpleIndex.name;
        this.indexes.splice(this.indexes.indexOf(simpleIndex), 1);
      }
      if (!prop.unique && simpleUnique) {
        Utils_1.Utils.defaultValue(simpleUnique, "name", true);
        prop.unique = simpleUnique.name;
        this.uniques.splice(this.uniques.indexOf(simpleUnique), 1);
      }
      if (prop.index && owner && prop.fieldNames.length > 1) {
        this.indexes.push({ properties: prop.name });
        prop.index = false;
      }
      if (owner && prop.fieldNames.length > 1 && prop.unique) {
        this.uniques.push({ properties: prop.name });
        prop.unique = false;
      }
    }
    clone() {
      return this;
    }
  }
  exports.EntityMetadata = EntityMetadata;
});

// node_modules/@mikro-orm/core/exceptions.js
var require_exceptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UniqueConstraintViolationException = exports.TableNotFoundException = exports.TableExistsException = exports.SyntaxErrorException = exports.ReadOnlyException = exports.NotNullConstraintViolationException = exports.NonUniqueFieldNameException = exports.LockWaitTimeoutException = exports.InvalidFieldNameException = exports.CheckConstraintViolationException = exports.ForeignKeyConstraintViolationException = exports.DeadlockException = exports.DatabaseObjectNotFoundException = exports.DatabaseObjectExistsException = exports.ConstraintViolationException = exports.ServerException = exports.ConnectionException = exports.DriverException = undefined;

  class DriverException extends Error {
    code;
    errno;
    sqlState;
    sqlMessage;
    errmsg;
    constructor(previous) {
      super(previous.message);
      Object.assign(this, previous);
      this.name = this.constructor.name;
      this.stack += "\n\nprevious " + previous.stack;
    }
  }
  exports.DriverException = DriverException;

  class ConnectionException extends DriverException {
  }
  exports.ConnectionException = ConnectionException;

  class ServerException extends DriverException {
  }
  exports.ServerException = ServerException;

  class ConstraintViolationException extends ServerException {
  }
  exports.ConstraintViolationException = ConstraintViolationException;

  class DatabaseObjectExistsException extends ServerException {
  }
  exports.DatabaseObjectExistsException = DatabaseObjectExistsException;

  class DatabaseObjectNotFoundException extends ServerException {
  }
  exports.DatabaseObjectNotFoundException = DatabaseObjectNotFoundException;

  class DeadlockException extends ServerException {
  }
  exports.DeadlockException = DeadlockException;

  class ForeignKeyConstraintViolationException extends ConstraintViolationException {
  }
  exports.ForeignKeyConstraintViolationException = ForeignKeyConstraintViolationException;

  class CheckConstraintViolationException extends ConstraintViolationException {
  }
  exports.CheckConstraintViolationException = CheckConstraintViolationException;

  class InvalidFieldNameException extends ServerException {
  }
  exports.InvalidFieldNameException = InvalidFieldNameException;

  class LockWaitTimeoutException extends ServerException {
  }
  exports.LockWaitTimeoutException = LockWaitTimeoutException;

  class NonUniqueFieldNameException extends ServerException {
  }
  exports.NonUniqueFieldNameException = NonUniqueFieldNameException;

  class NotNullConstraintViolationException extends ConstraintViolationException {
  }
  exports.NotNullConstraintViolationException = NotNullConstraintViolationException;

  class ReadOnlyException extends ServerException {
  }
  exports.ReadOnlyException = ReadOnlyException;

  class SyntaxErrorException extends ServerException {
  }
  exports.SyntaxErrorException = SyntaxErrorException;

  class TableExistsException extends DatabaseObjectExistsException {
  }
  exports.TableExistsException = TableExistsException;

  class TableNotFoundException extends DatabaseObjectNotFoundException {
  }
  exports.TableNotFoundException = TableNotFoundException;

  class UniqueConstraintViolationException extends ConstraintViolationException {
  }
  exports.UniqueConstraintViolationException = UniqueConstraintViolationException;
});

// node_modules/@mikro-orm/core/types/DateType.js
var require_DateType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DateType = undefined;
  var Type_1 = require_Type();

  class DateType5 extends Type_1.Type {
    compareAsType() {
      return "string";
    }
    ensureComparable() {
      return false;
    }
    getColumnType(prop, platform) {
      return platform.getDateTypeDeclarationSQL(prop.length);
    }
  }
  exports.DateType = DateType5;
});

// node_modules/@mikro-orm/core/types/TimeType.js
var require_TimeType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeType = undefined;
  var Type_1 = require_Type();
  var errors_1 = require_errors3();

  class TimeType extends Type_1.Type {
    convertToDatabaseValue(value14, platform) {
      if (value14 && !value14.toString().match(/^\d{2,}:(?:[0-5]\d):(?:[0-5]\d)$/)) {
        throw errors_1.ValidationError.invalidType(TimeType, value14, "JS");
      }
      return super.convertToDatabaseValue(value14, platform);
    }
    compareAsType() {
      return "string";
    }
    ensureComparable() {
      return false;
    }
    getColumnType(prop, platform) {
      return platform.getTimeTypeDeclarationSQL(prop.length);
    }
  }
  exports.TimeType = TimeType;
});

// node_modules/@mikro-orm/core/types/DateTimeType.js
var require_DateTimeType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DateTimeType = undefined;
  var Type_1 = require_Type();

  class DateTimeType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getDateTimeTypeDeclarationSQL({ length: prop.length });
    }
    compareAsType() {
      return "Date";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.DateTimeType = DateTimeType;
});

// node_modules/@mikro-orm/core/types/BigIntType.js
var require_BigIntType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BigIntType = undefined;
  var Type_1 = require_Type();

  class BigIntType2 extends Type_1.Type {
    mode;
    constructor(mode) {
      super();
      this.mode = mode;
    }
    convertToDatabaseValue(value14) {
      if (value14 == null) {
        return value14;
      }
      return "" + value14;
    }
    convertToJSValue(value14) {
      if (value14 == null) {
        return value14;
      }
      switch (this.mode) {
        case "number":
          return Number(value14);
        case "string":
          return String(value14);
        case "bigint":
        default:
          return BigInt(value14);
      }
    }
    toJSON(value14) {
      return this.convertToDatabaseValue(value14);
    }
    getColumnType(prop, platform) {
      return platform.getBigIntTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return this.mode ?? "bigint";
    }
  }
  exports.BigIntType = BigIntType2;
});

// node_modules/@mikro-orm/core/types/Uint8ArrayType.js
var require_Uint8ArrayType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uint8ArrayType = undefined;
  var Type_1 = require_Type();

  class Uint8ArrayType3 extends Type_1.Type {
    convertToDatabaseValue(value14) {
      if (!value14) {
        return value14;
      }
      return Buffer.from(value14);
    }
    convertToJSValue(value14) {
      if (!value14) {
        return value14;
      }
      if (value14 instanceof Buffer) {
        return new Uint8Array(value14);
      }
      if (value14.buffer instanceof Buffer) {
        return new Uint8Array(value14.buffer);
      }
      return new Uint8Array(Buffer.from(value14));
    }
    compareAsType() {
      return "Buffer";
    }
    ensureComparable() {
      return false;
    }
    getColumnType(prop, platform) {
      return platform.getBlobDeclarationSQL();
    }
  }
  exports.Uint8ArrayType = Uint8ArrayType3;
});

// node_modules/@mikro-orm/core/types/BlobType.js
var require_BlobType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BlobType = undefined;
  var Uint8ArrayType_1 = require_Uint8ArrayType();

  class BlobType extends Uint8ArrayType_1.Uint8ArrayType {
    convertToJSValue(value14) {
      if (value14 instanceof Buffer || !value14) {
        return value14;
      }
      if (value14.buffer instanceof Buffer) {
        return value14.buffer;
      }
      return Buffer.from(value14);
    }
    compareAsType() {
      return "Buffer";
    }
    ensureComparable() {
      return false;
    }
    getColumnType(prop, platform) {
      return platform.getBlobDeclarationSQL();
    }
  }
  exports.BlobType = BlobType;
});

// node_modules/@mikro-orm/core/types/ArrayType.js
var require_ArrayType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArrayType = undefined;
  var Type_1 = require_Type();
  var utils_1 = require_utils10();
  var errors_1 = require_errors3();

  class ArrayType7 extends Type_1.Type {
    hydrate;
    constructor(hydrate = (i2) => i2) {
      super();
      this.hydrate = hydrate;
    }
    convertToDatabaseValue(value14, platform, context) {
      if (!value14) {
        return value14;
      }
      if (Array.isArray(value14)) {
        return platform.marshallArray(value14);
      }
      if (context?.fromQuery) {
        return value14;
      }
      throw errors_1.ValidationError.invalidType(ArrayType7, value14, "JS");
    }
    convertToJSValue(value14, platform) {
      if (value14 == null) {
        return value14;
      }
      if (utils_1.Utils.isString(value14)) {
        value14 = platform.unmarshallArray(value14);
      }
      return value14.map((i2) => this.hydrate(i2));
    }
    compareAsType() {
      return "string[]";
    }
    toJSON(value14) {
      return value14;
    }
    getColumnType(prop, platform) {
      return platform.getArrayDeclarationSQL();
    }
  }
  exports.ArrayType = ArrayType7;
});

// node_modules/@mikro-orm/core/types/EnumArrayType.js
var require_EnumArrayType = __commonJS((exports) => {
  var mapHydrator = function(items, hydrate) {
    if (items && items.length > 0 && typeof items[0] === "number") {
      return (i2) => +i2;
    }
    return hydrate;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnumArrayType = undefined;
  var util_1 = import.meta.require("util");
  var ArrayType_1 = require_ArrayType();
  var errors_1 = require_errors3();

  class EnumArrayType extends ArrayType_1.ArrayType {
    owner;
    items;
    constructor(owner, items, hydrate = (i2) => i2) {
      super(mapHydrator(items, hydrate));
      this.owner = owner;
      this.items = items;
    }
    convertToDatabaseValue(value14, platform, context) {
      if (Array.isArray(value14) && Array.isArray(this.items)) {
        const invalid = value14.filter((v2) => !this.items.includes(v2));
        if (invalid.length > 0) {
          throw new errors_1.ValidationError(`Invalid enum array items provided in ${this.owner}: ${(0, util_1.inspect)(invalid)}`);
        }
      }
      return super.convertToDatabaseValue(value14, platform, context);
    }
  }
  exports.EnumArrayType = EnumArrayType;
});

// node_modules/@mikro-orm/core/types/EnumType.js
var require_EnumType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnumType = undefined;
  var Type_1 = require_Type();

  class EnumType extends Type_1.Type {
    getColumnType(prop, platform) {
      return prop.columnTypes?.[0] ?? platform.getEnumTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "string";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.EnumType = EnumType;
});

// node_modules/@mikro-orm/core/types/IntegerType.js
var require_IntegerType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegerType = undefined;
  var Type_1 = require_Type();

  class IntegerType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getIntegerTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "number";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.IntegerType = IntegerType;
});

// node_modules/@mikro-orm/core/types/SmallIntType.js
var require_SmallIntType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SmallIntType = undefined;
  var Type_1 = require_Type();

  class SmallIntType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getSmallIntTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "number";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.SmallIntType = SmallIntType;
});

// node_modules/@mikro-orm/core/types/TinyIntType.js
var require_TinyIntType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TinyIntType = undefined;
  var Type_1 = require_Type();

  class TinyIntType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getTinyIntTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "number";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.TinyIntType = TinyIntType;
});

// node_modules/@mikro-orm/core/types/MediumIntType.js
var require_MediumIntType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MediumIntType = undefined;
  var IntegerType_1 = require_IntegerType();

  class MediumIntType extends IntegerType_1.IntegerType {
    getColumnType(prop, platform) {
      return platform.getMediumIntTypeDeclarationSQL(prop);
    }
  }
  exports.MediumIntType = MediumIntType;
});

// node_modules/@mikro-orm/core/types/FloatType.js
var require_FloatType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FloatType = undefined;
  var Type_1 = require_Type();

  class FloatType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getFloatDeclarationSQL();
    }
    compareAsType() {
      return "number";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.FloatType = FloatType;
});

// node_modules/@mikro-orm/core/types/DoubleType.js
var require_DoubleType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DoubleType = undefined;
  var Type_1 = require_Type();

  class DoubleType extends Type_1.Type {
    convertToJSValue(value14) {
      if (this.prop?.runtimeType === "number") {
        return +value14;
      }
      return value14;
    }
    getColumnType(prop, platform) {
      return platform.getDoubleDeclarationSQL();
    }
    compareAsType() {
      return this.prop?.runtimeType ?? "number";
    }
  }
  exports.DoubleType = DoubleType;
});

// node_modules/@mikro-orm/core/types/BooleanType.js
var require_BooleanType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BooleanType = undefined;
  var Type_1 = require_Type();

  class BooleanType2 extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getBooleanTypeDeclarationSQL();
    }
    compareAsType() {
      return "boolean";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.BooleanType = BooleanType2;
});

// node_modules/@mikro-orm/core/types/DecimalType.js
var require_DecimalType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DecimalType = undefined;
  var Type_1 = require_Type();

  class DecimalType extends Type_1.Type {
    convertToJSValue(value14) {
      if (this.prop?.runtimeType === "number") {
        return +value14;
      }
      return value14;
    }
    getColumnType(prop, platform) {
      return platform.getDecimalTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return this.prop?.runtimeType ?? "string";
    }
  }
  exports.DecimalType = DecimalType;
});

// node_modules/@mikro-orm/core/types/StringType.js
var require_StringType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StringType = undefined;
  var Type_1 = require_Type();

  class StringType2 extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getVarcharTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "string";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.StringType = StringType2;
});

// node_modules/@mikro-orm/core/types/UuidType.js
var require_UuidType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UuidType = undefined;
  var Type_1 = require_Type();

  class UuidType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getUuidTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "string";
    }
  }
  exports.UuidType = UuidType;
});

// node_modules/@mikro-orm/core/types/TextType.js
var require_TextType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TextType = undefined;
  var Type_1 = require_Type();

  class TextType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getTextTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "string";
    }
    ensureComparable() {
      return false;
    }
  }
  exports.TextType = TextType;
});

// node_modules/@mikro-orm/core/types/IntervalType.js
var require_IntervalType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntervalType = undefined;
  var Type_1 = require_Type();

  class IntervalType extends Type_1.Type {
    getColumnType(prop, platform) {
      return platform.getIntervalTypeDeclarationSQL(prop);
    }
    convertToJSValue(value14, platform) {
      return platform.convertIntervalToJSValue(value14);
    }
    convertToDatabaseValue(value14, platform) {
      return platform.convertIntervalToDatabaseValue(value14);
    }
  }
  exports.IntervalType = IntervalType;
});

// node_modules/@mikro-orm/core/types/UnknownType.js
var require_UnknownType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnknownType = undefined;
  var StringType_1 = require_StringType();

  class UnknownType extends StringType_1.StringType {
    getColumnType(prop, platform) {
      return prop.columnTypes?.[0] ?? platform.getVarcharTypeDeclarationSQL(prop);
    }
    compareAsType() {
      return "unknown";
    }
  }
  exports.UnknownType = UnknownType;
});

// node_modules/@mikro-orm/core/types/index.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.t = exports.types = exports.IntervalType = exports.UnknownType = exports.TextType = exports.UuidType = exports.StringType = exports.DecimalType = exports.BooleanType = exports.DoubleType = exports.FloatType = exports.MediumIntType = exports.TinyIntType = exports.SmallIntType = exports.IntegerType = exports.JsonType = exports.EnumType = exports.EnumArrayType = exports.ArrayType = exports.Uint8ArrayType = exports.BlobType = exports.BigIntType = exports.DateTimeType = exports.TimeType = exports.DateType = exports.Type = undefined;
  var Type_1 = require_Type();
  Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
    return Type_1.Type;
  } });
  var DateType_1 = require_DateType();
  Object.defineProperty(exports, "DateType", { enumerable: true, get: function() {
    return DateType_1.DateType;
  } });
  var TimeType_1 = require_TimeType();
  Object.defineProperty(exports, "TimeType", { enumerable: true, get: function() {
    return TimeType_1.TimeType;
  } });
  var DateTimeType_1 = require_DateTimeType();
  Object.defineProperty(exports, "DateTimeType", { enumerable: true, get: function() {
    return DateTimeType_1.DateTimeType;
  } });
  var BigIntType_1 = require_BigIntType();
  Object.defineProperty(exports, "BigIntType", { enumerable: true, get: function() {
    return BigIntType_1.BigIntType;
  } });
  var BlobType_1 = require_BlobType();
  Object.defineProperty(exports, "BlobType", { enumerable: true, get: function() {
    return BlobType_1.BlobType;
  } });
  var Uint8ArrayType_1 = require_Uint8ArrayType();
  Object.defineProperty(exports, "Uint8ArrayType", { enumerable: true, get: function() {
    return Uint8ArrayType_1.Uint8ArrayType;
  } });
  var ArrayType_1 = require_ArrayType();
  Object.defineProperty(exports, "ArrayType", { enumerable: true, get: function() {
    return ArrayType_1.ArrayType;
  } });
  var EnumArrayType_1 = require_EnumArrayType();
  Object.defineProperty(exports, "EnumArrayType", { enumerable: true, get: function() {
    return EnumArrayType_1.EnumArrayType;
  } });
  var EnumType_1 = require_EnumType();
  Object.defineProperty(exports, "EnumType", { enumerable: true, get: function() {
    return EnumType_1.EnumType;
  } });
  var JsonType_1 = require_JsonType();
  Object.defineProperty(exports, "JsonType", { enumerable: true, get: function() {
    return JsonType_1.JsonType;
  } });
  var IntegerType_1 = require_IntegerType();
  Object.defineProperty(exports, "IntegerType", { enumerable: true, get: function() {
    return IntegerType_1.IntegerType;
  } });
  var SmallIntType_1 = require_SmallIntType();
  Object.defineProperty(exports, "SmallIntType", { enumerable: true, get: function() {
    return SmallIntType_1.SmallIntType;
  } });
  var TinyIntType_1 = require_TinyIntType();
  Object.defineProperty(exports, "TinyIntType", { enumerable: true, get: function() {
    return TinyIntType_1.TinyIntType;
  } });
  var MediumIntType_1 = require_MediumIntType();
  Object.defineProperty(exports, "MediumIntType", { enumerable: true, get: function() {
    return MediumIntType_1.MediumIntType;
  } });
  var FloatType_1 = require_FloatType();
  Object.defineProperty(exports, "FloatType", { enumerable: true, get: function() {
    return FloatType_1.FloatType;
  } });
  var DoubleType_1 = require_DoubleType();
  Object.defineProperty(exports, "DoubleType", { enumerable: true, get: function() {
    return DoubleType_1.DoubleType;
  } });
  var BooleanType_1 = require_BooleanType();
  Object.defineProperty(exports, "BooleanType", { enumerable: true, get: function() {
    return BooleanType_1.BooleanType;
  } });
  var DecimalType_1 = require_DecimalType();
  Object.defineProperty(exports, "DecimalType", { enumerable: true, get: function() {
    return DecimalType_1.DecimalType;
  } });
  var StringType_1 = require_StringType();
  Object.defineProperty(exports, "StringType", { enumerable: true, get: function() {
    return StringType_1.StringType;
  } });
  var UuidType_1 = require_UuidType();
  Object.defineProperty(exports, "UuidType", { enumerable: true, get: function() {
    return UuidType_1.UuidType;
  } });
  var TextType_1 = require_TextType();
  Object.defineProperty(exports, "TextType", { enumerable: true, get: function() {
    return TextType_1.TextType;
  } });
  var IntervalType_1 = require_IntervalType();
  Object.defineProperty(exports, "IntervalType", { enumerable: true, get: function() {
    return IntervalType_1.IntervalType;
  } });
  var UnknownType_1 = require_UnknownType();
  Object.defineProperty(exports, "UnknownType", { enumerable: true, get: function() {
    return UnknownType_1.UnknownType;
  } });
  exports.types = {
    date: DateType_1.DateType,
    time: TimeType_1.TimeType,
    datetime: DateTimeType_1.DateTimeType,
    bigint: BigIntType_1.BigIntType,
    blob: BlobType_1.BlobType,
    uint8array: Uint8ArrayType_1.Uint8ArrayType,
    array: ArrayType_1.ArrayType,
    enumArray: EnumArrayType_1.EnumArrayType,
    enum: EnumType_1.EnumType,
    json: JsonType_1.JsonType,
    integer: IntegerType_1.IntegerType,
    smallint: SmallIntType_1.SmallIntType,
    tinyint: TinyIntType_1.TinyIntType,
    mediumint: MediumIntType_1.MediumIntType,
    float: FloatType_1.FloatType,
    double: DoubleType_1.DoubleType,
    boolean: BooleanType_1.BooleanType,
    decimal: DecimalType_1.DecimalType,
    string: StringType_1.StringType,
    uuid: UuidType_1.UuidType,
    text: TextType_1.TextType,
    interval: IntervalType_1.IntervalType,
    unknown: UnknownType_1.UnknownType
  };
  exports.t = exports.types;
});

// node_modules/@mikro-orm/core/metadata/EntitySchema.js
var require_EntitySchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntitySchema = undefined;
  var typings_1 = require_typings();
  var BaseEntity_1 = require_BaseEntity();
  var enums_1 = require_enums();
  var types_1 = require_types();
  var utils_1 = require_utils10();
  var EnumArrayType_1 = require_EnumArrayType();

  class EntitySchema {
    static REGISTRY = new Map;
    _meta = new typings_1.EntityMetadata;
    internal = false;
    initialized = false;
    constructor(meta) {
      meta.name = meta.class ? meta.class.name : meta.name;
      if (meta.name) {
        meta.abstract ??= false;
      }
      if (meta.class && !meta.internal) {
        EntitySchema.REGISTRY.set(meta.class, this);
      }
      if (meta.tableName || meta.collection) {
        utils_1.Utils.renameKey(meta, "tableName", "collection");
        meta.tableName = meta.collection;
      }
      Object.assign(this._meta, { className: meta.name }, meta);
      this._meta.root ??= this._meta;
    }
    static fromMetadata(meta) {
      const schema = new EntitySchema({ ...meta, internal: true });
      schema.internal = true;
      return schema;
    }
    addProperty(name, type73, options = {}) {
      const rename = (data, from, to) => {
        if (from in options && !(to in options)) {
          options[to] = [options[from]];
          delete options[from];
        }
      };
      if (name !== options.name) {
        utils_1.Utils.renameKey(options, "name", "fieldName");
      }
      rename(options, "fieldName", "fieldNames");
      rename(options, "ref", "ref");
      rename(options, "joinColumn", "joinColumns");
      rename(options, "inverseJoinColumn", "inverseJoinColumns");
      rename(options, "referenceColumnName", "referencedColumnNames");
      rename(options, "columnType", "columnTypes");
      const prop = { name, kind: enums_1.ReferenceKind.SCALAR, ...options, type: this.normalizeType(options, type73) };
      if (type73 && types_1.Type.isMappedType(type73.prototype)) {
        prop.type = type73;
      }
      if (utils_1.Utils.isString(prop.formula)) {
        const formula = prop.formula;
        prop.formula = () => formula;
      }
      if (prop.formula) {
        prop.persist ??= false;
      }
      this._meta.properties[name] = prop;
    }
    addEnum(name, type73, options = {}) {
      if (options.items instanceof Function) {
        options.items = utils_1.Utils.extractEnumValues(options.items());
      }
      if (options.array && !options.type) {
        options.type = new EnumArrayType_1.EnumArrayType(`${this._meta.className}.${name}`, options.items);
        options.enum = false;
      }
      const prop = { enum: true, ...options };
      if (prop.array) {
        prop.enum = false;
      }
      if (prop.nativeEnumName && Array.isArray(prop.items)) {
        prop.items = prop.items.map((val) => "" + val);
      }
      this.addProperty(name, this.internal ? type73 : type73 || "enum", prop);
    }
    addVersion(name, type73, options = {}) {
      this.addProperty(name, type73, { version: true, ...options });
    }
    addPrimaryKey(name, type73, options = {}) {
      this.addProperty(name, type73, { primary: true, ...options });
    }
    addSerializedPrimaryKey(name, type73, options = {}) {
      this._meta.serializedPrimaryKey = name;
      this.addProperty(name, type73, options);
    }
    addEmbedded(name, options) {
      utils_1.Utils.defaultValue(options, "prefix", true);
      if (options.array) {
        options.object = true;
      }
      this._meta.properties[name] = {
        name,
        type: this.normalizeType(options),
        kind: enums_1.ReferenceKind.EMBEDDED,
        ...options
      };
    }
    addManyToOne(name, type73, options) {
      const prop = this.createProperty(enums_1.ReferenceKind.MANY_TO_ONE, options);
      prop.owner = true;
      if (prop.joinColumns && !prop.fieldNames) {
        prop.fieldNames = prop.joinColumns;
      }
      if (prop.fieldNames && !prop.joinColumns) {
        prop.joinColumns = prop.fieldNames;
      }
      this.addProperty(name, type73, prop);
    }
    addManyToMany(name, type73, options) {
      options.fixedOrder = options.fixedOrder || !!options.fixedOrderColumn;
      if (!options.owner && !options.mappedBy) {
        options.owner = true;
      }
      if (options.owner) {
        utils_1.Utils.renameKey(options, "mappedBy", "inversedBy");
      }
      const prop = this.createProperty(enums_1.ReferenceKind.MANY_TO_MANY, options);
      this.addProperty(name, type73, prop);
    }
    addOneToMany(name, type73, options) {
      const prop = this.createProperty(enums_1.ReferenceKind.ONE_TO_MANY, options);
      this.addProperty(name, type73, prop);
    }
    addOneToOne(name, type73, options) {
      const prop = this.createProperty(enums_1.ReferenceKind.ONE_TO_ONE, options);
      utils_1.Utils.defaultValue(prop, "owner", !!prop.inversedBy || !prop.mappedBy);
      utils_1.Utils.defaultValue(prop, "unique", prop.owner);
      if (prop.owner && options.mappedBy) {
        utils_1.Utils.renameKey(prop, "mappedBy", "inversedBy");
      }
      if (prop.joinColumns && !prop.fieldNames) {
        prop.fieldNames = prop.joinColumns;
      }
      if (prop.fieldNames && !prop.joinColumns) {
        prop.joinColumns = prop.fieldNames;
      }
      this.addProperty(name, type73, prop);
    }
    addIndex(options) {
      this._meta.indexes.push(options);
    }
    addUnique(options) {
      this._meta.uniques.push(options);
    }
    setCustomRepository(repository) {
      this._meta.repository = repository;
    }
    setExtends(base) {
      this._meta.extends = base;
    }
    setClass(proto) {
      this._meta.class = proto;
      this._meta.prototype = proto.prototype;
      this._meta.className = proto.name;
      const tokens = utils_1.Utils.tokenize(proto);
      this._meta.constructorParams = utils_1.Utils.getParamNames(tokens, "constructor");
      this._meta.toJsonParams = utils_1.Utils.getParamNames(tokens, "toJSON").filter((p2) => p2 !== "...args");
      if (!this.internal) {
        EntitySchema.REGISTRY.set(proto, this);
      }
      if (Object.getPrototypeOf(proto) !== BaseEntity_1.BaseEntity) {
        this._meta.extends = this._meta.extends || Object.getPrototypeOf(proto).name || undefined;
      }
    }
    get meta() {
      return this._meta;
    }
    get name() {
      return this._meta.className;
    }
    init() {
      if (this.initialized) {
        return this;
      }
      if (!this._meta.class) {
        const name = this.name;
        this._meta.class = { [name]: class {
        } }[name];
      }
      this.setClass(this._meta.class);
      if (this._meta.abstract && !this._meta.discriminatorColumn) {
        delete this._meta.name;
      }
      const tableName = this._meta.collection ?? this._meta.tableName;
      if (tableName?.includes(".") && !this._meta.schema) {
        this._meta.schema = tableName.substring(0, tableName.indexOf("."));
        this._meta.collection = tableName.substring(tableName.indexOf(".") + 1);
      }
      this.initProperties();
      this.initPrimaryKeys();
      this._meta.props = Object.values(this._meta.properties);
      this._meta.relations = this._meta.props.filter((prop) => prop.kind !== enums_1.ReferenceKind.SCALAR && prop.kind !== enums_1.ReferenceKind.EMBEDDED);
      this.initialized = true;
      return this;
    }
    initProperties() {
      utils_1.Utils.entries(this._meta.properties).forEach(([name, options]) => {
        if (types_1.Type.isMappedType(options.type)) {
          options.type ??= options.type.constructor.name;
        }
        switch (options.kind) {
          case enums_1.ReferenceKind.ONE_TO_ONE:
            this.addOneToOne(name, options.type, options);
            break;
          case enums_1.ReferenceKind.ONE_TO_MANY:
            this.addOneToMany(name, options.type, options);
            break;
          case enums_1.ReferenceKind.MANY_TO_ONE:
            this.addManyToOne(name, options.type, options);
            break;
          case enums_1.ReferenceKind.MANY_TO_MANY:
            this.addManyToMany(name, options.type, options);
            break;
          case enums_1.ReferenceKind.EMBEDDED:
            this.addEmbedded(name, options);
            break;
          default:
            if (options.enum) {
              this.addEnum(name, options.type, options);
            } else if (options.primary) {
              this.addPrimaryKey(name, options.type, options);
            } else if (options.serializedPrimaryKey) {
              this.addSerializedPrimaryKey(name, options.type, options);
            } else if (options.version) {
              this.addVersion(name, options.type, options);
            } else {
              this.addProperty(name, options.type, options);
            }
        }
      });
    }
    initPrimaryKeys() {
      const pks = Object.values(this._meta.properties).filter((prop) => prop.primary);
      if (pks.length > 0) {
        this._meta.primaryKeys = pks.map((prop) => prop.name);
        this._meta.compositePK = pks.length > 1;
        this._meta.simplePK = !this._meta.compositePK && pks[0].kind === enums_1.ReferenceKind.SCALAR && !pks[0].customType;
      }
      if (pks.length === 1 && ["number", "bigint"].includes(pks[0].type)) {
        pks[0].autoincrement ??= true;
      }
      const serializedPrimaryKey = Object.values(this._meta.properties).find((prop) => prop.serializedPrimaryKey);
      if (serializedPrimaryKey) {
        this._meta.serializedPrimaryKey = serializedPrimaryKey.name;
      }
    }
    normalizeType(options, type73) {
      if ("entity" in options) {
        if (utils_1.Utils.isString(options.entity)) {
          type73 = options.type = options.entity;
        } else if (options.entity) {
          const tmp = options.entity();
          type73 = options.type = Array.isArray(tmp) ? tmp.map((t2) => utils_1.Utils.className(t2)).sort().join(" | ") : utils_1.Utils.className(tmp);
        }
      }
      if (type73 instanceof Function) {
        type73 = type73.name;
      }
      if (["String", "Number", "Boolean", "Array"].includes(type73)) {
        type73 = type73.toLowerCase();
      }
      return type73;
    }
    createProperty(kind, options) {
      return {
        kind,
        cascade: [enums_1.Cascade.PERSIST],
        ...options
      };
    }
  }
  exports.EntitySchema = EntitySchema;
});

// node_modules/@mikro-orm/core/metadata/MetadataValidator.js
var require_MetadataValidator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetadataValidator = undefined;
  var utils_1 = require_utils10();
  var errors_1 = require_errors3();
  var enums_1 = require_enums();

  class MetadataValidator {
    static validateSingleDecorator(meta, propertyName, reference) {
      if (meta.properties[propertyName] && meta.properties[propertyName].kind !== reference) {
        throw errors_1.MetadataError.multipleDecorators(meta.className, propertyName);
      }
    }
    validateEntityDefinition(metadata, name, options) {
      const meta = metadata.get(name);
      if (meta.virtual || meta.expression) {
        for (const prop of utils_1.Utils.values(meta.properties)) {
          if (![enums_1.ReferenceKind.SCALAR, enums_1.ReferenceKind.EMBEDDED, enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind)) {
            throw new errors_1.MetadataError(`Only scalars, embedded properties and to-many relations are allowed inside virtual entity. Found '${prop.kind}' in ${meta.className}.${prop.name}`);
          }
          if (prop.primary) {
            throw new errors_1.MetadataError(`Virtual entity ${meta.className} cannot have primary key ${meta.className}.${prop.name}`);
          }
        }
        return;
      }
      if (!meta.embeddable && (!meta.primaryKeys || meta.primaryKeys.length === 0)) {
        throw errors_1.MetadataError.fromMissingPrimaryKey(meta);
      }
      this.validateVersionField(meta);
      this.validateDuplicateFieldNames(meta, options);
      this.validateIndexes(meta, meta.indexes ?? [], "index");
      this.validateIndexes(meta, meta.uniques ?? [], "unique");
      for (const prop of utils_1.Utils.values(meta.properties)) {
        if (prop.kind !== enums_1.ReferenceKind.SCALAR) {
          this.validateReference(meta, prop, metadata);
          this.validateBidirectional(meta, prop, metadata);
        } else if (metadata.has(prop.type)) {
          throw errors_1.MetadataError.propertyTargetsEntityType(meta, prop, metadata.get(prop.type));
        }
      }
    }
    validateDiscovered(discovered, options) {
      if (discovered.length === 0 && options.warnWhenNoEntities) {
        throw errors_1.MetadataError.noEntityDiscovered();
      }
      const duplicates = utils_1.Utils.findDuplicates(discovered.map((meta) => meta.className));
      if (duplicates.length > 0 && options.checkDuplicateEntities) {
        throw errors_1.MetadataError.duplicateEntityDiscovered(duplicates);
      }
      const tableNames = discovered.filter((meta) => !meta.abstract && meta === meta.root && (meta.tableName || meta.collection) && meta.schema !== "*");
      const duplicateTableNames = utils_1.Utils.findDuplicates(tableNames.map((meta) => {
        const tableName = meta.tableName || meta.collection;
        return (meta.schema ? "." + meta.schema : "") + tableName;
      }));
      if (duplicateTableNames.length > 0 && options.checkDuplicateTableNames && options.checkDuplicateEntities) {
        throw errors_1.MetadataError.duplicateEntityDiscovered(duplicateTableNames, "table names");
      }
      if (discovered.filter((meta) => meta.name).length === 0 && options.warnWhenNoEntities) {
        throw errors_1.MetadataError.onlyAbstractEntitiesDiscovered();
      }
      const unwrap = (type73) => type73.replace(/Array<(.*)>/, "$1").replace(/\[]$/, "").replace(/\((.*)\)/, "$1");
      const name = (p2) => {
        if (typeof p2 === "function") {
          return utils_1.Utils.className(p2());
        }
        return utils_1.Utils.className(p2);
      };
      const pivotProps = new Map;
      discovered.forEach((meta) => Object.values(meta.properties).forEach((prop) => {
        if (prop.kind !== enums_1.ReferenceKind.SCALAR && !unwrap(prop.type).split(/ ?\| ?/).every((type73) => discovered.find((m2) => m2.className === type73))) {
          throw errors_1.MetadataError.fromUnknownEntity(prop.type, `${meta.className}.${prop.name}`);
        }
        if (prop.pivotEntity) {
          const props = pivotProps.get(name(prop.pivotEntity)) ?? [];
          props.push({ meta, prop });
          pivotProps.set(name(prop.pivotEntity), props);
        }
      }));
      pivotProps.forEach((props) => {
        if (props.length > 1 && props.every((p2) => !p2.prop.mappedBy && !p2.prop.inversedBy)) {
          throw errors_1.MetadataError.invalidManyToManyWithPivotEntity(props[0].meta, props[0].prop, props[1].meta, props[1].prop);
        }
      });
    }
    validateReference(meta, prop, metadata) {
      if (!prop.type) {
        throw errors_1.MetadataError.fromWrongTypeDefinition(meta, prop);
      }
      if (!metadata.find(prop.type)) {
        throw errors_1.MetadataError.fromWrongTypeDefinition(meta, prop);
      }
      if (metadata.find(prop.type).abstract && !metadata.find(prop.type).discriminatorColumn) {
        throw errors_1.MetadataError.targetIsAbstract(meta, prop);
      }
    }
    validateBidirectional(meta, prop, metadata) {
      if (prop.inversedBy) {
        const inverse = metadata.get(prop.type).properties[prop.inversedBy];
        this.validateOwningSide(meta, prop, inverse, metadata);
      } else if (prop.mappedBy) {
        const inverse = metadata.get(prop.type).properties[prop.mappedBy];
        this.validateInverseSide(meta, prop, inverse, metadata);
      } else {
        if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY && !prop.mappedBy) {
          throw errors_1.MetadataError.fromMissingOption(meta, prop, "mappedBy");
        }
      }
    }
    validateOwningSide(meta, prop, inverse, metadata) {
      if (!inverse) {
        throw errors_1.MetadataError.fromWrongReference(meta, prop, "inversedBy");
      }
      const targetClassName = metadata.find(inverse.type)?.root.className;
      if (inverse.type !== meta.className && targetClassName !== meta.root.className) {
        throw errors_1.MetadataError.fromWrongReference(meta, prop, "inversedBy", inverse);
      }
      if (inverse.inversedBy || inverse.owner) {
        throw errors_1.MetadataError.fromWrongOwnership(meta, prop, "inversedBy");
      }
    }
    validateInverseSide(meta, prop, owner, metadata) {
      if (prop.mappedBy && !owner) {
        throw errors_1.MetadataError.fromWrongReference(meta, prop, "mappedBy");
      }
      if (owner.type !== meta.className && metadata.find(owner.type)?.root.className !== meta.root.className) {
        throw errors_1.MetadataError.fromWrongReference(meta, prop, "mappedBy", owner);
      }
      if (owner.mappedBy) {
        throw errors_1.MetadataError.fromWrongOwnership(meta, prop, "mappedBy");
      }
      const valid = [
        { owner: enums_1.ReferenceKind.MANY_TO_ONE, inverse: enums_1.ReferenceKind.ONE_TO_MANY },
        { owner: enums_1.ReferenceKind.MANY_TO_MANY, inverse: enums_1.ReferenceKind.MANY_TO_MANY },
        { owner: enums_1.ReferenceKind.ONE_TO_ONE, inverse: enums_1.ReferenceKind.ONE_TO_ONE }
      ];
      if (!valid.find((spec) => spec.owner === owner.kind && spec.inverse === prop.kind)) {
        throw errors_1.MetadataError.fromWrongReferenceKind(meta, owner, prop);
      }
      if (prop.primary) {
        throw errors_1.MetadataError.fromInversideSidePrimary(meta, owner, prop);
      }
    }
    validateIndexes(meta, indexes, type73) {
      for (const index of indexes) {
        for (const propName of utils_1.Utils.asArray(index.properties)) {
          const prop = meta.root.properties[propName];
          if (!prop && !Object.values(meta.root.properties).some((p2) => propName.startsWith(p2.name + "."))) {
            throw errors_1.MetadataError.unknownIndexProperty(meta, propName, type73);
          }
        }
      }
    }
    validateDuplicateFieldNames(meta, options) {
      const candidates = Object.values(meta.properties).filter((prop) => prop.persist !== false && !prop.inherited && prop.fieldNames?.length === 1 && (prop.kind !== enums_1.ReferenceKind.EMBEDDED || prop.object)).map((prop) => prop.fieldNames[0]);
      const duplicates = utils_1.Utils.findDuplicates(candidates);
      if (duplicates.length > 0 && options.checkDuplicateFieldNames) {
        const pairs = duplicates.flatMap((name) => {
          return Object.values(meta.properties).filter((p2) => p2.fieldNames?.[0] === name).map((prop) => {
            return [prop.embedded ? prop.embedded.join(".") : prop.name, prop.fieldNames[0]];
          });
        });
        throw errors_1.MetadataError.duplicateFieldName(meta.className, pairs);
      }
    }
    validateVersionField(meta) {
      if (!meta.versionProperty) {
        return;
      }
      const props = Object.values(meta.properties).filter((p2) => p2.version);
      if (props.length > 1) {
        throw errors_1.MetadataError.multipleVersionFields(meta, props.map((p2) => p2.name));
      }
      const prop = meta.properties[meta.versionProperty];
      const type73 = prop.runtimeType ?? prop.columnTypes?.[0] ?? prop.type;
      if (type73 !== "number" && type73 !== "Date" && !type73.startsWith("timestamp") && !type73.startsWith("datetime")) {
        throw errors_1.MetadataError.invalidVersionFieldType(meta);
      }
    }
  }
  exports.MetadataValidator = MetadataValidator;
});

// node_modules/@mikro-orm/core/metadata/MetadataStorage.js
var require_MetadataStorage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetadataStorage = undefined;
  var typings_1 = require_typings();
  var Utils_1 = require_Utils();
  var errors_1 = require_errors3();
  var EntityHelper_1 = require_EntityHelper();

  class MetadataStorage {
    static metadata = Utils_1.Utils.getGlobalStorage("metadata");
    metadata;
    constructor(metadata = {}) {
      this.metadata = Utils_1.Utils.copy(metadata, false);
    }
    static getMetadata(entity, path) {
      const key = entity && path ? entity + "-" + Utils_1.Utils.hash(path) : null;
      if (key && !MetadataStorage.metadata[key]) {
        MetadataStorage.metadata[key] = new typings_1.EntityMetadata({ className: entity, path });
      }
      if (key) {
        return MetadataStorage.metadata[key];
      }
      return MetadataStorage.metadata;
    }
    static isKnownEntity(name) {
      return !!Object.values(this.metadata).find((meta) => meta.className === name);
    }
    static getMetadataFromDecorator(target) {
      const path = Utils_1.Utils.lookupPathFromDecorator(target.name);
      const meta = MetadataStorage.getMetadata(target.name, path);
      Object.defineProperty(target, "__path", { value: path, writable: true });
      return meta;
    }
    static init() {
      return new MetadataStorage(MetadataStorage.metadata);
    }
    static clear() {
      Object.keys(this.metadata).forEach((k) => delete this.metadata[k]);
    }
    getAll() {
      return this.metadata;
    }
    getByDiscriminatorColumn(meta, data) {
      const value14 = data[meta.root.discriminatorColumn];
      if (!value14) {
        return;
      }
      const type73 = meta.root.discriminatorMap[value14];
      return this.metadata[type73];
    }
    get(entityName, init = false, validate = true) {
      entityName = Utils_1.Utils.className(entityName);
      if (validate && !init && !this.has(entityName)) {
        throw errors_1.MetadataError.missingMetadata(entityName);
      }
      if (init && !this.has(entityName)) {
        this.metadata[entityName] = new typings_1.EntityMetadata;
      }
      return this.metadata[entityName];
    }
    find(entityName) {
      if (!entityName) {
        return;
      }
      entityName = Utils_1.Utils.className(entityName);
      return this.metadata[entityName];
    }
    has(entity) {
      return entity in this.metadata;
    }
    set(entity, meta) {
      return this.metadata[entity] = meta;
    }
    reset(entity) {
      delete this.metadata[entity];
    }
    decorate(em) {
      Object.values(this.metadata).filter((meta) => meta.prototype).forEach((meta) => EntityHelper_1.EntityHelper.decorate(meta, em));
    }
    *[Symbol.iterator]() {
      for (const meta of Object.values(this.metadata)) {
        yield meta;
      }
    }
  }
  exports.MetadataStorage = MetadataStorage;
});

// node_modules/@mikro-orm/core/metadata/MetadataDiscovery.js
var require_MetadataDiscovery = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetadataDiscovery = undefined;
  var path_1 = import.meta.require("path");
  var globby_1 = __importDefault(require_globby());
  var typings_1 = require_typings();
  var Utils_1 = require_Utils();
  var MetadataValidator_1 = require_MetadataValidator();
  var MetadataStorage_1 = require_MetadataStorage();
  var EntitySchema_1 = require_EntitySchema();
  var enums_1 = require_enums();
  var errors_1 = require_errors3();
  var types_1 = require_types();
  var colors_1 = require_colors();
  var RawQueryFragment_1 = require_RawQueryFragment();

  class MetadataDiscovery {
    metadata;
    platform;
    config;
    namingStrategy;
    metadataProvider;
    cache;
    logger;
    schemaHelper;
    validator = new MetadataValidator_1.MetadataValidator;
    discovered = [];
    constructor(metadata, platform, config) {
      this.metadata = metadata;
      this.platform = platform;
      this.config = config;
      this.namingStrategy = this.config.getNamingStrategy();
      this.metadataProvider = this.config.getMetadataProvider();
      this.cache = this.config.getMetadataCacheAdapter();
      this.logger = this.config.getLogger();
      this.schemaHelper = this.platform.getSchemaHelper();
    }
    async discover(preferTsNode = true) {
      const startTime = Date.now();
      this.logger.log("discovery", `ORM entity discovery started, using ${colors_1.colors.cyan(this.metadataProvider.constructor.name)}`);
      await this.findEntities(preferTsNode);
      for (const meta of this.discovered) {
        await this.config.get("discovery").onMetadata?.(meta, this.platform);
      }
      this.processDiscoveredEntities(this.discovered);
      const diff = Date.now() - startTime;
      this.logger.log("discovery", `- entity discovery finished, found ${colors_1.colors.green("" + this.discovered.length)} entities, took ${colors_1.colors.green(`${diff} ms`)}`);
      const storage = this.mapDiscoveredEntities();
      await this.config.get("discovery").afterDiscovered?.(storage, this.platform);
      return storage;
    }
    discoverSync(preferTsNode = true) {
      const startTime = Date.now();
      this.logger.log("discovery", `ORM entity discovery started, using ${colors_1.colors.cyan(this.metadataProvider.constructor.name)} in sync mode`);
      this.findEntities(preferTsNode, true);
      for (const meta of this.discovered) {
        this.config.get("discovery").onMetadata?.(meta, this.platform);
      }
      this.processDiscoveredEntities(this.discovered);
      const diff = Date.now() - startTime;
      this.logger.log("discovery", `- entity discovery finished, found ${colors_1.colors.green("" + this.discovered.length)} entities, took ${colors_1.colors.green(`${diff} ms`)}`);
      const storage = this.mapDiscoveredEntities();
      this.config.get("discovery").afterDiscovered?.(storage, this.platform);
      return storage;
    }
    mapDiscoveredEntities() {
      const discovered = new MetadataStorage_1.MetadataStorage;
      this.discovered.filter((meta) => meta.name).sort((a2, b2) => b2.name.localeCompare(a2.name)).forEach((meta) => {
        this.platform.validateMetadata(meta);
        discovered.set(meta.name, meta);
      });
      return discovered;
    }
    processDiscoveredEntities(discovered) {
      for (const meta of discovered) {
        let i2 = 1;
        Object.values(meta.properties).forEach((prop) => meta.propertyOrder.set(prop.name, i2++));
        Object.values(meta.properties).forEach((prop) => this.initPolyEmbeddables(prop, discovered));
      }
      const filtered = discovered.filter((meta) => meta.name);
      filtered.sort((a2, b2) => !a2.embeddable === !b2.embeddable ? 0 : a2.embeddable ? 1 : -1);
      filtered.forEach((meta) => this.initSingleTableInheritance(meta, filtered));
      filtered.forEach((meta) => this.defineBaseEntityProperties(meta));
      filtered.forEach((meta) => this.metadata.set(meta.className, EntitySchema_1.EntitySchema.fromMetadata(meta).init().meta));
      filtered.forEach((meta) => this.initAutoincrement(meta));
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initEmbeddables(meta, prop)));
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initFactoryField(meta, prop)));
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initFieldName(prop)));
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initVersionProperty(meta, prop)));
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initCustomType(meta, prop)));
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initGeneratedColumn(meta, prop)));
      filtered.forEach((meta) => this.initAutoincrement(meta));
      filtered.forEach((meta) => this.initCheckConstraints(meta));
      for (const meta of filtered) {
        for (const prop of Object.values(meta.properties)) {
          this.initDefaultValue(prop);
          this.inferTypeFromDefault(prop);
          this.initColumnType(prop);
        }
      }
      filtered.forEach((meta) => Object.values(meta.properties).forEach((prop) => this.initIndexes(prop)));
      filtered.forEach((meta) => this.autoWireBidirectionalProperties(meta));
      filtered.forEach((meta) => this.findReferencingProperties(meta, filtered));
      for (const meta of filtered) {
        discovered.push(...this.processEntity(meta));
      }
      discovered.forEach((meta) => meta.sync(true));
      const combinedCachePath = this.cache.combine?.();
      if (combinedCachePath) {
        this.config.get("metadataCache").combined = combinedCachePath;
      }
      return discovered.map((meta) => this.metadata.get(meta.className));
    }
    findEntities(preferTsNode, sync = false) {
      this.discovered.length = 0;
      const options = this.config.get("discovery");
      const key = preferTsNode && this.config.get("tsNode", Utils_1.Utils.detectTsNode()) && this.config.get("entitiesTs").length > 0 ? "entitiesTs" : "entities";
      const paths = this.config.get(key).filter((item) => Utils_1.Utils.isString(item));
      const refs = this.config.get(key).filter((item) => !Utils_1.Utils.isString(item));
      if (paths.length > 0) {
        if (sync || options.requireEntitiesArray) {
          throw new Error(`[requireEntitiesArray] Explicit list of entities is required, please use the 'entities' option.`);
        }
        return this.discoverDirectories(paths).then(() => {
          this.discoverReferences(refs);
          this.discoverMissingTargets();
          this.validator.validateDiscovered(this.discovered, options);
          return this.discovered;
        });
      }
      this.discoverReferences(refs);
      this.discoverMissingTargets();
      this.validator.validateDiscovered(this.discovered, options);
      return this.discovered;
    }
    discoverMissingTargets() {
      const unwrap = (type73) => type73.replace(/Array<(.*)>/, "$1").replace(/\[]$/, "").replace(/\((.*)\)/, "$1");
      const missing = [];
      this.discovered.forEach((meta) => Object.values(meta.properties).forEach((prop) => {
        if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && prop.pivotEntity && !this.discovered.find((m2) => m2.className === Utils_1.Utils.className(prop.pivotEntity))) {
          const target = typeof prop.pivotEntity === "function" ? prop.pivotEntity() : prop.pivotEntity;
          missing.push(target);
        }
        if (prop.kind !== enums_1.ReferenceKind.SCALAR && !unwrap(prop.type).split(/ ?\| ?/).every((type73) => this.discovered.find((m2) => m2.className === type73))) {
          const target = typeof prop.entity === "function" ? prop.entity() : prop.type;
          missing.push(...Utils_1.Utils.asArray(target));
        }
      }));
      if (missing.length > 0) {
        this.tryDiscoverTargets(missing);
      }
    }
    tryDiscoverTargets(targets) {
      for (const target of targets) {
        if (typeof target === "function" && target.name && !this.metadata.has(target.name)) {
          this.discoverReferences([target]);
          this.discoverMissingTargets();
        }
      }
    }
    async discoverDirectories(paths) {
      paths = paths.map((path) => Utils_1.Utils.normalizePath(path));
      const files = await (0, globby_1.default)(paths, { cwd: Utils_1.Utils.normalizePath(this.config.get("baseDir")) });
      this.logger.log("discovery", `- processing ${colors_1.colors.cyan("" + files.length)} files`);
      const found = [];
      for (const filepath of files) {
        const filename = (0, path_1.basename)(filepath);
        if (!filename.match(/\.[cm]?[jt]s$/) || filename.endsWith(".js.map") || filename.match(/\.d\.[cm]?ts/) || filename.startsWith(".") || filename.match(/index\.[cm]?[jt]s$/)) {
          this.logger.log("discovery", `- ignoring file ${filename}`);
          continue;
        }
        const name = this.namingStrategy.getClassName(filename);
        const path = Utils_1.Utils.normalizePath(this.config.get("baseDir"), filepath);
        const targets = await this.getEntityClassOrSchema(path, name);
        for (const target of targets) {
          if (!(target instanceof Function) && !(target instanceof EntitySchema_1.EntitySchema)) {
            this.logger.log("discovery", `- ignoring file ${filename}`);
            continue;
          }
          this.metadata.set(name, Utils_1.Utils.copy(MetadataStorage_1.MetadataStorage.getMetadata(name, path), false));
          const entity = this.prepare(target);
          const schema = this.getSchema(entity);
          const meta = schema.init().meta;
          this.metadata.set(meta.className, meta);
          found.push([entity, path]);
        }
      }
      for (const [entity, path] of found) {
        this.discoverEntity(entity, path);
      }
    }
    discoverReferences(refs) {
      const found = [];
      for (const entity of refs) {
        const schema = this.getSchema(this.prepare(entity));
        const meta = schema.init().meta;
        this.metadata.set(meta.className, meta);
        found.push(entity);
      }
      for (const entity of found) {
        this.discoverEntity(entity);
      }
      for (const meta of Object.values(this.metadata.getAll())) {
        let parent = meta.extends;
        if (parent instanceof EntitySchema_1.EntitySchema && !this.metadata.has(parent.meta.className)) {
          this.discoverReferences([parent]);
        }
        if (!meta.class) {
          continue;
        }
        parent = Object.getPrototypeOf(meta.class);
        if (parent.name !== "" && !this.metadata.has(parent.name)) {
          this.discoverReferences([parent]);
        }
      }
      return this.discovered.filter((meta) => found.find((m2) => m2.name === meta.className));
    }
    prepare(entity) {
      if ("schema" in entity && entity.schema instanceof EntitySchema_1.EntitySchema) {
        return entity.schema;
      }
      return entity;
    }
    getSchema(entity) {
      if (entity instanceof EntitySchema_1.EntitySchema) {
        return entity;
      }
      if (EntitySchema_1.EntitySchema.REGISTRY.has(entity)) {
        return EntitySchema_1.EntitySchema.REGISTRY.get(entity);
      }
      const path = entity.__path;
      if (path) {
        const meta2 = Utils_1.Utils.copy(MetadataStorage_1.MetadataStorage.getMetadata(entity.name, path), false);
        meta2.path = Utils_1.Utils.relativePath(path, this.config.get("baseDir"));
        this.metadata.set(entity.name, meta2);
      }
      const exists = this.metadata.has(entity.name);
      const meta = this.metadata.get(entity.name, true);
      meta.abstract ??= !(exists && meta.name);
      const schema = EntitySchema_1.EntitySchema.fromMetadata(meta);
      schema.setClass(entity);
      schema.meta.useCache = this.metadataProvider.useCache();
      return schema;
    }
    discoverEntity(entity, path) {
      entity = this.prepare(entity);
      this.logger.log("discovery", `- processing entity ${colors_1.colors.cyan(entity.name)}${colors_1.colors.grey(path ? ` (${path})` : "")}`);
      const schema = this.getSchema(entity);
      const meta = schema.init().meta;
      const root = Utils_1.Utils.getRootEntity(this.metadata, meta);
      this.metadata.set(meta.className, meta);
      schema.meta.path = Utils_1.Utils.relativePath(path || meta.path, this.config.get("baseDir"));
      const cache = meta.useCache && meta.path && this.cache.get(meta.className + (0, path_1.extname)(meta.path));
      if (cache) {
        this.logger.log("discovery", `- using cached metadata for entity ${colors_1.colors.cyan(meta.className)}`);
        this.metadataProvider.loadFromCache(meta, cache);
        meta.root = root;
        this.discovered.push(meta);
        return;
      }
      Utils_1.Utils.values(meta.properties).forEach((prop) => this.inferDefaultValue(meta, prop));
      this.metadataProvider.loadEntityMetadata(meta, meta.className);
      if (!meta.collection && meta.name) {
        const entityName = root.discriminatorColumn ? root.name : meta.name;
        meta.collection = this.namingStrategy.classToTableName(entityName);
      }
      delete meta.root;
      this.saveToCache(meta);
      meta.root = root;
      this.discovered.push(meta);
    }
    saveToCache(meta) {
      if (!meta.useCache) {
        return;
      }
      const copy = Utils_1.Utils.copy(meta, false);
      copy.props.filter((prop) => types_1.Type.isMappedType(prop.type)).forEach((prop) => {
        ["type", "customType"].filter((k) => types_1.Type.isMappedType(prop[k])).forEach((k) => delete prop[k]);
      });
      copy.props.filter((prop) => prop.default).forEach((prop) => {
        const raw = RawQueryFragment_1.RawQueryFragment.getKnownFragment(prop.default);
        if (raw) {
          prop.defaultRaw ??= this.platform.formatQuery(raw.sql, raw.params);
          delete prop.default;
        }
      });
      [
        "prototype",
        "props",
        "referencingProperties",
        "propertyOrder",
        "relations",
        "concurrencyCheckKeys",
        "checks"
      ].forEach((key) => delete copy[key]);
      if (meta.path) {
        this.cache.set(meta.className + (0, path_1.extname)(meta.path), copy, meta.path);
      }
    }
    initNullability(prop) {
      if (prop.kind === enums_1.ReferenceKind.MANY_TO_ONE) {
        return Utils_1.Utils.defaultValue(prop, "nullable", prop.optional || prop.cascade.includes(enums_1.Cascade.REMOVE) || prop.cascade.includes(enums_1.Cascade.ALL));
      }
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_ONE) {
        return Utils_1.Utils.defaultValue(prop, "nullable", prop.optional || !prop.owner || prop.cascade.includes(enums_1.Cascade.REMOVE) || prop.cascade.includes(enums_1.Cascade.ALL));
      }
      return Utils_1.Utils.defaultValue(prop, "nullable", prop.optional);
    }
    applyNamingStrategy(meta, prop) {
      if (!prop.fieldNames) {
        this.initFieldName(prop);
      }
      if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY) {
        this.initManyToManyFields(meta, prop);
      }
      if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind)) {
        this.initManyToOneFields(prop);
      }
      if (prop.kind === enums_1.ReferenceKind.ONE_TO_MANY) {
        this.initOneToManyFields(prop);
      }
    }
    initFieldName(prop, object12 = false) {
      if (prop.fieldNames && prop.fieldNames.length > 0) {
        return;
      }
      if (prop.kind === enums_1.ReferenceKind.SCALAR || prop.kind === enums_1.ReferenceKind.EMBEDDED) {
        prop.fieldNames = [this.namingStrategy.propertyToColumnName(prop.name, object12)];
      } else if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind)) {
        prop.fieldNames = this.initManyToOneFieldName(prop, prop.name);
      } else if (prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && prop.owner) {
        prop.fieldNames = this.initManyToManyFieldName(prop, prop.name);
      }
    }
    initManyToOneFieldName(prop, name) {
      const meta2 = this.metadata.get(prop.type);
      const ret = [];
      for (const primaryKey of meta2.primaryKeys) {
        this.initFieldName(meta2.properties[primaryKey]);
        for (const fieldName of meta2.properties[primaryKey].fieldNames) {
          ret.push(this.namingStrategy.joinKeyColumnName(name, fieldName, meta2.compositePK));
        }
      }
      return ret;
    }
    initManyToManyFieldName(prop, name) {
      const meta2 = this.metadata.get(prop.type);
      return meta2.primaryKeys.map(() => this.namingStrategy.propertyToColumnName(name));
    }
    initManyToManyFields(meta, prop) {
      const meta2 = this.metadata.get(prop.type);
      Utils_1.Utils.defaultValue(prop, "fixedOrder", !!prop.fixedOrderColumn);
      const pivotMeta = this.metadata.find(prop.pivotEntity);
      const props = Object.values(pivotMeta?.properties ?? {});
      const pks = props.filter((p2) => p2.primary);
      const fks = props.filter((p2) => p2.kind === enums_1.ReferenceKind.MANY_TO_ONE);
      if (pivotMeta) {
        pivotMeta.pivotTable = true;
        prop.pivotTable = pivotMeta.tableName;
        if (pks.length === 1) {
          prop.fixedOrder = true;
          prop.fixedOrderColumn = pks[0].name;
        }
      }
      if (pivotMeta && (pks.length === 2 || fks.length >= 2)) {
        const owner = prop.mappedBy ? meta2.properties[prop.mappedBy] : prop;
        const [first, second] = this.ensureCorrectFKOrderInPivotEntity(pivotMeta, owner);
        prop.joinColumns = first.fieldNames;
        prop.inverseJoinColumns = second.fieldNames;
      }
      if (!prop.pivotTable && prop.owner && this.platform.usesPivotTable()) {
        prop.pivotTable = this.namingStrategy.joinTableName(meta.tableName, meta2.tableName, prop.name);
      }
      if (prop.mappedBy) {
        const prop2 = meta2.properties[prop.mappedBy];
        this.initManyToManyFields(meta2, prop2);
        prop.pivotTable = prop2.pivotTable;
        prop.pivotEntity = prop2.pivotEntity ?? prop2.pivotTable;
        prop.fixedOrder = prop2.fixedOrder;
        prop.fixedOrderColumn = prop2.fixedOrderColumn;
        prop.joinColumns = prop2.inverseJoinColumns;
        prop.inverseJoinColumns = prop2.joinColumns;
      }
      if (!prop.referencedColumnNames) {
        prop.referencedColumnNames = Utils_1.Utils.flatten(meta.primaryKeys.map((primaryKey) => meta.properties[primaryKey].fieldNames));
      }
      if (!prop.joinColumns) {
        prop.joinColumns = prop.referencedColumnNames.map((referencedColumnName) => this.namingStrategy.joinKeyColumnName(meta.className, referencedColumnName, meta.compositePK));
      }
      if (!prop.inverseJoinColumns) {
        const meta22 = this.metadata.get(prop.type);
        prop.inverseJoinColumns = this.initManyToOneFieldName(prop, meta22.className);
      }
    }
    initManyToOneFields(prop) {
      const meta2 = this.metadata.get(prop.type);
      const fieldNames = Utils_1.Utils.flatten(meta2.primaryKeys.map((primaryKey) => meta2.properties[primaryKey].fieldNames));
      Utils_1.Utils.defaultValue(prop, "referencedTableName", meta2.collection);
      if (!prop.joinColumns) {
        prop.joinColumns = fieldNames.map((fieldName) => this.namingStrategy.joinKeyColumnName(prop.name, fieldName, fieldNames.length > 1));
      }
      if (!prop.referencedColumnNames) {
        prop.referencedColumnNames = fieldNames;
      }
    }
    initOneToManyFields(prop) {
      const meta2 = this.metadata.get(prop.type);
      if (!prop.joinColumns) {
        prop.joinColumns = [this.namingStrategy.joinColumnName(prop.name)];
      }
      if (!prop.referencedColumnNames) {
        meta2.getPrimaryProps().forEach((pk) => this.applyNamingStrategy(meta2, pk));
        prop.referencedColumnNames = Utils_1.Utils.flatten(meta2.getPrimaryProps().map((pk) => pk.fieldNames));
      }
    }
    processEntity(meta) {
      const pks = Object.values(meta.properties).filter((prop) => prop.primary);
      meta.primaryKeys = pks.map((prop) => prop.name);
      meta.compositePK = pks.length > 1;
      if (pks.length === 1 && pks[0].kind !== enums_1.ReferenceKind.SCALAR) {
        pks[0].deleteRule ??= "cascade";
      }
      meta.forceConstructor = this.shouldForceConstructorUsage(meta);
      this.validator.validateEntityDefinition(this.metadata, meta.name, this.config.get("discovery"));
      for (const prop of Object.values(meta.properties)) {
        this.initNullability(prop);
        this.applyNamingStrategy(meta, prop);
        this.initDefaultValue(prop);
        this.inferTypeFromDefault(prop);
        this.initVersionProperty(meta, prop);
        this.initCustomType(meta, prop);
        this.initColumnType(prop);
        this.initRelation(prop);
      }
      meta.simplePK = pks.length === 1 && pks[0].kind === enums_1.ReferenceKind.SCALAR && !pks[0].customType;
      meta.serializedPrimaryKey = this.platform.getSerializedPrimaryKeyField(meta.primaryKeys[0]);
      const serializedPKProp = meta.properties[meta.serializedPrimaryKey];
      if (serializedPKProp && meta.serializedPrimaryKey !== meta.primaryKeys[0]) {
        serializedPKProp.persist = false;
      }
      if (this.platform.usesPivotTable()) {
        return Object.values(meta.properties).filter((prop) => prop.kind === enums_1.ReferenceKind.MANY_TO_MANY && prop.owner && prop.pivotTable).map((prop) => this.definePivotTableEntity(meta, prop));
      }
      return [];
    }
    findReferencingProperties(meta, metadata) {
      for (const meta2 of metadata) {
        const prop2 = meta2.relations.find((prop22) => {
          return prop22.kind !== enums_1.ReferenceKind.SCALAR && prop22.type === meta.className;
        });
        if (prop2) {
          meta.referencingProperties.push({ meta: meta2, prop: prop2 });
        }
      }
    }
    initFactoryField(meta, prop) {
      ["mappedBy", "inversedBy", "pivotEntity"].forEach((type73) => {
        const value14 = prop[type73];
        if (value14 instanceof Function) {
          const meta2 = this.metadata.get(prop.type);
          prop[type73] = value14(meta2.properties)?.name;
          if (prop[type73] == null) {
            throw errors_1.MetadataError.fromWrongReference(meta, prop, type73);
          }
        }
      });
    }
    ensureCorrectFKOrderInPivotEntity(meta, owner) {
      const pks = Object.values(meta.properties).filter((p2) => p2.primary);
      const fks = Object.values(meta.properties).filter((p2) => p2.kind === enums_1.ReferenceKind.MANY_TO_ONE);
      let first, second;
      if (pks.length === 2) {
        [first, second] = pks;
      } else if (fks.length >= 2) {
        [first, second] = fks;
      } else {
        return [];
      }
      if (owner.type === first.type && first.type !== second.type) {
        delete meta.properties[first.name];
        meta.removeProperty(first.name, false);
        meta.addProperty(first);
        [first, second] = [second, first];
      }
      return [first, second];
    }
    definePivotTableEntity(meta, prop) {
      const pivotMeta = this.metadata.find(prop.pivotEntity);
      if (!prop.inversedBy && prop.targetMeta) {
        const inverseName = `${meta.className}_${prop.name}__inverse`;
        prop.inversedBy = inverseName;
        const inverseProp = {
          name: inverseName,
          kind: enums_1.ReferenceKind.MANY_TO_MANY,
          type: meta.className,
          mappedBy: prop.name,
          pivotEntity: prop.pivotEntity,
          pivotTable: prop.pivotTable,
          persist: false,
          hydrate: false
        };
        this.applyNamingStrategy(prop.targetMeta, inverseProp);
        this.initCustomType(prop.targetMeta, inverseProp);
        this.initRelation(inverseProp);
        prop.targetMeta.properties[inverseName] = inverseProp;
      }
      if (pivotMeta) {
        this.ensureCorrectFKOrderInPivotEntity(pivotMeta, prop);
        return pivotMeta;
      }
      let tableName = prop.pivotTable;
      let schemaName;
      if (prop.pivotTable.includes(".")) {
        [schemaName, tableName] = prop.pivotTable.split(".");
      }
      schemaName ??= meta.schema;
      const targetType = prop.targetMeta.className;
      const data = new typings_1.EntityMetadata({
        name: prop.pivotTable,
        className: prop.pivotTable,
        collection: tableName,
        schema: schemaName,
        pivotTable: true
      });
      prop.pivotEntity = data.className;
      if (prop.fixedOrder) {
        const primaryProp = this.defineFixedOrderProperty(prop, targetType);
        data.properties[primaryProp.name] = primaryProp;
      } else {
        data.compositePK = true;
      }
      if (meta.name === targetType && prop.joinColumns.every((joinColumn, idx) => joinColumn === prop.inverseJoinColumns[idx])) {
        prop.joinColumns = prop.referencedColumnNames.map((name) => this.namingStrategy.joinKeyColumnName(meta.className + "_1", name, meta.compositePK));
        prop.inverseJoinColumns = prop.referencedColumnNames.map((name) => this.namingStrategy.joinKeyColumnName(meta.className + "_2", name, meta.compositePK));
        if (prop.inversedBy) {
          const prop2 = this.metadata.get(targetType).properties[prop.inversedBy];
          prop2.inverseJoinColumns = prop.joinColumns;
          prop2.joinColumns = prop.inverseJoinColumns;
        }
      }
      data.properties[meta.name + "_owner"] = this.definePivotProperty(prop, meta.name + "_owner", meta.name, targetType + "_inverse", true);
      data.properties[targetType + "_inverse"] = this.definePivotProperty(prop, targetType + "_inverse", targetType, meta.name + "_owner", false);
      return this.metadata.set(data.className, data);
    }
    defineFixedOrderProperty(prop, targetType) {
      const pk = prop.fixedOrderColumn || this.namingStrategy.referenceColumnName();
      const primaryProp = {
        name: pk,
        type: "number",
        kind: enums_1.ReferenceKind.SCALAR,
        primary: true,
        autoincrement: true,
        unsigned: this.platform.supportsUnsigned()
      };
      this.initFieldName(primaryProp);
      this.initColumnType(primaryProp);
      prop.fixedOrderColumn = pk;
      if (prop.inversedBy) {
        const prop2 = this.metadata.get(targetType).properties[prop.inversedBy];
        prop2.fixedOrder = true;
        prop2.fixedOrderColumn = pk;
      }
      return primaryProp;
    }
    definePivotProperty(prop, name, type73, inverse, owner) {
      const ret = {
        name,
        type: type73,
        kind: enums_1.ReferenceKind.MANY_TO_ONE,
        cascade: [enums_1.Cascade.ALL],
        fixedOrder: prop.fixedOrder,
        fixedOrderColumn: prop.fixedOrderColumn,
        index: this.platform.indexForeignKeys(),
        primary: !prop.fixedOrder,
        autoincrement: false
      };
      const meta = this.metadata.get(type73);
      ret.targetMeta = meta;
      ret.joinColumns = [];
      ret.inverseJoinColumns = [];
      const schema = meta.schema ?? this.config.get("schema") ?? this.platform.getDefaultSchemaName();
      ret.referencedTableName = schema && schema !== "*" ? schema + "." + meta.tableName : meta.tableName;
      if (owner) {
        ret.owner = true;
        ret.inversedBy = inverse;
        ret.referencedColumnNames = prop.referencedColumnNames;
        ret.fieldNames = ret.joinColumns = prop.joinColumns;
        ret.inverseJoinColumns = prop.referencedColumnNames;
        meta.primaryKeys.forEach((primaryKey) => {
          const prop2 = meta.properties[primaryKey];
          ret.length = prop2.length;
          ret.precision = prop2.precision;
          ret.scale = prop2.scale;
        });
      } else {
        ret.owner = false;
        ret.mappedBy = inverse;
        ret.fieldNames = ret.joinColumns = prop.inverseJoinColumns;
        ret.referencedColumnNames = [];
        ret.inverseJoinColumns = [];
        meta.primaryKeys.forEach((primaryKey) => {
          const prop2 = meta.properties[primaryKey];
          ret.referencedColumnNames.push(...prop2.fieldNames);
          ret.inverseJoinColumns.push(...prop2.fieldNames);
          ret.length = prop2.length;
          ret.precision = prop2.precision;
          ret.scale = prop2.scale;
        });
      }
      this.initColumnType(ret);
      this.initRelation(ret);
      return ret;
    }
    autoWireBidirectionalProperties(meta) {
      Object.values(meta.properties).filter((prop) => prop.kind !== enums_1.ReferenceKind.SCALAR && !prop.owner && prop.mappedBy).forEach((prop) => {
        const meta2 = this.metadata.get(prop.type);
        const prop2 = meta2.properties[prop.mappedBy];
        if (prop2 && !prop2.inversedBy) {
          prop2.inversedBy = prop.name;
        }
      });
    }
    defineBaseEntityProperties(meta) {
      const base = meta.extends && this.metadata.get(Utils_1.Utils.className(meta.extends));
      if (!base || base === meta) {
        return 0;
      }
      let order = this.defineBaseEntityProperties(base);
      const ownProps = Object.values(meta.properties);
      const old = ownProps.map((x) => x.name);
      meta.properties = {};
      Object.values(base.properties).forEach((prop) => {
        if (!prop.inherited) {
          meta.properties[prop.name] = prop;
        }
      });
      ownProps.forEach((prop) => meta.properties[prop.name] = prop);
      meta.filters = { ...base.filters, ...meta.filters };
      if (!meta.discriminatorValue) {
        Object.values(base.properties).filter((prop) => !old.includes(prop.name)).forEach((prop) => {
          meta.properties[prop.name] = { ...prop };
          meta.propertyOrder.set(prop.name, order += 0.01);
        });
      }
      meta.indexes = Utils_1.Utils.unique([...base.indexes, ...meta.indexes]);
      meta.uniques = Utils_1.Utils.unique([...base.uniques, ...meta.uniques]);
      const pks = Object.values(meta.properties).filter((p2) => p2.primary).map((p2) => p2.name);
      if (pks.length > 0 && meta.primaryKeys.length === 0) {
        meta.primaryKeys = pks;
      }
      Utils_1.Utils.keys(base.hooks).forEach((type73) => {
        meta.hooks[type73] = Utils_1.Utils.unique([...base.hooks[type73], ...meta.hooks[type73] || []]);
      });
      if (meta.constructorParams.length === 0 && base.constructorParams.length > 0) {
        meta.constructorParams = [...base.constructorParams];
      }
      if (meta.toJsonParams.length === 0 && base.toJsonParams.length > 0) {
        meta.toJsonParams = [...base.toJsonParams];
      }
      return order;
    }
    initPolyEmbeddables(embeddedProp, discovered, visited2 = new Set) {
      if (embeddedProp.kind !== enums_1.ReferenceKind.EMBEDDED || visited2.has(embeddedProp)) {
        return;
      }
      visited2.add(embeddedProp);
      const types = embeddedProp.type.split(/ ?\| ?/);
      let embeddable = this.discovered.find((m2) => m2.name === embeddedProp.type);
      const polymorphs = this.discovered.filter((m2) => types.includes(m2.name));
      if (!embeddable && polymorphs.length > 0) {
        const properties = {};
        let discriminatorColumn;
        const processExtensions = (meta) => {
          const parent = this.discovered.find((m2) => {
            return meta.extends && Utils_1.Utils.className(meta.extends) === m2.className;
          });
          if (!parent) {
            return;
          }
          discriminatorColumn ??= parent.discriminatorColumn;
          Object.values(parent.properties).forEach((prop) => properties[prop.name] = prop);
          processExtensions(parent);
        };
        polymorphs.forEach((meta) => {
          Object.values(meta.properties).forEach((prop) => properties[prop.name] = prop);
          processExtensions(meta);
        });
        const name = polymorphs.map((t2) => t2.className).sort().join(" | ");
        embeddable = new typings_1.EntityMetadata({
          name,
          className: name,
          embeddable: true,
          abstract: true,
          properties,
          polymorphs,
          discriminatorColumn
        });
        embeddable.sync();
        discovered.push(embeddable);
        polymorphs.forEach((meta) => meta.root = embeddable);
      }
    }
    initEmbeddables(meta, embeddedProp, visited2 = new Set) {
      if (embeddedProp.kind !== enums_1.ReferenceKind.EMBEDDED || visited2.has(embeddedProp)) {
        return;
      }
      visited2.add(embeddedProp);
      const embeddable = this.discovered.find((m2) => m2.name === embeddedProp.type);
      if (!embeddable) {
        throw errors_1.MetadataError.fromUnknownEntity(embeddedProp.type, `${meta.className}.${embeddedProp.name}`);
      }
      embeddedProp.embeddable = embeddable.class;
      embeddedProp.embeddedProps = {};
      let order = meta.propertyOrder.get(embeddedProp.name);
      const getRootProperty = (prop) => prop.embedded ? getRootProperty(meta.properties[prop.embedded[0]]) : prop;
      const isParentObject = (prop) => {
        if (prop.object || prop.array) {
          return true;
        }
        return prop.embedded ? isParentObject(meta.properties[prop.embedded[0]]) : false;
      };
      const rootProperty = getRootProperty(embeddedProp);
      const object12 = isParentObject(embeddedProp);
      this.initFieldName(embeddedProp, rootProperty !== embeddedProp && object12);
      const prefix = embeddedProp.prefix === false ? "" : embeddedProp.prefix === true ? embeddedProp.embeddedPath?.join("_") ?? embeddedProp.fieldNames[0] + "_" : embeddedProp.prefix;
      for (const prop of Object.values(embeddable.properties).filter((p2) => p2.persist !== false)) {
        const name = (embeddedProp.embeddedPath?.join("_") ?? embeddedProp.fieldNames[0] + "_") + prop.name;
        meta.properties[name] = Utils_1.Utils.copy(prop, false);
        meta.properties[name].name = name;
        meta.properties[name].embedded = [embeddedProp.name, prop.name];
        meta.propertyOrder.set(name, order += 0.01);
        embeddedProp.embeddedProps[prop.name] = meta.properties[name];
        if (embeddedProp.nullable) {
          meta.properties[name].nullable = true;
        }
        if (meta.properties[name].fieldNames) {
          meta.properties[name].fieldNames[0] = prefix + meta.properties[name].fieldNames[0];
        } else {
          const name2 = meta.properties[name].name;
          meta.properties[name].name = prefix + prop.name;
          this.initFieldName(meta.properties[name]);
          meta.properties[name].name = name2;
        }
        if (object12) {
          embeddedProp.object = true;
          let path = [];
          let tmp = embeddedProp;
          while (tmp.embedded && tmp.object) {
            path.unshift(tmp.embedded[1]);
            tmp = meta.properties[tmp.embedded[0]];
          }
          if (tmp === rootProperty) {
            path.unshift(rootProperty.fieldNames[0]);
          } else if (embeddedProp.embeddedPath) {
            path = [...embeddedProp.embeddedPath];
          } else {
            path = [embeddedProp.fieldNames[0]];
          }
          this.initFieldName(prop, true);
          path.push(prop.fieldNames[0]);
          meta.properties[name].fieldNames = prop.fieldNames;
          meta.properties[name].embeddedPath = path;
          const fieldName = (0, RawQueryFragment_1.raw)(this.platform.getSearchJsonPropertySQL(path.join("->"), prop.type, true));
          meta.properties[name].fieldNameRaw = fieldName.sql;
          meta.properties[name].persist = false;
          meta.properties[name].userDefined = false;
          meta.properties[name].object = true;
        }
        this.initEmbeddables(meta, meta.properties[name], visited2);
      }
      for (const index of embeddable.indexes) {
        meta.indexes.push({
          ...index,
          properties: Utils_1.Utils.asArray(index.properties).map((p2) => {
            return embeddedProp.embeddedProps[p2].name;
          })
        });
      }
      for (const unique of embeddable.uniques) {
        meta.uniques.push({
          ...unique,
          properties: Utils_1.Utils.asArray(unique.properties).map((p2) => {
            return embeddedProp.embeddedProps[p2].name;
          })
        });
      }
    }
    initSingleTableInheritance(meta, metadata) {
      if (meta.root !== meta && !meta.__processed) {
        meta.root = metadata.find((m2) => m2.className === meta.root.className);
        meta.root.__processed = true;
      } else {
        delete meta.root.__processed;
      }
      if (!meta.root.discriminatorColumn) {
        return;
      }
      if (!meta.root.discriminatorMap) {
        meta.root.discriminatorMap = {};
        const children = metadata.filter((m2) => m2.root.className === meta.root.className && !m2.abstract);
        children.forEach((m2) => {
          const name = m2.discriminatorValue ?? this.namingStrategy.classToTableName(m2.className);
          meta.root.discriminatorMap[name] = m2.className;
        });
      }
      meta.discriminatorValue = Object.entries(meta.root.discriminatorMap).find(([, className]) => className === meta.className)?.[0];
      if (!meta.root.properties[meta.root.discriminatorColumn]) {
        this.createDiscriminatorProperty(meta.root);
      }
      Utils_1.Utils.defaultValue(meta.root.properties[meta.root.discriminatorColumn], "items", Object.keys(meta.root.discriminatorMap));
      Utils_1.Utils.defaultValue(meta.root.properties[meta.root.discriminatorColumn], "index", true);
      if (meta.root === meta) {
        return;
      }
      Object.values(meta.properties).forEach((prop) => {
        const exists = meta.root.properties[prop.name];
        prop = Utils_1.Utils.copy(prop, false);
        prop.nullable = true;
        if (!exists) {
          prop.inherited = true;
        }
        meta.root.addProperty(prop);
      });
      meta.collection = meta.root.collection;
      meta.root.indexes = Utils_1.Utils.unique([...meta.root.indexes, ...meta.indexes]);
      meta.root.uniques = Utils_1.Utils.unique([...meta.root.uniques, ...meta.uniques]);
    }
    createDiscriminatorProperty(meta) {
      meta.addProperty({
        name: meta.discriminatorColumn,
        type: "string",
        enum: true,
        kind: enums_1.ReferenceKind.SCALAR,
        userDefined: false
      });
    }
    initAutoincrement(meta) {
      const pks = meta.getPrimaryProps();
      if (pks.length === 1 && this.isNumericProperty(pks[0])) {
        pks[0].autoincrement ??= true;
      }
    }
    initCheckConstraints(meta) {
      const map3 = this.createColumnMappingObject(meta);
      for (const check10 of meta.checks) {
        const columns = check10.property ? meta.properties[check10.property].fieldNames : [];
        check10.name ??= this.namingStrategy.indexName(meta.tableName, columns, "check");
        if (check10.expression instanceof Function) {
          check10.expression = check10.expression(map3);
        }
      }
    }
    initGeneratedColumn(meta, prop) {
      if (!prop.generated && prop.columnTypes) {
        const match = prop.columnTypes[0].match(/(.*) generated always as (.*)/);
        if (match) {
          prop.columnTypes[0] = match[1];
          prop.generated = match[2];
        }
        return;
      }
      const map3 = this.createColumnMappingObject(meta);
      if (prop.generated instanceof Function) {
        prop.generated = prop.generated(map3);
      }
    }
    createColumnMappingObject(meta) {
      return Object.values(meta.properties).reduce((o2, prop) => {
        if (prop.fieldNames) {
          o2[prop.name] = prop.fieldNames[0];
        }
        return o2;
      }, {});
    }
    getDefaultVersionValue(prop) {
      if (typeof prop.defaultRaw !== "undefined") {
        return prop.defaultRaw;
      }
      if (prop.default != null) {
        return "" + this.platform.quoteVersionValue(prop.default, prop);
      }
      if (prop.type.toLowerCase() === "date") {
        prop.length ??= this.platform.getDefaultVersionLength();
        return this.platform.getCurrentTimestampSQL(prop.length);
      }
      return "1";
    }
    inferDefaultValue(meta, prop) {
      if (!meta.class) {
        return;
      }
      try {
        const now = Date.now();
        const entity1 = new meta.class;
        const entity2 = new meta.class;
        if (this.config.get("discovery").inferDefaultValues && prop.default === undefined && entity1[prop.name] != null && entity1[prop.name] === entity2[prop.name] && entity1[prop.name] !== now) {
          prop.default ??= entity1[prop.name];
        }
        if (entity1[prop.name] === null) {
          prop.nullable ??= true;
        }
        if (prop.kind === enums_1.ReferenceKind.SCALAR && prop.type == null && entity1[prop.name] != null) {
          prop.type = Utils_1.Utils.getObjectType(entity1[prop.name]);
        }
      } catch {
      }
    }
    initDefaultValue(prop) {
      if (prop.defaultRaw || !("default" in prop)) {
        return;
      }
      let val = prop.default;
      const raw = RawQueryFragment_1.RawQueryFragment.getKnownFragment(val);
      if (raw) {
        prop.defaultRaw = this.platform.formatQuery(raw.sql, raw.params);
        return;
      }
      if (prop.customType instanceof types_1.ArrayType && Array.isArray(prop.default)) {
        val = prop.customType.convertToDatabaseValue(prop.default, this.platform);
      }
      prop.defaultRaw = typeof val === "string" ? `'${val}'` : "" + val;
    }
    inferTypeFromDefault(prop) {
      if (prop.defaultRaw == null && prop.default == null || prop.type !== "any") {
        return;
      }
      switch (typeof prop.default) {
        case "string":
          prop.type = prop.runtimeType = "string";
          break;
        case "number":
          prop.type = prop.runtimeType = "number";
          break;
        case "boolean":
          prop.type = prop.runtimeType = "boolean";
          break;
      }
      if (prop.defaultRaw?.startsWith("current_timestamp")) {
        prop.type = prop.runtimeType = "Date";
      }
    }
    initVersionProperty(meta, prop) {
      if (prop.version) {
        this.initDefaultValue(prop);
        meta.versionProperty = prop.name;
        prop.defaultRaw = this.getDefaultVersionValue(prop);
      }
      if (prop.concurrencyCheck && !prop.primary) {
        meta.concurrencyCheckKeys.add(prop.name);
      }
    }
    initCustomType(meta, prop) {
      if (types_1.Type.isMappedType(prop.type) && !prop.customType) {
        prop.customType = prop.type;
        prop.type = prop.customType.constructor.name;
      }
      if (typeof prop.type === "function" && types_1.Type.isMappedType(prop.type.prototype) && !prop.customType) {
        prop.customType = new prop.type;
        prop.type = prop.customType.constructor.name;
      }
      if (!prop.customType && ["json", "jsonb"].includes(prop.type?.toLowerCase())) {
        prop.customType = new types_1.JsonType;
      }
      if (prop.kind === enums_1.ReferenceKind.SCALAR && !prop.customType && prop.columnTypes && ["json", "jsonb"].includes(prop.columnTypes[0])) {
        prop.customType = new types_1.JsonType;
      }
      if (!prop.customType && prop.array && prop.items) {
        prop.customType = new types_1.EnumArrayType(`${meta.className}.${prop.name}`, prop.items);
      }
      if (!prop.customType && prop.type === "number[]") {
        prop.customType = new types_1.ArrayType((i2) => +i2);
      }
      if (!prop.customType && (prop.type?.toLowerCase() === "array" || prop.type?.toString().endsWith("[]"))) {
        prop.customType = new types_1.ArrayType;
      }
      if (!prop.customType && prop.type?.toLowerCase() === "buffer") {
        prop.customType = new types_1.BlobType;
      }
      if (!prop.customType && prop.type?.toLowerCase() === "uint8array") {
        prop.customType = new types_1.Uint8ArrayType;
      }
      const mappedType = this.getMappedType(prop);
      if (prop.fieldNames?.length === 1 && !prop.customType) {
        [types_1.BigIntType, types_1.DoubleType, types_1.DecimalType, types_1.IntervalType].filter((type73) => mappedType instanceof type73).forEach((type73) => prop.customType = new type73);
      }
      if (prop.customType && !prop.columnTypes) {
        const mappedType2 = this.getMappedType({ columnTypes: [prop.customType.getColumnType(prop, this.platform)] });
        if (prop.customType.compareAsType() === "any") {
          prop.runtimeType ??= mappedType2.runtimeType;
        } else {
          prop.runtimeType ??= prop.customType.runtimeType;
        }
      } else {
        prop.runtimeType ??= mappedType.runtimeType;
      }
      if (prop.customType) {
        prop.customType.platform = this.platform;
        prop.customType.meta = meta;
        prop.customType.prop = prop;
        prop.columnTypes ??= [prop.customType.getColumnType(prop, this.platform)];
        prop.hasConvertToJSValueSQL = !!prop.customType.convertToJSValueSQL && prop.customType.convertToJSValueSQL("", this.platform) !== "";
        prop.hasConvertToDatabaseValueSQL = !!prop.customType.convertToDatabaseValueSQL && prop.customType.convertToDatabaseValueSQL("", this.platform) !== "";
        if (prop.customType instanceof types_1.BigIntType && ["string", "bigint", "number"].includes(prop.runtimeType.toLowerCase())) {
          prop.customType.mode = prop.runtimeType.toLowerCase();
        }
      }
      if (types_1.Type.isMappedType(prop.customType) && prop.kind === enums_1.ReferenceKind.SCALAR && !prop.type?.toString().endsWith("[]")) {
        prop.type = prop.customType.name;
      }
      if (!prop.customType && [enums_1.ReferenceKind.ONE_TO_ONE, enums_1.ReferenceKind.MANY_TO_ONE].includes(prop.kind) && this.metadata.get(prop.type).compositePK) {
        prop.customTypes = [];
        for (const pk of this.metadata.get(prop.type).getPrimaryProps()) {
          if (pk.customType) {
            prop.customTypes.push(pk.customType);
            prop.hasConvertToJSValueSQL ||= !!pk.customType.convertToJSValueSQL && pk.customType.convertToJSValueSQL("", this.platform) !== "";
            prop.hasConvertToDatabaseValueSQL ||= !!pk.customType.convertToDatabaseValueSQL && pk.customType.convertToDatabaseValueSQL("", this.platform) !== "";
          } else {
            prop.customTypes.push(undefined);
          }
        }
      }
      if (prop.kind === enums_1.ReferenceKind.SCALAR && !(mappedType instanceof types_1.UnknownType)) {
        prop.columnTypes ??= [mappedType.getColumnType(prop, this.platform)];
        if (!Object.values(types_1.t).some((type73) => type73 === mappedType.constructor)) {
          prop.customType ??= mappedType;
        }
      }
    }
    initRelation(prop) {
      if (prop.kind === enums_1.ReferenceKind.SCALAR) {
        return;
      }
      const meta2 = this.discovered.find((m2) => m2.className === prop.type);
      prop.referencedPKs = meta2.primaryKeys;
      prop.targetMeta = meta2;
    }
    initColumnType(prop) {
      this.initUnsigned(prop);
      this.metadata.find(prop.type)?.getPrimaryProps().map((pk) => {
        prop.length ??= pk.length;
        prop.precision ??= pk.precision;
        prop.scale ??= pk.scale;
      });
      if (prop.kind === enums_1.ReferenceKind.SCALAR && (prop.type == null || prop.type === "object") && prop.columnTypes?.[0]) {
        delete prop.type;
        const mappedType = this.getMappedType(prop);
        prop.type = mappedType.compareAsType();
      }
      if (prop.columnTypes || !this.schemaHelper) {
        return;
      }
      if (prop.kind === enums_1.ReferenceKind.SCALAR) {
        const mappedType = this.getMappedType(prop);
        prop.columnTypes = [mappedType.getColumnType(prop, this.platform)];
        return;
      }
      if (prop.kind === enums_1.ReferenceKind.EMBEDDED && prop.object && !prop.columnTypes) {
        prop.columnTypes = [this.platform.getJsonDeclarationSQL()];
        return;
      }
      const targetMeta = this.metadata.get(prop.type);
      prop.columnTypes = [];
      for (const pk of targetMeta.getPrimaryProps()) {
        this.initCustomType(targetMeta, pk);
        this.initColumnType(pk);
        const mappedType = this.getMappedType(pk);
        let columnTypes = pk.columnTypes;
        if (pk.autoincrement) {
          columnTypes = [mappedType.getColumnType({ ...pk, autoincrement: false }, this.platform)];
        }
        prop.columnTypes.push(...columnTypes);
        if (!targetMeta.compositePK) {
          prop.customType = pk.customType;
        }
      }
    }
    getMappedType(prop) {
      if (prop.customType) {
        return prop.customType;
      }
      let t2 = prop.columnTypes?.[0] ?? prop.type;
      if (prop.nativeEnumName) {
        t2 = "enum";
      } else if (prop.enum) {
        t2 = prop.items?.every((item) => Utils_1.Utils.isString(item)) ? "enum" : "tinyint";
      }
      if (t2 === "Date") {
        t2 = "datetime";
      }
      return this.platform.getMappedType(t2);
    }
    initUnsigned(prop) {
      if ([enums_1.ReferenceKind.MANY_TO_ONE, enums_1.ReferenceKind.ONE_TO_ONE].includes(prop.kind)) {
        const meta2 = this.metadata.get(prop.type);
        meta2.primaryKeys.forEach((primaryKey) => {
          const pk = meta2.properties[primaryKey];
          prop.unsigned ||= this.platform.supportsUnsigned() && this.isNumericProperty(pk);
        });
        return;
      }
      prop.unsigned ??= (prop.primary || prop.unsigned) && this.isNumericProperty(prop) && this.platform.supportsUnsigned();
    }
    initIndexes(prop) {
      if (prop.kind === enums_1.ReferenceKind.MANY_TO_ONE && this.platform.indexForeignKeys()) {
        prop.index ??= true;
      }
    }
    isNumericProperty(prop) {
      if (prop.customType) {
        return this.platform.isNumericColumn(prop.customType);
      }
      const numericMappedType = prop.columnTypes?.[0] && this.platform.isNumericColumn(this.platform.getMappedType(prop.columnTypes[0]));
      return numericMappedType || prop.type === "number" || this.platform.isBigIntProperty(prop);
    }
    async getEntityClassOrSchema(path, name) {
      const exports2 = await Utils_1.Utils.dynamicImport(path);
      const targets = Object.values(exports2).filter((item) => item instanceof EntitySchema_1.EntitySchema || item instanceof Function && MetadataStorage_1.MetadataStorage.isKnownEntity(item.name));
      for (const item of targets) {
        if (item instanceof EntitySchema_1.EntitySchema) {
          targets.forEach((item2, idx) => {
            if (item.meta.class === item2) {
              targets.splice(idx, 1);
            }
          });
        }
      }
      if (targets.length > 0) {
        return targets;
      }
      const target = exports2.default ?? exports2[name];
      if (!target) {
        throw errors_1.MetadataError.entityNotFound(name, path.replace(this.config.get("baseDir"), "."));
      }
      return [target];
    }
    shouldForceConstructorUsage(meta) {
      const forceConstructor = this.config.get("forceEntityConstructor");
      if (Array.isArray(forceConstructor)) {
        return forceConstructor.some((cls) => Utils_1.Utils.className(cls) === meta.className);
      }
      return meta.forceConstructor = forceConstructor;
    }
  }
  exports.MetadataDiscovery = MetadataDiscovery;
});

// node_modules/@mikro-orm/core/metadata/index.js
var require_metadata = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_EntitySchema(), exports);
  __exportStar(require_MetadataDiscovery(), exports);
  __exportStar(require_MetadataStorage(), exports);
  __exportStar(require_MetadataProvider(), exports);
  __exportStar(require_MetadataValidator(), exports);
  __exportStar(require_ReflectMetadataProvider(), exports);
});

// node_modules/@mikro-orm/core/MikroORM.js
var require_MikroORM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MikroORM = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  var logging_1 = require_logging();
  var cache_1 = require_cache2();

  class MikroORM {
    em;
    config;
    metadata;
    driver;
    logger;
    discovery;
    static async init(options) {
      utils_1.ConfigurationLoader.registerDotenv(options);
      const coreVersion = await utils_1.ConfigurationLoader.checkPackageVersion();
      const env = utils_1.ConfigurationLoader.loadEnvironmentVars();
      if (!options) {
        options = (await utils_1.ConfigurationLoader.getConfiguration()).getAll();
      }
      options = utils_1.Utils.mergeConfig(options, env);
      await utils_1.ConfigurationLoader.commonJSCompat(options);
      if ("DRIVER" in this && !options.driver) {
        options.driver = this.DRIVER;
      }
      const orm = new MikroORM(options);
      orm.logger.log("info", `MikroORM version: ${logging_1.colors.green(coreVersion)}`);
      const allowGlobalContext = orm.config.get("allowGlobalContext");
      orm.config.set("allowGlobalContext", true);
      await orm.discoverEntities();
      orm.config.set("allowGlobalContext", allowGlobalContext);
      orm.driver.getPlatform().lookupExtensions(orm);
      if (orm.config.get("connect")) {
        await orm.connect();
      }
      for (const extension of orm.config.get("extensions")) {
        extension.register(orm);
      }
      if (orm.config.get("connect") && orm.config.get("ensureIndexes")) {
        await orm.getSchemaGenerator().ensureIndexes();
      }
      return orm;
    }
    static initSync(options) {
      utils_1.ConfigurationLoader.registerDotenv(options);
      const env = utils_1.ConfigurationLoader.loadEnvironmentVars();
      options = utils_1.Utils.merge(options, env);
      if ("DRIVER" in this && !options.driver) {
        options.driver = this.DRIVER;
      }
      const orm = new MikroORM(options);
      const allowGlobalContext = orm.config.get("allowGlobalContext");
      orm.config.set("allowGlobalContext", true);
      orm.discoverEntitiesSync();
      orm.config.set("allowGlobalContext", allowGlobalContext);
      orm.driver.getPlatform().lookupExtensions(orm);
      for (const extension of orm.config.get("extensions")) {
        extension.register(orm);
      }
      return orm;
    }
    constructor(options) {
      if (options instanceof utils_1.Configuration) {
        this.config = options;
      } else {
        this.config = new utils_1.Configuration(options);
      }
      const discovery = this.config.get("discovery");
      if (discovery.disableDynamicFileAccess) {
        this.config.set("metadataProvider", metadata_1.ReflectMetadataProvider);
        this.config.set("metadataCache", { adapter: cache_1.NullCacheAdapter });
        discovery.requireEntitiesArray = true;
      }
      this.driver = this.config.getDriver();
      this.logger = this.config.getLogger();
      this.discovery = new metadata_1.MetadataDiscovery(new metadata_1.MetadataStorage, this.driver.getPlatform(), this.config);
    }
    async connect() {
      const connection = await this.driver.connect();
      const clientUrl = connection.getClientUrl();
      const dbName = this.config.get("dbName");
      const db = dbName + (clientUrl ? " on " + clientUrl : "");
      if (this.config.get("ensureDatabase")) {
        const options = this.config.get("ensureDatabase");
        await this.schema.ensureDatabase(typeof options === "boolean" ? {} : { ...options, forceCheck: true });
      }
      if (await this.isConnected()) {
        this.logger.log("info", `MikroORM successfully connected to database ${logging_1.colors.green(db)}`);
      } else {
        this.logger.error("info", `MikroORM failed to connect to database ${db}`);
      }
      return this.driver;
    }
    async reconnect(options = {}) {
      for (const key of utils_1.Utils.keys(options)) {
        this.config.set(key, options[key]);
      }
      await this.driver.reconnect();
    }
    async isConnected() {
      return this.driver.getConnection().isConnected();
    }
    async checkConnection() {
      return this.driver.getConnection().checkConnection();
    }
    async close(force = false) {
      if (await this.isConnected()) {
        await this.driver.close(force);
      }
      if (this.config.getMetadataCacheAdapter()?.close) {
        await this.config.getMetadataCacheAdapter().close();
      }
      if (this.config.getResultCacheAdapter()?.close) {
        await this.config.getResultCacheAdapter().close();
      }
    }
    getMetadata(entityName) {
      if (entityName) {
        entityName = utils_1.Utils.className(entityName);
        return this.metadata.get(entityName);
      }
      return this.metadata;
    }
    async discoverEntities() {
      this.metadata = await this.discovery.discover(this.config.get("tsNode"));
      this.createEntityManager();
    }
    discoverEntitiesSync() {
      this.metadata = this.discovery.discoverSync(this.config.get("tsNode"));
      this.createEntityManager();
    }
    createEntityManager() {
      this.driver.setMetadata(this.metadata);
      this.em = this.driver.createEntityManager();
      this.em.global = true;
      this.metadata.decorate(this.em);
      this.driver.setMetadata(this.metadata);
    }
    discoverEntity(entities) {
      entities = utils_1.Utils.asArray(entities);
      const tmp = this.discovery.discoverReferences(entities);
      const options = this.config.get("discovery");
      new metadata_1.MetadataValidator().validateDiscovered([...Object.values(this.metadata.getAll()), ...tmp], options);
      const metadata = this.discovery.processDiscoveredEntities(tmp);
      metadata.forEach((meta) => this.metadata.set(meta.className, meta));
      this.metadata.decorate(this.em);
    }
    getSchemaGenerator() {
      const extension = this.config.getExtension("@mikro-orm/schema-generator");
      if (extension) {
        return extension;
      }
      throw new Error(`SchemaGenerator extension not registered.`);
    }
    getEntityGenerator() {
      const extension = this.config.getExtension("@mikro-orm/entity-generator");
      if (extension) {
        return extension;
      }
      throw new Error(`EntityGenerator extension not registered.`);
    }
    getMigrator() {
      const extension = this.config.getExtension("@mikro-orm/migrator");
      if (extension) {
        return extension;
      }
      throw new Error(`Migrator extension not registered.`);
    }
    getSeeder() {
      const extension = this.config.getExtension("@mikro-orm/seeder");
      if (extension) {
        return extension;
      }
      throw new Error(`SeedManager extension not registered.`);
    }
    get schema() {
      return this.getSchemaGenerator();
    }
    get seeder() {
      return this.getSeeder();
    }
    get migrator() {
      return this.getMigrator();
    }
    get entityGenerator() {
      return this.getEntityGenerator();
    }
  }
  exports.MikroORM = MikroORM;
});

// node_modules/@mikro-orm/core/serialization/index.js
var require_serialization = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_EntityTransformer(), exports);
  __exportStar(require_EntitySerializer(), exports);
  __exportStar(require_SerializationContext(), exports);
});

// node_modules/@mikro-orm/core/drivers/IDatabaseDriver.js
var require_IDatabaseDriver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityManagerType = undefined;
  exports.EntityManagerType = Symbol("EntityManagerType");
});

// node_modules/@mikro-orm/core/drivers/DatabaseDriver.js
var require_DatabaseDriver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseDriver = undefined;
  var IDatabaseDriver_1 = require_IDatabaseDriver();
  var utils_1 = require_utils10();
  var enums_1 = require_enums();
  var EntityManager_1 = require_EntityManager();
  var errors_1 = require_errors3();
  var exceptions_1 = require_exceptions();
  var wrap_1 = require_wrap();

  class DatabaseDriver {
    config;
    dependencies;
    [IDatabaseDriver_1.EntityManagerType];
    connection;
    replicas = [];
    platform;
    logger;
    comparator;
    metadata;
    constructor(config, dependencies) {
      this.config = config;
      this.dependencies = dependencies;
      this.logger = this.config.getLogger();
    }
    async nativeUpdateMany(entityName, where, data, options) {
      throw new Error(`Batch updates are not supported by ${this.constructor.name} driver`);
    }
    createEntityManager(useContext) {
      const EntityManagerClass = this.config.get("entityManager", EntityManager_1.EntityManager);
      return new EntityManagerClass(this.config, this, this.metadata, useContext);
    }
    async findVirtual(entityName, where, options) {
      throw new Error(`Virtual entities are not supported by ${this.constructor.name} driver.`);
    }
    async countVirtual(entityName, where, options) {
      throw new Error(`Counting virtual entities is not supported by ${this.constructor.name} driver.`);
    }
    async aggregate(entityName, pipeline) {
      throw new Error(`Aggregations are not supported by ${this.constructor.name} driver`);
    }
    async loadFromPivotTable(prop, owners, where, orderBy, ctx, options, pivotJoin) {
      throw new Error(`${this.constructor.name} does not use pivot tables`);
    }
    async syncCollections(collections, options) {
      for (const coll of collections) {
        if (!coll.property.owner) {
          if (coll.getSnapshot() === undefined) {
            throw errors_1.ValidationError.cannotModifyInverseCollection(coll.owner, coll.property);
          }
          continue;
        }
        {
          const pk = coll.property.targetMeta.primaryKeys[0];
          const data = { [coll.property.name]: coll.getIdentifiers(pk) };
          await this.nativeUpdate(coll.owner.constructor.name, (0, wrap_1.helper)(coll.owner).getPrimaryKey(), data, options);
        }
      }
    }
    mapResult(result, meta, populate = []) {
      if (!result || !meta) {
        return result ?? null;
      }
      return this.comparator.mapResult(meta.className, result);
    }
    async connect() {
      await this.connection.connect();
      await Promise.all(this.replicas.map((replica) => replica.connect()));
      return this.connection;
    }
    async reconnect() {
      await this.close(true);
      await this.connect();
      return this.connection;
    }
    getConnection(type73 = "write") {
      if (type73 === "write" || this.replicas.length === 0) {
        return this.connection;
      }
      const rand = utils_1.Utils.randomInt(0, this.replicas.length - 1);
      return this.replicas[rand];
    }
    async close(force) {
      await Promise.all(this.replicas.map((replica) => replica.close(force)));
      await this.connection.close(force);
    }
    getPlatform() {
      return this.platform;
    }
    setMetadata(metadata) {
      this.metadata = metadata;
      this.comparator = new utils_1.EntityComparator(this.metadata, this.platform);
      this.connection.setMetadata(metadata);
      this.connection.setPlatform(this.platform);
      this.replicas.forEach((replica) => {
        replica.setMetadata(metadata);
        replica.setPlatform(this.platform);
      });
    }
    getMetadata() {
      return this.metadata;
    }
    getDependencies() {
      return this.dependencies;
    }
    processCursorOptions(meta, options, orderBy) {
      const { first, last, before, after, overfetch } = options;
      const limit = first || last;
      const isLast = !first && !!last;
      const definition = utils_1.Cursor.getDefinition(meta, orderBy);
      const $and = [];
      const isCursor = (val, key) => {
        return !!val && typeof val === "object" && key in val;
      };
      const createCursor = (val, key, inverse = false) => {
        let def = isCursor(val, key) ? val[key] : val;
        if (utils_1.Utils.isPlainObject(def)) {
          def = utils_1.Cursor.for(meta, def, orderBy);
        }
        const offsets = def ? utils_1.Cursor.decode(def) : [];
        if (definition.length === offsets.length) {
          return this.createCursorCondition(definition, offsets, inverse);
        }
        return {};
      };
      if (after) {
        $and.push(createCursor(after, "endCursor"));
      }
      if (before) {
        $and.push(createCursor(before, "startCursor", true));
      }
      if (limit) {
        options.limit = limit + (overfetch ? 1 : 0);
      }
      const createOrderBy = (prop, direction) => {
        if (utils_1.Utils.isPlainObject(direction)) {
          const value14 = utils_1.Utils.keys(direction).reduce((o2, key) => {
            Object.assign(o2, createOrderBy(key, direction[key]));
            return o2;
          }, {});
          return { [prop]: value14 };
        }
        const desc = direction === enums_1.QueryOrderNumeric.DESC || direction.toString().toLowerCase() === "desc";
        const dir = utils_1.Utils.xor(desc, isLast) ? "desc" : "asc";
        return { [prop]: dir };
      };
      return {
        orderBy: definition.map(([prop, direction]) => createOrderBy(prop, direction)),
        where: $and.length > 1 ? { $and } : { ...$and[0] }
      };
    }
    createCursorCondition(definition, offsets, inverse) {
      const createCondition = (prop2, direction2, offset2, eq = false) => {
        if (utils_1.Utils.isPlainObject(direction2)) {
          const value14 = utils_1.Utils.keys(direction2).reduce((o2, key) => {
            Object.assign(o2, createCondition(key, direction2[key], offset2[prop2][key], eq));
            return o2;
          }, {});
          return { [prop2]: value14 };
        }
        const desc = direction2 === enums_1.QueryOrderNumeric.DESC || direction2.toString().toLowerCase() === "desc";
        const operator = utils_1.Utils.xor(desc, inverse) ? "$lt" : "$gt";
        return { [prop2]: { [operator + (eq ? "e" : "")]: offset2 } };
      };
      const [order, ...otherOrders] = definition;
      const [offset, ...otherOffsets] = offsets;
      const [prop, direction] = order;
      if (!otherOrders.length) {
        return createCondition(prop, direction, offset);
      }
      return {
        ...createCondition(prop, direction, offset, true),
        $or: [
          createCondition(prop, direction, offset),
          this.createCursorCondition(otherOrders, otherOffsets, inverse)
        ]
      };
    }
    mapDataToFieldNames(data, stringifyJsonArrays, properties, convertCustomTypes, object12) {
      if (!properties || data == null) {
        return data;
      }
      data = Object.assign({}, data);
      Object.keys(data).forEach((k) => {
        const prop = properties[k];
        if (!prop) {
          return;
        }
        if (prop.embeddedProps && !prop.object && !object12) {
          const copy = data[k];
          delete data[k];
          Object.assign(data, this.mapDataToFieldNames(copy, stringifyJsonArrays, prop.embeddedProps, convertCustomTypes));
          return;
        }
        if (prop.embeddedProps && (object12 || prop.object)) {
          const copy = data[k];
          delete data[k];
          if (prop.array) {
            data[prop.fieldNames[0]] = copy.map((item) => this.mapDataToFieldNames(item, stringifyJsonArrays, prop.embeddedProps, convertCustomTypes, true));
          } else {
            data[prop.fieldNames[0]] = this.mapDataToFieldNames(copy, stringifyJsonArrays, prop.embeddedProps, convertCustomTypes, true);
          }
          if (stringifyJsonArrays && prop.array) {
            data[prop.fieldNames[0]] = this.platform.convertJsonToDatabaseValue(data[prop.fieldNames[0]]);
          }
          return;
        }
        if (prop.joinColumns && Array.isArray(data[k])) {
          const copy = utils_1.Utils.flatten(data[k]);
          delete data[k];
          prop.joinColumns.forEach((joinColumn, idx) => data[joinColumn] = copy[idx]);
          return;
        }
        if (prop.customType && convertCustomTypes && !this.platform.isRaw(data[k])) {
          data[k] = prop.customType.convertToDatabaseValue(data[k], this.platform, { fromQuery: true, key: k, mode: "query-data" });
        }
        if (prop.hasConvertToDatabaseValueSQL && !prop.object && !this.platform.isRaw(data[k])) {
          const quoted = this.platform.quoteValue(data[k]);
          const sql = prop.customType.convertToDatabaseValueSQL(quoted, this.platform);
          data[k] = (0, utils_1.raw)(sql.replace(/\?/g, "\\?"));
        }
        if (!prop.customType && (Array.isArray(data[k]) || utils_1.Utils.isPlainObject(data[k]))) {
          data[k] = JSON.stringify(data[k]);
        }
        if (prop.fieldNames) {
          utils_1.Utils.renameKey(data, k, prop.fieldNames[0]);
        }
      });
      return data;
    }
    inlineEmbeddables(meta, data, where) {
      if (data == null) {
        return;
      }
      utils_1.Utils.keys(data).forEach((k) => {
        if (utils_1.Utils.isOperator(k)) {
          utils_1.Utils.asArray(data[k]).forEach((payload) => this.inlineEmbeddables(meta, payload, where));
        }
      });
      meta.props.forEach((prop) => {
        if (prop.kind === enums_1.ReferenceKind.EMBEDDED && prop.object && !where && utils_1.Utils.isObject(data[prop.name])) {
          return;
        }
        if (prop.kind === enums_1.ReferenceKind.EMBEDDED && utils_1.Utils.isObject(data[prop.name])) {
          const props = prop.embeddedProps;
          let unknownProp = false;
          Object.keys(data[prop.name]).forEach((kk) => {
            const operator = Object.keys(data[prop.name]).some((f) => utils_1.Utils.isOperator(f) && !["$exists", "$ne", "$eq"].includes(f));
            if (operator) {
              throw errors_1.ValidationError.cannotUseOperatorsInsideEmbeddables(meta.name, prop.name, data);
            }
            if (prop.object && where) {
              const inline = (payload, sub, path) => {
                if (sub.kind === enums_1.ReferenceKind.EMBEDDED && utils_1.Utils.isObject(payload[sub.embedded[1]])) {
                  return Object.keys(payload[sub.embedded[1]]).forEach((kkk) => {
                    if (!sub.embeddedProps[kkk]) {
                      throw errors_1.ValidationError.invalidEmbeddableQuery(meta.className, kkk, sub.type);
                    }
                    inline(payload[sub.embedded[1]], sub.embeddedProps[kkk], [...path, sub.embedded[1]]);
                  });
                }
                data[`${path.join(".")}.${sub.embedded[1]}`] = payload[sub.embedded[1]];
              };
              const parentPropName = kk.substring(0, kk.indexOf("."));
              if (props[kk]) {
                inline(data[prop.name], props[kk] || props[parentPropName], [prop.name]);
              } else if (props[parentPropName]) {
                data[`${prop.name}.${kk}`] = data[prop.name][kk];
              } else {
                unknownProp = true;
              }
            } else if (props[kk]) {
              data[props[kk].name] = data[prop.name][props[kk].embedded[1]];
            } else {
              throw errors_1.ValidationError.invalidEmbeddableQuery(meta.className, kk, prop.type);
            }
          });
          if (!unknownProp) {
            delete data[prop.name];
          }
        }
      });
    }
    getPrimaryKeyFields(entityName) {
      const meta = this.metadata.find(entityName);
      return meta ? utils_1.Utils.flatten(meta.getPrimaryProps().map((pk) => pk.fieldNames)) : [this.config.getNamingStrategy().referenceColumnName()];
    }
    createReplicas(cb) {
      const replicas = this.config.get("replicas", []);
      const ret = [];
      const props = ["dbName", "clientUrl", "host", "port", "user", "password", "multipleStatements", "pool", "name"];
      replicas.forEach((conf) => {
        props.forEach((prop) => conf[prop] = (prop in conf) ? conf[prop] : this.config.get(prop));
        ret.push(cb(conf));
      });
      return ret;
    }
    async lockPessimistic(entity, options) {
      throw new Error(`Pessimistic locks are not supported by ${this.constructor.name} driver`);
    }
    convertException(exception) {
      if (exception instanceof exceptions_1.DriverException) {
        return exception;
      }
      return this.platform.getExceptionConverter().convertException(exception);
    }
    rethrow(promise4) {
      return promise4.catch((e2) => {
        throw this.convertException(e2);
      });
    }
    getTableName(meta, options) {
      const tableName = this.platform.quoteIdentifier(meta.tableName);
      const schema = this.getSchemaName(meta, options);
      if (schema) {
        return this.platform.quoteIdentifier(schema) + "." + tableName;
      }
      return tableName;
    }
    getSchemaName(meta, options) {
      if (meta?.schema && meta.schema !== "*") {
        return meta.schema;
      }
      if (options?.schema === "*") {
        return this.config.get("schema");
      }
      const schemaName = meta?.schema === "*" ? this.config.get("schema") : meta?.schema;
      return options?.schema ?? schemaName ?? this.config.get("schema");
    }
  }
  exports.DatabaseDriver = DatabaseDriver;
});

// node_modules/@mikro-orm/core/drivers/index.js
var require_drivers = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_IDatabaseDriver(), exports);
  __exportStar(require_DatabaseDriver(), exports);
});

// node_modules/@mikro-orm/core/connections/Connection.js
var require_Connection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Connection = undefined;
  var url_1 = import.meta.require("url");
  var utils_1 = require_utils10();

  class Connection {
    config;
    type;
    metadata;
    platform;
    options;
    logger;
    connected = false;
    constructor(config, options, type73 = "write") {
      this.config = config;
      this.type = type73;
      this.logger = this.config.getLogger();
      if (options) {
        this.options = options;
      } else {
        const props = ["dbName", "clientUrl", "host", "port", "user", "password", "multipleStatements", "pool", "schema"];
        this.options = props.reduce((o2, i2) => {
          o2[i2] = this.config.get(i2);
          return o2;
        }, {});
      }
    }
    async close(force) {
      Object.keys(this.options).filter((k) => k !== "name").forEach((k) => delete this.options[k]);
    }
    async ensureConnection() {
      if (!this.connected) {
        await this.connect();
      }
    }
    async transactional(cb, options) {
      throw new Error(`Transactions are not supported by current driver`);
    }
    async begin(options) {
      throw new Error(`Transactions are not supported by current driver`);
    }
    async commit(ctx, eventBroadcaster) {
      throw new Error(`Transactions are not supported by current driver`);
    }
    async rollback(ctx, eventBroadcaster) {
      throw new Error(`Transactions are not supported by current driver`);
    }
    getConnectionOptions() {
      const ret = {};
      if (this.options.clientUrl) {
        const url = new url_1.URL(this.options.clientUrl);
        this.options.host = ret.host = this.options.host ?? decodeURIComponent(url.hostname);
        this.options.port = ret.port = this.options.port ?? +url.port;
        this.options.user = ret.user = this.options.user ?? decodeURIComponent(url.username);
        this.options.password = ret.password = this.options.password ?? decodeURIComponent(url.password);
        this.options.dbName = ret.database = this.options.dbName ?? decodeURIComponent(url.pathname).replace(/^\//, "");
        if (this.options.schema || url.searchParams.has("schema")) {
          this.options.schema = ret.schema = this.options.schema ?? decodeURIComponent(url.searchParams.get("schema"));
          this.config.set("schema", ret.schema);
        }
      } else {
        const url = new url_1.URL(this.config.getClientUrl());
        this.options.host = ret.host = this.options.host ?? this.config.get("host", decodeURIComponent(url.hostname));
        this.options.port = ret.port = this.options.port ?? this.config.get("port", +url.port);
        this.options.user = ret.user = this.options.user ?? this.config.get("user", decodeURIComponent(url.username));
        this.options.password = ret.password = this.options.password ?? this.config.get("password", decodeURIComponent(url.password));
        this.options.dbName = ret.database = this.options.dbName ?? this.config.get("dbName", decodeURIComponent(url.pathname).replace(/^\//, ""));
      }
      return ret;
    }
    getClientUrl() {
      const options = this.getConnectionOptions();
      const url = new url_1.URL(this.config.getClientUrl(true));
      const password = options.password ? ":*****" : "";
      const schema = options.schema && options.schema !== this.platform.getDefaultSchemaName() ? `?schema=${options.schema}` : "";
      return `${url.protocol}//${options.user}${password}@${options.host}:${options.port}${schema}`;
    }
    setMetadata(metadata) {
      this.metadata = metadata;
    }
    setPlatform(platform) {
      this.platform = platform;
    }
    getPlatform() {
      return this.platform;
    }
    async executeQuery(query, cb, context) {
      const now = Date.now();
      try {
        const res = await cb();
        this.logQuery(query, {
          ...context,
          took: Date.now() - now,
          results: Array.isArray(res) ? res.length : undefined,
          affected: utils_1.Utils.isPlainObject(res) ? res.affectedRows : undefined
        });
        return res;
      } catch (e2) {
        this.logQuery(query, { ...context, took: Date.now() - now, level: "error" });
        throw e2;
      }
    }
    logQuery(query, context = {}) {
      this.logger.logQuery({
        level: "info",
        connection: {
          type: this.type,
          name: this.options.name || this.config.get("name") || this.options.host
        },
        ...context,
        query
      });
    }
  }
  exports.Connection = Connection;
});

// node_modules/@mikro-orm/core/connections/index.js
var require_connections = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_Connection(), exports);
});

// node_modules/@mikro-orm/core/naming-strategy/NamingStrategy.js
var require_NamingStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@mikro-orm/core/naming-strategy/AbstractNamingStrategy.js
var require_AbstractNamingStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractNamingStrategy = undefined;

  class AbstractNamingStrategy {
    getClassName(file, separator = "-") {
      const name = file.split(".")[0];
      const ret = name.replace(new RegExp(`${separator}+(\\w)`, "g"), (m2) => m2[1].toUpperCase());
      return ret.charAt(0).toUpperCase() + ret.slice(1);
    }
    classToMigrationName(timestamp, customMigrationName) {
      let migrationName = `Migration${timestamp}`;
      if (customMigrationName) {
        migrationName += `_${customMigrationName}`;
      }
      return migrationName;
    }
    indexName(tableName, columns, type73) {
      if (tableName.includes(".")) {
        tableName = tableName.substring(tableName.indexOf(".") + 1);
      }
      if (type73 === "primary") {
        return `${tableName}_pkey`;
      }
      columns = columns.map((col) => col.replace(/\./g, "_"));
      if (type73 === "sequence") {
        return `${tableName}_${columns.join("_")}_seq`;
      }
      if (columns.length > 0) {
        return `${tableName}_${columns.join("_")}_${type73}`;
      }
      return `${tableName}_${type73}`;
    }
    getEntityName(tableName, schemaName) {
      return this.getClassName(tableName, "_");
    }
    columnNameToProperty(columnName) {
      return columnName.replace(/[_\- ](\w)/g, (m2) => m2[1].toUpperCase()).replace(/[_\- ]+/g, "");
    }
    aliasName(entityName, index) {
      return entityName.charAt(0).toLowerCase() + index;
    }
  }
  exports.AbstractNamingStrategy = AbstractNamingStrategy;
});

// node_modules/@mikro-orm/core/naming-strategy/MongoNamingStrategy.js
var require_MongoNamingStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoNamingStrategy = undefined;
  var AbstractNamingStrategy_1 = require_AbstractNamingStrategy();

  class MongoNamingStrategy extends AbstractNamingStrategy_1.AbstractNamingStrategy {
    classToTableName(entityName) {
      return entityName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    }
    joinColumnName(propertyName) {
      return propertyName;
    }
    joinKeyColumnName(entityName, referencedColumnName) {
      return entityName;
    }
    joinTableName(sourceEntity, targetEntity, propertyName) {
      return this.classToTableName(sourceEntity) + "_" + this.propertyToColumnName(propertyName);
    }
    propertyToColumnName(propertyName) {
      return propertyName;
    }
    referenceColumnName() {
      return "_id";
    }
  }
  exports.MongoNamingStrategy = MongoNamingStrategy;
});

// node_modules/@mikro-orm/core/naming-strategy/UnderscoreNamingStrategy.js
var require_UnderscoreNamingStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnderscoreNamingStrategy = undefined;
  var AbstractNamingStrategy_1 = require_AbstractNamingStrategy();

  class UnderscoreNamingStrategy extends AbstractNamingStrategy_1.AbstractNamingStrategy {
    classToTableName(entityName) {
      return this.underscore(entityName);
    }
    joinColumnName(propertyName) {
      return this.underscore(propertyName) + "_" + this.referenceColumnName();
    }
    joinKeyColumnName(entityName, referencedColumnName) {
      return this.classToTableName(entityName) + "_" + (referencedColumnName || this.referenceColumnName());
    }
    joinTableName(sourceEntity, targetEntity, propertyName) {
      return this.classToTableName(sourceEntity) + "_" + this.classToTableName(propertyName);
    }
    propertyToColumnName(propertyName, object12) {
      return this.underscore(propertyName);
    }
    referenceColumnName() {
      return "id";
    }
    underscore(name) {
      return name.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    }
  }
  exports.UnderscoreNamingStrategy = UnderscoreNamingStrategy;
});

// node_modules/@mikro-orm/core/naming-strategy/EntityCaseNamingStrategy.js
var require_EntityCaseNamingStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntityCaseNamingStrategy = undefined;
  var AbstractNamingStrategy_1 = require_AbstractNamingStrategy();

  class EntityCaseNamingStrategy extends AbstractNamingStrategy_1.AbstractNamingStrategy {
    classToTableName(entityName) {
      return entityName;
    }
    joinColumnName(propertyName) {
      return propertyName;
    }
    joinKeyColumnName(entityName, referencedColumnName, composite4 = false) {
      const name = entityName.substr(0, 1).toLowerCase() + entityName.substr(1);
      if (composite4 && referencedColumnName) {
        return name + "_" + referencedColumnName;
      }
      return name;
    }
    joinTableName(sourceEntity, targetEntity, propertyName) {
      return this.classToTableName(sourceEntity) + "_" + this.propertyToColumnName(propertyName);
    }
    propertyToColumnName(propertyName) {
      return propertyName;
    }
    referenceColumnName() {
      return "id";
    }
  }
  exports.EntityCaseNamingStrategy = EntityCaseNamingStrategy;
});

// node_modules/@mikro-orm/core/naming-strategy/index.js
var require_naming_strategy = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_NamingStrategy(), exports);
  __exportStar(require_AbstractNamingStrategy(), exports);
  __exportStar(require_MongoNamingStrategy(), exports);
  __exportStar(require_UnderscoreNamingStrategy(), exports);
  __exportStar(require_EntityCaseNamingStrategy(), exports);
});

// node_modules/@mikro-orm/core/platforms/ExceptionConverter.js
var require_ExceptionConverter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExceptionConverter = undefined;
  var exceptions_1 = require_exceptions();

  class ExceptionConverter {
    convertException(exception) {
      return new exceptions_1.DriverException(exception);
    }
  }
  exports.ExceptionConverter = ExceptionConverter;
});

// node_modules/@mikro-orm/core/platforms/Platform.js
var require_Platform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Platform = exports.JsonProperty = undefined;
  var clone_1 = require_clone2();
  var entity_1 = require_entity();
  var naming_strategy_1 = require_naming_strategy();
  var ExceptionConverter_1 = require_ExceptionConverter();
  var types_1 = require_types();
  var Utils_1 = require_Utils();
  var enums_1 = require_enums();
  exports.JsonProperty = Symbol("JsonProperty");

  class Platform {
    exceptionConverter = new ExceptionConverter_1.ExceptionConverter;
    config;
    namingStrategy;
    timezone;
    usesPivotTable() {
      return false;
    }
    supportsTransactions() {
      return !this.config.get("disableTransactions");
    }
    usesImplicitTransactions() {
      return true;
    }
    getNamingStrategy() {
      return naming_strategy_1.UnderscoreNamingStrategy;
    }
    usesReturningStatement() {
      return false;
    }
    usesCascadeStatement() {
      return false;
    }
    supportsNativeEnums() {
      return false;
    }
    getSchemaHelper() {
      return;
    }
    indexForeignKeys() {
      return false;
    }
    allowsMultiInsert() {
      return true;
    }
    usesBatchInserts() {
      return true;
    }
    usesBatchUpdates() {
      return true;
    }
    usesDefaultKeyword() {
      return true;
    }
    normalizePrimaryKey(data) {
      return data;
    }
    denormalizePrimaryKey(data) {
      return data;
    }
    getSerializedPrimaryKeyField(field) {
      return field;
    }
    usesDifferentSerializedPrimaryKey() {
      return false;
    }
    getCurrentTimestampSQL(length) {
      return "current_timestamp" + (length ? `(${length})` : "");
    }
    getDateTimeTypeDeclarationSQL(column = { length: 0 }) {
      return "datetime" + (column.length ? `(${column.length})` : "");
    }
    getDefaultDateTimeLength() {
      return 0;
    }
    getDateTypeDeclarationSQL(length) {
      return "date" + (length ? `(${length})` : "");
    }
    getTimeTypeDeclarationSQL(length) {
      return "time" + (length ? `(${length})` : "");
    }
    getRegExpOperator(val, flags) {
      return "regexp";
    }
    getRegExpValue(val) {
      if (val.flags.includes("i")) {
        return { $re: `(?i)${val.source}` };
      }
      return { $re: val.source };
    }
    isAllowedTopLevelOperator(operator) {
      return operator === "$not";
    }
    quoteVersionValue(value14, prop) {
      return value14;
    }
    getDefaultVersionLength() {
      return 3;
    }
    allowsComparingTuples() {
      return true;
    }
    allowsUniqueBatchUpdates() {
      return true;
    }
    isBigIntProperty(prop) {
      return prop.columnTypes && prop.columnTypes[0] === "bigint";
    }
    isRaw(value14) {
      return typeof value14 === "object" && value14 !== null && "__raw" in value14;
    }
    getDefaultSchemaName() {
      return;
    }
    getBooleanTypeDeclarationSQL() {
      return "boolean";
    }
    getIntegerTypeDeclarationSQL(column) {
      return "int";
    }
    getSmallIntTypeDeclarationSQL(column) {
      return "smallint";
    }
    getMediumIntTypeDeclarationSQL(column) {
      return "mediumint";
    }
    getTinyIntTypeDeclarationSQL(column) {
      return "tinyint";
    }
    getBigIntTypeDeclarationSQL(column) {
      return "bigint";
    }
    getVarcharTypeDeclarationSQL(column) {
      return `varchar(${column.length ?? 255})`;
    }
    getIntervalTypeDeclarationSQL(column) {
      return "interval" + (column.length ? `(${column.length})` : "");
    }
    getTextTypeDeclarationSQL(_column) {
      return `text`;
    }
    getEnumTypeDeclarationSQL(column) {
      if (column.items?.every((item) => Utils_1.Utils.isString(item))) {
        return `enum('${column.items.join("','")}')`;
      }
      return this.getTinyIntTypeDeclarationSQL(column);
    }
    getFloatDeclarationSQL() {
      return "float";
    }
    getDoubleDeclarationSQL() {
      return "double";
    }
    getDecimalTypeDeclarationSQL(column) {
      const precision = column.precision ?? 10;
      const scale = column.scale ?? 0;
      return `numeric(${precision},${scale})`;
    }
    getUuidTypeDeclarationSQL(column) {
      column.length ??= 36;
      return this.getVarcharTypeDeclarationSQL(column);
    }
    extractSimpleType(type73) {
      return type73.toLowerCase().match(/[^(), ]+/)[0];
    }
    getMappedType(type73) {
      const mappedType = this.config.get("discovery").getMappedType?.(type73, this);
      return mappedType ?? this.getDefaultMappedType(type73);
    }
    getDefaultMappedType(type73) {
      if (type73.endsWith("[]")) {
        return types_1.Type.getType(types_1.ArrayType);
      }
      switch (this.extractSimpleType(type73)) {
        case "string":
        case "varchar":
          return types_1.Type.getType(types_1.StringType);
        case "interval":
          return types_1.Type.getType(types_1.IntervalType);
        case "text":
          return types_1.Type.getType(types_1.TextType);
        case "number":
          return types_1.Type.getType(types_1.IntegerType);
        case "bigint":
          return types_1.Type.getType(types_1.BigIntType);
        case "smallint":
          return types_1.Type.getType(types_1.SmallIntType);
        case "tinyint":
          return types_1.Type.getType(types_1.TinyIntType);
        case "mediumint":
          return types_1.Type.getType(types_1.MediumIntType);
        case "float":
          return types_1.Type.getType(types_1.FloatType);
        case "double":
          return types_1.Type.getType(types_1.DoubleType);
        case "integer":
          return types_1.Type.getType(types_1.IntegerType);
        case "decimal":
        case "numeric":
          return types_1.Type.getType(types_1.DecimalType);
        case "boolean":
          return types_1.Type.getType(types_1.BooleanType);
        case "blob":
        case "buffer":
          return types_1.Type.getType(types_1.BlobType);
        case "uint8array":
          return types_1.Type.getType(types_1.Uint8ArrayType);
        case "uuid":
          return types_1.Type.getType(types_1.UuidType);
        case "date":
          return types_1.Type.getType(types_1.DateType);
        case "datetime":
          return types_1.Type.getType(types_1.DateTimeType);
        case "timestamp":
          return types_1.Type.getType(types_1.DateTimeType);
        case "time":
          return types_1.Type.getType(types_1.TimeType);
        case "object":
        case "json":
          return types_1.Type.getType(types_1.JsonType);
        case "enum":
          return types_1.Type.getType(types_1.EnumType);
        default:
          return types_1.Type.getType(types_1.UnknownType);
      }
    }
    supportsMultipleStatements() {
      return this.config.get("multipleStatements");
    }
    getArrayDeclarationSQL() {
      return "text";
    }
    marshallArray(values) {
      return values.join(",");
    }
    unmarshallArray(value14) {
      if (value14 === "") {
        return [];
      }
      return value14.split(",");
    }
    getBlobDeclarationSQL() {
      return "blob";
    }
    getJsonDeclarationSQL() {
      return "json";
    }
    getSearchJsonPropertySQL(path, type73, aliased) {
      return path;
    }
    getSearchJsonPropertyKey(path, type73, aliased, value14) {
      return path.join(".");
    }
    getJsonIndexDefinition(index) {
      return index.columnNames;
    }
    getFullTextWhereClause(prop) {
      throw new Error("Full text searching is not supported by this driver.");
    }
    supportsCreatingFullTextIndex() {
      throw new Error("Full text searching is not supported by this driver.");
    }
    getFullTextIndexExpression(indexName, schemaName, tableName, columns) {
      throw new Error("Full text searching is not supported by this driver.");
    }
    convertsJsonAutomatically() {
      return true;
    }
    convertJsonToDatabaseValue(value14, context) {
      return JSON.stringify(value14);
    }
    convertJsonToJSValue(value14) {
      return (0, Utils_1.parseJsonSafe)(value14);
    }
    convertIntervalToJSValue(value14) {
      return value14;
    }
    convertIntervalToDatabaseValue(value14) {
      return value14;
    }
    parseDate(value14) {
      return new Date(value14);
    }
    getRepositoryClass() {
      return entity_1.EntityRepository;
    }
    getDefaultCharset() {
      return "utf8";
    }
    getExceptionConverter() {
      return this.exceptionConverter;
    }
    lookupExtensions(orm) {
    }
    getSchemaGenerator(driver, em) {
      throw new Error(`${driver.constructor.name} does not support SchemaGenerator`);
    }
    processDateProperty(value14) {
      return value14;
    }
    quoteIdentifier(id, quote = "`") {
      return `${quote}${id.toString().replace(".", `${quote}.${quote}`)}${quote}`;
    }
    quoteValue(value14) {
      return value14;
    }
    formatQuery(sql, params) {
      if (params.length === 0) {
        return sql;
      }
      let j = 0;
      let pos = 0;
      let ret = "";
      if (sql[0] === "?") {
        if (sql[1] === "?") {
          ret += this.quoteIdentifier(params[j++]);
          pos = 2;
        } else {
          ret += this.quoteValue(params[j++]);
          pos = 1;
        }
      }
      while (pos < sql.length) {
        const idx = sql.indexOf("?", pos + 1);
        if (idx === -1) {
          ret += sql.substring(pos, sql.length);
          break;
        }
        if (sql.substring(idx - 1, idx + 1) === "\\?") {
          ret += sql.substring(pos, idx - 1) + "?";
          pos = idx + 1;
        } else if (sql.substring(idx, idx + 2) === "??") {
          ret += sql.substring(pos, idx) + this.quoteIdentifier(params[j++]);
          pos = idx + 2;
        } else {
          ret += sql.substring(pos, idx) + this.quoteValue(params[j++]);
          pos = idx + 1;
        }
      }
      return ret;
    }
    cloneEmbeddable(data) {
      const copy = (0, clone_1.clone)(data);
      Object.defineProperty(copy, exports.JsonProperty, { enumerable: false, value: true });
      return copy;
    }
    setConfig(config) {
      this.config = config;
      this.namingStrategy = config.getNamingStrategy();
      if (this.config.get("forceUtcTimezone")) {
        this.timezone = "Z";
      } else {
        this.timezone = this.config.get("timezone");
      }
    }
    getConfig() {
      return this.config;
    }
    getTimezone() {
      return this.timezone;
    }
    isNumericColumn(mappedType) {
      return [types_1.IntegerType, types_1.SmallIntType, types_1.BigIntType].some((t2) => mappedType instanceof t2);
    }
    supportsUnsigned() {
      return false;
    }
    getIndexName(tableName, columns, type73) {
      return this.namingStrategy.indexName(tableName, columns, type73);
    }
    getDefaultPrimaryName(tableName, columns) {
      return this.namingStrategy.indexName(tableName, columns, "primary");
    }
    supportsCustomPrimaryKeyNames() {
      return false;
    }
    isPopulated(key, populate) {
      return populate === true || populate !== false && populate.some((p2) => p2.field === key || p2.all);
    }
    shouldHaveColumn(prop, populate, exclude5, includeFormulas = true) {
      if (exclude5?.includes(prop.name)) {
        return false;
      }
      if (exclude5?.find((k) => k.startsWith(`${prop.name}.`) && !this.isPopulated(prop.name, populate))) {
        return false;
      }
      if (prop.formula) {
        return includeFormulas && (!prop.lazy || this.isPopulated(prop.name, populate));
      }
      if (prop.persist === false) {
        return false;
      }
      if (prop.lazy && (populate === false || populate !== true && !populate.some((p2) => p2.field === prop.name))) {
        return false;
      }
      if ([enums_1.ReferenceKind.SCALAR, enums_1.ReferenceKind.MANY_TO_ONE].includes(prop.kind)) {
        return true;
      }
      if (prop.kind === enums_1.ReferenceKind.EMBEDDED) {
        return !!prop.object;
      }
      return prop.kind === enums_1.ReferenceKind.ONE_TO_ONE && prop.owner;
    }
    supportsDownMigrations() {
      return true;
    }
    validateMetadata(meta) {
      return;
    }
    generateCustomOrder(escapedColumn, values) {
      throw new Error("Not supported");
    }
    castColumn(prop) {
      return "";
    }
    castJsonValue(prop) {
      return "";
    }
    clone() {
      return this;
    }
  }
  exports.Platform = Platform;
});

// node_modules/@mikro-orm/core/platforms/index.js
var require_platforms = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_Platform(), exports);
  __exportStar(require_ExceptionConverter(), exports);
});

// node_modules/@mikro-orm/core/decorators/PrimaryKey.js
var require_PrimaryKey = __commonJS((exports) => {
  var createDecorator = function(options, serialized) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      metadata_1.MetadataValidator.validateSingleDecorator(meta, propertyName, enums_1.ReferenceKind.SCALAR);
      const k = serialized ? "serializedPrimaryKey" : "primary";
      options[k] = true;
      meta.properties[propertyName] = { name: propertyName, kind: enums_1.ReferenceKind.SCALAR, ...options };
      return Utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  var PrimaryKey = function(options = {}) {
    return createDecorator(options, false);
  };
  var SerializedPrimaryKey = function(options = {}) {
    return createDecorator(options, true);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SerializedPrimaryKey = exports.PrimaryKey = undefined;
  var metadata_1 = require_metadata();
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();
  exports.PrimaryKey = PrimaryKey;
  exports.SerializedPrimaryKey = SerializedPrimaryKey;
});

// node_modules/@mikro-orm/core/decorators/Entity.js
var require_Entity = __commonJS((exports) => {
  var Entity = function(options = {}) {
    return function(target) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target);
      utils_1.Utils.mergeConfig(meta, options);
      meta.class = target;
      if (!options.abstract || meta.discriminatorColumn) {
        meta.name = target.name;
      }
      return target;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entity = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  exports.Entity = Entity;
});

// node_modules/@mikro-orm/core/decorators/OneToMany.js
var require_OneToMany = __commonJS((exports) => {
  var createOneToDecorator = function(entity, mappedBy, options, kind) {
    return function(target, propertyName) {
      options = utils_1.Utils.processDecoratorParameters({ entity, mappedBy, options });
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      metadata_1.MetadataValidator.validateSingleDecorator(meta, propertyName, kind);
      const property = { name: propertyName, kind };
      meta.properties[propertyName] = Object.assign(meta.properties[propertyName] ?? {}, property, options);
      return utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  var OneToMany = function(entity, mappedBy, options = {}) {
    return createOneToDecorator(entity, mappedBy, options, enums_1.ReferenceKind.ONE_TO_MANY);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OneToMany = exports.createOneToDecorator = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  var enums_1 = require_enums();
  exports.createOneToDecorator = createOneToDecorator;
  exports.OneToMany = OneToMany;
});

// node_modules/@mikro-orm/core/decorators/OneToOne.js
var require_OneToOne = __commonJS((exports) => {
  var OneToOne = function(entity, mappedByOrOptions, options = {}) {
    const mappedBy = typeof mappedByOrOptions === "object" ? mappedByOrOptions.mappedBy : mappedByOrOptions;
    options = typeof mappedByOrOptions === "object" ? { ...mappedByOrOptions, ...options } : options;
    return (0, OneToMany_1.createOneToDecorator)(entity, mappedBy, options, enums_1.ReferenceKind.ONE_TO_ONE);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OneToOne = undefined;
  var enums_1 = require_enums();
  var OneToMany_1 = require_OneToMany();
  exports.OneToOne = OneToOne;
});

// node_modules/@mikro-orm/core/decorators/ManyToOne.js
var require_ManyToOne = __commonJS((exports) => {
  var ManyToOne = function(entity = {}, options = {}) {
    return function(target, propertyName) {
      options = utils_1.Utils.processDecoratorParameters({ entity, options });
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      metadata_1.MetadataValidator.validateSingleDecorator(meta, propertyName, enums_1.ReferenceKind.MANY_TO_ONE);
      const property = { name: propertyName, kind: enums_1.ReferenceKind.MANY_TO_ONE };
      meta.properties[propertyName] = Object.assign(meta.properties[propertyName] ?? {}, property, options);
      return utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ManyToOne = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  var enums_1 = require_enums();
  exports.ManyToOne = ManyToOne;
});

// node_modules/@mikro-orm/core/decorators/ManyToMany.js
var require_ManyToMany = __commonJS((exports) => {
  var ManyToMany = function(entity, mappedBy, options = {}) {
    return function(target, propertyName) {
      options = utils_1.Utils.processDecoratorParameters({ entity, mappedBy, options });
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      metadata_1.MetadataValidator.validateSingleDecorator(meta, propertyName, enums_1.ReferenceKind.MANY_TO_MANY);
      const property = { name: propertyName, kind: enums_1.ReferenceKind.MANY_TO_MANY };
      meta.properties[propertyName] = Object.assign(meta.properties[propertyName] ?? {}, property, options);
      return utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ManyToMany = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  var enums_1 = require_enums();
  exports.ManyToMany = ManyToMany;
});

// node_modules/@mikro-orm/core/decorators/Property.js
var require_Property = __commonJS((exports) => {
  var Property2 = function(options = {}) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      const desc = Object.getOwnPropertyDescriptor(target, propertyName) || {};
      metadata_1.MetadataValidator.validateSingleDecorator(meta, propertyName, enums_1.ReferenceKind.SCALAR);
      const name = options.name || propertyName;
      if (propertyName !== name && !(desc.value instanceof Function)) {
        utils_1.Utils.renameKey(options, "name", "fieldName");
      }
      options.name = propertyName;
      const { check: check10, ...opts } = options;
      const prop = { kind: enums_1.ReferenceKind.SCALAR, ...opts };
      prop.getter = !!desc.get;
      prop.setter = !!desc.set;
      if (desc.value instanceof Function) {
        prop.getter = true;
        prop.persist = false;
        prop.type = "method";
        prop.getterName = propertyName;
        prop.name = name;
      }
      if (check10) {
        meta.checks.push({ property: prop.name, expression: check10 });
      }
      meta.properties[prop.name] = prop;
      return utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Property = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  var enums_1 = require_enums();
  exports.Property = Property2;
});

// node_modules/@mikro-orm/core/decorators/Check.js
var require_Check = __commonJS((exports) => {
  var Check3 = function(options) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(propertyName ? target.constructor : target);
      options.property ??= propertyName;
      meta.checks.push(options);
      if (!propertyName) {
        return target;
      }
      return Utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Check = undefined;
  var metadata_1 = require_metadata();
  var Utils_1 = require_Utils();
  exports.Check = Check3;
});

// node_modules/@mikro-orm/core/decorators/Enum.js
var require_Enum = __commonJS((exports) => {
  var Enum2 = function(options = {}) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      options = options instanceof Function ? { items: options } : options;
      meta.properties[propertyName] = {
        name: propertyName,
        kind: enums_1.ReferenceKind.SCALAR,
        enum: true,
        ...options
      };
      return Utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Enum = undefined;
  var metadata_1 = require_metadata();
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();
  exports.Enum = Enum2;
});

// node_modules/@mikro-orm/core/decorators/Formula.js
var require_Formula = __commonJS((exports) => {
  var Formula = function(formula, options = {}) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      meta.properties[propertyName] = {
        name: propertyName,
        kind: enums_1.ReferenceKind.SCALAR,
        formula,
        ...options
      };
      return Utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Formula = undefined;
  var metadata_1 = require_metadata();
  var enums_1 = require_enums();
  var Utils_1 = require_Utils();
  exports.Formula = Formula;
});

// node_modules/@mikro-orm/core/decorators/Indexed.js
var require_Indexed = __commonJS((exports) => {
  var createDecorator = function(options, unique) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(propertyName ? target.constructor : target);
      options.properties = options.properties || propertyName;
      const key = unique ? "uniques" : "indexes";
      meta[key].push(options);
      if (!propertyName) {
        return target;
      }
      return Utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  var Index2 = function(options = {}) {
    return createDecorator(options, false);
  };
  var Unique = function(options = {}) {
    return createDecorator(options, true);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unique = exports.Index = undefined;
  var metadata_1 = require_metadata();
  var Utils_1 = require_Utils();
  exports.Index = Index2;
  exports.Unique = Unique;
});

// node_modules/@mikro-orm/core/decorators/Embeddable.js
var require_Embeddable = __commonJS((exports) => {
  var Embeddable = function(options = {}) {
    return function(target) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target);
      meta.class = target;
      meta.name = target.name;
      meta.embeddable = true;
      Object.assign(meta, options);
      return target;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Embeddable = undefined;
  var metadata_1 = require_metadata();
  exports.Embeddable = Embeddable;
});

// node_modules/@mikro-orm/core/decorators/Embedded.js
var require_Embedded = __commonJS((exports) => {
  var Embedded = function(type73 = {}, options = {}) {
    return function(target, propertyName) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      metadata_1.MetadataValidator.validateSingleDecorator(meta, propertyName, enums_1.ReferenceKind.EMBEDDED);
      options = type73 instanceof Function ? { entity: type73, ...options } : { ...type73, ...options };
      utils_1.Utils.defaultValue(options, "prefix", true);
      meta.properties[propertyName] = {
        name: propertyName,
        kind: enums_1.ReferenceKind.EMBEDDED,
        ...options
      };
      return utils_1.Utils.propertyDecoratorReturnValue();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Embedded = undefined;
  var metadata_1 = require_metadata();
  var utils_1 = require_utils10();
  var enums_1 = require_enums();
  exports.Embedded = Embedded;
});

// node_modules/@mikro-orm/core/decorators/Filter.js
var require_Filter = __commonJS((exports) => {
  var Filter = function(options) {
    return function(target) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target);
      meta.filters[options.name] = options;
      return target;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Filter = undefined;
  var metadata_1 = require_metadata();
  exports.Filter = Filter;
});

// node_modules/@mikro-orm/core/decorators/CreateRequestContext.js
var require_CreateRequestContext = __commonJS((exports) => {
  var CreateRequestContext = function(getContext) {
    return function(target, propertyKey, descriptor) {
      const originalMethod = descriptor.value;
      descriptor.value = async function(...args) {
        let orm;
        if (typeof getContext === "function") {
          orm = await (getContext(this) ?? this.orm);
        } else if (getContext) {
          orm = await getContext;
        } else {
          orm = await this.orm;
        }
        if (!(orm instanceof MikroORM_1.MikroORM)) {
          throw new Error("@CreateRequestContext() decorator can only be applied to methods of classes with `orm: MikroORM` property, or with a callback parameter like `@CreateRequestContext(() => orm)`");
        }
        return await RequestContext_1.RequestContext.create(orm.em, () => {
          return originalMethod.apply(this, args);
        });
      };
      return descriptor;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateRequestContext = undefined;
  var MikroORM_1 = require_MikroORM();
  var RequestContext_1 = require_RequestContext();
  exports.CreateRequestContext = CreateRequestContext;
});

// node_modules/@mikro-orm/core/decorators/EnsureRequestContext.js
var require_EnsureRequestContext = __commonJS((exports) => {
  var EnsureRequestContext = function(getContext) {
    return function(target, propertyKey, descriptor) {
      const originalMethod = descriptor.value;
      descriptor.value = async function(...args) {
        if (RequestContext_1.RequestContext.currentRequestContext()) {
          return originalMethod.apply(this, args);
        }
        const orm = getContext instanceof MikroORM_1.MikroORM ? getContext : getContext?.(this) ?? this.orm;
        if (!(orm instanceof MikroORM_1.MikroORM)) {
          throw new Error("@EnsureRequestContext() decorator can only be applied to methods of classes with `orm: MikroORM` property, or with a callback parameter like `@EnsureRequestContext(() => orm)`");
        }
        return await RequestContext_1.RequestContext.create(orm.em, () => {
          return originalMethod.apply(this, args);
        });
      };
      return descriptor;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnsureRequestContext = undefined;
  var MikroORM_1 = require_MikroORM();
  var RequestContext_1 = require_RequestContext();
  exports.EnsureRequestContext = EnsureRequestContext;
});

// node_modules/@mikro-orm/core/decorators/hooks.js
var require_hooks = __commonJS((exports) => {
  var hook = function(type73) {
    return function(target, method) {
      const meta = metadata_1.MetadataStorage.getMetadataFromDecorator(target.constructor);
      if (!meta.hooks[type73]) {
        meta.hooks[type73] = [];
      }
      meta.hooks[type73].push(method);
    };
  };
  var BeforeCreate = function() {
    return hook(enums_1.EventType.beforeCreate);
  };
  var AfterCreate = function() {
    return hook(enums_1.EventType.afterCreate);
  };
  var BeforeUpdate = function() {
    return hook(enums_1.EventType.beforeUpdate);
  };
  var AfterUpdate = function() {
    return hook(enums_1.EventType.afterUpdate);
  };
  var BeforeUpsert = function() {
    return hook(enums_1.EventType.beforeUpsert);
  };
  var AfterUpsert = function() {
    return hook(enums_1.EventType.afterUpsert);
  };
  var OnInit = function() {
    return hook(enums_1.EventType.onInit);
  };
  var OnLoad = function() {
    return hook(enums_1.EventType.onLoad);
  };
  var BeforeDelete = function() {
    return hook(enums_1.EventType.beforeDelete);
  };
  var AfterDelete = function() {
    return hook(enums_1.EventType.afterDelete);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AfterDelete = exports.BeforeDelete = exports.OnLoad = exports.OnInit = exports.AfterUpsert = exports.BeforeUpsert = exports.AfterUpdate = exports.BeforeUpdate = exports.AfterCreate = exports.BeforeCreate = undefined;
  var metadata_1 = require_metadata();
  var enums_1 = require_enums();
  exports.BeforeCreate = BeforeCreate;
  exports.AfterCreate = AfterCreate;
  exports.BeforeUpdate = BeforeUpdate;
  exports.AfterUpdate = AfterUpdate;
  exports.BeforeUpsert = BeforeUpsert;
  exports.AfterUpsert = AfterUpsert;
  exports.OnInit = OnInit;
  exports.OnLoad = OnLoad;
  exports.BeforeDelete = BeforeDelete;
  exports.AfterDelete = AfterDelete;
});

// node_modules/@mikro-orm/core/decorators/index.js
var require_decorators = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OneToMany = undefined;
  __exportStar(require_PrimaryKey(), exports);
  __exportStar(require_Entity(), exports);
  __exportStar(require_OneToOne(), exports);
  __exportStar(require_ManyToOne(), exports);
  __exportStar(require_ManyToMany(), exports);
  var OneToMany_1 = require_OneToMany();
  Object.defineProperty(exports, "OneToMany", { enumerable: true, get: function() {
    return OneToMany_1.OneToMany;
  } });
  __exportStar(require_Property(), exports);
  __exportStar(require_Check(), exports);
  __exportStar(require_Enum(), exports);
  __exportStar(require_Formula(), exports);
  __exportStar(require_Indexed(), exports);
  __exportStar(require_Embeddable(), exports);
  __exportStar(require_Embedded(), exports);
  __exportStar(require_Filter(), exports);
  __exportStar(require_CreateRequestContext(), exports);
  __exportStar(require_EnsureRequestContext(), exports);
  __exportStar(require_hooks(), exports);
});

// node_modules/@mikro-orm/core/index.js
var require_core = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Config = exports.HiddenProps = exports.EagerProps = exports.OptionalProps = exports.EntityRepositoryType = exports.EntityMetadata = exports.PrimaryKeyProp = undefined;
  var typings_1 = require_typings();
  Object.defineProperty(exports, "PrimaryKeyProp", { enumerable: true, get: function() {
    return typings_1.PrimaryKeyProp;
  } });
  Object.defineProperty(exports, "EntityMetadata", { enumerable: true, get: function() {
    return typings_1.EntityMetadata;
  } });
  Object.defineProperty(exports, "EntityRepositoryType", { enumerable: true, get: function() {
    return typings_1.EntityRepositoryType;
  } });
  Object.defineProperty(exports, "OptionalProps", { enumerable: true, get: function() {
    return typings_1.OptionalProps;
  } });
  Object.defineProperty(exports, "EagerProps", { enumerable: true, get: function() {
    return typings_1.EagerProps;
  } });
  Object.defineProperty(exports, "HiddenProps", { enumerable: true, get: function() {
    return typings_1.HiddenProps;
  } });
  Object.defineProperty(exports, "Config", { enumerable: true, get: function() {
    return typings_1.Config;
  } });
  __exportStar(require_enums(), exports);
  __exportStar(require_errors3(), exports);
  __exportStar(require_exceptions(), exports);
  __exportStar(require_MikroORM(), exports);
  __exportStar(require_entity(), exports);
  __exportStar(require_serialization(), exports);
  __exportStar(require_events2(), exports);
  __exportStar(require_EntityManager(), exports);
  __exportStar(require_unit_of_work(), exports);
  __exportStar(require_utils10(), exports);
  __exportStar(require_logging(), exports);
  __exportStar(require_hydration(), exports);
  __exportStar(require_drivers(), exports);
  __exportStar(require_connections(), exports);
  __exportStar(require_platforms(), exports);
  __exportStar(require_types(), exports);
  __exportStar(require_naming_strategy(), exports);
  __exportStar(require_metadata(), exports);
  __exportStar(require_cache2(), exports);
  __exportStar(require_decorators(), exports);
});

// node_modules/@mikro-orm/mongodb/MongoConnection.js
var require_MongoConnection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoConnection = undefined;
  var mongodb_1 = require_lib3();
  var bson_1 = require_bson();
  var util_1 = import.meta.require("util");
  var core_1 = require_core();

  class MongoConnection extends core_1.Connection {
    client;
    db;
    constructor(config, options, type73 = "write") {
      super(config, options, type73);
      bson_1.ObjectId.prototype[util_1.inspect.custom] = function() {
        return `ObjectId('${this.toHexString()}')`;
      };
      Date.prototype[util_1.inspect.custom] = function() {
        return `ISODate('${this.toISOString()}')`;
      };
    }
    async connect() {
      const driverOptions = this.config.get("driverOptions");
      if (driverOptions instanceof mongodb_1.MongoClient) {
        this.logger.log("info", "Reusing MongoClient provided via `driverOptions`");
        this.client = driverOptions;
      } else {
        this.client = new mongodb_1.MongoClient(this.config.getClientUrl(), this.getConnectionOptions());
        await this.client.connect();
      }
      this.db = this.client.db(this.config.get("dbName"));
      this.connected = true;
    }
    async close(force) {
      await this.client?.close(!!force);
      this.connected = false;
    }
    async isConnected() {
      try {
        const res = await this.db?.command({ ping: 1 });
        return this.connected = !!res.ok;
      } catch (error21) {
        return this.connected = false;
      }
    }
    async checkConnection() {
      try {
        const res = await this.db?.command({ ping: 1 });
        return { ok: !!res.ok };
      } catch (error21) {
        return { ok: false, reason: error21.message, error: error21 };
      }
    }
    getClient() {
      return this.client;
    }
    getCollection(name) {
      return this.db.collection(this.getCollectionName(name));
    }
    async createCollection(name) {
      return this.db.createCollection(this.getCollectionName(name));
    }
    async listCollections() {
      const collections = await this.db.listCollections({}, { nameOnly: true }).toArray();
      return collections.map((c2) => c2.name);
    }
    async dropCollection(name) {
      return this.db.dropCollection(this.getCollectionName(name));
    }
    getDefaultClientUrl() {
      return "mongodb://127.0.0.1:27017";
    }
    getConnectionOptions() {
      const ret = {};
      const pool = this.config.get("pool");
      const username = this.config.get("user");
      const password = this.config.get("password");
      if (this.config.get("host")) {
        throw new core_1.ValidationError("Mongo driver does not support `host` options, use `clientUrl` instead!");
      }
      if (username && password) {
        ret.auth = { username, password };
      }
      if (pool.min) {
        ret.minPoolSize = pool.min;
      }
      if (pool.max) {
        ret.maxPoolSize = pool.max;
      }
      return core_1.Utils.mergeConfig(ret, this.config.get("driverOptions"));
    }
    getClientUrl() {
      const options = this.getConnectionOptions();
      const clientUrl = this.config.getClientUrl(true);
      const match = clientUrl.match(/^(\w+):\/\/((.*@.+)|.+)$/);
      return match ? `${match[1]}://${options.auth ? options.auth.username + ":*****@" : ""}${match[2]}` : clientUrl;
    }
    getDb() {
      return this.db;
    }
    async execute(query) {
      throw new Error(`${this.constructor.name} does not support generic execute method`);
    }
    async find(collection, where, orderBy, limit, offset, fields, ctx, loggerContext) {
      await this.ensureConnection();
      collection = this.getCollectionName(collection);
      const options = ctx ? { session: ctx } : {};
      if (fields) {
        options.projection = fields.reduce((o2, k) => ({ ...o2, [k]: 1 }), {});
      }
      const resultSet = this.getCollection(collection).find(where, options);
      let query = `db.getCollection('${collection}').find(${this.logObject(where)}, ${this.logObject(options)})`;
      orderBy = core_1.Utils.asArray(orderBy);
      if (Array.isArray(orderBy) && orderBy.length > 0) {
        const orderByTuples = [];
        orderBy.forEach((o2) => {
          core_1.Utils.keys(o2).forEach((k) => {
            const direction = o2[k];
            orderByTuples.push([k.toString(), core_1.Utils.isString(direction) ? direction.toUpperCase() === core_1.QueryOrder.ASC ? 1 : -1 : direction]);
          });
        });
        if (orderByTuples.length > 0) {
          query += `.sort(${this.logObject(orderByTuples)})`;
          resultSet.sort(orderByTuples);
        }
      }
      if (limit !== undefined) {
        query += `.limit(${limit})`;
        resultSet.limit(limit);
      }
      if (offset !== undefined) {
        query += `.skip(${offset})`;
        resultSet.skip(offset);
      }
      const now = Date.now();
      const res = await resultSet.toArray();
      this.logQuery(`${query}.toArray();`, { took: Date.now() - now, results: res.length, ...loggerContext });
      return res;
    }
    async insertOne(collection, data, ctx) {
      return this.runQuery("insertOne", collection, data, undefined, ctx);
    }
    async insertMany(collection, data, ctx) {
      return this.runQuery("insertMany", collection, data, undefined, ctx);
    }
    async updateMany(collection, where, data, ctx, upsert, upsertOptions) {
      return this.runQuery("updateMany", collection, data, where, ctx, upsert, upsertOptions);
    }
    async bulkUpdateMany(collection, where, data, ctx, upsert, upsertOptions) {
      return this.runQuery("bulkUpdateMany", collection, data, where, ctx, upsert, upsertOptions);
    }
    async deleteMany(collection, where, ctx) {
      return this.runQuery("deleteMany", collection, undefined, where, ctx);
    }
    async aggregate(collection, pipeline, ctx, loggerContext) {
      await this.ensureConnection();
      collection = this.getCollectionName(collection);
      const options = ctx ? { session: ctx } : {};
      const query = `db.getCollection('${collection}').aggregate(${this.logObject(pipeline)}, ${this.logObject(options)}).toArray();`;
      const now = Date.now();
      const res = await this.getCollection(collection).aggregate(pipeline, options).toArray();
      this.logQuery(query, { took: Date.now() - now, results: res.length, ...loggerContext });
      return res;
    }
    async countDocuments(collection, where, ctx) {
      return this.runQuery("countDocuments", collection, undefined, where, ctx);
    }
    async transactional(cb, options = {}) {
      await this.ensureConnection();
      const session = await this.begin(options);
      try {
        const ret = await cb(session);
        await this.commit(session, options.eventBroadcaster);
        return ret;
      } catch (error21) {
        await this.rollback(session, options.eventBroadcaster);
        throw error21;
      } finally {
        await session.endSession();
      }
    }
    async begin(options = {}) {
      await this.ensureConnection();
      const { ctx, isolationLevel, eventBroadcaster, ...txOptions } = options;
      if (!ctx) {
        await eventBroadcaster?.dispatchEvent(core_1.EventType.beforeTransactionStart);
      }
      const session = ctx || this.client.startSession();
      session.startTransaction(txOptions);
      this.logQuery("db.begin();");
      await eventBroadcaster?.dispatchEvent(core_1.EventType.afterTransactionStart, session);
      return session;
    }
    async commit(ctx, eventBroadcaster) {
      await this.ensureConnection();
      await eventBroadcaster?.dispatchEvent(core_1.EventType.beforeTransactionCommit, ctx);
      await ctx.commitTransaction();
      this.logQuery("db.commit();");
      await eventBroadcaster?.dispatchEvent(core_1.EventType.afterTransactionCommit, ctx);
    }
    async rollback(ctx, eventBroadcaster) {
      await this.ensureConnection();
      await eventBroadcaster?.dispatchEvent(core_1.EventType.beforeTransactionRollback, ctx);
      await ctx.abortTransaction();
      this.logQuery("db.rollback();");
      await eventBroadcaster?.dispatchEvent(core_1.EventType.afterTransactionRollback, ctx);
    }
    async runQuery(method, collection, data, where, ctx, upsert, upsertOptions, loggerContext) {
      await this.ensureConnection();
      collection = this.getCollectionName(collection);
      const logger = this.config.getLogger();
      const options = ctx ? { session: ctx, upsert } : { upsert };
      if (options.upsert === undefined) {
        delete options.upsert;
      }
      const now = Date.now();
      let res;
      let query;
      const log = (msg) => logger.isEnabled("query") ? msg() : "";
      switch (method) {
        case "insertOne":
          Object.keys(data).filter((k) => typeof data[k] === "undefined").forEach((k) => delete data[k]);
          query = log(() => `db.getCollection('${collection}').insertOne(${this.logObject(data)}, ${this.logObject(options)});`);
          res = await this.rethrow(this.getCollection(collection).insertOne(data, options), query);
          break;
        case "insertMany":
          data.forEach((data2) => Object.keys(data2).filter((k) => typeof data2[k] === "undefined").forEach((k) => delete data2[k]));
          query = log(() => `db.getCollection('${collection}').insertMany(${this.logObject(data)}, ${this.logObject(options)});`);
          res = await this.rethrow(this.getCollection(collection).insertMany(data, options), query);
          break;
        case "updateMany": {
          const payload = Object.keys(data).some((k) => k.startsWith("$")) ? data : this.createUpdatePayload(data, upsertOptions);
          query = log(() => `db.getCollection('${collection}').updateMany(${this.logObject(where)}, ${this.logObject(payload)}, ${this.logObject(options)});`);
          res = await this.rethrow(this.getCollection(collection).updateMany(where, payload, options), query);
          break;
        }
        case "bulkUpdateMany": {
          query = log(() => `bulk = db.getCollection('${collection}').initializeUnorderedBulkOp(${this.logObject(options)});\n`);
          const bulk = this.getCollection(collection).initializeUnorderedBulkOp(options);
          data.forEach((row, idx) => {
            const id = where[idx];
            const cond = core_1.Utils.isPlainObject(id) ? id : { _id: id };
            const doc = this.createUpdatePayload(row, upsertOptions);
            if (upsert) {
              query += log(() => `bulk.find(${this.logObject(cond)}).upsert().update(${this.logObject(doc)});\n`);
              bulk.find(cond).upsert().update(doc);
              return;
            }
            query += log(() => `bulk.find(${this.logObject(cond)}).update(${this.logObject(doc)});\n`);
            bulk.find(cond).update(doc);
          });
          query += log(() => `bulk.execute()`);
          res = await this.rethrow(bulk.execute(), query);
          break;
        }
        case "deleteMany":
        case "countDocuments":
          query = log(() => `db.getCollection('${collection}').${method}(${this.logObject(where)}, ${this.logObject(options)});`);
          res = await this.rethrow(this.getCollection(collection)[method](where, options), query);
          break;
      }
      this.logQuery(query, { took: Date.now() - now, ...loggerContext });
      if (method === "countDocuments") {
        return res;
      }
      return this.transformResult(res);
    }
    rethrow(promise4, query) {
      return promise4.catch((e2) => {
        this.logQuery(query, { level: "error" });
        e2.message += "\nQuery: " + query;
        throw e2;
      });
    }
    createUpdatePayload(row, upsertOptions) {
      const doc = { $set: row };
      const $unset = {};
      core_1.Utils.keys(row).filter((k) => typeof row[k] === "undefined").forEach((k) => {
        $unset[k] = "";
        delete row[k];
      });
      if (upsertOptions) {
        if (upsertOptions.onConflictAction === "ignore") {
          doc.$setOnInsert = doc.$set;
          delete doc.$set;
        }
        if (upsertOptions.onConflictMergeFields) {
          doc.$setOnInsert = {};
          upsertOptions.onConflictMergeFields.forEach((f) => {
            doc.$setOnInsert[f] = doc.$set[f];
            delete doc.$set[f];
          });
          const { $set, $setOnInsert } = doc;
          doc.$set = $setOnInsert;
          doc.$setOnInsert = $set;
        } else if (upsertOptions.onConflictExcludeFields) {
          doc.$setOnInsert = {};
          upsertOptions.onConflictExcludeFields.forEach((f) => {
            doc.$setOnInsert[f] = doc.$set[f];
            delete doc.$set[f];
          });
        }
      }
      if (core_1.Utils.hasObjectKeys($unset)) {
        doc.$unset = $unset;
        if (!core_1.Utils.hasObjectKeys(doc.$set)) {
          delete doc.$set;
        }
      }
      return doc;
    }
    transformResult(res) {
      return {
        affectedRows: res.modifiedCount || res.deletedCount || res.insertedCount || 0,
        insertId: res.insertedId ?? res.insertedIds?.[0],
        insertedIds: res.insertedIds ? Object.values(res.insertedIds) : undefined
      };
    }
    getCollectionName(name) {
      name = core_1.Utils.className(name);
      const meta = this.metadata.find(name);
      return meta ? meta.collection : name;
    }
    logObject(o2) {
      if (o2.session) {
        o2 = { ...o2, session: `[ClientSession]` };
      }
      return (0, util_1.inspect)(o2, { depth: 5, compact: true, breakLength: 300 });
    }
  }
  exports.MongoConnection = MongoConnection;
});

// node_modules/@mikro-orm/mongodb/MongoExceptionConverter.js
var require_MongoExceptionConverter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoExceptionConverter = undefined;
  var core_1 = require_core();

  class MongoExceptionConverter extends core_1.ExceptionConverter {
    convertException(exception) {
      switch (exception.code) {
        case 48:
          return new core_1.TableExistsException(exception);
        case 11000:
          return new core_1.UniqueConstraintViolationException(exception);
      }
      return super.convertException(exception);
    }
  }
  exports.MongoExceptionConverter = MongoExceptionConverter;
});

// node_modules/@mikro-orm/mongodb/MongoEntityRepository.js
var require_MongoEntityRepository = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoEntityRepository = undefined;
  var core_1 = require_core();

  class MongoEntityRepository extends core_1.EntityRepository {
    em;
    constructor(em, entityName) {
      super(em, entityName);
      this.em = em;
    }
    async aggregate(pipeline) {
      return this.getEntityManager().aggregate(this.entityName, pipeline);
    }
    getCollection() {
      return this.getEntityManager().getCollection(this.entityName);
    }
    getEntityManager() {
      return this.em;
    }
  }
  exports.MongoEntityRepository = MongoEntityRepository;
});

// node_modules/@mikro-orm/mongodb/MongoSchemaGenerator.js
var require_MongoSchemaGenerator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoSchemaGenerator = undefined;
  var core_1 = require_core();

  class MongoSchemaGenerator extends core_1.AbstractSchemaGenerator {
    static register(orm) {
      orm.config.registerExtension("@mikro-orm/schema-generator", () => new MongoSchemaGenerator(orm.em));
    }
    async createSchema(options = {}) {
      options.ensureIndexes ??= true;
      const existing = await this.connection.listCollections();
      const metadata = this.getOrderedMetadata();
      metadata.push({ collection: this.config.get("migrations").tableName });
      const promises = metadata.filter((meta) => !existing.includes(meta.collection)).map((meta) => this.connection.createCollection(meta.collection).catch((err) => {
        const existsErrorMessage = `Collection ${this.config.get("dbName")}.${meta.collection} already exists.`;
        if (!(err.name === "MongoServerError" && err.message.includes(existsErrorMessage))) {
          throw err;
        }
      }));
      if (options.ensureIndexes) {
        await this.ensureIndexes({ ensureCollections: false });
      }
      await Promise.all(promises);
    }
    async dropSchema(options = {}) {
      const db = this.connection.getDb();
      const collections = await db.listCollections().toArray();
      const existing = collections.map((c2) => c2.name);
      const metadata = this.getOrderedMetadata();
      if (options.dropMigrationsTable) {
        metadata.push({ collection: this.config.get("migrations").tableName });
      }
      const promises = metadata.filter((meta) => existing.includes(meta.collection)).map((meta) => this.connection.dropCollection(meta.collection));
      await Promise.all(promises);
    }
    async updateSchema(options = {}) {
      await this.createSchema(options);
    }
    async ensureDatabase() {
      return false;
    }
    async refreshDatabase(options = {}) {
      await this.ensureDatabase();
      await this.dropSchema();
      await this.createSchema(options);
    }
    async dropIndexes(options) {
      const db = this.connection.getDb();
      const collections = await db.listCollections().toArray();
      const promises = [];
      for (const collection of collections) {
        if (options?.collectionsWithFailedIndexes && !options.collectionsWithFailedIndexes.includes(collection.name)) {
          continue;
        }
        const indexes = await db.collection(collection.name).listIndexes().toArray();
        for (const index of indexes) {
          const isIdIndex = index.key._id === 1 && core_1.Utils.getObjectKeysSize(index.key) === 1;
          if (!isIdIndex && !options?.skipIndexes?.find((idx) => idx.collection === collection.name && idx.indexName === index.name)) {
            promises.push(db.collection(collection.name).dropIndex(index.name));
          }
        }
      }
      await Promise.all(promises);
    }
    async ensureIndexes(options = {}) {
      options.ensureCollections ??= true;
      options.retryLimit ??= 3;
      if (options.ensureCollections) {
        await this.createSchema({ ensureIndexes: false });
      }
      const promises = [];
      for (const meta of this.getOrderedMetadata()) {
        if (Array.isArray(options?.retry) && !options.retry.includes(meta.collection)) {
          continue;
        }
        promises.push(...this.createIndexes(meta));
        promises.push(...this.createUniqueIndexes(meta));
        for (const prop of meta.props) {
          promises.push(...this.createPropertyIndexes(meta, prop, "index"));
          promises.push(...this.createPropertyIndexes(meta, prop, "unique"));
        }
      }
      const res = await Promise.allSettled(promises.map((p2) => p2[1]));
      if (res.some((r) => r.status === "rejected") && options.retry !== false) {
        const skipIndexes = [];
        const collectionsWithFailedIndexes = [];
        for (let i2 = 0;i2 < res.length; i2++) {
          const r = res[i2];
          if (r.status === "rejected") {
            collectionsWithFailedIndexes.push(promises[i2][0]);
          } else {
            skipIndexes.push({ collection: promises[i2][0], indexName: r.value });
          }
        }
        await this.dropIndexes({ skipIndexes, collectionsWithFailedIndexes });
        if (options.retryLimit === 0) {
          throw new Error(`Failed to create indexes: ${collectionsWithFailedIndexes.join(", ")}`);
        }
        await this.ensureIndexes({
          retry: collectionsWithFailedIndexes,
          retryLimit: options.retryLimit - 1
        });
      }
    }
    createIndexes(meta) {
      const res = [];
      meta.indexes.forEach((index) => {
        let fieldOrSpec;
        const properties = core_1.Utils.flatten(core_1.Utils.asArray(index.properties).map((prop) => meta.properties[prop].fieldNames));
        const collection = this.connection.getCollection(meta.className);
        if (Array.isArray(index.options) && index.options.length === 2 && properties.length === 0) {
          res.push([collection.collectionName, collection.createIndex(index.options[0], index.options[1])]);
          return;
        }
        if (index.options && properties.length === 0) {
          res.push([collection.collectionName, collection.createIndex(index.options)]);
          return;
        }
        if (index.type) {
          if (index.type === "fulltext") {
            index.type = "text";
          }
          const spec = {};
          properties.forEach((prop) => spec[prop] = index.type);
          fieldOrSpec = spec;
        } else {
          fieldOrSpec = properties.reduce((o2, i2) => {
            o2[i2] = 1;
            return o2;
          }, {});
        }
        res.push([collection.collectionName, collection.createIndex(fieldOrSpec, {
          name: index.name,
          unique: false,
          ...index.options || {}
        })]);
      });
      return res;
    }
    createUniqueIndexes(meta) {
      const res = [];
      meta.uniques.forEach((index) => {
        const properties = core_1.Utils.flatten(core_1.Utils.asArray(index.properties).map((prop) => meta.properties[prop].fieldNames));
        const fieldOrSpec = properties.reduce((o2, i2) => {
          o2[i2] = 1;
          return o2;
        }, {});
        const collection = this.connection.getCollection(meta.className);
        res.push([collection.collectionName, collection.createIndex(fieldOrSpec, {
          name: index.name,
          unique: true,
          ...index.options || {}
        })]);
      });
      return res;
    }
    createPropertyIndexes(meta, prop, type73) {
      if (!prop[type73] || !meta.collection) {
        return [];
      }
      const collection = this.connection.getCollection(meta.className);
      const fieldOrSpec = prop.embeddedPath ? prop.embeddedPath.join(".") : prop.fieldNames.reduce((o2, i2) => {
        o2[i2] = 1;
        return o2;
      }, {});
      return [[collection.collectionName, collection.createIndex(fieldOrSpec, {
        name: core_1.Utils.isString(prop[type73]) ? prop[type73] : undefined,
        unique: type73 === "unique",
        sparse: prop.nullable === true
      })]];
    }
  }
  exports.MongoSchemaGenerator = MongoSchemaGenerator;
});

// node_modules/@mikro-orm/mongodb/MongoPlatform.js
var require_MongoPlatform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoPlatform = undefined;
  var bson_1 = require_bson();
  var core_1 = require_core();
  var MongoExceptionConverter_1 = require_MongoExceptionConverter();
  var MongoEntityRepository_1 = require_MongoEntityRepository();
  var MongoSchemaGenerator_1 = require_MongoSchemaGenerator();

  class MongoPlatform extends core_1.Platform {
    exceptionConverter = new MongoExceptionConverter_1.MongoExceptionConverter;
    setConfig(config) {
      config.set("autoJoinOneToOneOwner", false);
      config.set("loadStrategy", "select-in");
      config.get("discovery").inferDefaultValues = false;
      super.setConfig(config);
    }
    getNamingStrategy() {
      return core_1.MongoNamingStrategy;
    }
    getRepositoryClass() {
      return MongoEntityRepository_1.MongoEntityRepository;
    }
    lookupExtensions(orm) {
      MongoSchemaGenerator_1.MongoSchemaGenerator.register(orm);
    }
    getSchemaGenerator(driver, em) {
      return new MongoSchemaGenerator_1.MongoSchemaGenerator(em ?? driver);
    }
    normalizePrimaryKey(data) {
      if (data instanceof bson_1.ObjectId) {
        return data.toHexString();
      }
      return data;
    }
    denormalizePrimaryKey(data) {
      return new bson_1.ObjectId(data);
    }
    getSerializedPrimaryKeyField(field) {
      return "id";
    }
    usesDifferentSerializedPrimaryKey() {
      return true;
    }
    usesImplicitTransactions() {
      return false;
    }
    convertsJsonAutomatically() {
      return true;
    }
    convertJsonToDatabaseValue(value14) {
      return value14;
    }
    convertJsonToJSValue(value14) {
      return value14;
    }
    marshallArray(values) {
      return values;
    }
    cloneEmbeddable(data) {
      const ret = super.cloneEmbeddable(data);
      core_1.Utils.dropUndefinedProperties(ret);
      return ret;
    }
    shouldHaveColumn(prop, populate, exclude5) {
      if (super.shouldHaveColumn(prop, populate, exclude5)) {
        return true;
      }
      return prop.kind === core_1.ReferenceKind.MANY_TO_MANY && prop.owner;
    }
    validateMetadata(meta) {
      const pk = meta.getPrimaryProps()[0];
      if (pk && pk.fieldNames?.[0] !== "_id") {
        throw core_1.MetadataError.invalidPrimaryKey(meta, pk, "_id");
      }
    }
    isAllowedTopLevelOperator(operator) {
      return ["$not", "$fulltext"].includes(operator);
    }
  }
  exports.MongoPlatform = MongoPlatform;
});

// node_modules/@mikro-orm/mongodb/MongoEntityManager.js
var require_MongoEntityManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoEntityManager = undefined;
  var core_1 = require_core();

  class MongoEntityManager extends core_1.EntityManager {
    async aggregate(entityName, pipeline) {
      entityName = core_1.Utils.className(entityName);
      return this.getDriver().aggregate(entityName, pipeline);
    }
    getCollection(entityName) {
      return this.getConnection().getCollection(entityName);
    }
    getRepository(entityName) {
      return super.getRepository(entityName);
    }
    async begin(options = {}) {
      return super.begin(options);
    }
    async transactional(cb, options = {}) {
      return super.transactional(cb, options);
    }
  }
  exports.MongoEntityManager = MongoEntityManager;
});

// node_modules/@mikro-orm/mongodb/MongoDriver.js
var require_MongoDriver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDriver = undefined;
  var bson_1 = require_bson();
  var core_1 = require_core();
  var MongoConnection_1 = require_MongoConnection();
  var MongoPlatform_1 = require_MongoPlatform();
  var MongoEntityManager_1 = require_MongoEntityManager();

  class MongoDriver extends core_1.DatabaseDriver {
    [core_1.EntityManagerType];
    connection = new MongoConnection_1.MongoConnection(this.config);
    platform = new MongoPlatform_1.MongoPlatform;
    constructor(config) {
      super(config, ["mongodb"]);
    }
    createEntityManager(useContext) {
      const EntityManagerClass = this.config.get("entityManager", MongoEntityManager_1.MongoEntityManager);
      return new EntityManagerClass(this.config, this, this.metadata, useContext);
    }
    async find(entityName, where, options = {}) {
      if (this.metadata.find(entityName)?.virtual) {
        return this.findVirtual(entityName, where, options);
      }
      const { first, last, before, after } = options;
      const fields = this.buildFields(entityName, options.populate || [], options.fields, options.exclude);
      where = this.renameFields(entityName, where, true);
      const isCursorPagination = [first, last, before, after].some((v2) => v2 != null);
      if (isCursorPagination) {
        const andWhere = (cond1, cond2) => {
          if (core_1.Utils.isEmpty(cond1)) {
            return cond2;
          }
          if (core_1.Utils.isEmpty(cond2)) {
            return cond1;
          }
          return { $and: [cond1, cond2] };
        };
        const meta = this.metadata.find(entityName);
        const { orderBy: newOrderBy, where: newWhere } = this.processCursorOptions(meta, options, options.orderBy);
        const newWhereConverted = this.renameFields(entityName, newWhere, true);
        const orderBy2 = core_1.Utils.asArray(newOrderBy).map((order) => this.renameFields(entityName, order));
        const res2 = await this.rethrow(this.getConnection("read").find(entityName, andWhere(where, newWhereConverted), orderBy2, options.limit, options.offset, fields, options.ctx, options.logging));
        if (isCursorPagination && !first && !!last) {
          res2.reverse();
        }
        return res2.map((r) => this.mapResult(r, this.metadata.find(entityName)));
      }
      const orderBy = core_1.Utils.asArray(options.orderBy).map((orderBy2) => this.renameFields(entityName, orderBy2, false));
      const res = await this.rethrow(this.getConnection("read").find(entityName, where, orderBy, options.limit, options.offset, fields, options.ctx));
      return res.map((r) => this.mapResult(r, this.metadata.find(entityName)));
    }
    async findOne(entityName, where, options = { populate: [], orderBy: {} }) {
      if (this.metadata.find(entityName)?.virtual) {
        const [item] = await this.findVirtual(entityName, where, options);
        return item ?? null;
      }
      if (core_1.Utils.isPrimaryKey(where)) {
        where = this.buildFilterById(entityName, where);
      }
      const fields = this.buildFields(entityName, options.populate || [], options.fields, options.exclude);
      where = this.renameFields(entityName, where, true);
      const orderBy = core_1.Utils.asArray(options.orderBy).map((orderBy2) => this.renameFields(entityName, orderBy2, false));
      const res = await this.rethrow(this.getConnection("read").find(entityName, where, orderBy, 1, undefined, fields, options.ctx, options.logging));
      return this.mapResult(res[0], this.metadata.find(entityName));
    }
    async findVirtual(entityName, where, options) {
      const meta = this.metadata.find(entityName);
      if (meta.expression instanceof Function) {
        const em = this.createEntityManager();
        return meta.expression(em, where, options);
      }
      return super.findVirtual(entityName, where, options);
    }
    async count(entityName, where, options = {}, ctx) {
      if (this.metadata.find(entityName)?.virtual) {
        return this.countVirtual(entityName, where, options);
      }
      where = this.renameFields(entityName, where, true);
      return this.rethrow(this.getConnection("read").countDocuments(entityName, where, ctx));
    }
    async nativeInsert(entityName, data, options = {}) {
      data = this.renameFields(entityName, data);
      return this.rethrow(this.getConnection("write").insertOne(entityName, data, options.ctx));
    }
    async nativeInsertMany(entityName, data, options = {}) {
      data = data.map((d2) => this.renameFields(entityName, d2));
      const meta = this.metadata.find(entityName);
      const pk = meta?.getPrimaryProps()[0].fieldNames[0] ?? "_id";
      const res = await this.rethrow(this.getConnection("write").insertMany(entityName, data, options.ctx));
      res.rows = res.insertedIds.map((id) => ({ [pk]: id }));
      return res;
    }
    async nativeUpdate(entityName, where, data, options = {}) {
      if (core_1.Utils.isPrimaryKey(where)) {
        where = this.buildFilterById(entityName, where);
      }
      where = this.renameFields(entityName, where, true);
      data = this.renameFields(entityName, data);
      options = { ...options };
      const meta = this.metadata.find(entityName);
      const rename = (field) => meta ? meta.properties[field]?.fieldNames[0] ?? field : field;
      if (options.onConflictFields) {
        options.onConflictFields = options.onConflictFields.map(rename);
      }
      if (options.onConflictMergeFields) {
        options.onConflictMergeFields = options.onConflictMergeFields.map(rename);
      }
      if (options.onConflictExcludeFields) {
        options.onConflictExcludeFields = options.onConflictExcludeFields.map(rename);
      }
      return this.rethrow(this.getConnection("write").updateMany(entityName, where, data, options.ctx, options.upsert, options));
    }
    async nativeUpdateMany(entityName, where, data, options = {}) {
      where = where.map((row) => {
        if (core_1.Utils.isPlainObject(row)) {
          return this.renameFields(entityName, row, true);
        }
        return row;
      });
      data = data.map((row) => this.renameFields(entityName, row));
      options = { ...options };
      const meta = this.metadata.find(entityName);
      const rename = (field) => meta ? meta.properties[field]?.fieldNames[0] ?? field : field;
      if (options.onConflictFields) {
        options.onConflictFields = options.onConflictFields.map(rename);
      }
      if (options.onConflictMergeFields) {
        options.onConflictMergeFields = options.onConflictMergeFields.map(rename);
      }
      if (options.onConflictExcludeFields) {
        options.onConflictExcludeFields = options.onConflictExcludeFields.map(rename);
      }
      return this.rethrow(this.getConnection("write").bulkUpdateMany(entityName, where, data, options.ctx, options.upsert, options));
    }
    async nativeDelete(entityName, where, options = {}) {
      if (core_1.Utils.isPrimaryKey(where)) {
        where = this.buildFilterById(entityName, where);
      }
      where = this.renameFields(entityName, where, true);
      return this.rethrow(this.getConnection("write").deleteMany(entityName, where, options.ctx));
    }
    async aggregate(entityName, pipeline, ctx) {
      return this.rethrow(this.getConnection("read").aggregate(entityName, pipeline, ctx));
    }
    getPlatform() {
      return this.platform;
    }
    renameFields(entityName, data, where = false, object12) {
      const copiedData = Object.assign({}, data);
      const meta = this.metadata.find(entityName);
      if (meta?.serializedPrimaryKey && !meta.embeddable && meta.serializedPrimaryKey !== meta.primaryKeys[0]) {
        core_1.Utils.renameKey(copiedData, meta.serializedPrimaryKey, meta.primaryKeys[0]);
      }
      if (meta && !meta.embeddable) {
        this.inlineEmbeddables(meta, copiedData, where);
      }
      if (copiedData.$and) {
        for (let i2 = 0;i2 < copiedData.$and.length; i2++) {
          const and = copiedData.$and[i2];
          if ("$fulltext" in and) {
            if ("$fulltext" in copiedData) {
              throw new Error("Cannot merge multiple $fulltext conditions to top level of the query object.");
            }
            copiedData.$fulltext = and.$fulltext;
            delete and.$fulltext;
          }
        }
      }
      if ("$fulltext" in copiedData) {
        copiedData.$text = { $search: copiedData.$fulltext };
        delete copiedData.$fulltext;
      }
      if (core_1.Utils.hasNestedKey(copiedData, "$fulltext")) {
        throw new Error("Full text search is only supported on the top level of the query object.");
      }
      core_1.Utils.keys(copiedData).forEach((k) => {
        if (core_1.Utils.isGroupOperator(k)) {
          if (Array.isArray(copiedData[k])) {
            copiedData[k] = copiedData[k].map((v2) => this.renameFields(entityName, v2));
          } else {
            copiedData[k] = this.renameFields(entityName, copiedData[k]);
          }
          return;
        }
        if (meta?.properties[k]) {
          const prop = meta.properties[k];
          let isObjectId = false;
          if (prop.kind === core_1.ReferenceKind.SCALAR) {
            isObjectId = prop.type.toLowerCase() === "objectid";
          } else if (prop.kind === core_1.ReferenceKind.EMBEDDED) {
            if (copiedData[prop.name] == null) {
              return;
            }
            if (prop.array && Array.isArray(copiedData[prop.name])) {
              copiedData[prop.name] = copiedData[prop.name].map((item) => this.renameFields(prop.type, item, where, true));
            } else {
              copiedData[prop.name] = this.renameFields(prop.type, copiedData[prop.name], where, prop.object || object12);
            }
          } else {
            const meta2 = this.metadata.find(prop.type);
            const pk = meta2.properties[meta2.primaryKeys[0]];
            isObjectId = pk.type.toLowerCase() === "objectid";
          }
          if (isObjectId) {
            copiedData[k] = this.convertObjectIds(copiedData[k]);
          }
          if (prop.fieldNames) {
            core_1.Utils.renameKey(copiedData, k, prop.fieldNames[0]);
          }
        }
        if (core_1.Utils.isPlainObject(copiedData[k]) && "$re" in copiedData[k]) {
          copiedData[k] = new RegExp(copiedData[k].$re);
        }
      });
      return copiedData;
    }
    convertObjectIds(data) {
      if (data instanceof bson_1.ObjectId) {
        return data;
      }
      if (core_1.Utils.isString(data) && data.match(/^[0-9a-f]{24}$/i)) {
        return new bson_1.ObjectId(data);
      }
      if (Array.isArray(data)) {
        return data.map((item) => this.convertObjectIds(item));
      }
      if (core_1.Utils.isObject(data)) {
        Object.keys(data).forEach((k) => {
          data[k] = this.convertObjectIds(data[k]);
        });
      }
      return data;
    }
    buildFilterById(entityName, id) {
      const meta = this.metadata.find(entityName);
      if (meta.properties[meta.primaryKeys[0]].type.toLowerCase() === "objectid") {
        return { _id: new bson_1.ObjectId(id) };
      }
      return { _id: id };
    }
    buildFields(entityName, populate, fields, exclude5) {
      const meta = this.metadata.find(entityName);
      if (!meta) {
        return fields;
      }
      const lazyProps = meta.props.filter((prop) => prop.lazy && !populate.some((p2) => p2.field === prop.name || p2.all));
      const ret = [];
      if (fields) {
        for (let field of fields) {
          if (core_1.Utils.isPlainObject(field)) {
            continue;
          }
          if (field.toString().includes(".")) {
            field = field.toString().substring(0, field.toString().indexOf("."));
          }
          let prop = meta.properties[field];
          if (prop) {
            if (!prop.fieldNames) {
              continue;
            }
            prop = prop.serializedPrimaryKey ? meta.getPrimaryProps()[0] : prop;
            ret.push(prop.fieldNames[0]);
          } else if (field === "*") {
            const props = meta.props.filter((prop2) => this.platform.shouldHaveColumn(prop2, populate));
            ret.push(...core_1.Utils.flatten(props.filter((p2) => !lazyProps.includes(p2)).map((p2) => p2.fieldNames)));
          } else {
            ret.push(field);
          }
        }
        ret.unshift(...meta.primaryKeys.filter((pk) => !fields.includes(pk)));
      } else if (!core_1.Utils.isEmpty(exclude5) || lazyProps.some((p2) => !p2.formula)) {
        const props = meta.props.filter((prop) => this.platform.shouldHaveColumn(prop, populate, exclude5));
        ret.push(...core_1.Utils.flatten(props.filter((p2) => !lazyProps.includes(p2)).map((p2) => p2.fieldNames)));
      }
      return ret.length > 0 ? ret : undefined;
    }
  }
  exports.MongoDriver = MongoDriver;
});

// node_modules/@mikro-orm/mongodb/MongoMikroORM.js
var require_MongoMikroORM = __commonJS((exports) => {
  var defineMongoConfig = function(options) {
    return (0, core_1.defineConfig)({ driver: MongoDriver_1.MongoDriver, ...options });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineMongoConfig = exports.MongoMikroORM = undefined;
  var core_1 = require_core();
  var MongoDriver_1 = require_MongoDriver();

  class MongoMikroORM extends core_1.MikroORM {
    static DRIVER = MongoDriver_1.MongoDriver;
    static async init(options) {
      return super.init(options);
    }
    static initSync(options) {
      return super.initSync(options);
    }
  }
  exports.MongoMikroORM = MongoMikroORM;
  exports.defineMongoConfig = defineMongoConfig;
});

// node_modules/@mikro-orm/mongodb/index.js
var require_mongodb = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectId = exports.defineConfig = exports.MikroORM = exports.EntityRepository = exports.EntityManager = undefined;
  __exportStar(require_MongoConnection(), exports);
  __exportStar(require_MongoDriver(), exports);
  __exportStar(require_MongoPlatform(), exports);
  __exportStar(require_MongoEntityManager(), exports);
  __exportStar(require_MongoEntityRepository(), exports);
  __exportStar(require_MongoSchemaGenerator(), exports);
  var MongoEntityManager_1 = require_MongoEntityManager();
  Object.defineProperty(exports, "EntityManager", { enumerable: true, get: function() {
    return MongoEntityManager_1.MongoEntityManager;
  } });
  var MongoEntityRepository_1 = require_MongoEntityRepository();
  Object.defineProperty(exports, "EntityRepository", { enumerable: true, get: function() {
    return MongoEntityRepository_1.MongoEntityRepository;
  } });
  var MongoMikroORM_1 = require_MongoMikroORM();
  Object.defineProperty(exports, "MikroORM", { enumerable: true, get: function() {
    return MongoMikroORM_1.MongoMikroORM;
  } });
  Object.defineProperty(exports, "defineConfig", { enumerable: true, get: function() {
    return MongoMikroORM_1.defineMongoConfig;
  } });
  var bson_1 = require_bson();
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_1.ObjectId;
  } });
  __exportStar(require_core(), exports);
});

// node_modules/@mikro-orm/mongo-highlighter/enums.js
var require_enums2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TOKEN_TYPE_TO_HIGHLIGHT = exports.HighlightSubject = exports.TokenType = undefined;
  var TokenType;
  (function(TokenType2) {
    TokenType2[TokenType2["WHITESPACE"] = 0] = "WHITESPACE";
    TokenType2[TokenType2["WORD"] = 1] = "WORD";
    TokenType2[TokenType2["QUOTE"] = 2] = "QUOTE";
    TokenType2[TokenType2["BACKTICK_QUOTE"] = 3] = "BACKTICK_QUOTE";
    TokenType2[TokenType2["BOUNDARY"] = 4] = "BOUNDARY";
    TokenType2[TokenType2["NUMBER"] = 5] = "NUMBER";
    TokenType2[TokenType2["ERROR"] = 6] = "ERROR";
    TokenType2[TokenType2["VARIABLE"] = 7] = "VARIABLE";
    TokenType2[TokenType2["LITERAL"] = 8] = "LITERAL";
  })(TokenType = exports.TokenType || (exports.TokenType = {}));
  var HighlightSubject;
  (function(HighlightSubject2) {
    HighlightSubject2["BOUNDARY"] = "boundary";
    HighlightSubject2["WORD"] = "word";
    HighlightSubject2["BACKTICK_QUOTE"] = "backtickQuote";
    HighlightSubject2["QUOTE"] = "quote";
    HighlightSubject2["NUMBER"] = "number";
    HighlightSubject2["VARIABLE"] = "variable";
    HighlightSubject2["LITERAL"] = "literal";
  })(HighlightSubject = exports.HighlightSubject || (exports.HighlightSubject = {}));
  exports.TOKEN_TYPE_TO_HIGHLIGHT = {
    [TokenType.BOUNDARY]: HighlightSubject.BOUNDARY,
    [TokenType.WORD]: HighlightSubject.WORD,
    [TokenType.BACKTICK_QUOTE]: HighlightSubject.BACKTICK_QUOTE,
    [TokenType.QUOTE]: HighlightSubject.QUOTE,
    [TokenType.NUMBER]: HighlightSubject.NUMBER,
    [TokenType.VARIABLE]: HighlightSubject.VARIABLE,
    [TokenType.LITERAL]: HighlightSubject.LITERAL
  };
});

// node_modules/@mikro-orm/mongo-highlighter/Tokenizer.js
var require_Tokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tokenizer = undefined;
  var enums_1 = require_enums2();

  class Tokenizer {
    constructor() {
      this.literal = ["true", "false", "null", "undefined", "NaN", "Infinity"];
      this.boundaries = [",", ";", ":", ")", "(", ".", "=", "<", ">", "+", "-", "*", "/", "!", "^", "%", "|", "&", "#"];
      this.regexBoundaries = "(" + this.quoteRegex(this.boundaries).join("|") + ")";
      this.regexLiteral = "(" + this.quoteRegex(this.literal).join("|") + ")";
    }
    tokenize(string6) {
      const tokens = [];
      let oldStringLen = string6.length + 1;
      let token;
      let currentLength = string6.length;
      while (currentLength) {
        if (oldStringLen <= currentLength) {
          tokens.push({ type: enums_1.TokenType.ERROR, value: string6 });
          return tokens;
        }
        oldStringLen = currentLength;
        token = this.createNextToken(string6, token);
        const tokenLength = token.value.length;
        tokens.push(token);
        string6 = string6.substr(tokenLength);
        currentLength -= tokenLength;
      }
      return tokens;
    }
    createNextToken(str, previous) {
      let match;
      match = str.match(/^\s+/);
      if (match) {
        return { type: enums_1.TokenType.WHITESPACE, value: match[0] };
      }
      if (['"', "\'", "`", "["].includes(str[0])) {
        const type73 = str[0] === "`" || str[0] === "[" ? enums_1.TokenType.BACKTICK_QUOTE : enums_1.TokenType.QUOTE;
        return { type: type73, value: this.getQuotedString(str) };
      }
      match = new RegExp(`^([0-9]+(.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)(\$|\\s|"'\`|${this.regexBoundaries})`).exec(str);
      if (match) {
        return { type: enums_1.TokenType.NUMBER, value: match[1] };
      }
      match = new RegExp(`^(${this.regexBoundaries})`).exec(str);
      if (match) {
        if (previous && match[1] === ":") {
          previous.type = enums_1.TokenType.VARIABLE;
        }
        return { type: enums_1.TokenType.BOUNDARY, value: match[1] };
      }
      const lower = str.toLowerCase();
      match = new RegExp(`^(${this.regexLiteral})(\$|\\s|${this.regexBoundaries})`).exec(lower);
      if (match) {
        return { type: enums_1.TokenType.LITERAL, value: str.substr(0, match[1].length) };
      }
      match = new RegExp(`^(.*?)(\$|\\s|["'\`]|${this.regexBoundaries})`).exec(str);
      return { type: enums_1.TokenType.WORD, value: match[1] };
    }
    quoteRegex(strings) {
      return strings.map((str) => str.replace(new RegExp(`[.\\\\+*?\\[^\\]\$(){}=!<>|:\\${"/"}-]`, "g"), "\\$&"));
    }
    getQuotedString(string6) {
      var _a;
      const re = '^(((`[^`]*($|`))+)|(("[^"\\\\]*(?:\\\\.[^"\\\\]*)*("|$))+)|((\'[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*(\'|$))+))';
      const m2 = new RegExp(re, "s").exec(string6);
      return (_a = m2 === null || m2 === undefined ? undefined : m2[1]) !== null && _a !== undefined ? _a : "";
    }
  }
  exports.Tokenizer = Tokenizer;
});

// node_modules/ansi-colors/symbols.js
var require_symbols = __commonJS((exports, module) => {
  var isHyper = typeof process !== "undefined" && process.env.TERM_PROGRAM === "Hyper";
  var isWindows = typeof process !== "undefined" && process.platform === "win32";
  var isLinux = typeof process !== "undefined" && process.platform === "linux";
  var common = {
    ballotDisabled: "\u2612",
    ballotOff: "\u2610",
    ballotOn: "\u2611",
    bullet: "\u2022",
    bulletWhite: "\u25E6",
    fullBlock: "\u2588",
    heart: "\u2764",
    identicalTo: "\u2261",
    line: "\u2500",
    mark: "\u203B",
    middot: "\xB7",
    minus: "\uFF0D",
    multiplication: "\xD7",
    obelus: "\xF7",
    pencilDownRight: "\u270E",
    pencilRight: "\u270F",
    pencilUpRight: "\u2710",
    percent: "%",
    pilcrow2: "\u2761",
    pilcrow: "\xB6",
    plusMinus: "\xB1",
    question: "?",
    section: "\xA7",
    starsOff: "\u2606",
    starsOn: "\u2605",
    upDownArrow: "\u2195"
  };
  var windows = Object.assign({}, common, {
    check: "\u221A",
    cross: "\xD7",
    ellipsisLarge: "...",
    ellipsis: "...",
    info: "i",
    questionSmall: "?",
    pointer: ">",
    pointerSmall: "\xBB",
    radioOff: "( )",
    radioOn: "(*)",
    warning: "\u203C"
  });
  var other = Object.assign({}, common, {
    ballotCross: "\u2718",
    check: "\u2714",
    cross: "\u2716",
    ellipsisLarge: "\u22EF",
    ellipsis: "\u2026",
    info: "\u2139",
    questionFull: "\uFF1F",
    questionSmall: "\uFE56",
    pointer: isLinux ? "\u25B8" : "\u276F",
    pointerSmall: isLinux ? "\u2023" : "\u203A",
    radioOff: "\u25EF",
    radioOn: "\u25C9",
    warning: "\u26A0"
  });
  module.exports = isWindows && !isHyper ? windows : other;
  Reflect.defineProperty(module.exports, "common", { enumerable: false, value: common });
  Reflect.defineProperty(module.exports, "windows", { enumerable: false, value: windows });
  Reflect.defineProperty(module.exports, "other", { enumerable: false, value: other });
});

// node_modules/ansi-colors/index.js
var require_ansi_colors = __commonJS((exports, module) => {
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
  var hasColor = () => {
    if (typeof process !== "undefined") {
      return process.env.FORCE_COLOR !== "0";
    }
    return false;
  };
  var create4 = () => {
    const colors2 = {
      enabled: hasColor(),
      visible: true,
      styles: {},
      keys: {}
    };
    const ansi = (style2) => {
      let open = style2.open = `\x1B[${style2.codes[0]}m`;
      let close = style2.close = `\x1B[${style2.codes[1]}m`;
      let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
      style2.wrap = (input, newline) => {
        if (input.includes(close))
          input = input.replace(regex, close + open);
        let output = open + input + close;
        return newline ? output.replace(/\r*\n/g, `${close}\$&${open}`) : output;
      };
      return style2;
    };
    const wrap2 = (style2, input, newline) => {
      return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
    };
    const style = (input, stack) => {
      if (input === "" || input == null)
        return "";
      if (colors2.enabled === false)
        return input;
      if (colors2.visible === false)
        return "";
      let str = "" + input;
      let nl = str.includes("\n");
      let n2 = stack.length;
      if (n2 > 0 && stack.includes("unstyle")) {
        stack = [...new Set(["unstyle", ...stack])].reverse();
      }
      while (n2-- > 0)
        str = wrap2(colors2.styles[stack[n2]], str, nl);
      return str;
    };
    const define2 = (name, codes, type73) => {
      colors2.styles[name] = ansi({ name, codes });
      let keys = colors2.keys[type73] || (colors2.keys[type73] = []);
      keys.push(name);
      Reflect.defineProperty(colors2, name, {
        configurable: true,
        enumerable: true,
        set(value14) {
          colors2.alias(name, value14);
        },
        get() {
          let color = (input) => style(input, color.stack);
          Reflect.setPrototypeOf(color, colors2);
          color.stack = this.stack ? this.stack.concat(name) : [name];
          return color;
        }
      });
    };
    define2("reset", [0, 0], "modifier");
    define2("bold", [1, 22], "modifier");
    define2("dim", [2, 22], "modifier");
    define2("italic", [3, 23], "modifier");
    define2("underline", [4, 24], "modifier");
    define2("inverse", [7, 27], "modifier");
    define2("hidden", [8, 28], "modifier");
    define2("strikethrough", [9, 29], "modifier");
    define2("black", [30, 39], "color");
    define2("red", [31, 39], "color");
    define2("green", [32, 39], "color");
    define2("yellow", [33, 39], "color");
    define2("blue", [34, 39], "color");
    define2("magenta", [35, 39], "color");
    define2("cyan", [36, 39], "color");
    define2("white", [37, 39], "color");
    define2("gray", [90, 39], "color");
    define2("grey", [90, 39], "color");
    define2("bgBlack", [40, 49], "bg");
    define2("bgRed", [41, 49], "bg");
    define2("bgGreen", [42, 49], "bg");
    define2("bgYellow", [43, 49], "bg");
    define2("bgBlue", [44, 49], "bg");
    define2("bgMagenta", [45, 49], "bg");
    define2("bgCyan", [46, 49], "bg");
    define2("bgWhite", [47, 49], "bg");
    define2("blackBright", [90, 39], "bright");
    define2("redBright", [91, 39], "bright");
    define2("greenBright", [92, 39], "bright");
    define2("yellowBright", [93, 39], "bright");
    define2("blueBright", [94, 39], "bright");
    define2("magentaBright", [95, 39], "bright");
    define2("cyanBright", [96, 39], "bright");
    define2("whiteBright", [97, 39], "bright");
    define2("bgBlackBright", [100, 49], "bgBright");
    define2("bgRedBright", [101, 49], "bgBright");
    define2("bgGreenBright", [102, 49], "bgBright");
    define2("bgYellowBright", [103, 49], "bgBright");
    define2("bgBlueBright", [104, 49], "bgBright");
    define2("bgMagentaBright", [105, 49], "bgBright");
    define2("bgCyanBright", [106, 49], "bgBright");
    define2("bgWhiteBright", [107, 49], "bgBright");
    colors2.ansiRegex = ANSI_REGEX;
    colors2.hasColor = colors2.hasAnsi = (str) => {
      colors2.ansiRegex.lastIndex = 0;
      return typeof str === "string" && str !== "" && colors2.ansiRegex.test(str);
    };
    colors2.alias = (name, color) => {
      let fn = typeof color === "string" ? colors2[color] : color;
      if (typeof fn !== "function") {
        throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
      }
      if (!fn.stack) {
        Reflect.defineProperty(fn, "name", { value: name });
        colors2.styles[name] = fn;
        fn.stack = [name];
      }
      Reflect.defineProperty(colors2, name, {
        configurable: true,
        enumerable: true,
        set(value14) {
          colors2.alias(name, value14);
        },
        get() {
          let color2 = (input) => style(input, color2.stack);
          Reflect.setPrototypeOf(color2, colors2);
          color2.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
          return color2;
        }
      });
    };
    colors2.theme = (custom) => {
      if (!isObject(custom))
        throw new TypeError("Expected theme to be an object");
      for (let name of Object.keys(custom)) {
        colors2.alias(name, custom[name]);
      }
      return colors2;
    };
    colors2.alias("unstyle", (str) => {
      if (typeof str === "string" && str !== "") {
        colors2.ansiRegex.lastIndex = 0;
        return str.replace(colors2.ansiRegex, "");
      }
      return "";
    });
    colors2.alias("noop", (str) => str);
    colors2.none = colors2.clear = colors2.noop;
    colors2.stripColor = colors2.unstyle;
    colors2.symbols = require_symbols();
    colors2.define = define2;
    return colors2;
  };
  module.exports = create4();
  module.exports.create = create4;
});

// node_modules/@mikro-orm/mongo-highlighter/MongoHighlighter.js
var require_MongoHighlighter = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoHighlighter = undefined;
  var ansi_colors_1 = __importDefault(require_ansi_colors());
  var Tokenizer_1 = require_Tokenizer();
  var enums_1 = require_enums2();

  class MongoHighlighter {
    constructor(theme = {}) {
      this.theme = theme;
      this.tokenizer = new Tokenizer_1.Tokenizer;
      this.theme = Object.assign(Object.assign({}, MongoHighlighter.DEFAULT_THEME), this.theme);
    }
    highlight(query) {
      const tokens = this.tokenizer.tokenize(query);
      let token;
      let ret = "";
      let position = 0;
      while (token = tokens[position++]) {
        ret += this.highlightToken(token.type, token.value);
      }
      return ret;
    }
    highlightToken(type73, value14) {
      if (type73 === enums_1.TokenType.BOUNDARY && ["(", ")"].includes(value14)) {
        return value14;
      }
      return this.colorize(type73, value14);
    }
    colorize(type73, value14) {
      if (!enums_1.TOKEN_TYPE_TO_HIGHLIGHT[type73] || !this.theme[enums_1.TOKEN_TYPE_TO_HIGHLIGHT[type73]]) {
        return value14;
      }
      return this.theme[enums_1.TOKEN_TYPE_TO_HIGHLIGHT[type73]](value14);
    }
  }
  exports.MongoHighlighter = MongoHighlighter;
  MongoHighlighter.DEFAULT_THEME = {
    [enums_1.HighlightSubject.QUOTE]: ansi_colors_1.default.yellow,
    [enums_1.HighlightSubject.BACKTICK_QUOTE]: ansi_colors_1.default.yellow,
    [enums_1.HighlightSubject.BOUNDARY]: ansi_colors_1.default.reset,
    [enums_1.HighlightSubject.NUMBER]: ansi_colors_1.default.green,
    [enums_1.HighlightSubject.WORD]: undefined,
    [enums_1.HighlightSubject.VARIABLE]: ansi_colors_1.default.cyan,
    [enums_1.HighlightSubject.LITERAL]: ansi_colors_1.default.green
  };
});

// node_modules/@mikro-orm/mongo-highlighter/index.js
var require_mongo_highlighter = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !exports2.hasOwnProperty(p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_Tokenizer(), exports);
  __exportStar(require_MongoHighlighter(), exports);
});

// node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsUint8Array(value) {
  return value instanceof Uint8Array;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsPlainObject(value) {
  return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return IsNumber(value) && Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    const isNumber = IsNumber(value);
    return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  CloneType: () => {
    {
      return CloneType;
    }
  },
  CloneRest: () => {
    {
      return CloneRest;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined2;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol2;
    }
  },
  IsString: () => {
    {
      return IsString2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject2;
    }
  },
  IsNumber: () => {
    {
      return IsNumber2;
    }
  },
  IsNull: () => {
    {
      return IsNull2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction2;
    }
  },
  IsDate: () => {
    {
      return IsDate2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean2;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt2;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator2;
    }
  },
  IsArray: () => {
    {
      return IsArray2;
    }
  }
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit = function(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey = function(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
};
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined3;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array3;
    }
  },
  IsTuple: () => {
    {
      return IsTuple;
    }
  },
  IsTransform: () => {
    {
      return IsTransform;
    }
  },
  IsThis: () => {
    {
      return IsThis;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol3;
    }
  },
  IsString: () => {
    {
      return IsString3;
    }
  },
  IsSchema: () => {
    {
      return IsSchema;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp2;
    }
  },
  IsRef: () => {
    {
      return IsRef;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise2;
    }
  },
  IsOptional: () => {
    {
      return IsOptional;
    }
  },
  IsObject: () => {
    {
      return IsObject3;
    }
  },
  IsNumber: () => {
    {
      return IsNumber3;
    }
  },
  IsNull: () => {
    {
      return IsNull3;
    }
  },
  IsNot: () => {
    {
      return IsNot;
    }
  },
  IsNever: () => {
    {
      return IsNever;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf;
    }
  },
  IsKind: () => {
    {
      return IsKind;
    }
  },
  IsIterator: () => {
    {
      return IsIterator3;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect;
    }
  },
  IsInteger: () => {
    {
      return IsInteger2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction3;
    }
  },
  IsDate: () => {
    {
      return IsDate3;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean3;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt3;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator3;
    }
  },
  IsArray: () => {
    {
      return IsArray3;
    }
  },
  IsAny: () => {
    {
      return IsAny;
    }
  }
});
var IsPattern = function(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value2) {
  if (!IsString2(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value2) {
  return IsOptionalBoolean(value2) || IsSchema(value2);
};
var IsOptionalBigInt = function(value2) {
  return IsUndefined2(value2) || IsBigInt2(value2);
};
var IsOptionalNumber = function(value2) {
  return IsUndefined2(value2) || IsNumber2(value2);
};
var IsOptionalBoolean = function(value2) {
  return IsUndefined2(value2) || IsBoolean2(value2);
};
var IsOptionalString = function(value2) {
  return IsUndefined2(value2) || IsString2(value2);
};
var IsOptionalPattern = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
};
var IsOptionalFormat = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2);
};
var IsOptionalSchema = function(value2) {
  return IsUndefined2(value2) || IsSchema(value2);
};
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsProperties(value2) {
  return IsObject2(value2) && Object.entries(value2).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect") && (IsString2(value2.type) && value2.type !== "object" ? false : true) && IsArray2(value2.allOf) && value2.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && Kind in value2 && value2[Kind] === kind;
}
function IsLiteralString(value2) {
  return IsLiteral(value2) && IsString2(value2.const);
}
function IsLiteralNumber(value2) {
  return IsLiteral(value2) && IsNumber2(value2.const);
}
function IsLiteralBoolean(value2) {
  return IsLiteral(value2) && IsBoolean2(value2.const);
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
}
function IsLiteralValue(value2) {
  return IsBoolean2(value2) || IsNumber2(value2) || IsString2(value2);
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey") && IsArray2(value2.keys) && value2.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
}
function IsNever(value2) {
  return IsKindOf(value2, "Never") && IsObject2(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot(value2) {
  return IsKindOf(value2, "Not") && IsSchema(value2.not);
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && IsObject2(value2.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive(value2) {
  return IsObject2(value2) && Hint in value2 && value2[Hint] === "Recursive";
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && IsString2(value2.source) && IsString2(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
}
function IsString3(value2) {
  return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && IsString2(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis(value2) {
  return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsTransform(value2) {
  return IsObject2(value2) && TransformKind in value2;
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && IsNumber2(value2.minItems) && IsNumber2(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined2(value2.items) && IsUndefined2(value2.additionalItems) && value2.minItems === 0 || IsArray2(value2.items) && value2.items.every((schema) => IsSchema(schema)));
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
}
function IsUnionLiteral(value2) {
  return IsUnion(value2) && value2.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && IsObject2(value2) && IsArray2(value2.anyOf) && value2.anyOf.every((schema) => IsSchema(schema));
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
}
function IsKind(value2) {
  return IsObject2(value2) && Kind in value2 && IsString2(value2[Kind]) && !KnownTypes.includes(value2[Kind]);
}
function IsSchema(value2) {
  return IsObject2(value2) && (IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
};
var AddOptional = function(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional(P[K2], F) };
  }, {});
};
var FromMappedResult = function(R, F) {
  return FromProperties(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(T) {
  return T.every((L) => IsOptional(L));
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var RemoveOptionalFromRest = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
};
var ResolveIntersect = function(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
};
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional = function(T) {
  return T.some((L) => IsOptional(L));
};
var RemoveOptionalFromRest2 = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
};
var RemoveOptionalFromType2 = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
};
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape = function(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
};
var FromUnion2 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, ...IndexPropertyKeys(L)];
  }, []);
};
var FromLiteral = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties2 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };
  }, {});
};
var FromMappedResult2 = function(T, R, options) {
  return FromProperties2(T, R.properties, options);
};
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest = function(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
};
var FromIntersectRest = function(T) {
  return T.filter((L) => !IsNever(L));
};
var FromIntersect = function(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
};
var FromUnionRest = function(T) {
  return T;
};
var FromUnion3 = function(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
};
var FromTuple = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
};
var FromArray = function(T, K) {
  return K === "[number]" ? T : Never();
};
var FromProperty = function(T, K) {
  return K in T ? T[K] : Never();
};
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
var FromSchema = function(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
};
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(T, K, options) {
  return { [K]: Index(T, [K], options) };
};
var MappedIndexPropertyKeys = function(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
};
var MappedIndexProperties = function(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
};
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
};
var AddReadonly = function(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties3 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly(K[K2], F) };
  }, {});
};
var FromMappedResult3 = function(R, F) {
  return FromProperties3(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  return T.reduce((Acc, L) => [...Acc, ...L], []);
}
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult4 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  return P.reduce((Acc, L) => {
    return { ...Acc, [L]: Literal(L) };
  }, {});
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties4 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
  }, {});
};
var FromSchemaType = function(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
};
function MappedFunctionReturnType(K, T, Acc = {}) {
  return K.reduce((Acc2, L) => {
    return { ...Acc2, [L]: FromSchemaType(L, T) };
  }, {});
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest3 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, KeyOfPropertyKeys(L)];
  }, []);
};
var FromIntersect2 = function(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
};
var FromUnion4 = function(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
};
var FromTuple2 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf(K[K2], options) };
  }, {});
};
var FromMappedResult5 = function(R, options) {
  return FromProperties6(R.properties, options);
};
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction(error8) {
  switch (error8.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error8.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error8.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error8.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error8.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error8.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error8.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error8.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error8.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error8.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error8.schema.const === "string" ? `'${error8.schema.const}'` : error8.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error8.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error8.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error8.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error8.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error8.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error8.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error8.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error8.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error8.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error8.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error8.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}

class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
};
var BooleanType = function(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
};
var BigIntType = function(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
};
var NullType = function(value3) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
};
var StringType = function(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
};
var Uint8ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
};
var UndefinedType = function(value3) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit3 = function(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsPlainObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  value;
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined = function(value3) {
  return value3 !== undefined;
};
var Create = function(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
};
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  iterator;
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type3.IsNever(right) || exports_type3.IsIntersect(right) || exports_type3.IsUnion(right) || exports_type3.IsUnknown(right) || exports_type3.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type3.IsNever(right) ? FromNeverRight(left, right) : exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny2 = function(left, right) {
  return exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) && right.anyOf.some((schema) => exports_type3.IsAny(schema) || exports_type3.IsUnknown(schema)) ? ExtendsResult.True : exports_type3.IsUnion(right) ? ExtendsResult.Union : exports_type3.IsUnknown(right) ? ExtendsResult.True : exports_type3.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : exports_type3.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type3.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromAsyncIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromBigInt2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type3.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type3.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromDate2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type3.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type3.IsNumber(left) || exports_type3.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger2 = function(left, right) {
  return exports_type3.IsInteger(right) || exports_type3.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type3.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromLiteral3 = function(left, right) {
  return exports_type3.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsString(right) ? FromStringRight(left, right) : exports_type3.IsNumber(right) ? FromNumberRight(left, right) : exports_type3.IsInteger(right) ? FromIntegerRight(left, right) : exports_type3.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever2 = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type3.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot2 = function(left, right) {
  return exports_type3.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type3.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type3.IsLiteralNumber(left) ? ExtendsResult.True : exports_type3.IsNumber(left) || exports_type3.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsInteger(right) || exports_type3.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type3.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type3.IsString(schema.properties.description.anyOf[0]) && exports_type3.IsUndefined(schema.properties.description.anyOf[1]) || exports_type3.IsString(schema.properties.description.anyOf[1]) && exports_type3.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type3.IsOptional(left) && !exports_type3.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : exports_type3.IsNever(left) || exports_type3.IsLiteralString(left) && IsObjectStringLike(right) || exports_type3.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type3.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type3.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type3.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type3.IsString(left) && IsObjectStringLike(right) || exports_type3.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type3.IsNumber(left) && IsObjectNumberLike(right) || exports_type3.IsInteger(left) && IsObjectNumberLike(right) || exports_type3.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type3.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type3.IsDate(left) && IsObjectDateLike(right) || exports_type3.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type3.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type3.IsRecord(left) && exports_type3.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type3.IsRecord(left) && exports_type3.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : !exports_type3.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type3.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type3.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type3.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type3.IsLiteralString(left) && exports_type3.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type3.IsUint8Array(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsString(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsArray(left) && exports_type3.IsNumber(Key) ? Visit5(left, Value) : exports_type3.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : !exports_type3.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
};
var FromRegExp2 = function(left, right) {
  const L = exports_type3.IsRegExp(left) ? String2() : left;
  const R = exports_type3.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type3.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type3.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral3 = function(left, right) {
  return exports_type3.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type3.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type3.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type3.IsNever(left) ? ExtendsResult.True : exports_type3.IsUnknown(left) ? ExtendsResult.False : exports_type3.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple4 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type3.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type3.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsRecord(right) ? FromRecordRight(left, right) : exports_type3.IsVoid(right) ? FromVoidRight(left, right) : exports_type3.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown2 = function(left, right) {
  return exports_type3.IsNever(right) ? FromNeverRight(left, right) : exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : exports_type3.IsString(right) ? FromStringRight(left, right) : exports_type3.IsNumber(right) ? FromNumberRight(left, right) : exports_type3.IsInteger(right) ? FromIntegerRight(left, right) : exports_type3.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type3.IsArray(right) ? FromArrayRight(left, right) : exports_type3.IsTuple(right) ? FromTupleRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type3.IsUndefined(left) ? ExtendsResult.True : exports_type3.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid2 = function(left, right) {
  return exports_type3.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type3.IsUnion(right) ? FromUnionRight(left, right) : exports_type3.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type3.IsAny(right) ? FromAnyRight(left, right) : exports_type3.IsObject(right) ? FromObjectRight(left, right) : exports_type3.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit5 = function(left, right) {
  return exports_type3.IsTemplateLiteral(left) || exports_type3.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type3.IsRegExp(left) || exports_type3.IsRegExp(right) ? FromRegExp2(left, right) : exports_type3.IsNot(left) || exports_type3.IsNot(right) ? FromNot2(left, right) : exports_type3.IsAny(left) ? FromAny2(left, right) : exports_type3.IsArray(left) ? FromArray4(left, right) : exports_type3.IsBigInt(left) ? FromBigInt2(left, right) : exports_type3.IsBoolean(left) ? FromBoolean2(left, right) : exports_type3.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type3.IsConstructor(left) ? FromConstructor2(left, right) : exports_type3.IsDate(left) ? FromDate2(left, right) : exports_type3.IsFunction(left) ? FromFunction2(left, right) : exports_type3.IsInteger(left) ? FromInteger2(left, right) : exports_type3.IsIntersect(left) ? FromIntersect4(left, right) : exports_type3.IsIterator(left) ? FromIterator2(left, right) : exports_type3.IsLiteral(left) ? FromLiteral3(left, right) : exports_type3.IsNever(left) ? FromNever2(left, right) : exports_type3.IsNull(left) ? FromNull2(left, right) : exports_type3.IsNumber(left) ? FromNumber2(left, right) : exports_type3.IsObject(left) ? FromObject2(left, right) : exports_type3.IsRecord(left) ? FromRecord2(left, right) : exports_type3.IsString(left) ? FromString2(left, right) : exports_type3.IsSymbol(left) ? FromSymbol2(left, right) : exports_type3.IsTuple(left) ? FromTuple4(left, right) : exports_type3.IsPromise(left) ? FromPromise2(left, right) : exports_type3.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type3.IsUndefined(left) ? FromUndefined2(left, right) : exports_type3.IsUnion(left) ? FromUnion6(left, right) : exports_type3.IsUnknown(left) ? FromUnknown2(left, right) : exports_type3.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties7 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined2 = function(value3) {
  return value3 !== undefined;
};
var FromAny3 = function(schema, references, value3) {
  return true;
};
var FromArray5 = function(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator3 = function(schema, references, value3) {
  return IsAsyncIterator(value3);
};
var FromBigInt3 = function(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean3 = function(schema, references, value3) {
  return IsBoolean(value3);
};
var FromConstructor3 = function(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
};
var FromDate3 = function(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction3 = function(schema, references, value3) {
  return IsFunction(value3);
};
var FromInteger3 = function(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect5 = function(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator3 = function(schema, references, value3) {
  return IsIterator(value3);
};
var FromLiteral4 = function(schema, references, value3) {
  return value3 === schema.const;
};
var FromNever3 = function(schema, references, value3) {
  return false;
};
var FromNot3 = function(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
};
var FromNull3 = function(schema, references, value3) {
  return IsNull(value3);
};
var FromNumber3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
};
var FromPromise3 = function(schema, references, value3) {
  return IsPromise(value3);
};
var FromRecord3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromRegExp3 = function(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
};
var FromString3 = function(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
};
var FromSymbol3 = function(schema, references, value3) {
  return IsSymbol(value3);
};
var FromTemplateLiteral4 = function(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
};
var FromThis2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromTuple5 = function(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
};
var FromUndefined3 = function(schema, references, value3) {
  return IsUndefined(value3);
};
var FromUnion7 = function(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
};
var FromUint8Array3 = function(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown3 = function(schema, references, value3) {
  return true;
};
var FromVoid3 = function(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
};
var FromKind2 = function(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
};
var Visit6 = function(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType3 = function(value3) {
  const keys = [...Object.getOwnPropertyNames(value3), ...Object.getOwnPropertySymbols(value3)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone2(value3[key]) }), {});
};
var ArrayType3 = function(value3) {
  return value3.map((element) => Clone2(element));
};
var TypedArrayType = function(value3) {
  return value3.slice();
};
var DateType3 = function(value3) {
  return new Date(value3.toISOString());
};
var ValueType = function(value3) {
  return value3;
};
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsPlainObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault = function(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArray6 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
};
var FromIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    return FromDefault(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit7(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord4 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit7(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion8 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
};
var SelectUnion = function(union9, references, value3) {
  let [select, best] = [union9.anyOf[0], 0];
  for (const schema of union9.anyOf) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
};
var DefaultClone = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
};
var Default = function(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
};
var FromArray7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
};
var FromIntersect7 = function(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsPlainObject(created) && IsPlainObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
};
var FromNever5 = function(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
};
var FromRecord5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromThis4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromTuple7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
};
var FromUnion9 = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
};
var Visit8 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var FromArray8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
};
var FromIntersect8 = function(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
};
var FromObject6 = function(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRecord6 = function(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRef5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromThis5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromTuple8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
};
var FromUnion10 = function(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
};
var Visit9 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys = function(T) {
  return T.reduce((Acc, L) => {
    return SetDistinct([...Acc, ...KeyOfPropertyKeys(L)]);
  }, []);
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  return T.reduce((Acc, L) => {
    return FilterNever([...Acc, ...IndexFromPropertyKeys(L, [K])]);
  }, []);
};
var CompositeProperties = function(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
};
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric = function(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
};
var IsValueToString = function(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
};
var IsValueTrue = function(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
};
var IsValueFalse = function(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
};
var IsTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsDateTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateString = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
};
var TryConvertLiteralString = function(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralNumber = function(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralBoolean = function(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteral = function(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
};
var TryConvertBoolean = function(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
};
var TryConvertBigInt = function(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
};
var TryConvertString = function(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
};
var TryConvertNumber = function(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertInteger = function(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertNull = function(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
};
var TryConvertUndefined = function(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
};
var TryConvertDate = function(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
};
var Default2 = function(value3) {
  return value3;
};
var FromArray9 = function(schema, references, value3) {
  if (IsArray(value3)) {
    return value3.map((value4) => Visit10(schema.items, references, value4));
  }
  return value3;
};
var FromBigInt5 = function(schema, references, value3) {
  return TryConvertBigInt(value3);
};
var FromBoolean5 = function(schema, references, value3) {
  return TryConvertBoolean(value3);
};
var FromDate5 = function(schema, references, value3) {
  return TryConvertDate(value3);
};
var FromInteger5 = function(schema, references, value3) {
  return TryConvertInteger(value3);
};
var FromIntersect9 = function(schema, references, value3) {
  const allObjects = schema.allOf.every((schema2) => IsObject3(schema2));
  if (allObjects)
    return Visit10(Composite(schema.allOf), references, value3);
  return Visit10(schema.allOf[0], references, value3);
};
var FromLiteral6 = function(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
};
var FromNull5 = function(schema, references, value3) {
  return TryConvertNull(value3);
};
var FromNumber5 = function(schema, references, value3) {
  return TryConvertNumber(value3);
};
var FromObject7 = function(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  return Object.getOwnPropertyNames(schema.properties).reduce((value4, key) => {
    return !IsUndefined(value4[key]) ? { ...value4, [key]: Visit10(schema.properties[key], references, value4[key]) } : { ...value4 };
  }, value3);
};
var FromRecord7 = function(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
};
var FromRef6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromString5 = function(schema, references, value3) {
  return TryConvertString(value3);
};
var FromSymbol5 = function(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
};
var FromThis6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromTuple9 = function(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
};
var FromUndefined5 = function(schema, references, value3) {
  return TryConvertUndefined(value3);
};
var FromUnion11 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (Check(subschema, references, converted)) {
      return converted;
    }
  }
  return value3;
};
var Visit10 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault = function(schema, value3) {
  return value3 === undefined && "default" in schema ? Clone2(schema.default) : value3;
};
var IsCheckable2 = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var IsDefaultSchema = function(value3) {
  return IsSchema(value3) && "default" in value3;
};
var FromArray10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
};
var FromThis7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
};
var FromTuple10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion12 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit11 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
};
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate = function(path, value3) {
  return { type: "update", path, value: value3 };
};
var CreateInsert = function(path, value3) {
  return { type: "insert", path, value: value3 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
function* ObjectType4(path, current, next) {
  if (!IsPlainObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsPlainObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  value;
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType5 = function(left, right) {
  if (!IsPlainObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType4 = function(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
};
var ArrayType5 = function(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var TypedArrayType3 = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var ValueType3 = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsPlainObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType6 = function(root, path, current, next) {
  if (!IsPlainObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType6 = function(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType4 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType4 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit13 = function(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsPlainObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
};
var IsNonMutableValue = function(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
};
var IsMismatchedValue = function(current, next) {
  return IsPlainObject(current) && IsArray(next) || IsArray(current) && IsPlainObject(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default4 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, value3, error19);
  }
};
var FromArray11 = function(schema, references, value3) {
  return IsArray(value3) ? Default4(schema, value3.map((value4) => Visit14(schema.items, references, value4))) : Default4(schema, value3);
};
var FromIntersect11 = function(schema, references, value3) {
  if (!IsPlainObject(value3) || IsValueType(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(Index(schema, [key]), references, value4[key]) } : value4;
  }, value3);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromNot5 = function(schema, references, value3) {
  return Default4(schema, Visit14(schema.not, references, value3));
};
var FromObject9 = function(schema, references, value3) {
  if (!IsPlainObject(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(schema.properties[key], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRecord9 = function(schema, references, value3) {
  if (!IsPlainObject(value3))
    return Default4(schema, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit14(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRef8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromThis8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromTuple11 = function(schema, references, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, schema.items.map((schema2, index) => Visit14(schema2, references, value3[index]))) : Default4(schema, value3);
};
var FromUnion13 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, value3);
    return Default4(schema, decoded);
  }
  return Default4(schema, value3);
};
var Visit14 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, value3);
    case "Not":
      return FromNot5(schema_, references_, value3);
    case "Object":
      return FromObject9(schema_, references_, value3);
    case "Record":
      return FromRecord9(schema_, references_, value3);
    case "Ref":
      return FromRef8(schema_, references_, value3);
    case "Symbol":
      return Default4(schema_, value3);
    case "This":
      return FromThis8(schema_, references_, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, value3);
    case "Union":
      return FromUnion13(schema_, references_, value3);
    default:
      return Default4(schema_, value3);
  }
};
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error19) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error19) {
    super(`${error19 instanceof Error ? error19.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default5 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, value3, error20);
  }
};
var FromArray12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  return IsArray(defaulted) ? defaulted.map((value4) => Visit15(schema.items, references, value4)) : defaulted;
};
var FromIntersect12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3) || IsValueType(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in defaulted ? { ...value4, [key]: Visit15(Index(schema, [key]), references, value4[key]) } : value4;
  }, defaulted);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromNot6 = function(schema, references, value3) {
  return Default5(schema.not, Default5(schema, value3));
};
var FromObject10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit15(schema.properties[key], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRecord10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsPlainObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit15(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRef9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromThis9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromTuple12 = function(schema, references, value3) {
  const value1 = Default5(schema, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, value1[index])) : [];
};
var FromUnion14 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, value3);
    return Default5(schema, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, value1);
  }
  return Default5(schema, value3);
};
var Visit15 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, value3);
    case "Not":
      return FromNot6(schema_, references_, value3);
    case "Object":
      return FromObject10(schema_, references_, value3);
    case "Record":
      return FromRecord10(schema_, references_, value3);
    case "Ref":
      return FromRef9(schema_, references_, value3);
    case "This":
      return FromThis9(schema_, references_, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, value3);
    case "Union":
      return FromUnion14(schema_, references_, value3);
    default:
      return Default5(schema_, value3);
  }
};
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error20) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray13 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromAsyncIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromConstructor6 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromFunction5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromIntersect13 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
};
var FromIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.not, references);
};
var FromObject11 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
};
var FromPromise5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.item, references);
};
var FromRecord11 = function(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform(schema) || Visit16(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromThis10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromTuple13 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
};
var FromUnion15 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
};
var Visit16 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => {
    {
      return Patch2;
    }
  },
  Mutate: () => {
    {
      return Mutate2;
    }
  },
  Hash: () => {
    {
      return Hash2;
    }
  },
  Errors: () => {
    {
      return Errors2;
    }
  },
  Equal: () => {
    {
      return Equal2;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Diff: () => {
    {
      return Diff2;
    }
  },
  Default: () => {
    {
      return Default6;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create3;
    }
  },
  Convert: () => {
    {
      return Convert2;
    }
  },
  Clone: () => {
    {
      return Clone3;
    }
  },
  Clean: () => {
    {
      return Clean2;
    }
  },
  Check: () => {
    {
      return Check2;
    }
  },
  Cast: () => {
    {
      return Cast2;
    }
  }
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return TransformDecode(schema, references, value3);
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode(schema, references, value3);
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest4 = function(T) {
  return T.map((L) => AwaitedResolve(L));
};
var FromIntersect14 = function(T) {
  return Intersect(FromRest4(T));
};
var FromUnion16 = function(T) {
  return Union(FromRest4(T));
};
var FromPromise6 = function(T) {
  return AwaitedResolve(T);
};
var AwaitedResolve = function(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
};
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray14 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties8 = function(value4) {
  return globalThis.Object.getOwnPropertyNames(value4).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value4[key], false)) };
  }, {});
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value4, root) {
  return IsAsyncIterator2(value4) ? ConditionalReadonly(Any(), root) : IsIterator2(value4) ? ConditionalReadonly(Any(), root) : IsArray2(value4) ? Readonly(Tuple(FromArray14(value4))) : IsUint8Array2(value4) ? Uint8Array2() : IsDate2(value4) ? Date2() : IsObject2(value4) ? ConditionalReadonly(Object2(FromProperties8(value4)), root) : IsFunction2(value4) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value4) ? Undefined() : IsNull2(value4) ? Null() : IsSymbol2(value4) ? Symbol2() : IsBigInt2(value4) ? BigInt2() : IsNumber2(value4) ? Literal(value4) : IsBoolean2(value4) ? Literal(value4) : IsString2(value4) ? Literal(value4) : Object2({});
};
function Const(T, options = {}) {
  return exports_type2.CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest5 = function(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
};
var FromProperties9 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref2(properties[key], references) };
  }, {});
};
var FromConstructor7 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromFunction6 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromIntersect15 = function(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
};
var FromUnion17 = function(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
};
var FromTuple14 = function(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
};
var FromArray15 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromObject12 = function(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
};
var FromPromise7 = function(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
};
var FromAsyncIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromRef11 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
};
var DerefResolve = function(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
};
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value6) => Literal(value6));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties10 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
};
var FromMappedResult7 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties11 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
};
var FromMappedResult8 = function(R, T) {
  return FromProperties11(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value6) {
  const [first, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value6) {
  const [first, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value6) {
  return value6.toUpperCase();
};
var ApplyLowercase = function(value6) {
  return value6.toLowerCase();
};
var FromTemplateLiteral6 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value6) => Literal(value6));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
};
var FromLiteralValue = function(value6, mode) {
  return typeof value6 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value6) : mode === "Capitalize" ? ApplyCapitalize(value6) : mode === "Uppercase" ? ApplyUppercase(value6) : mode === "Lowercase" ? ApplyLowercase(value6) : value6 : value6.toString();
};
var FromRest6 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
};
var FromMappedResult9 = function(R, K, options) {
  return FromProperties12(R.properties, K, options);
};
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect16 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromUnion18 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromProperty2 = function(T, K) {
  const { [K]: _, ...R } = T;
  return R;
};
var FromProperties13 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty2(T2, K2);
  }, T);
};
var OmitResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
};
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
};
var FromPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
};
var FromMappedKey3 = function(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
};
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest7 = function(T) {
  return T.map((L) => PartialResolve(L));
};
var FromProperties14 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
};
var PartialResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
};
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties15 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
};
var FromMappedResult10 = function(R, options) {
  return FromProperties15(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties16 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
};
var FromMappedResult11 = function(R, K, options) {
  return FromProperties16(R.properties, K, options);
};
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect17 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromUnion19 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromProperties17 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
};
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
};
var FromPropertyKeys3 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
};
var FromMappedKey4 = function(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
};
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern = function(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
};
var RecordCreateFromKeys = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object2(P, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
};
var FromLiteralKey = function(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
};
var FromRegExpKey = function(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
};
var FromStringKey = function(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
};
var FromIntegerKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
var FromNumberKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest8 = function(T) {
  return T.map((L) => RequiredResolve(L));
};
var FromProperties18 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
};
var RequiredResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
};
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
};
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema) {
  return JSON.parse(JSON.stringify(schema));
}
// node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

class TransformDecodeBuilder {
  schema;
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  schema;
  decode;
  constructor(schema, decode2) {
    this.schema = schema;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema) {
    const Encode2 = (value10) => schema[TransformKind].Encode(encode2(value10));
    const Decode2 = (value10) => this.decode(schema[TransformKind].Decode(value10));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema = CloneType(this.schema);
    return IsTransform(schema) ? this.EncodeTransform(encode2, schema) : this.EncodeSchema(encode2, schema);
  }
}
// node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type4 = {};
__export(exports_type4, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  Strict: () => {
    {
      return Strict;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Deref: () => {
    {
      return Deref2;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean2;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = exports_type4;
// node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Errors(value10) {
    return Errors(this.schema, this.references, value10);
  }
  Check(value10) {
    return this.checkFunc(value10);
  }
  Decode(value10) {
    if (!this.checkFunc(value10))
      throw new TransformDecodeCheckError(this.schema, value10, this.Errors(value10).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value10) : value10;
  }
  Encode(value10) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value10) : value10;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value10, this.Errors(value10).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value10) {
    if (value10.length === 0)
      return false;
    return Character.IsNumeric(value10.charCodeAt(0));
  }
  function IsAccessor(value10) {
    if (IsFirstCharacterNumeric(value10))
      return false;
    for (let i = 0;i < value10.length; i++) {
      const code = value10.charCodeAt(i);
      const check10 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check10)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object12, key) {
    return IsAccessor(key) ? `${object12}.${key}` : `${object12}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value10, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value10} ? ${expression} : true)` : `(${MemberExpression.Encode(value10, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value10) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value10} === 'object' && ${value10} !== null && !Array.isArray(${value10}))` : `(typeof ${value10} === 'object' && ${value10} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value10) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value10} === 'object' && ${value10} !== null && !Array.isArray(${value10}) && !(${value10} instanceof Date) && !(${value10} instanceof Uint8Array))` : `(typeof ${value10} === 'object' && ${value10} !== null && !(${value10} instanceof Date) && !(${value10} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value10) {
    return !TypeSystemPolicy.AllowNaN ? `(typeof ${value10} === 'number' && Number.isFinite(${value10}))` : `typeof ${value10} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value10) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value10} === undefined || ${value10} === null)` : `${value10} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value10) {
    yield "true";
  }
  function* FromArray16(schema, references, value10) {
    yield `Array.isArray(${value10})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema.maxItems))
      yield `${value10}.length <= ${schema.maxItems}`;
    if (IsNumber(schema.minItems))
      yield `${value10}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value10}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {
      const containsSchema = IsSchema(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check10 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check10}})(${value10})`;
    }
    if (schema.uniqueItems === true) {
      const check10 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check10} }`;
      yield `((${parameter}) => { ${block} )(${value10})`;
    }
  }
  function* FromAsyncIterator7(schema, references, value10) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value10})`;
  }
  function* FromBigInt6(schema, references, value10) {
    yield `(typeof ${value10} === 'bigint')`;
    if (IsBigInt(schema.exclusiveMaximum))
      yield `${value10} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt(schema.exclusiveMinimum))
      yield `${value10} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt(schema.maximum))
      yield `${value10} <= BigInt(${schema.maximum})`;
    if (IsBigInt(schema.minimum))
      yield `${value10} >= BigInt(${schema.minimum})`;
    if (IsBigInt(schema.multipleOf))
      yield `(${value10} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value10) {
    yield `(typeof ${value10} === 'boolean')`;
  }
  function* FromConstructor8(schema, references, value10) {
    yield* Visit17(schema.returns, references, `${value10}.prototype`);
  }
  function* FromDate6(schema, references, value10) {
    yield `(${value10} instanceof Date) && Number.isFinite(${value10}.getTime())`;
    if (IsNumber(schema.exclusiveMaximumTimestamp))
      yield `${value10}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema.exclusiveMinimumTimestamp))
      yield `${value10}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema.maximumTimestamp))
      yield `${value10}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber(schema.minimumTimestamp))
      yield `${value10}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber(schema.multipleOfTimestamp))
      yield `(${value10}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema, references, value10) {
    yield `(typeof ${value10} === 'function')`;
  }
  function* FromInteger6(schema, references, value10) {
    yield `(typeof ${value10} === 'number' && Number.isInteger(${value10}))`;
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value10} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value10} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value10} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value10} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value10} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema, references, value10) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value10)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value10}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value10}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value10}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema, references, value10) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value10})`;
  }
  function* FromLiteral7(schema, references, value10) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value10} === ${schema.const})`;
    } else {
      yield `(${value10} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value10) {
    yield `false`;
  }
  function* FromNot8(schema, references, value10) {
    const expression = CreateExpression(schema.not, references, value10);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value10) {
    yield `(${value10} === null)`;
  }
  function* FromNumber6(schema, references, value10) {
    yield Policy.IsNumberLike(value10);
    if (IsNumber(schema.exclusiveMaximum))
      yield `${value10} < ${schema.exclusiveMaximum}`;
    if (IsNumber(schema.exclusiveMinimum))
      yield `${value10} > ${schema.exclusiveMinimum}`;
    if (IsNumber(schema.maximum))
      yield `${value10} <= ${schema.maximum}`;
    if (IsNumber(schema.minimum))
      yield `${value10} >= ${schema.minimum}`;
    if (IsNumber(schema.multipleOf))
      yield `(${value10} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject13(schema, references, value10) {
    yield Policy.IsObjectLike(value10);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value10}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value10}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value10, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value10})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value10, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value10}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value10}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value10}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value10}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value10) {
    yield `(typeof value === 'object' && typeof ${value10}.then === 'function')`;
  }
  function* FromRecord12(schema, references, value10) {
    yield Policy.IsRecordLike(value10);
    if (IsNumber(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value10}).length >= ${schema.minProperties}`;
    if (IsNumber(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value10}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value10) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value10}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema, references, value10) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value10})`;
    yield* Visit17(target, references, value10);
  }
  function* FromRegExp5(schema, references, value10) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value10} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value10}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value10}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value10})`;
  }
  function* FromString6(schema, references, value10) {
    yield `(typeof ${value10} === 'string')`;
    if (IsNumber(schema.maxLength))
      yield `${value10}.length <= ${schema.maxLength}`;
    if (IsNumber(schema.minLength))
      yield `${value10}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value10})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value10})`;
    }
  }
  function* FromSymbol6(schema, references, value10) {
    yield `(typeof ${value10} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value10) {
    yield `(typeof ${value10} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value10})`;
  }
  function* FromThis11(schema, references, value10) {
    yield `${CreateFunctionName(schema.$ref)}(${value10})`;
  }
  function* FromTuple15(schema, references, value10) {
    yield `Array.isArray(${value10})`;
    if (schema.items === undefined)
      return yield `${value10}.length === 0`;
    yield `(${value10}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value10}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value10) {
    yield `${value10} === undefined`;
  }
  function* FromUnion20(schema, references, value10) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value10));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value10) {
    yield `${value10} instanceof Uint8Array`;
    if (IsNumber(schema.maxByteLength))
      yield `(${value10}.length <= ${schema.maxByteLength})`;
    if (IsNumber(schema.minByteLength))
      yield `(${value10}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value10) {
    yield "true";
  }
  function* FromVoid5(schema, references, value10) {
    yield Policy.IsVoidLike(value10);
  }
  function* FromKind4(schema, references, value10) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value10})`;
  }
  function* Visit17(schema, references, value10, useHoisting = true) {
    const references_ = IsString(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value10})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value10})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value10);
      case "Array":
        return yield* FromArray16(schema_, references_, value10);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value10);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value10);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value10);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value10);
      case "Date":
        return yield* FromDate6(schema_, references_, value10);
      case "Function":
        return yield* FromFunction7(schema_, references_, value10);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value10);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value10);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value10);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value10);
      case "Never":
        return yield* FromNever6(schema_, references_, value10);
      case "Not":
        return yield* FromNot8(schema_, references_, value10);
      case "Null":
        return yield* FromNull6(schema_, references_, value10);
      case "Number":
        return yield* FromNumber6(schema_, references_, value10);
      case "Object":
        return yield* FromObject13(schema_, references_, value10);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value10);
      case "Record":
        return yield* FromRecord12(schema_, references_, value10);
      case "Ref":
        return yield* FromRef12(schema_, references_, value10);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value10);
      case "String":
        return yield* FromString6(schema_, references_, value10);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value10);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value10);
      case "This":
        return yield* FromThis11(schema_, references_, value10);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value10);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value10);
      case "Union":
        return yield* FromUnion20(schema_, references_, value10);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value10);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value10);
      case "Void":
        return yield* FromVoid5(schema_, references_, value10);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value10);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value10, useHoisting = true) {
    return `(${[...Visit17(schema, references, value10, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value10, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value10, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type73) {
    const annotation = state.language === "typescript" ? `: ${type73}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type73) {
    return state.language === "typescript" ? `: ${type73}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value10) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value10);
    }
    function formatRegistryFunction(format, value10) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value10);
    }
    function hashFunction(value10) {
      return Hash(value10);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
var W$ = Object.create;
var { defineProperty: G1, getPrototypeOf: J$, getOwnPropertyNames: Z$ } = Object;
var X$ = Object.prototype.hasOwnProperty;
var R0 = ($, W, J) => {
  J = $ != null ? W$(J$($)) : {};
  const Z = W || !$ || !$.__esModule ? G1(J, "default", { value: $, enumerable: true }) : J;
  for (let X of Z$($))
    if (!X$.call(Z, X))
      G1(Z, X, { get: () => $[X], enumerable: true });
  return Z;
};
var X0 = ($, W) => () => (W || $((W = { exports: {} }).exports, W), W.exports);
var I1 = X0((k$, l0) => {
  var K0 = function() {
  }, Y$ = function($, W, J) {
    this.fn = $, this.context = W, this.once = J || false;
  }, U1 = function($, W, J, Z, X) {
    if (typeof J !== "function")
      throw new TypeError("The listener must be a function");
    var B = new Y$(J, Z || $, X), Y = f ? f + W : W;
    if (!$._events[Y])
      $._events[Y] = B, $._eventsCount++;
    else if (!$._events[Y].fn)
      $._events[Y].push(B);
    else
      $._events[Y] = [$._events[Y], B];
    return $;
  }, E0 = function($, W) {
    if (--$._eventsCount === 0)
      $._events = new K0;
    else
      delete $._events[W];
  }, g = function() {
    this._events = new K0, this._eventsCount = 0;
  }, B$ = Object.prototype.hasOwnProperty, f = "~";
  if (Object.create) {
    if (K0.prototype = Object.create(null), !new K0().__proto__)
      f = false;
  }
  g.prototype.eventNames = function $() {
    var W = [], J, Z;
    if (this._eventsCount === 0)
      return W;
    for (Z in J = this._events)
      if (B$.call(J, Z))
        W.push(f ? Z.slice(1) : Z);
    if (Object.getOwnPropertySymbols)
      return W.concat(Object.getOwnPropertySymbols(J));
    return W;
  };
  g.prototype.listeners = function $(W) {
    var J = f ? f + W : W, Z = this._events[J];
    if (!Z)
      return [];
    if (Z.fn)
      return [Z.fn];
    for (var X = 0, B = Z.length, Y = new Array(B);X < B; X++)
      Y[X] = Z[X].fn;
    return Y;
  };
  g.prototype.listenerCount = function $(W) {
    var J = f ? f + W : W, Z = this._events[J];
    if (!Z)
      return 0;
    if (Z.fn)
      return 1;
    return Z.length;
  };
  g.prototype.emit = function $(W, J, Z, X, B, Y) {
    var D = f ? f + W : W;
    if (!this._events[D])
      return false;
    var Q = this._events[D], z = arguments.length, G, U;
    if (Q.fn) {
      if (Q.once)
        this.removeListener(W, Q.fn, undefined, true);
      switch (z) {
        case 1:
          return Q.fn.call(Q.context), true;
        case 2:
          return Q.fn.call(Q.context, J), true;
        case 3:
          return Q.fn.call(Q.context, J, Z), true;
        case 4:
          return Q.fn.call(Q.context, J, Z, X), true;
        case 5:
          return Q.fn.call(Q.context, J, Z, X, B), true;
        case 6:
          return Q.fn.call(Q.context, J, Z, X, B, Y), true;
      }
      for (U = 1, G = new Array(z - 1);U < z; U++)
        G[U - 1] = arguments[U];
      Q.fn.apply(Q.context, G);
    } else {
      var T = Q.length, j;
      for (U = 0;U < T; U++) {
        if (Q[U].once)
          this.removeListener(W, Q[U].fn, undefined, true);
        switch (z) {
          case 1:
            Q[U].fn.call(Q[U].context);
            break;
          case 2:
            Q[U].fn.call(Q[U].context, J);
            break;
          case 3:
            Q[U].fn.call(Q[U].context, J, Z);
            break;
          case 4:
            Q[U].fn.call(Q[U].context, J, Z, X);
            break;
          default:
            if (!G)
              for (j = 1, G = new Array(z - 1);j < z; j++)
                G[j - 1] = arguments[j];
            Q[U].fn.apply(Q[U].context, G);
        }
      }
    }
    return true;
  };
  g.prototype.on = function $(W, J, Z) {
    return U1(this, W, J, Z, false);
  };
  g.prototype.once = function $(W, J, Z) {
    return U1(this, W, J, Z, true);
  };
  g.prototype.removeListener = function $(W, J, Z, X) {
    var B = f ? f + W : W;
    if (!this._events[B])
      return this;
    if (!J)
      return E0(this, B), this;
    var Y = this._events[B];
    if (Y.fn) {
      if (Y.fn === J && (!X || Y.once) && (!Z || Y.context === Z))
        E0(this, B);
    } else {
      for (var D = 0, Q = [], z = Y.length;D < z; D++)
        if (Y[D].fn !== J || X && !Y[D].once || Z && Y[D].context !== Z)
          Q.push(Y[D]);
      if (Q.length)
        this._events[B] = Q.length === 1 ? Q[0] : Q;
      else
        E0(this, B);
    }
    return this;
  };
  g.prototype.removeAllListeners = function $(W) {
    var J;
    if (W) {
      if (J = f ? f + W : W, this._events[J])
        E0(this, J);
    } else
      this._events = new K0, this._eventsCount = 0;
    return this;
  };
  g.prototype.off = g.prototype.removeListener;
  g.prototype.addListener = g.prototype.on;
  g.prefixed = f;
  g.EventEmitter = g;
  if (typeof l0 !== "undefined")
    l0.exports = g;
});
var J1 = X0((_W, R1) => {
  var j$ = function($) {
    var W = $.indexOf("%");
    if (W === -1)
      return $;
    var J = $.length, Z = "", X = 0, B = 0, Y = W, D = w1;
    while (W > -1 && W < J) {
      var Q = C1($[W + 1], 4), z = C1($[W + 2], 0), G = Q | z, U = W1[G];
      if (D = W1[256 + D + U], B = B << 6 | G & W1[364 + U], D === w1)
        Z += $.slice(X, Y), Z += B <= 65535 ? String.fromCharCode(B) : String.fromCharCode(55232 + (B >> 10), 56320 + (B & 1023)), B = 0, X = W + 3, W = Y = $.indexOf("%", X);
      else if (D === F$)
        return null;
      else {
        if (W += 3, W < J && $.charCodeAt(W) === 37)
          continue;
        return null;
      }
    }
    return Z + $.slice(X);
  }, C1 = function($, W) {
    var J = P$[$];
    return J === undefined ? 255 : J << W;
  }, w1 = 12, F$ = 0, W1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], P$ = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  R1.exports = j$;
});
var x1 = X0((GW, L1) => {
  var T$ = function($) {
    const W = new b1;
    if (typeof $ !== "string")
      return W;
    let J = $.length, Z = "", X = "", B = -1, Y = -1, D = false, Q = false, z = false, G = false, U = false, T = 0;
    for (let j = 0;j < J + 1; j++)
      if (T = j !== J ? $.charCodeAt(j) : 38, T === 38) {
        if (U = Y > B, !U)
          Y = j;
        if (Z = $.slice(B + 1, Y), U || Z.length > 0) {
          if (z)
            Z = Z.replace(H1, " ");
          if (D)
            Z = E1(Z) || Z;
          if (U) {
            if (X = $.slice(Y + 1, j), G)
              X = X.replace(H1, " ");
            if (Q)
              X = E1(X) || X;
          }
          const K = W[Z];
          if (K === undefined)
            W[Z] = X;
          else if (K.pop)
            K.push(X);
          else
            W[Z] = [K, X];
        }
        X = "", B = j, Y = j, D = false, Q = false, z = false, G = false;
      } else if (T === 61)
        if (Y <= B)
          Y = j;
        else
          Q = true;
      else if (T === 43)
        if (Y > B)
          G = true;
        else
          z = true;
      else if (T === 37)
        if (Y > B)
          Q = true;
        else
          D = true;
    return W;
  }, E1 = J1(), H1 = /\+/g, b1 = function() {
  };
  b1.prototype = Object.create(null);
  L1.exports = T$;
});
var f1 = X0((zW, g1) => {
  var S$ = function($) {
    const W = $.length;
    if (W === 0)
      return "";
    let J = "", Z = 0, X = 0;
    $:
      for (;X < W; X++) {
        let B = $.charCodeAt(X);
        while (B < 128) {
          if (V$[B] !== 1) {
            if (Z < X)
              J += $.slice(Z, X);
            Z = X + 1, J += l[B];
          }
          if (++X === W)
            break $;
          B = $.charCodeAt(X);
        }
        if (Z < X)
          J += $.slice(Z, X);
        if (B < 2048) {
          Z = X + 1, J += l[192 | B >> 6] + l[128 | B & 63];
          continue;
        }
        if (B < 55296 || B >= 57344) {
          Z = X + 1, J += l[224 | B >> 12] + l[128 | B >> 6 & 63] + l[128 | B & 63];
          continue;
        }
        if (++X, X >= W)
          throw new Error("URI malformed");
        const Y = $.charCodeAt(X) & 1023;
        Z = X + 1, B = 65536 + ((B & 1023) << 10 | Y), J += l[240 | B >> 18] + l[128 | B >> 12 & 63] + l[128 | B >> 6 & 63] + l[128 | B & 63];
      }
    if (Z === 0)
      return $;
    if (Z < W)
      return J + $.slice(Z);
    return J;
  }, l = Array.from({ length: 256 }, ($, W) => "%" + ((W < 16 ? "0" : "") + W.toString(16)).toUpperCase()), V$ = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  g1.exports = { encodeString: S$ };
});
var k1 = X0((KW, v1) => {
  var y1 = function($) {
    const W = typeof $;
    if (W === "string")
      return Z1($);
    else if (W === "bigint")
      return $.toString();
    else if (W === "boolean")
      return $ ? "true" : "false";
    else if (W === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : Z1("" + $);
    return "";
  }, q$ = function($) {
    let W = "";
    if ($ === null || typeof $ !== "object")
      return W;
    const J = "&", Z = Object.keys($), X = Z.length;
    let B = 0;
    for (let Y = 0;Y < X; Y++) {
      const D = Z[Y], Q = $[D], z = Z1(D) + "=";
      if (Y)
        W += J;
      if (Array.isArray(Q)) {
        B = Q.length;
        for (let G = 0;G < B; G++) {
          if (G)
            W += J;
          W += z, W += y1(Q[G]);
        }
      } else
        W += z, W += y1(Q);
    }
    return W;
  }, { encodeString: Z1 } = f1();
  v1.exports = q$;
});
var X1 = X0((UW, F0) => {
  var m1 = x1(), u1 = k1(), h1 = { parse: m1, stringify: u1 };
  F0.exports = h1;
  F0.exports.default = h1;
  F0.exports.parse = m1;
  F0.exports.stringify = u1;
});
var B0 = ($, W) => ({ part: $, store: null, inert: W !== undefined ? new Map(W.map((J) => [J.part.charCodeAt(0), J])) : null, params: null, wildcardStore: null });
var z1 = ($, W) => ({ ...$, part: W });
var K1 = ($) => ({ paramName: $, store: null, inert: null });

class s {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, W, J) {
    let Z;
    if (typeof W != "string")
      throw TypeError("Route path must be a string");
    W === "" ? W = "/" : W[0] !== "/" && (W = `/${W}`), this.history.push([$, W, J]);
    let X = W[W.length - 1] === "*";
    X && (W = W.slice(0, -1));
    let B = W.split(s.regex.static), Y = W.match(s.regex.params) || [];
    B[B.length - 1] === "" && B.pop(), Z = this.root[$] ? this.root[$] : this.root[$] = B0("/");
    let D = 0;
    for (let Q = 0;Q < B.length; ++Q) {
      let z = B[Q];
      if (Q > 0) {
        let G = Y[D++].slice(1);
        if (Z.params === null)
          Z.params = K1(G);
        else if (Z.params.paramName !== G)
          throw Error(`Cannot create route "${W}" with parameter "${G}" because a route already exists with a different parameter name ("${Z.params.paramName}") in the same location`);
        let U = Z.params;
        if (U.inert === null) {
          Z = U.inert = B0(z);
          continue;
        }
        Z = U.inert;
      }
      for (let G = 0;; ) {
        if (G === z.length) {
          if (G < Z.part.length) {
            let U = z1(Z, Z.part.slice(G));
            Object.assign(Z, B0(z, [U]));
          }
          break;
        }
        if (G === Z.part.length) {
          if (Z.inert === null)
            Z.inert = new Map;
          else if (Z.inert.has(z.charCodeAt(G))) {
            Z = Z.inert.get(z.charCodeAt(G)), z = z.slice(G), G = 0;
            continue;
          }
          let U = B0(z.slice(G));
          Z.inert.set(z.charCodeAt(G), U), Z = U;
          break;
        }
        if (z[G] !== Z.part[G]) {
          let U = z1(Z, Z.part.slice(G)), T = B0(z.slice(G));
          Object.assign(Z, B0(Z.part.slice(0, G), [U, T])), Z = T;
          break;
        }
        ++G;
      }
    }
    if (D < Y.length) {
      let Q = Y[D], z = Q.slice(1);
      if (Z.params === null)
        Z.params = K1(z);
      else if (Z.params.paramName !== z)
        throw Error(`Cannot create route "${W}" with parameter "${z}" because a route already exists with a different parameter name ("${Z.params.paramName}") in the same location`);
      return Z.params.store === null && (Z.params.store = J), Z.params.store;
    }
    return X ? (Z.wildcardStore === null && (Z.wildcardStore = J), Z.wildcardStore) : (Z.store === null && (Z.store = J), Z.store);
  }
  find($, W) {
    let J = this.root[$];
    return J ? p0(W, W.length, J, 0) : null;
  }
}
var p0 = ($, W, J, Z) => {
  let X = J?.part, B = Z + X.length;
  if (X.length > 1) {
    if (B > W)
      return null;
    if (X.length < 15) {
      for (let Y = 1, D = Z + 1;Y < X.length; ++Y, ++D)
        if (X.charCodeAt(Y) !== $.charCodeAt(D))
          return null;
    } else if ($.substring(Z, B) !== X)
      return null;
  }
  if (B === W)
    return J.store !== null ? { store: J.store, params: {} } : J.wildcardStore !== null ? { store: J.wildcardStore, params: { "*": "" } } : null;
  if (J.inert !== null) {
    let Y = J.inert.get($.charCodeAt(B));
    if (Y !== undefined) {
      let D = p0($, W, Y, B);
      if (D !== null)
        return D;
    }
  }
  if (J.params !== null) {
    let Y = J.params, D = $.indexOf("/", B);
    if (D !== B) {
      if (D === -1 || D >= W) {
        if (Y.store !== null) {
          let Q = {};
          return Q[Y.paramName] = $.substring(B, W), { store: Y.store, params: Q };
        }
      } else if (Y.inert !== null) {
        let Q = p0($, W, Y.inert, D);
        if (Q !== null)
          return Q.params[Y.paramName] = $.substring(B, D), Q;
      }
    }
  }
  return J.wildcardStore !== null ? { store: J.wildcardStore, params: { "*": $.substring(B, W) } } : null;
};
var M1 = R0(I1(), 1);
var O1 = M1.default;
var H0 = () => {
  let $;
  return [new Promise((J) => {
    $ = J;
  }), $];
};
var t = () => {
  const [$, W] = H0(), [J, Z] = H0(), X = [], B = [];
  return { signal: $, consume: (Y) => {
    switch (Y.type) {
      case "begin":
        if (Y.unit && X.length === 0)
          for (let D = 0;D < Y.unit; D++) {
            const [Q, z] = H0(), [G, U] = H0();
            X.push(Q), B.push([(T) => {
              z({ children: [], end: G, name: T.name ?? "", skip: false, time: T.time });
            }, (T) => {
              U(T);
            }]);
          }
        W({ children: X, end: J, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        Z(Y.time);
        break;
    }
  }, consumeChild(Y) {
    switch (Y.type) {
      case "begin":
        if (!B[0])
          return;
        const [D] = B[0];
        D({ children: [], end: J, name: Y.name ?? "", skip: false, time: Y.time });
        break;
      case "end":
        const Q = B.shift();
        if (!Q)
          return;
        Q[1](Y.time);
    }
  }, resolve() {
    W({ children: [], end: new Promise((Y) => Y(0)), name: "", skip: true, time: 0 });
    for (let [Y, D] of B)
      Y({ children: [], end: new Promise((Q) => Q(0)), name: "", skip: true, time: 0 }), D(0);
    Z(0);
  } };
};
var A1 = ($, W, J) => {
  return async function Z(Z) {
    if (Z.event !== "request" || Z.type !== "begin")
      return;
    const X = Z.id, B = $(), Y = t(), D = t(), Q = t(), z = t(), G = t(), U = t(), T = t(), j = t();
    Y.consume(Z);
    const K = (P) => {
      if (P.id === X)
        switch (P.event) {
          case "request":
            Y.consume(P);
            break;
          case "request.unit":
            Y.consumeChild(P);
            break;
          case "parse":
            D.consume(P);
            break;
          case "parse.unit":
            D.consumeChild(P);
            break;
          case "transform":
            Q.consume(P);
            break;
          case "transform.unit":
            Q.consumeChild(P);
            break;
          case "beforeHandle":
            z.consume(P);
            break;
          case "beforeHandle.unit":
            z.consumeChild(P);
            break;
          case "handle":
            G.consume(P);
            break;
          case "afterHandle":
            U.consume(P);
            break;
          case "afterHandle.unit":
            U.consumeChild(P);
            break;
          case "error":
            T.consume(P);
            break;
          case "error.unit":
            T.consumeChild(P);
            break;
          case "response":
            if (P.type === "begin")
              Y.resolve(), D.resolve(), Q.resolve(), z.resolve(), G.resolve(), U.resolve(), T.resolve();
            else
              B.off("event", K);
            j.consume(P);
            break;
          case "response.unit":
            j.consumeChild(P);
            break;
          case "exit":
            Y.resolve(), D.resolve(), Q.resolve(), z.resolve(), G.resolve(), U.resolve(), T.resolve();
            break;
        }
    };
    B.on("event", K), await J({ id: X, context: Z.ctx, set: Z.ctx?.set, store: Z.ctx?.store, time: Z.time, request: Y.signal, parse: D.signal, transform: Q.signal, beforeHandle: z.signal, handle: G.signal, afterHandle: U.signal, error: T.signal, response: j.signal }), B.emit(`res${X}.${W}`, undefined);
  };
};
var D$ = function($, W) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var J = {}, Z = W || {}, X = Z.decode || G$, B = 0;
  while (B < $.length) {
    var Y = $.indexOf("=", B);
    if (Y === -1)
      break;
    var D = $.indexOf(";", B);
    if (D === -1)
      D = $.length;
    else if (D < Y) {
      B = $.lastIndexOf(";", Y - 1) + 1;
      continue;
    }
    var Q = $.slice(B, Y).trim();
    if (J[Q] === undefined) {
      var z = $.slice(Y + 1, D).trim();
      if (z.charCodeAt(0) === 34)
        z = z.slice(1, -1);
      J[Q] = U$(z, X);
    }
    B = D + 1;
  }
  return J;
};
var _$ = function($, W, J) {
  var Z = J || {}, X = Z.encode || z$;
  if (typeof X !== "function")
    throw new TypeError("option encode is invalid");
  if (!b0.test($))
    throw new TypeError("argument name is invalid");
  var B = X(W);
  if (B && !b0.test(B))
    throw new TypeError("argument val is invalid");
  var Y = $ + "=" + B;
  if (Z.maxAge != null) {
    var D = Z.maxAge - 0;
    if (isNaN(D) || !isFinite(D))
      throw new TypeError("option maxAge is invalid");
    Y += "; Max-Age=" + Math.floor(D);
  }
  if (Z.domain) {
    if (!b0.test(Z.domain))
      throw new TypeError("option domain is invalid");
    Y += "; Domain=" + Z.domain;
  }
  if (Z.path) {
    if (!b0.test(Z.path))
      throw new TypeError("option path is invalid");
    Y += "; Path=" + Z.path;
  }
  if (Z.expires) {
    var Q = Z.expires;
    if (!K$(Q) || isNaN(Q.valueOf()))
      throw new TypeError("option expires is invalid");
    Y += "; Expires=" + Q.toUTCString();
  }
  if (Z.httpOnly)
    Y += "; HttpOnly";
  if (Z.secure)
    Y += "; Secure";
  if (Z.partitioned)
    Y += "; Partitioned";
  if (Z.priority) {
    var z = typeof Z.priority === "string" ? Z.priority.toLowerCase() : Z.priority;
    switch (z) {
      case "low":
        Y += "; Priority=Low";
        break;
      case "medium":
        Y += "; Priority=Medium";
        break;
      case "high":
        Y += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (Z.sameSite) {
    var G = typeof Z.sameSite === "string" ? Z.sameSite.toLowerCase() : Z.sameSite;
    switch (G) {
      case true:
        Y += "; SameSite=Strict";
        break;
      case "lax":
        Y += "; SameSite=Lax";
        break;
      case "strict":
        Y += "; SameSite=Strict";
        break;
      case "none":
        Y += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Y;
};
var G$ = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var z$ = function($) {
  return encodeURIComponent($);
};
var K$ = function($) {
  return Q$.call($) === "[object Date]" || $ instanceof Date;
};
var U$ = function($, W) {
  try {
    return W($);
  } catch (J) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var L0 = D$;
var x0 = _$;
var Q$ = Object.prototype.toString;
var b0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

class m {
  $;
  W;
  name;
  setter;
  constructor($, W = {}) {
    this._value = $;
    this.property = W;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const W = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in W)
      this._value = W.value, delete W.value;
    return this.property = W, this.sync();
  }
  set($) {
    const W = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in W)
      this._value = W.value, delete W.value;
    return this.property = W, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var N1 = ($, W, J) => new Proxy($, { get(Z, X) {
  if (X in Z)
    return Z[X];
  const B = new m(undefined, J ? { ...J } : undefined);
  return B.setter = W, B.name = X, B;
}, set(Z, X, B) {
  if (!(B instanceof m))
    return false;
  if (!W.cookie)
    W.cookie = {};
  return B.setter = W, B.name = X, B.sync(), Z[X] = B, true;
} });
var g0 = async ($, W, { secret: J, sign: Z, ...X } = {}) => {
  if (!W)
    return N1({}, $, X);
  const B = {}, Y = typeof J === "string";
  if (Z && Z !== true && !Array.isArray(Z))
    Z = [Z];
  const D = Object.keys(L0(W));
  for (let Q = 0;Q < D.length; Q++) {
    const z = D[Q];
    let G = L0(W)[z];
    if (Z === true || Z?.includes(z)) {
      if (!J)
        throw new Error("No secret is provided to cookie plugin");
      if (Y) {
        if (G = await i0(G, J), G === false)
          throw new U0(z);
      } else {
        let j = true;
        for (let K = 0;K < J.length; K++) {
          const P = await i0(G, J[K]);
          if (P !== false) {
            G = P, j = false;
            break;
          }
        }
        if (j)
          throw new U0(z);
      }
    }
    if (G === undefined)
      continue;
    const U = G.charCodeAt(0);
    if (U === 123 || U === 91)
      try {
        const j = new m(JSON.parse(G));
        j.setter = $, j.name = z, B[z] = j;
        continue;
      } catch {
      }
    if (f0(G))
      G = +G;
    else if (G === "true")
      G = true;
    else if (G === "false")
      G = false;
    const T = new m(G, X);
    T.setter = $, T.name = z, B[z] = T;
  }
  return N1(B, $);
};
var I0 = "toJSON" in new Headers;
var u = ($) => {
  for (let W in $)
    return true;
  return false;
};
var M0 = ($, W) => {
  const J = $.size;
  if (J && W && W.status !== 206 && W.status !== 304 && W.status !== 412 && W.status !== 416 || !W && J) {
    if (W) {
      if (W.headers instanceof Headers) {
        if (I0)
          W.headers = W.headers.toJSON();
        else
          for (let [Z, X] of W.headers.entries())
            if (Z in W.headers)
              W.headers[Z] = X;
      }
      return new Response($, { status: W.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${J - 1}/${J}` }, W.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${J - 1}/${J}` } });
  }
  return new Response($);
};
var F1 = ($, W) => {
  if (!$ || !Array.isArray(W))
    return $;
  $.delete("Set-Cookie");
  for (let J = 0;J < W.length; J++) {
    const Z = W[J].indexOf("=");
    $.append("Set-Cookie", `${W[J].slice(0, Z)}=${W[J].slice(Z + 1)}`);
  }
  return $;
};
var j1 = ($) => {
  if (!$ || typeof $ !== "object" || !u($))
    return;
  const W = [];
  for (let [J, Z] of Object.entries($)) {
    if (!J || !Z)
      continue;
    if (Array.isArray(Z.value))
      for (let X = 0;X < Z.value.length; X++) {
        let B = Z.value[X];
        if (B === undefined || B === null)
          continue;
        if (typeof B === "object")
          B = JSON.stringify(B);
        W.push(x0(J, B, Z));
      }
    else {
      let X = Z.value;
      if (X === undefined || X === null)
        continue;
      if (typeof X === "object")
        X = JSON.stringify(X);
      W.push(x0(J, Z.value, Z));
    }
  }
  if (W.length === 0)
    return;
  if (W.length === 1)
    return W[0];
  return W;
};
var v = ($, W) => {
  if ($?.[$.$passthrough])
    $ = $[$.$passthrough];
  if ($?.[c])
    W.status = $[c], $ = $.response;
  if (u(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = O0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && u(W.cookie))
      W.headers["Set-Cookie"] = j1(W.cookie);
    if (W.headers["Set-Cookie"] && Array.isArray(W.headers["Set-Cookie"]))
      W.headers = F1(new Headers(W.headers), W.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return M0($, W);
      case "Object":
      case "Array":
        return Response.json($, W);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, W);
      case undefined:
        if (!$)
          return new Response("", W);
        return Response.json($, W);
      case "Response":
        const J = { ...W.headers };
        if (I0)
          W.headers = $.headers.toJSON();
        else
          for (let [X, B] of $.headers.entries())
            if (X in W.headers)
              W.headers[X] = B;
        for (let X in J)
          $.headers.append(X, J[X]);
        return $;
      case "Error":
        return h($, W);
      case "Promise":
        return $.then((X) => v(X, W));
      case "Function":
        return v($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response) {
          const X = { ...W.headers };
          if (I0)
            W.headers = $.headers.toJSON();
          else
            for (let [B, Y] of $.headers.entries())
              if (B in W.headers)
                W.headers[B] = Y;
          for (let B in X)
            $.headers.append(B, X[B]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((X) => v(X, W));
        if ($ instanceof Error)
          return h($, W);
        const Z = JSON.stringify($);
        if (Z.charCodeAt(0) === 123) {
          if (!W.headers["Content-Type"])
            W.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), W);
        }
        return new Response(Z, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return M0($, W);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return h($, W);
      case "Promise":
        return $.then((Z) => {
          const X = i(Z);
          if (X !== undefined)
            return X;
          return new Response("");
        });
      case "Function":
        return i($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((Z) => v(Z, W));
        if ($ instanceof Error)
          return h($, W);
        const J = JSON.stringify($);
        if (J.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(J);
    }
};
var y = ($, W) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    W.status = $[c], $ = $.response;
  if (u(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = O0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && u(W.cookie))
      W.headers["Set-Cookie"] = j1(W.cookie);
    if (W.headers["Set-Cookie"] && Array.isArray(W.headers["Set-Cookie"]))
      W.headers = F1(new Headers(W.headers), W.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return M0($, W);
      case "Object":
      case "Array":
        return Response.json($, W);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, W);
      case undefined:
        if (!$)
          return;
        return Response.json($, W);
      case "Response":
        const J = Object.assign({}, W.headers);
        if (I0)
          W.headers = $.headers.toJSON();
        else
          for (let [X, B] of $.headers.entries())
            if (!(X in W.headers))
              W.headers[X] = B;
        for (let X in J)
          $.headers.append(X, J[X]);
        if ($.status !== W.status)
          W.status = $.status;
        return $;
      case "Promise":
        return $.then((X) => {
          const B = y(X, W);
          if (B !== undefined)
            return B;
          return;
        });
      case "Error":
        return h($, W);
      case "Function":
        return y($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response) {
          const X = { ...W.headers };
          if (I0)
            W.headers = $.headers.toJSON();
          else
            for (let [B, Y] of $.headers.entries())
              if (B in W.headers)
                W.headers[B] = Y;
          for (let B in X)
            $.headers.append(B, X[B]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((X) => y(X, W));
        if ($ instanceof Error)
          return h($, W);
        const Z = JSON.stringify($);
        if (Z.charCodeAt(0) === 123) {
          if (!W.headers["Content-Type"])
            W.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), W);
        }
        return new Response(Z, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return M0($, W);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((Z) => {
          const X = y(Z, W);
          if (X !== undefined)
            return X;
          return;
        });
      case "Error":
        return h($, W);
      case "Function":
        return i($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((Z) => y(Z, W));
        if ($ instanceof Error)
          return h($, W);
        const J = JSON.stringify($);
        if (J.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(J);
    }
};
var i = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    return v($.response, { status: $[c], headers: {} });
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return M0($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return h($);
    case "Promise":
      return $.then(i);
    case "Function":
      return i($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return new Response($.body, { headers: { "Content-Type": "application/json" } });
      if ($ instanceof Promise)
        return $.then(i);
      if ($ instanceof Error)
        return h($);
      const W = JSON.stringify($);
      if (W.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(W);
  }
};
var h = ($, W) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: W?.status !== 200 ? W?.status ?? 500 : 500, headers: W?.headers });
var r0 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var t0 = ($, W) => {
  const J = new URL($);
  return J.pathname = W, J.toString();
};
var I$ = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || u(Object.getPrototypeOf($));
var d = ($, W, { skipKeys: J } = {}) => {
  if (r0($) && r0(W))
    for (let [Z, X] of Object.entries(W)) {
      if (J?.includes(Z))
        continue;
      if (!r0(X)) {
        $[Z] = X;
        continue;
      }
      if (!(Z in $)) {
        $[Z] = X;
        continue;
      }
      if (I$(X)) {
        $[Z] = X;
        continue;
      }
      $[Z] = d($[Z], X);
    }
  return $;
};
var T1 = ($, W) => d($, W, { skipKeys: ["properties"] });
var H = ($, W) => {
  if (!$)
    return [];
  const J = [...Array.isArray($) ? $ : [$]], Z = [];
  for (let X of J)
    if (X.$elysiaChecksum)
      Z.push(X.$elysiaChecksum);
  for (let X of Array.isArray(W) ? W : [W])
    if (!Z.includes(X?.$elysiaChecksum))
      J.push(X);
  return J;
};
var M$ = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "onResponse", "mapResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var a = ($, W) => {
  return { ...$, ...W, body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, response: W?.response ?? $?.response, type: $?.type || W?.type, detail: d(W?.detail ?? {}, $?.detail ?? {}), parse: H($?.parse ?? [], W?.parse ?? []), transform: H($?.transform ?? [], W?.transform ?? []), beforeHandle: H($?.beforeHandle ?? [], W?.beforeHandle ?? []), afterHandle: H($?.afterHandle ?? [], W?.afterHandle ?? []), onResponse: H($?.onResponse ?? [], W?.onResponse ?? []), mapResponse: H($?.mapResponse ?? [], W?.mapResponse ?? []), trace: H($?.trace ?? [], W?.trace ?? []), error: H($?.error ?? [], W?.error ?? []) };
};
var p = ($, { models: W = {}, additionalProperties: J = false, dynamic: Z = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  const X = typeof $ === "string" ? W[$] : $;
  if (X.type === "object" && "additionalProperties" in X === false)
    X.additionalProperties = J;
  if (Z)
    return { schema: X, references: "", checkFunc: () => {
    }, code: "", Check: (B) => exports_value2.Check(X, B), Errors: (B) => exports_value2.Errors(X, B), Code: () => "" };
  return TypeCompiler.Compile(X, Object.values(W));
};
var a0 = ($, { models: W = {}, additionalProperties: J = false, dynamic: Z = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  const X = typeof $ === "string" ? W[$] : $, B = (D, Q) => {
    if (Z)
      return { schema: D, references: "", checkFunc: () => {
      }, code: "", Check: (z) => exports_value2.Check(D, z), Errors: (z) => exports_value2.Errors(D, z), Code: () => "" };
    return TypeCompiler.Compile(D, Q);
  };
  if (Kind in X) {
    if ("additionalProperties" in X === false)
      X.additionalProperties = J;
    return { 200: B(X, Object.values(W)) };
  }
  const Y = {};
  return Object.keys(X).forEach((D) => {
    const Q = X[+D];
    if (typeof Q === "string") {
      if (Q in W) {
        const z = W[Q];
        z.type === "object" && "additionalProperties" in z, Y[+D] = Kind in z ? B(z, Object.values(W)) : z;
      }
      return;
    }
    if (Q.type === "object" && "additionalProperties" in Q === false)
      Q.additionalProperties = J;
    Y[+D] = Kind in Q ? B(Q, Object.values(W)) : Q;
  }), Y;
};
var O$ = typeof Bun !== "undefined";
var A$ = O$ && typeof Bun.hash === "function";
var A0 = ($) => {
  if (A$)
    return Bun.hash($);
  let W = 9;
  for (let J = 0;J < $.length; )
    W = Math.imul(W ^ $.charCodeAt(J++), 387420489);
  return W = W ^ W >>> 9;
};
var v0 = ($, W, J) => {
  const Z = (X) => {
    if (J && !X.$elysiaChecksum)
      X.$elysiaChecksum = J;
    return X;
  };
  return { ...$, ...W, start: H($.start, ("start" in W ? W.start ?? [] : []).map(Z)), request: H($.request, ("request" in W ? W.request ?? [] : []).map(Z)), parse: H($.parse, "parse" in W ? W?.parse ?? [] : []).map(Z), transform: H($.transform, (W?.transform ?? []).map(Z)), beforeHandle: H($.beforeHandle, (W?.beforeHandle ?? []).map(Z)), afterHandle: H($.afterHandle, (W?.afterHandle ?? []).map(Z)), mapResponse: H($.mapResponse, (W?.mapResponse ?? []).map(Z)), onResponse: H($.onResponse, (W?.onResponse ?? []).map(Z)), trace: $.trace, error: H($.error, (W?.error ?? []).map(Z)), stop: H($.stop, ("stop" in W ? W.stop ?? [] : []).map(Z)) };
};
var V1 = ($, W = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (W)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((J) => {
    if (W)
      J.$elysiaHookType = "global";
    else
      J.$elysiaHookType = undefined;
    return J;
  });
};
var Y0 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((W) => W.$elysiaHookType === "global");
};
var s0 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: Y0($?.parse), transform: Y0($?.transform), beforeHandle: Y0($?.beforeHandle), afterHandle: Y0($?.afterHandle), onResponse: Y0($?.onResponse), error: Y0($?.error) };
};
var O0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var Q0 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const J = new TextEncoder, Z = await crypto.subtle.importKey("raw", J.encode(W), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), X = await crypto.subtle.sign("HMAC", Z, J.encode($)), B = Array.from(new Uint8Array(X)), Y = btoa(String.fromCharCode(...B));
  return `${$}.${Y.replace(/=+$/, "")}`;
};
var i0 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const J = $.slice(0, $.lastIndexOf("."));
  return await Q0(J, W) === $ ? J : false;
};
var o0 = ($, W, J = W) => {
  for (let [Z, X] of Object.entries(W ?? {})) {
    if (M$.includes(Z) || !(Z in $))
      continue;
    if (typeof $[Z] === "function")
      $[Z](X);
    else if (typeof $[Z] === "object")
      o0($[Z], X, J);
  }
};
var f0 = ($) => $.trim().length !== 0 && !Number.isNaN(Number($));
var S1 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var D0 = Symbol("ElysiaErrorCode");
var c = Symbol("ElysiaResponse");
var N0 = (S1?.NODE_ENV ?? S1?.ENV) === "production";
class k0 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class o extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class U0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, W) {
    super(W ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class R extends Error {
  $;
  W;
  J;
  code = "VALIDATION";
  status = 400;
  constructor($, W, J) {
    const Z = N0 ? undefined : ("Errors" in W) ? W.Errors(J).First() : exports_value2.Errors(W, J).First(), X = Z?.schema.error ? typeof Z.schema.error === "function" ? Z.schema.error($, W, J) : Z.schema.error : undefined, B = Z?.path?.slice(1) || "root";
    let Y = "";
    if (X)
      Y = typeof X === "object" ? JSON.stringify(X) : X + "";
    else if (N0)
      Y = JSON.stringify({ type: $, message: Z?.message });
    else
      Y = JSON.stringify({ type: $, at: B, message: Z?.message, expected: exports_value2.Create(W.schema), found: J, errors: [...W.Errors(J)] }, null, 2);
    super(Y);
    this.type = $;
    this.validator = W;
    this.value = J;
    Object.setPrototypeOf(this, R.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel($) {
    const W = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(W);
    } catch {
      return W;
    }
  }
  get model() {
    return R.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var $1 = { open($) {
  $.data.open?.($);
}, message($, W) {
  $.data.message?.($, W);
}, drain($) {
  $.data.drain?.($);
}, close($, W, J) {
  $.data.close?.($, W, J);
} };

class _0 {
  $;
  W;
  validator;
  constructor($, W) {
    this.raw = $;
    this.data = W;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else {
      const J = new Uint32Array(1);
      crypto.getRandomValues(J), this.id = J[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, W = undefined, J) => {
      if (this.validator?.Check(W) === false)
        throw new R("message", this.validator, W);
      if (typeof W === "object")
        W = JSON.stringify(W);
      return this.raw.publish($, W, J), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new R("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var c1 = R0(X1(), 1);
var d1 = R0(J1(), 1);
var w$ = new Headers().toJSON;
var p1 = new RegExp(" (\\w+) = context", "g");
var l1 = { value: 0 };
var i1 = ({ hasTrace: $, hasTraceSet: W = false, addFn: J, condition: Z = {} }) => {
  if ($)
    return J("\nconst reporter = getReporter()\n"), (X, { name: B, attribute: Y = "", unit: D = 0 } = {}) => {
      const Q = X.indexOf("."), z = Q === -1;
      if (X !== "request" && X !== "response" && !Z[z ? X : X.slice(0, Q)])
        return () => {
          if (W && X === "afterHandle")
            J("\nawait traceDone\n");
        };
      if (z)
        B ||= X;
      else
        B ||= "anonymous";
      J("\n" + `reporter.emit('event', {
					id,
					event: '${X}',
					type: 'begin',
					name: '${B}',
					time: performance.now(),
					${z ? `unit: ${D},` : ""}
					${Y}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let G = false;
      return () => {
        if (G)
          return;
        if (G = true, J("\n" + `reporter.emit('event', {
							id,
							event: '${X}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), W && X === "afterHandle")
          J("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var P0 = ($) => {
  const W = $.indexOf(")");
  if ($.charCodeAt(W + 2) === 61 && $.charCodeAt(W + 5) !== 123)
    return true;
  return $.includes("return");
};
var C$ = ($, { injectResponse: W = "" } = {}) => ({ composeValidation: (J, Z = `c.${J}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${J}',
${J},
${Z}
)` : `c.set.status = 400; return new ValidationError(
	'${J}',
	${J},
	${Z}
).toResponse(c.set.headers)`, composeResponseValidation: (J = "r") => {
  const Z = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${J}
)` : `return new ValidationError(
'response',
response[c.set.status],
${J}
).toResponse(c.set.headers)`;
  return `\n${W}
		if(!(${J} instanceof Response) && response[c.set.status]?.Check(${J}) === false) {
	if(!(response instanceof Error))
		${Z}
}\n`;
} });
var b = ($, W) => {
  if (W.startsWith("[object "))
    return false;
  if (W = W.trimStart(), W = W.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(W))
    W = W.slice(W.indexOf("("));
  const J = W.charCodeAt(0) === 40 || W.startsWith("function") ? W.slice(W.indexOf("(") + 1, W.indexOf(")")) : W.slice(0, W.indexOf("=") - 1);
  if (J === "")
    return false;
  const Z = J.charCodeAt(0) === 123 ? J.indexOf("...") : -1;
  if (J.charCodeAt(0) === 123) {
    if (J.includes($))
      return true;
    if (Z === -1)
      return false;
  }
  if (W.match(new RegExp(`${J}(.${$}|\\["${$}"\\])`)))
    return true;
  const X = Z !== -1 ? J.slice(Z + 3, J.indexOf(" ", Z + 3)) : undefined;
  if (W.match(new RegExp(`${X}(.${$}|\\["${$}"\\])`)))
    return true;
  const B = [J];
  if (X)
    B.push(X);
  for (let D of W.matchAll(p1))
    B.push(D[1]);
  const Y = new RegExp(`{.*?} = (${B.join("|")})`, "g");
  for (let [D] of W.matchAll(Y))
    if (D.includes(`{ ${$}`) || D.includes(`, ${$}`))
      return true;
  return false;
};
var T0 = ($) => {
  if ($ = $.trimStart(), $.startsWith("[object"))
    return false;
  if ($ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const W = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (W === "")
    return false;
  const J = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1, Z = J !== -1 ? W.slice(J + 3, W.indexOf(" ", J + 3)) : undefined, X = [W];
  if (Z)
    X.push(Z);
  for (let Y of $.matchAll(p1))
    X.push(Y[1]);
  for (let Y of X)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  const B = new RegExp(`{.*?} = (${X.join("|")})`, "g");
  for (let [Y] of $.matchAll(B))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Y}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var G0 = Symbol.for("TypeBox.Kind");
var m0 = ($, W) => {
  if (!W)
    return;
  if (G0 in W && W[G0] === $)
    return true;
  if (W.type === "object") {
    const J = W.properties;
    for (let Z of Object.keys(J)) {
      const X = J[Z];
      if (X.type === "object") {
        if (m0($, X))
          return true;
      } else if (X.anyOf) {
        for (let B = 0;B < X.anyOf.length; B++)
          if (m0($, X.anyOf[B]))
            return true;
      }
      if (G0 in X && X[G0] === $)
        return true;
    }
    return false;
  }
  return W.properties && G0 in W.properties && W.properties[G0] === $;
};
var e = ($, W) => {
  if (!W)
    return;
  if (W.type === "object") {
    const J = W.properties;
    if (!J)
      return false;
    for (let Z of Object.keys(J)) {
      const X = J[Z];
      if ($ in X)
        return true;
      if (X.type === "object") {
        if (e($, X))
          return true;
      } else if (X.anyOf) {
        for (let B = 0;B < X.anyOf.length; B++)
          if (e($, X.anyOf[B]))
            return true;
      }
    }
    return false;
  }
  return $ in W;
};
var B1 = Symbol.for("TypeBox.Transform");
var $0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const W = $.properties;
    for (let J of Object.keys(W)) {
      const Z = W[J];
      if (Z.type === "object") {
        if ($0(Z))
          return true;
      } else if (Z.anyOf) {
        for (let B = 0;B < Z.anyOf.length; B++)
          if ($0(Z.anyOf[B]))
            return true;
      }
      if (B1 in Z)
        return true;
    }
    return false;
  }
  return B1 in $ || $.properties && B1 in $.properties;
};
var R$ = ($) => {
  if (!$)
    return;
  const W = $?.schema;
  if (W && "anyOf" in W) {
    let J = false;
    const Z = W.anyOf[0].type;
    for (let X of W.anyOf)
      if (X.type !== Z) {
        J = true;
        break;
      }
    if (!J)
      return Z;
  }
  return $.schema?.type;
};
var E$ = /(?:return|=>) \S+\(/g;
var L = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  const W = $.toString();
  if (W.includes("=> response.clone("))
    return false;
  return !!W.match(E$);
};
var H$ = ($) => {
  if (!$.includes("query: {") || $.includes("query,") || $.includes("query }"))
    return false;
  const W = $.indexOf("query: {");
  return $ = $.slice(W + 9), $ = $.slice(0, $.indexOf("}")), $.split(",").map((J) => {
    const Z = J.indexOf(":");
    if (Z === -1)
      return J.trim();
    return J.slice(0, Z).trim();
  });
};
var n1 = ({ path: $, method: W, hooks: J, validator: Z, handler: X, handleError: B, definitions: Y, schema: D, onRequest: Q, config: z, getReporter: G, setHeader: U }) => {
  const T = z.forceErrorEncapsulation || J.error.length > 0 || typeof Bun === "undefined" || J.onResponse.length > 0 || !!J.trace.length, j = typeof X === "function", K = j ? "handler(c)" : "handler", P = J.onResponse.length ? `\n;(async () => {${J.onResponse.map((M, O) => `await res${O}(c)`).join(";")}})();\n` : "", I = J.trace.map((M) => M.toString());
  let A = false;
  if (j && T0(X.toString()))
    A = true;
  if (!A)
    for (let [M, O] of Object.entries(J)) {
      if (!Array.isArray(O) || !O.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(M))
        continue;
      for (let F of O) {
        if (typeof F !== "function")
          continue;
        if (T0(F.toString())) {
          A = true;
          break;
        }
      }
      if (A)
        break;
    }
  const N = { parse: I.some((M) => b("parse", M)), transform: I.some((M) => b("transform", M)), handle: I.some((M) => b("handle", M)), beforeHandle: I.some((M) => b("beforeHandle", M)), afterHandle: I.some((M) => b("afterHandle", M)), error: T || I.some((M) => b("error", M)) }, V = J.trace.length > 0;
  let _ = "";
  const k = Z || W !== "GET" && W !== "HEAD" ? [X, ...J.transform, ...J.beforeHandle, ...J.afterHandle, ...J.mapResponse].map((M) => typeof M === "function" ? M.toString() : `${M}`) : [], V0 = W !== "GET" && W !== "HEAD" && (A || J.type !== "none" && (!!Z.body || !!J.type || k.some((M) => b("body", M)))), h0 = A || Z.headers || k.some((M) => b("headers", M)) || U && Object.keys(U).length, S0 = A || !!Z.cookie || k.some((M) => b("cookie", M)), x = Z?.cookie?.schema;
  let r = "";
  if (x?.sign) {
    if (!x.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${W}) ${$}.`);
    const M = !x.secrets ? undefined : typeof x.secrets === "string" ? x.secrets : x.secrets[0];
    if (r += `const _setCookie = c.set.cookie
		if(_setCookie) {`, x.sign === true)
      r += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${M}')
			}`;
    else
      for (let O of x.sign)
        r += `if(_setCookie['${O}']?.value) { c.set.cookie['${O}'].value = await signCookie(_setCookie['${O}'].value, '${M}') }\n`;
    r += "}\n";
  }
  const { composeValidation: J0, composeResponseValidation: q0 } = C$(T);
  if (h0)
    _ += w$ ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (S0) {
    const M = (F, S) => {
      const w = x?.[F] ?? S;
      if (!w)
        return typeof S === "string" ? `${F}: "${S}",` : `${F}: ${S},`;
      if (typeof w === "string")
        return `${F}: '${w}',`;
      if (w instanceof Date)
        return `${F}: new Date(${w.getTime()}),`;
      return `${F}: ${w},`;
    }, O = x ? `{
			secret: ${x.secrets !== undefined ? typeof x.secrets === "string" ? `'${x.secrets}'` : "[" + x.secrets.reduce((F, S) => F + `'${S}',`, "") + "]" : "undefined"},
			sign: ${x.sign === true ? true : x.sign !== undefined ? "[" + x.sign.reduce((F, S) => F + `'${S}',`, "") + "]" : "undefined"},
			${M("domain")}
			${M("expires")}
			${M("httpOnly")}
			${M("maxAge")}
			${M("path", "/")}
			${M("priority")}
			${M("sameSite")}
			${M("secure")}
		}` : "undefined";
    if (h0)
      _ += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${O})\n`;
    else
      _ += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${O})\n`;
  }
  if (A || Z.query || k.some((M) => b("query", M))) {
    let M = [], O = false;
    if (Z.query && Z.query.schema.type === "object")
      M = Object.keys(Z.query.schema.properties);
    else
      for (let F of k) {
        const S = H$(F);
        if (!S) {
          O = true;
          continue;
        }
        for (let w of S)
          if (M.indexOf(w) === -1)
            M.push(w);
      }
    if (!O && M.length)
      _ += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${M.map((F, S) => `
						memory = url.indexOf('${F}=')

						const a${S} = memory === -1 ? undefined : url.slice(memory = memory + ${F.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join("\n")}

				c.query = {
					${M.map((F, S) => `${F}: a${S}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    else
      _ += "c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}";
  }
  const w0 = J.trace.map((M) => M.toString()).some((M) => b("set", M) || T0(M));
  A || J.trace.some((M) => b("set", M.toString()));
  const C0 = U && Object.keys(U).length || w0 || S0 || k.some((M) => b("set", M)) || Q.some((M) => b("set", M.toString()));
  if (V)
    _ += "\nconst id = c.$$requestId\n";
  const E = i1({ hasTrace: V, hasTraceSet: w0, condition: N, addFn: (M) => {
    _ += M;
  } });
  if (_ += T ? "\n try {\n" : "", w0) {
    _ += "\nconst traceDone = Promise.all([";
    for (let M = 0;M < J.trace.length; M++)
      _ += `new Promise(r => { reporter.once(\`res\${id}.${M}\`, r) }),`;
    _ += "])\n";
  }
  const Z0 = typeof X === "function" && L(X), c0 = S0 || V0 || w0 || Z0 || !!J.mapResponse.length || J.parse.length > 0 || J.afterHandle.some(L) || J.beforeHandle.some(L) || J.transform.some(L), o1 = E("parse", { unit: J.parse.length });
  if (V0) {
    const M = R$(Z?.body);
    if (J.type && !Array.isArray(J.type)) {
      if (J.type)
        switch (J.type) {
          case "json":
          case "application/json":
            _ += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            _ += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            _ += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            _ += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            _ += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (J.parse.length)
        _ += "}}";
    } else {
      const F = (() => {
        if (J.parse.length && M && !Array.isArray(J.type)) {
          const S = Z?.body?.schema;
          switch (M) {
            case "object":
              if (m0("File", S) || m0("Files", S))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (F)
        _ += F;
      else {
        if (_ += "\n", _ += h0 ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", _ += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, J.parse.length) {
          _ += "let used = false\n";
          const S = E("parse", { unit: J.parse.length });
          for (let w = 0;w < J.parse.length; w++) {
            const d0 = E("parse.unit", { name: J.parse[w].name }), C = `bo${w}`;
            if (w !== 0)
              _ += "if(!used) {\n";
            if (_ += `let ${C} = parse[${w}](c, contentType)\n`, _ += `if(${C} instanceof Promise) ${C} = await ${C}\n`, _ += `if(${C} !== undefined) { c.body = ${C}; used = true }\n`, d0(), w !== 0)
              _ += "}";
          }
          S();
        }
        if (J.parse.length)
          _ += "if (!used)";
        _ += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}\n`, _ += "}\n";
      }
    }
    _ += "\n";
  }
  if (o1(), J?.transform) {
    const M = E("transform", { unit: J.transform.length });
    for (let O = 0;O < J.transform.length; O++) {
      const F = J.transform[O], S = E("transform.unit", { name: F.name });
      if (F.$elysia === "derive")
        _ += L(F) ? `Object.assign(c, await transform[${O}](c));` : `Object.assign(c, transform[${O}](c));`;
      else
        _ += L(F) ? `await transform[${O}](c);` : `transform[${O}](c);`;
      S();
    }
    M();
  }
  if (Z) {
    if (_ += "\n", Z.headers) {
      if (e("default", Z.headers.params))
        for (let [M, O] of Object.entries(exports_value2.Default(Z.headers.schema, {}))) {
          const F = typeof O === "object" ? JSON.stringify(O) : `'${O}'`;
          if (F)
            _ += `c.headers['${M}'] ??= ${F}\n`;
        }
      if (_ += `if(headers.Check(c.headers) === false) {
				${J0("headers")}
			}`, $0(Z.headers.schema))
        _ += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (Z.params) {
      if (e("default", Z.params.schema))
        for (let [M, O] of Object.entries(exports_value2.Default(Z.params.schema, {}))) {
          const F = typeof O === "object" ? JSON.stringify(O) : `'${O}'`;
          if (F)
            _ += `c.params['${M}'] ??= ${F}\n`;
        }
      if (_ += `if(params.Check(c.params) === false) {
				${J0("params")}
			}`, $0(Z.params.schema))
        _ += "\nc.params = params.Decode(c.params)\n";
    }
    if (Z.query) {
      if (e("default", Z.query.schema))
        for (let [M, O] of Object.entries(exports_value2.Default(Z.query.schema, {}))) {
          const F = typeof O === "object" ? JSON.stringify(O) : `'${O}'`;
          if (F)
            _ += `c.query['${M}'] ??= ${F}\n`;
        }
      if (_ += `if(query.Check(c.query) === false) {
				${J0("query")}
			}`, $0(Z.query.schema))
        _ += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (Z.body) {
      if (e("default", Z.body.schema))
        _ += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(Z.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${J0("body")}
     			}
            }`;
      else
        _ += `if(body.Check(c.body) === false) {
			${J0("body")}
		}`;
      if ($0(Z.body.schema))
        _ += "\nc.body = body.Decode(c.body)\n";
    }
    if (u(Z.cookie?.schema.properties ?? {})) {
      if (_ += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, e("default", Z.cookie.schema))
        for (let [M, O] of Object.entries(exports_value2.Default(Z.cookie.schema, {})))
          _ += `cookieValue['${M}'] = ${typeof O === "object" ? JSON.stringify(O) : O}\n`;
      if (_ += `if(cookie.Check(cookieValue) === false) {
				${J0("cookie", "cookieValue")}
			}`, $0(Z.cookie.schema))
        _ += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (J?.beforeHandle) {
    const M = E("beforeHandle", { unit: J.beforeHandle.length });
    for (let O = 0;O < J.beforeHandle.length; O++) {
      const F = J.beforeHandle[O], S = E("beforeHandle.unit", { name: F.name }), w = P0(F.toString());
      if (F.$elysia === "resolve")
        _ += L(F) ? `Object.assign(c, await beforeHandle[${O}](c));` : `Object.assign(c, beforeHandle[${O}](c));`;
      else if (!w)
        _ += L(F) ? `await beforeHandle[${O}](c);\n` : `beforeHandle[${O}](c);\n`, S();
      else {
        _ += L(F) ? `be = await beforeHandle[${O}](c);\n` : `be = beforeHandle[${O}](c);\n`, S(), _ += "if(be !== undefined) {\n";
        const d0 = E("afterHandle", { unit: J.transform.length });
        if (J.afterHandle) {
          E("handle", { name: j ? X.name : undefined })();
          for (let C = 0;C < J.afterHandle.length; C++) {
            const e1 = P0(J.afterHandle[C].toString()), $$ = E("afterHandle.unit", { name: J.afterHandle[C].name });
            if (_ += "c.response = be\n", !e1)
              _ += L(J.afterHandle[C]) ? `await afterHandle[${C}](c, be)\n` : `afterHandle[${C}](c, be)\n`;
            else
              _ += L(J.afterHandle[C]) ? `af = await afterHandle[${C}](c)\n` : `af = afterHandle[${C}](c)\n`, _ += "if(af !== undefined) { c.response = be = af }\n";
            $$();
          }
        }
        if (d0(), Z.response)
          _ += q0("be");
        if (J.mapResponse.length) {
          _ += "c.response = be";
          for (let C = 0;C < J.mapResponse.length; C++)
            _ += `\nif(mr === undefined) {
							mr = onMapResponse[${C}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}\n`;
        }
        _ += r, _ += "return mapEarlyResponse(be, c.set)}\n";
      }
    }
    M();
  }
  if (J?.afterHandle.length) {
    const M = E("handle", { name: j ? X.name : undefined });
    if (J.afterHandle.length)
      _ += Z0 ? `let r = c.response = await ${K};\n` : `let r = c.response = ${K};\n`;
    else
      _ += Z0 ? `let r = await ${K};\n` : `let r = ${K};\n`;
    M();
    const O = E("afterHandle", { unit: J.afterHandle.length });
    for (let F = 0;F < J.afterHandle.length; F++) {
      const S = P0(J.afterHandle[F].toString()), w = E("afterHandle.unit", { name: J.afterHandle[F].name });
      if (!S)
        _ += L(J.afterHandle[F]) ? `await afterHandle[${F}](c)\n` : `afterHandle[${F}](c)\n`, w();
      else if (_ += L(J.afterHandle[F]) ? `af = await afterHandle[${F}](c)\n` : `af = afterHandle[${F}](c)\n`, w(), Z.response)
        _ += "if(af !== undefined) {", O(), _ += q0("af"), _ += "c.response = af }";
      else
        _ += "if(af !== undefined) {", O(), _ += "c.response = af}\n";
    }
    if (O(), _ += "r = c.response\n", Z.response)
      _ += q0();
    if (_ += r, J.mapResponse.length)
      for (let F = 0;F < J.mapResponse.length; F++)
        _ += `\nmr = onMapResponse[${F}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr\n`;
    if (C0)
      _ += "return mapResponse(r, c.set)\n";
    else
      _ += "return mapCompactResponse(r)\n";
  } else {
    const M = E("handle", { name: j ? X.name : undefined });
    if (Z.response || J.mapResponse.length) {
      if (_ += Z0 ? `let r = await ${K};\n` : `let r = ${K};\n`, M(), Z.response)
        _ += q0();
      if (E("afterHandle")(), J.mapResponse.length) {
        _ += "c.response = r";
        for (let O = 0;O < J.mapResponse.length; O++)
          _ += `\nif(mr === undefined) { 
						mr = onMapResponse[${O}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}\n`;
      }
      if (_ += r, X instanceof Response)
        _ += `return ${K}.clone()\n`;
      else if (C0)
        _ += "return mapResponse(r, c.set)\n";
      else
        _ += "return mapCompactResponse(r)\n";
    } else if (N.handle || S0) {
      if (_ += Z0 ? `let r = await ${K};\n` : `let r = ${K};\n`, M(), E("afterHandle")(), J.mapResponse.length) {
        _ += "c.response = r";
        for (let O = 0;O < J.mapResponse.length; O++)
          _ += `\nif(mr === undefined) {
							mr = onMapResponse[${O}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}\n`;
      }
      if (_ += r, C0)
        _ += "return mapResponse(r, c.set)\n";
      else
        _ += "return mapCompactResponse(r)\n";
    } else {
      M();
      const O = Z0 ? `await ${K}` : K;
      if (E("afterHandle")(), X instanceof Response)
        _ += `return ${K}.clone()\n`;
      else if (C0)
        _ += `return mapResponse(${O}, c.set)\n`;
      else
        _ += `return mapCompactResponse(${O})\n`;
    }
  }
  if (T || P) {
    if (_ += `
} catch(error) {`, !c0)
      _ += "return (async () => {";
    _ += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const M = E("error", { unit: J.error.length });
    if (J.error.length) {
      _ += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let O = 0;O < J.error.length; O++) {
        const F = `er${O}`, S = E("error.unit", { name: J.error[O].name });
        if (_ += `\nlet ${F} = handleErrors[${O}](c)\n`, L(J.error[O]))
          _ += `if (${F} instanceof Promise) ${F} = await ${F}\n`;
        S(), _ += `${F} = mapEarlyResponse(${F}, set)\n`, _ += `if (${F}) {`, _ += `return ${F} }\n`;
      }
    }
    if (M(), _ += "return handleError(c, error)\n\n", !c0)
      _ += "})()";
    if (_ += "}", P || V) {
      _ += " finally { ";
      const O = E("response", { unit: J.onResponse.length });
      _ += P, O(), _ += "}";
    }
  }
  return _ = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${J.onResponse.length ? `const ${J.onResponse.map((M, O) => `res${O} = onResponse[${O}]`).join(",")}` : ""}

	return ${c0 ? "async" : ""} function handle(c) {
		${J.beforeHandle.length ? "let be" : ""}
		${J.afterHandle.length ? "let af" : ""}
		${J.mapResponse.length ? "let mr" : ""}

		${D && Y ? "c.schema = schema; c.defs = definitions;" : ""}
		${_}
	}`, Function("hooks", _)({ handler: X, hooks: J, validator: Z, handleError: B, utils: { mapResponse: v, mapCompactResponse: i, mapEarlyResponse: y, parseQuery: c1.parse }, error: { NotFoundError: o, ValidationError: R, InternalServerError: k0 }, schema: D, definitions: Y, ERROR_CODE: D0, getReporter: G, requestId: l1, parseCookie: g0, signCookie: Q0, decodeURIComponent: d1.default });
};
var Y1 = ($) => {
  let W = "", J = "";
  for (let K of Object.keys($.decorators))
    W += `,${K}: app.decorators.${K}`;
  const { router: Z, staticRouter: X } = $, B = $.event.trace.length > 0, Y = `
	const route = router.find(request.method, path) ${Z.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params

	return route.store(ctx)`;
  let D = "";
  for (let [K, { code: P, all: I }] of Object.entries(X.map))
    D += `case '${K}':\nswitch(request.method) {\n${P}\n${I ?? "default: break map"}}\n\n`;
  const Q = $.event.request.some(L);
  if (J += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}
	${X.variables}
	${$.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${Q ? "async" : ""} function map(request) {\n`, $.event.request.length)
    J += "let re";
  const z = $.event.trace.map((K) => K.toString()), G = i1({ hasTrace: B, hasTraceSet: $.event.trace.some((K) => {
    const P = K.toString();
    return b("set", P) || T0(P);
  }), condition: { request: z.some((K) => b("request", K) || T0(K)) }, addFn: (K) => {
    J += K;
  } });
  if ($.event.request.length) {
    J += `
			${B ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${B ? ",$$requestId: +id" : ""}
				${W}
			}
		`;
    const K = G("request", { attribute: "ctx", unit: $.event.request.length });
    J += "\n try {\n";
    for (let P = 0;P < $.event.request.length; P++) {
      const I = $.event.request[P], A = P0(I.toString()), N = L(I), V = G("request.unit", { name: $.event.request[P].name });
      if (A) {
        if (J += `re = mapEarlyResponse(
					${N ? "await" : ""} onRequest[${P}](ctx),
					ctx.set
				)\n`, V(), A)
          J += "if(re !== undefined) return re\n";
      } else
        J += `${N ? "await" : ""} onRequest[${P}](ctx)\n`, V();
    }
    J += `} catch (error) {
			return app.handleError(ctx, error)
		}`, K(), J += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else
    J += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${B ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${B ? ",$$requestId: id" : ""}
			${W}
		}`, G("request", { unit: $.event.request.length, attribute: z.some((K) => b("context", K)) || z.some((K) => b("store", K)) || z.some((K) => b("set", K)) ? "ctx" : "" })();
  const { wsPaths: U, wsRouter: T } = $;
  if (Object.keys(U).length || T.history.length) {
    J += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [K, P] of Object.entries(U))
      J += `
					case '${K}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${P}(ctx)

						break`;
    J += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  J += `
		map: switch(path) {
			${D}

			default:
				break
		}

		${Y}
	}`;
  const j = Q1($);
  return $.handleError = j, Function("data", J)({ app: $, mapEarlyResponse: y, NotFoundError: o, getReporter: () => $.reporter, requestId: l1, handleError: j });
};
var Q1 = ($) => {
  let W = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${$.event.error.find(L) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let J = 0;J < $.event.error.length; J++) {
    const Z = $.event.error[J], X = `${L(Z) ? "await " : ""}onError[${J}](context)`;
    if (P0(Z.toString()))
      W += `r = ${X}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}\n`;
    else
      W += X + "\n";
  }
  return W += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`, Function("inject", W)({ app: $, mapResponse: v, ERROR_CODE: D0, ELYSIA_RESPONSE: c });
};
var u0 = R0(X1(), 1);
var D1 = ($) => async (W) => {
  const J = { cookie: {}, status: 200, headers: {} };
  let Z;
  if ($.decorators)
    Z = $.decorators, Z.request = W, Z.set = J, Z.store = $.store;
  else
    Z = { set: J, store: $.store, request: W };
  const X = W.url, B = X.indexOf("/", 11), Y = X.indexOf("?", B + 1), D = Y === -1 ? X.substring(B) : X.substring(B, Y);
  try {
    for (let I = 0;I < $.event.request.length; I++) {
      const A = $.event.request[I];
      let N = A(Z);
      if (N instanceof Promise)
        N = await N;
      if (N = y(N, J), N)
        return N;
    }
    const Q = $.dynamicRouter.find(W.method, D) ?? $.dynamicRouter.find("ALL", D);
    if (!Q)
      throw new o;
    const { handle: z, hooks: G, validator: U, content: T } = Q.store;
    let j;
    if (W.method !== "GET" && W.method !== "HEAD")
      if (T)
        switch (T) {
          case "application/json":
            j = await W.json();
            break;
          case "text/plain":
            j = await W.text();
            break;
          case "application/x-www-form-urlencoded":
            j = u0.parse(await W.text());
            break;
          case "application/octet-stream":
            j = await W.arrayBuffer();
            break;
          case "multipart/form-data":
            j = {};
            const I = await W.formData();
            for (let A of I.keys()) {
              if (j[A])
                continue;
              const N = I.getAll(A);
              if (N.length === 1)
                j[A] = N[0];
              else
                j[A] = N;
            }
            break;
        }
      else {
        let I = W.headers.get("content-type");
        if (I) {
          const A = I.indexOf(";");
          if (A !== -1)
            I = I.slice(0, A);
          for (let N = 0;N < G.parse.length; N++) {
            let V = G.parse[N](Z, I);
            if (V instanceof Promise)
              V = await V;
            if (V) {
              j = V;
              break;
            }
          }
          if (j === undefined)
            switch (I) {
              case "application/json":
                j = await W.json();
                break;
              case "text/plain":
                j = await W.text();
                break;
              case "application/x-www-form-urlencoded":
                j = u0.parse(await W.text());
                break;
              case "application/octet-stream":
                j = await W.arrayBuffer();
                break;
              case "multipart/form-data":
                j = {};
                const N = await W.formData();
                for (let V of N.keys()) {
                  if (j[V])
                    continue;
                  const _ = N.getAll(V);
                  if (_.length === 1)
                    j[V] = _[0];
                  else
                    j[V] = _;
                }
                break;
            }
        }
      }
    Z.body = j, Z.params = Q?.params || undefined, Z.query = Y === -1 ? {} : u0.parse(X.substring(Y + 1)), Z.headers = {};
    for (let [I, A] of W.headers.entries())
      Z.headers[I] = A;
    const K = U?.cookie?.schema;
    Z.cookie = await g0(Z.set, Z.headers.cookie, K ? { secret: K.secrets !== undefined ? typeof K.secrets === "string" ? K.secrets : K.secrets.join(",") : undefined, sign: K.sign === true ? true : K.sign !== undefined ? typeof K.sign === "string" ? K.sign : K.sign.join(",") : undefined } : undefined);
    for (let I = 0;I < G.transform.length; I++) {
      const A = G.transform[I](Z);
      if (G.transform[I].$elysia === "derive")
        if (A instanceof Promise)
          Object.assign(Z, await A);
        else
          Object.assign(Z, A);
      else if (A instanceof Promise)
        await A;
    }
    if (U) {
      if (U.headers) {
        const I = {};
        for (let A in W.headers)
          I[A] = W.headers.get(A);
        if (U.headers.Check(I) === false)
          throw new R("header", U.headers, I);
      }
      if (U.params?.Check(Z.params) === false)
        throw new R("params", U.params, Z.params);
      if (U.query?.Check(Z.query) === false)
        throw new R("query", U.query, Z.query);
      if (U.cookie) {
        const I = {};
        for (let [A, N] of Object.entries(Z.cookie))
          I[A] = N.value;
        if (U.cookie?.Check(I) === false)
          throw new R("cookie", U.cookie, I);
      }
      if (U.body?.Check(j) === false)
        throw new R("body", U.body, j);
    }
    for (let I = 0;I < G.beforeHandle.length; I++) {
      let A = G.beforeHandle[I](Z);
      if (A instanceof Promise)
        A = await A;
      if (A !== undefined) {
        Z.response = A;
        for (let V = 0;V < G.afterHandle.length; V++) {
          let _ = G.afterHandle[V](Z);
          if (_ instanceof Promise)
            _ = await _;
          if (_)
            A = _;
        }
        const N = y(A, Z.set);
        if (N)
          return N;
      }
    }
    let P = z(Z);
    if (P instanceof Promise)
      P = await P;
    if (!G.afterHandle.length) {
      const I = U?.response?.[P.status];
      if (I?.Check(P) === false)
        throw new R("response", I, P);
    } else {
      Z.response = P;
      for (let I = 0;I < G.afterHandle.length; I++) {
        let A = G.afterHandle[I](Z);
        if (A instanceof Promise)
          A = await A;
        const N = y(A, Z.set);
        if (N !== undefined) {
          const V = U?.response?.[P.status];
          if (V?.Check(N) === false)
            throw new R("response", V, N);
          return N;
        }
      }
    }
    if (Z.set.cookie && K?.sign) {
      const I = !K.secrets ? undefined : typeof K.secrets === "string" ? K.secrets : K.secrets[0];
      if (K.sign === true)
        for (let [A, N] of Object.entries(Z.set.cookie))
          Z.set.cookie[A].value = await Q0(N.value, "${secret}");
      else
        for (let A of K.sign) {
          if (!(A in K.properties))
            continue;
          if (Z.set.cookie[A]?.value)
            Z.set.cookie[A].value = await Q0(Z.set.cookie[A].value, I);
        }
    }
    return v(P, Z.set);
  } catch (Q) {
    if (Q.status)
      J.status = Q.status;
    return $.handleError(Z, Q);
  } finally {
    for (let Q of $.event.onResponse)
      await Q(Z);
  }
};
var r1 = ($) => async (W, J) => {
  const Z = Object.assign(W, { error: J, code: J.code });
  Z.set = W.set;
  for (let X = 0;X < $.event.error.length; X++) {
    let B = $.event.error[X](Z);
    if (B instanceof Promise)
      B = await B;
    if (B !== undefined && B !== null)
      return v(B, W.set);
  }
  return new Response(typeof J.cause === "string" ? J.cause : J.message, { headers: W.set.headers, status: J.status ?? 500 });
};
var q = Object.assign({}, Type);
try {
  TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch {
}
var t1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var _1 = ($, W) => {
  if (!(W instanceof Blob))
    return false;
  if ($.minSize && W.size < t1($.minSize))
    return false;
  if ($.maxSize && W.size > t1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!W.type.startsWith($.extension))
        return false;
    } else {
      for (let J = 0;J < $.extension.length; J++)
        if (W.type.startsWith($.extension[J]))
          return true;
      return false;
    }
  return true;
};
var L$ = TypeSystem.Type("Files", ($, W) => {
  if (!Array.isArray(W))
    return _1($, W);
  if ($.minItems && W.length < $.minItems)
    return false;
  if ($.maxItems && W.length > $.maxItems)
    return false;
  for (let J = 0;J < W.length; J++)
    if (!_1($, W[J]))
      return false;
  return true;
});
exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
exports_format.Set("ObjectString", ($) => {
  let W = $.charCodeAt(0);
  if (W === 9 || W === 10 || W === 32)
    W = $.trimStart().charCodeAt(0);
  if (W !== 123 && W !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var W0 = { Numeric: ($) => {
  const W = Type.Number($);
  return q.Transform(q.Union([q.String({ format: "numeric", default: 0 }), q.Number($)], $)).Decode((J) => {
    const Z = +J;
    if (isNaN(Z))
      return J;
    if ($ && !exports_value2.Check(W, Z))
      throw new R("property", W, Z);
    return Z;
  }).Encode((J) => J);
}, ObjectString: ($, W) => q.Transform(q.Union([q.String({ format: "ObjectString", default: "" }), q.Object($, W)], W)).Decode((J) => {
  if (typeof J === "string")
    try {
      return JSON.parse(J);
    } catch {
      return J;
    }
  return J;
}).Encode((J) => JSON.stringify(J)), File: TypeSystem.Type("File", _1), Files: ($ = {}) => q.Transform(q.Union([L$($)])).Decode((W) => {
  if (Array.isArray(W))
    return W;
  return [W];
}).Encode((W) => W), Nullable: ($) => q.Union([q.Null(), $]), MaybeEmpty: ($) => q.Union([q.Null(), q.Undefined(), $]), Cookie: ($, W) => q.Object($, W) };
q.ObjectString = W0.ObjectString;
q.Numeric = W0.Numeric;
q.File = ($ = {}) => W0.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
q.Files = ($ = {}) => W0.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
q.Nullable = ($) => W0.Nullable($);
q.MaybeEmpty = W0.MaybeEmpty;
q.Cookie = W0.Cookie;

class n {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  macros = [];
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new O1;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new s;
  wsRouter = new s;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new s;
  lazyLoadModules = [];
  path = "";
  stack = undefined;
  constructor($) {
    if (this.config = { forceErrorEncapsulation: true, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, analytic: false, ...$, seed: $?.seed === undefined ? "" : $?.seed }, $?.analytic && ($?.name || $?.seed !== undefined))
      this.stack = new Error().stack;
  }
  add($, W, J, Z, { allowMeta: X = false, skipPrefix: B = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof W === "string")
      W = [W];
    for (let Y of W) {
      if (Y = Y === "" ? Y : Y.charCodeAt(0) === 47 ? Y : `/${Y}`, this.config.prefix && !B)
        Y = this.config.prefix + Y;
      if (Z?.type)
        switch (Z.type) {
          case "text":
            Z.type = "text/plain";
            break;
          case "json":
            Z.type = "application/json";
            break;
          case "formdata":
            Z.type = "multipart/form-data";
            break;
          case "urlencoded":
            Z.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            Z.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const D = this.definitions.type;
      let Q = p(Z?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: D, additionalProperties: true });
      if (u(this.config.cookie ?? {}))
        if (Q)
          Q.schema = T1(Q.schema, this.config.cookie ?? {});
        else
          Q = p(q.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: D, additionalProperties: true });
      const z = { body: p(Z?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: D }), headers: p(Z?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: D, additionalProperties: true }), params: p(Z?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: D }), query: p(Z?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: D }), cookie: Q, response: a0(Z?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: D }) }, G = this.event, U = Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
      if (this.macros.length) {
        const I = (N) => (V, _) => {
          if (typeof V === "function" || Array.isArray(V)) {
            if (!Z[N])
              Z[N] = [];
            if (typeof Z[N] === "function")
              Z[N] = [Z[N]];
            if (Array.isArray(V))
              Z[N] = Z[N].concat(V);
            else
              Z[N].push(V);
            return;
          }
          const { insert: k = "after", stack: V0 = "local" } = V;
          if (V0 === "global") {
            if (!Array.isArray(_))
              if (k === "before")
                G[N].unshift(_);
              else
                G[N].push(_);
            else if (k === "before")
              G[N] = _.concat(G[N]);
            else
              G[N] = G[N].concat(_);
            return;
          } else {
            if (!Z[N])
              Z[N] = [];
            if (typeof Z[N] === "function")
              Z[N] = [Z[N]];
            if (!Array.isArray(_))
              if (k === "before")
                Z[N].unshift(_);
              else
                Z[N].push(_);
            else if (k === "before")
              Z[N] = _.concat(Z[N]);
            else
              Z[N] = Z[N].concat(_);
            return;
          }
        }, A = { events: { global: G, local: Z }, onParse: I("parse"), onTransform: I("transform"), onBeforeHandle: I("beforeHandle"), onAfterHandle: I("afterHandle"), onResponse: I("onResponse"), onError: I("error") };
        for (let N of this.macros)
          o0(N(A), Z);
      }
      const T = a(G, Z), j = typeof J === "function";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, Y, { validator: z, hooks: T, content: Z?.type, handle: J }), this.config.strictPath === false)
          this.dynamicRouter.add($, U, { validator: z, hooks: T, content: Z?.type, handle: J });
        this.routes.push({ method: $, path: Y, composed: null, handler: J, hooks: T });
        return;
      }
      const K = n1({ path: Y, method: $, hooks: T, validator: z, handler: J, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: X ? this.definitions.type : undefined, schema: X ? this.schema : undefined, getReporter: () => this.reporter, setHeader: this.setHeaders });
      if (!j) {
        const I = Object.assign({ headers: {}, query: {}, params: {}, body: undefined, request: new Request(`http://localhost${Y}`), store: this.store, path: Y, set: { headers: this.setHeaders ?? {}, status: 200 } }, this.decorators);
        let A;
        for (let N of Object.values(T.request))
          try {
            const V = y(N(I), I.set);
            if (V !== undefined) {
              A = V;
              break;
            }
          } catch (V) {
            A = this.handleError(I, V);
            break;
          }
        if (A)
          K.response = A;
        else
          try {
            K.response = K(I);
          } catch (N) {
            K.response = this.handleError(I, N);
          }
      }
      const P = this.routes.findIndex((I) => I.path === Y && I.method === $);
      if (P !== -1)
        this.routes.splice(P, 1);
      if (this.routes.push({ method: $, path: Y, composed: K, handler: J, hooks: T }), $ === "$INTERNALWS") {
        const I = this.config.strictPath ? undefined : Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
        if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
          const A = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(K), K.response instanceof Response)
            this.staticRouter.variables += `const st${A} = staticRouter.handlers[${A}].response\n`;
          else
            this.staticRouter.variables += `const st${A} = staticRouter.handlers[${A}]\n`;
          if (this.wsPaths[Y] = A, I)
            this.wsPaths[I] = A;
        } else if (this.wsRouter.add("ws", Y, K), I)
          this.wsRouter.add("ws", I, K);
        return;
      }
      if (Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
        const I = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(K), K.response instanceof Response)
          this.staticRouter.variables += `const st${I} = staticRouter.handlers[${I}].response\n`;
        else
          this.staticRouter.variables += `const st${I} = staticRouter.handlers[${I}]\n`;
        if (!this.staticRouter.map[Y])
          this.staticRouter.map[Y] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[Y].all = `default: return st${I}(ctx)\n`;
        else if (K.response instanceof Response)
          this.staticRouter.map[Y].code = `case '${$}': return st${I}.clone()\n${this.staticRouter.map[Y].code}`;
        else
          this.staticRouter.map[Y].code = `case '${$}': return st${I}(ctx)\n${this.staticRouter.map[Y].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[U])
            this.staticRouter.map[U] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[U].all = `default: return st${I}(ctx)\n`;
          else if (K.response instanceof Response)
            this.staticRouter.map[U].code = `case '${$}': return st${I}.clone()\n${this.staticRouter.map[U].code}`;
          else
            this.staticRouter.map[U].code = `case '${$}': return st${I}(ctx)\n${this.staticRouter.map[U].code}`;
        }
      } else if (this.router.add($, Y, K), !this.config.strictPath)
        this.router.add($, Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/", K);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  resolve($) {
    return $.$elysia = "resolve", this.onBeforeHandle($);
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  mapResponse($) {
    return this.on("mapResponse", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", A1(() => this.reporter, this.event.trace.length, $)), this.on("trace", $), this;
  }
  error($, W) {
    switch (typeof $) {
      case "string":
        return W.prototype[D0] = $, this.definitions.error[$] = W, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [J, Z] of Object.entries($))
      Z.prototype[D0] = J, this.definitions.error[J] = Z;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, W) {
    for (let J of Array.isArray(W) ? W : [W])
      switch (J = V1(J), $) {
        case "start":
          this.event.start.push(J);
          break;
        case "request":
          this.event.request.push(J);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, J);
          break;
        case "transform":
          this.event.transform.push(J);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(J);
          break;
        case "afterHandle":
          this.event.afterHandle.push(J);
          break;
        case "mapResponse":
          this.event.mapResponse.push(J);
          break;
        case "response":
          this.event.onResponse.push(J);
          break;
        case "trace":
          this.event.trace.push(J);
          break;
        case "error":
          this.event.error.push(J);
          break;
        case "stop":
          this.event.stop.push(J);
          break;
      }
    return this;
  }
  group($, W, J) {
    const Z = new n({ ...this.config, prefix: "" });
    Z.store = this.store, Z.definitions = this.definitions, Z.getServer = () => this.server;
    const X = typeof W === "object", B = (X ? J : W)(Z);
    if (this.decorators = d(this.decorators, Z.decorators), B.event.request.length)
      this.event.request = [...this.event.request, ...B.event.request];
    if (B.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...B.event.onResponse];
    return this.model(B.definitions.type), Object.values(Z.routes).forEach(({ method: Y, path: D, handler: Q, hooks: z }) => {
      if (D = (X ? "" : this.config.prefix) + $ + D, X) {
        const G = W, U = z;
        this.add(Y, D, Q, a(G, { ...U, error: !U.error ? B.event.error : Array.isArray(U.error) ? [...U.error, ...B.event.error] : [U.error, ...B.event.error] }));
      } else
        this.add(Y, D, Q, a(z, { error: B.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, W) {
    if (!W)
      return this.event = v0(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const J = new n({ ...this.config, prefix: "" });
    J.store = this.store, J.definitions = this.definitions;
    const Z = W(J);
    if (this.decorators = d(this.decorators, J.decorators), Z.event.request.length)
      this.event.request = [...this.event.request, ...Z.event.request];
    if (Z.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Z.event.onResponse];
    return this.model(Z.definitions.type), Object.values(J.routes).forEach(({ method: X, path: B, handler: Y, hooks: D }) => {
      this.add(X, B, Y, a($, { ...D, error: !D.error ? Z.event.error : Array.isArray(D.error) ? [...D.error, ...Z.event.error] : [D.error, ...Z.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((W) => {
        if (typeof W === "function")
          return W(this);
        if (typeof W.default === "function")
          return W.default(this);
        return this._use(W);
      }).then((W) => W.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const X = $(this);
      if (X instanceof Promise)
        return this.lazyLoadModules.push(X.then((B) => {
          if (B instanceof n) {
            this.compile();
            for (let { method: Y, path: D, handler: Q, hooks: z } of Object.values(B.routes))
              this.add(Y, D, Q, a(z, { error: B.event.error }));
            return B;
          }
          if (typeof B === "function")
            return B(this);
          if (typeof B.default === "function")
            return B.default(this);
          return this._use(B);
        }).then((B) => B.compile())), this;
      return X;
    }
    const { name: W, seed: J } = $.config;
    $.getServer = () => this.getServer(), this.headers($.setHeaders);
    const Z = $.config.scoped;
    if (Z) {
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const B = J !== undefined ? A0(W + JSON.stringify(J)) : 0;
        if (this.dependencies[W].some(({ checksum: Y }) => B === Y))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: B, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: B, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })) });
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.macros = [...this.macros, ...$.macros], $.onRequest((B) => {
        Object.assign(B, this.decorators), Object.assign(B.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const X = this.mount($.fetch);
      return this.routes = this.routes.concat(X.routes), this;
    } else {
      $.reporter = this.reporter;
      for (let X of $.event.trace)
        this.trace(X);
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const X = J !== undefined ? A0(W + JSON.stringify(J)) : 0;
        if (!this.dependencies[W].some(({ checksum: Y }) => X === Y))
          this.macros.push(...$.macros);
        const B = [];
        for (let Y = 0;Y < this.macros.length; Y++) {
          const D = this.macros[Y];
          if (B.includes(D.$elysiaChecksum))
            this.macros.splice(Y, 1), Y--;
          B.push(D.$elysiaChecksum);
        }
      }
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: X, path: B, handler: Y, hooks: D } of Object.values($.routes))
      this.add(X, B, Y, a(D, { error: $.event.error }));
    if (!Z)
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const X = J !== undefined ? A0(W + JSON.stringify(J)) : 0;
        if (this.dependencies[W].some(({ checksum: B }) => X === B))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: X, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: X, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((B) => B?.$elysia === "derive").map((B) => ({ fn: B.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((B) => B?.$elysia === "resolve").map((B) => ({ fn: B.toString(), stack: new Error().stack ?? "" })) }), this.event = v0(this.event, s0($.event), X);
      } else
        this.event = v0(this.event, s0($.event));
    return this;
  }
  macro($) {
    return $.$elysiaChecksum = A0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), this.macros.push($), this;
  }
  mount($, W) {
    if ($ instanceof n || typeof $ === "function" || $.length === 0 || $ === "/") {
      const X = typeof $ === "function" ? $ : $ instanceof n ? $.compile().fetch : W instanceof n ? W.compile().fetch : W, B = async ({ request: Y, path: D }) => X(new Request(t0(Y.url, D || "/"), Y));
      return this.all("/", B, { type: "none" }), this.all("/*", B, { type: "none" }), this;
    }
    const J = $.length;
    if (W instanceof n)
      W = W.compile().fetch;
    const Z = async ({ request: X, path: B }) => W(new Request(t0(X.url, B.slice(J) || "/"), X));
    return this.all($, Z, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), Z, { type: "none" }), this;
  }
  get($, W, J) {
    return this.add("GET", $, W, J), this;
  }
  post($, W, J) {
    return this.add("POST", $, W, J), this;
  }
  put($, W, J) {
    return this.add("PUT", $, W, J), this;
  }
  patch($, W, J) {
    return this.add("PATCH", $, W, J), this;
  }
  delete($, W, J) {
    return this.add("DELETE", $, W, J), this;
  }
  options($, W, J) {
    return this.add("OPTIONS", $, W, J), this;
  }
  all($, W, J) {
    return this.add("ALL", $, W, J), this;
  }
  head($, W, J) {
    return this.add("HEAD", $, W, J), this;
  }
  connect($, W, J) {
    return this.add("CONNECT", $, W, J), this;
  }
  ws($, W) {
    const J = W.transformMessage ? Array.isArray(W.transformMessage) ? W.transformMessage : [W.transformMessage] : undefined;
    let Z = null;
    const X = p(W?.body, { models: this.definitions.type }), B = p(W?.response, { models: this.definitions.type }), Y = (D) => {
      if (typeof D === "string") {
        const Q = D?.charCodeAt(0);
        if (Q === 47 || Q === 123)
          try {
            D = JSON.parse(D);
          } catch {
          }
        else if (f0(D))
          D = +D;
      }
      if (J?.length)
        for (let Q = 0;Q < J.length; Q++) {
          const z = J[Q](D);
          if (z !== undefined)
            D = z;
        }
      return D;
    };
    return this.route("$INTERNALWS", $, (D) => {
      const { set: Q, path: z, qi: G, headers: U, query: T, params: j } = D;
      if (Z === null)
        Z = this.getServer();
      if (Z?.upgrade(D.request, { headers: typeof W.upgrade === "function" ? W.upgrade(D) : W.upgrade, data: { validator: B, open(K) {
        W.open?.(new _0(K, D));
      }, message: (K, P) => {
        const I = Y(P);
        if (X?.Check(I) === false)
          return void K.send(new R("message", X, I).message);
        W.message?.(new _0(K, D), I);
      }, drain(K) {
        W.drain?.(new _0(K, D));
      }, close(K, P, I) {
        W.close?.(new _0(K, D), P, I);
      } } }))
        return;
      return Q.status = 400, "Expected a websocket connection";
    }, { beforeHandle: W.beforeHandle, transform: W.transform, headers: W.headers, params: W.params, query: W.query }), this;
  }
  route($, W, J, { config: Z, ...X } = { config: { allowMeta: false } }) {
    return this.add($, W, J, X, Z), this;
  }
  state($, W) {
    switch (typeof $) {
      case "object":
        return this.store = d(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = W;
    return this;
  }
  decorate($, W) {
    switch (typeof $) {
      case "object":
        return this.decorators = d(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = W;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, W) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([J, Z]) => {
          if (!(J in this.definitions.type))
            this.definitions.type[J] = Z;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = W, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, W, J) {
    if (J === "")
      return this;
    const Z = ["_", "-", " "], X = (Q) => Q[0].toUpperCase() + Q.slice(1), B = $ === "prefix" ? (Q, z) => Z.includes(Q.at(-1) ?? "") ? Q + z : Q + X(z) : Z.includes(J.at(-1) ?? "") ? (Q, z) => z + Q : (Q, z) => z + X(Q), Y = (Q) => {
      const z = {};
      switch (Q) {
        case "decorator":
          for (let G in this.decorators)
            z[B(J, G)] = this.decorators[G];
          this.decorators = z;
          break;
        case "state":
          for (let G in this.store)
            z[B(J, G)] = this.store[G];
          this.store = z;
          break;
        case "model":
          for (let G in this.definitions.type)
            z[B(J, G)] = this.definitions.type[G];
          this.definitions.type = z;
          break;
        case "error":
          for (let G in this.definitions.error)
            z[B(J, G)] = this.definitions.error[G];
          this.definitions.error = z;
          break;
      }
    }, D = Array.isArray(W) ? W : [W];
    for (let Q of D.some((z) => z === "all") ? ["decorator", "state", "model", "error"] : D)
      Y(Q);
    return this;
  }
  prefix($, W) {
    return this.affix("prefix", $, W);
  }
  suffix($, W) {
    return this.affix("suffix", $, W);
  }
  compile() {
    if (this.fetch = this.config.aot ? Y1(this) : D1(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? Y1(this) : D1(this))($);
  };
  handleError = async ($, W) => (this.handleError = this.config.aot ? Q1(this) : r1(this))($, W);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, W) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const J = this.fetch, Z = typeof $ === "object" ? { development: !N0, reusePort: true, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...$1 }, fetch: J, error: this.outerErrorHandler } : { development: !N0, reusePort: true, ...this.config.serve, websocket: { ...this.config.websocket, ...$1 }, port: $, fetch: J, error: this.outerErrorHandler };
    if (this.server = Bun?.serve(Z), this.event.start.length)
      for (let X = 0;X < this.event.start.length; X++)
        this.event.start[X](this);
    if (W)
      W(this.server);
    return process.on("beforeExit", () => {
      for (let X = 0;X < this.event.stop.length; X++)
        this.event.stop[X](this);
    }), Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      for (let $ = 0;$ < this.event.stop.length; $++)
        this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}

// node_modules/@mikro-orm/mongodb/index.mjs
var import_2 = __toESM(require_mongodb(), 1);
var ALIAS_REPLACEMENT = import_2.default.ALIAS_REPLACEMENT;
var ALIAS_REPLACEMENT_RE = import_2.default.ALIAS_REPLACEMENT_RE;
var ARRAY_OPERATORS = import_2.default.ARRAY_OPERATORS;
var AbstractNamingStrategy = import_2.default.AbstractNamingStrategy;
var AbstractSchemaGenerator = import_2.default.AbstractSchemaGenerator;
var AfterCreate = import_2.default.AfterCreate;
var AfterDelete = import_2.default.AfterDelete;
var AfterUpdate = import_2.default.AfterUpdate;
var AfterUpsert = import_2.default.AfterUpsert;
var ArrayCollection = import_2.default.ArrayCollection;
var ArrayType7 = import_2.default.ArrayType;
var BaseEntity = import_2.default.BaseEntity;
var BeforeCreate = import_2.default.BeforeCreate;
var BeforeDelete = import_2.default.BeforeDelete;
var BeforeUpdate = import_2.default.BeforeUpdate;
var BeforeUpsert = import_2.default.BeforeUpsert;
var BigIntType2 = import_2.default.BigIntType;
var BlobType = import_2.default.BlobType;
var BooleanType2 = import_2.default.BooleanType;
var Cascade = import_2.default.Cascade;
var ChangeSet = import_2.default.ChangeSet;
var ChangeSetComputer = import_2.default.ChangeSetComputer;
var ChangeSetPersister = import_2.default.ChangeSetPersister;
var ChangeSetType = import_2.default.ChangeSetType;
var Check3 = import_2.default.Check;
var CheckConstraintViolationException = import_2.default.CheckConstraintViolationException;
var Collection = import_2.default.Collection;
var CommitOrderCalculator = import_2.default.CommitOrderCalculator;
var Config = import_2.default.Config;
var Configuration = import_2.default.Configuration;
var ConfigurationLoader = import_2.default.ConfigurationLoader;
var Connection = import_2.default.Connection;
var ConnectionException = import_2.default.ConnectionException;
var ConstraintViolationException = import_2.default.ConstraintViolationException;
var CreateRequestContext = import_2.default.CreateRequestContext;
var Cursor = import_2.default.Cursor;
var CursorError = import_2.default.CursorError;
var DatabaseDriver = import_2.default.DatabaseDriver;
var DatabaseObjectExistsException = import_2.default.DatabaseObjectExistsException;
var DatabaseObjectNotFoundException = import_2.default.DatabaseObjectNotFoundException;
var DataloaderType = import_2.default.DataloaderType;
var DataloaderUtils = import_2.default.DataloaderUtils;
var DateTimeType = import_2.default.DateTimeType;
var DateType5 = import_2.default.DateType;
var DeadlockException = import_2.default.DeadlockException;
var DecimalType = import_2.default.DecimalType;
var DefaultLogger = import_2.default.DefaultLogger;
var DoubleType = import_2.default.DoubleType;
var DriverException = import_2.default.DriverException;
var EagerProps = import_2.default.EagerProps;
var Embeddable = import_2.default.Embeddable;
var Embedded = import_2.default.Embedded;
var EnsureRequestContext = import_2.default.EnsureRequestContext;
var Entity = import_2.default.Entity;
var EntityAssigner = import_2.default.EntityAssigner;
var EntityCaseNamingStrategy = import_2.default.EntityCaseNamingStrategy;
var EntityComparator = import_2.default.EntityComparator;
var EntityFactory = import_2.default.EntityFactory;
var EntityHelper = import_2.default.EntityHelper;
var EntityIdentifier = import_2.default.EntityIdentifier;
var EntityLoader = import_2.default.EntityLoader;
var EntityManager = import_2.default.EntityManager;
var EntityManagerType = import_2.default.EntityManagerType;
var EntityMetadata = import_2.default.EntityMetadata;
var EntityRepository = import_2.default.EntityRepository;
var EntityRepositoryType = import_2.default.EntityRepositoryType;
var EntitySchema = import_2.default.EntitySchema;
var EntitySerializer = import_2.default.EntitySerializer;
var EntityTransformer = import_2.default.EntityTransformer;
var EntityValidator = import_2.default.EntityValidator;
var Enum2 = import_2.default.Enum;
var EnumArrayType = import_2.default.EnumArrayType;
var EnumType = import_2.default.EnumType;
var EventManager = import_2.default.EventManager;
var EventType = import_2.default.EventType;
var EventTypeMap = import_2.default.EventTypeMap;
var ExceptionConverter = import_2.default.ExceptionConverter;
var FileCacheAdapter = import_2.default.FileCacheAdapter;
var Filter = import_2.default.Filter;
var FloatType = import_2.default.FloatType;
var FlushMode = import_2.default.FlushMode;
var ForeignKeyConstraintViolationException = import_2.default.ForeignKeyConstraintViolationException;
var Formula = import_2.default.Formula;
var GeneratedCacheAdapter = import_2.default.GeneratedCacheAdapter;
var GroupOperator = import_2.default.GroupOperator;
var HiddenProps = import_2.default.HiddenProps;
var Hydrator = import_2.default.Hydrator;
var IdentityMap = import_2.default.IdentityMap;
var Index2 = import_2.default.Index;
var IntegerType = import_2.default.IntegerType;
var IntervalType = import_2.default.IntervalType;
var InvalidFieldNameException = import_2.default.InvalidFieldNameException;
var IsolationLevel = import_2.default.IsolationLevel;
var JsonProperty = import_2.default.JsonProperty;
var JsonType = import_2.default.JsonType;
var LoadStrategy = import_2.default.LoadStrategy;
var LockMode = import_2.default.LockMode;
var LockWaitTimeoutException = import_2.default.LockWaitTimeoutException;
var ManyToMany = import_2.default.ManyToMany;
var ManyToOne = import_2.default.ManyToOne;
var MediumIntType = import_2.default.MediumIntType;
var MemoryCacheAdapter = import_2.default.MemoryCacheAdapter;
var MetadataDiscovery = import_2.default.MetadataDiscovery;
var MetadataError = import_2.default.MetadataError;
var MetadataProvider = import_2.default.MetadataProvider;
var MetadataStorage = import_2.default.MetadataStorage;
var MetadataValidator = import_2.default.MetadataValidator;
var MikroORM = import_2.default.MikroORM;
var MongoConnection = import_2.default.MongoConnection;
var MongoDriver = import_2.default.MongoDriver;
var MongoEntityManager = import_2.default.MongoEntityManager;
var MongoEntityRepository = import_2.default.MongoEntityRepository;
var MongoNamingStrategy = import_2.default.MongoNamingStrategy;
var MongoPlatform = import_2.default.MongoPlatform;
var MongoSchemaGenerator = import_2.default.MongoSchemaGenerator;
var NodeState = import_2.default.NodeState;
var NonUniqueFieldNameException = import_2.default.NonUniqueFieldNameException;
var NotFoundError = import_2.default.NotFoundError;
var NotNullConstraintViolationException = import_2.default.NotNullConstraintViolationException;
var NullCacheAdapter = import_2.default.NullCacheAdapter;
var NullHighlighter = import_2.default.NullHighlighter;
var ObjectBindingPattern = import_2.default.ObjectBindingPattern;
var ObjectHydrator = import_2.default.ObjectHydrator;
var ObjectId = import_2.default.ObjectId;
var OnInit = import_2.default.OnInit;
var OnLoad = import_2.default.OnLoad;
var OneToMany = import_2.default.OneToMany;
var OneToOne = import_2.default.OneToOne;
var OptimisticLockError = import_2.default.OptimisticLockError;
var OptionalProps = import_2.default.OptionalProps;
var PlainObject = import_2.default.PlainObject;
var Platform = import_2.default.Platform;
var PopulateHint = import_2.default.PopulateHint;
var PrimaryKey = import_2.default.PrimaryKey;
var PrimaryKeyProp = import_2.default.PrimaryKeyProp;
var Property2 = import_2.default.Property;
var QueryFlag = import_2.default.QueryFlag;
var QueryHelper = import_2.default.QueryHelper;
var QueryOperator = import_2.default.QueryOperator;
var QueryOrder = import_2.default.QueryOrder;
var QueryOrderNumeric = import_2.default.QueryOrderNumeric;
var RawQueryFragment = import_2.default.RawQueryFragment;
var ReadOnlyException = import_2.default.ReadOnlyException;
var Ref2 = import_2.default.Ref;
var Reference = import_2.default.Reference;
var ReferenceKind = import_2.default.ReferenceKind;
var ReflectMetadataProvider = import_2.default.ReflectMetadataProvider;
var RequestContext = import_2.default.RequestContext;
var SCALAR_TYPES = import_2.default.SCALAR_TYPES;
var ScalarReference = import_2.default.ScalarReference;
var SerializationContext = import_2.default.SerializationContext;
var SerializedPrimaryKey = import_2.default.SerializedPrimaryKey;
var ServerException = import_2.default.ServerException;
var SimpleLogger = import_2.default.SimpleLogger;
var SmallIntType = import_2.default.SmallIntType;
var StringType2 = import_2.default.StringType;
var SyntaxErrorException = import_2.default.SyntaxErrorException;
var TableExistsException = import_2.default.TableExistsException;
var TableNotFoundException = import_2.default.TableNotFoundException;
var TextType = import_2.default.TextType;
var TimeType = import_2.default.TimeType;
var TinyIntType = import_2.default.TinyIntType;
var TransactionContext = import_2.default.TransactionContext;
var TransactionEventBroadcaster = import_2.default.TransactionEventBroadcaster;
var Type2 = import_2.default.Type;
var Uint8ArrayType3 = import_2.default.Uint8ArrayType;
var UnderscoreNamingStrategy = import_2.default.UnderscoreNamingStrategy;
var Unique = import_2.default.Unique;
var UniqueConstraintViolationException = import_2.default.UniqueConstraintViolationException;
var UnitOfWork = import_2.default.UnitOfWork;
var UnknownType = import_2.default.UnknownType;
var Utils = import_2.default.Utils;
var UuidType = import_2.default.UuidType;
var ValidationError = import_2.default.ValidationError;
var WrappedEntity = import_2.default.WrappedEntity;
var assign = import_2.default.assign;
var colors = import_2.default.colors;
var compareArrays = import_2.default.compareArrays;
var compareBooleans = import_2.default.compareBooleans;
var compareBuffers = import_2.default.compareBuffers;
var compareObjects = import_2.default.compareObjects;
var createSqlFunction = import_2.default.createSqlFunction;
var defineConfig = import_2.default.defineConfig;
var equals = import_2.default.equals;
var getOnConflictFields = import_2.default.getOnConflictFields;
var getOnConflictReturningFields = import_2.default.getOnConflictReturningFields;
var helper = import_2.default.helper;
var parseJsonSafe = import_2.default.parseJsonSafe;
var raw = import_2.default.raw;
var ref3 = import_2.default.ref;
var rel = import_2.default.rel;
var serialize = import_2.default.serialize;
var sql = import_2.default.sql;
var t2 = import_2.default.t;
var types = import_2.default.types;
var wrap = import_2.default.wrap;

// src/index.ts
var mongo_highlighter = __toESM(require_mongo_highlighter(), 1);

// node_modules/@mikro-orm/core/index.mjs
var import_3 = __toESM(require_core(), 1);
var ALIAS_REPLACEMENT2 = import_3.default.ALIAS_REPLACEMENT;
var ALIAS_REPLACEMENT_RE2 = import_3.default.ALIAS_REPLACEMENT_RE;
var ARRAY_OPERATORS2 = import_3.default.ARRAY_OPERATORS;
var AbstractNamingStrategy2 = import_3.default.AbstractNamingStrategy;
var AbstractSchemaGenerator2 = import_3.default.AbstractSchemaGenerator;
var AfterCreate2 = import_3.default.AfterCreate;
var AfterDelete2 = import_3.default.AfterDelete;
var AfterUpdate2 = import_3.default.AfterUpdate;
var AfterUpsert2 = import_3.default.AfterUpsert;
var ArrayCollection2 = import_3.default.ArrayCollection;
var ArrayType8 = import_3.default.ArrayType;
var BaseEntity2 = import_3.default.BaseEntity;
var BeforeCreate2 = import_3.default.BeforeCreate;
var BeforeDelete2 = import_3.default.BeforeDelete;
var BeforeUpdate2 = import_3.default.BeforeUpdate;
var BeforeUpsert2 = import_3.default.BeforeUpsert;
var BigIntType3 = import_3.default.BigIntType;
var BlobType2 = import_3.default.BlobType;
var BooleanType3 = import_3.default.BooleanType;
var Cascade2 = import_3.default.Cascade;
var ChangeSet2 = import_3.default.ChangeSet;
var ChangeSetComputer2 = import_3.default.ChangeSetComputer;
var ChangeSetPersister2 = import_3.default.ChangeSetPersister;
var ChangeSetType2 = import_3.default.ChangeSetType;
var Check4 = import_3.default.Check;
var CheckConstraintViolationException2 = import_3.default.CheckConstraintViolationException;
var Collection2 = import_3.default.Collection;
var CommitOrderCalculator2 = import_3.default.CommitOrderCalculator;
var Config2 = import_3.default.Config;
var Configuration2 = import_3.default.Configuration;
var ConfigurationLoader2 = import_3.default.ConfigurationLoader;
var Connection2 = import_3.default.Connection;
var ConnectionException2 = import_3.default.ConnectionException;
var ConstraintViolationException2 = import_3.default.ConstraintViolationException;
var CreateRequestContext2 = import_3.default.CreateRequestContext;
var Cursor2 = import_3.default.Cursor;
var CursorError2 = import_3.default.CursorError;
var DatabaseDriver2 = import_3.default.DatabaseDriver;
var DatabaseObjectExistsException2 = import_3.default.DatabaseObjectExistsException;
var DatabaseObjectNotFoundException2 = import_3.default.DatabaseObjectNotFoundException;
var DataloaderType2 = import_3.default.DataloaderType;
var DataloaderUtils2 = import_3.default.DataloaderUtils;
var DateTimeType2 = import_3.default.DateTimeType;
var DateType6 = import_3.default.DateType;
var DeadlockException2 = import_3.default.DeadlockException;
var DecimalType2 = import_3.default.DecimalType;
var DefaultLogger2 = import_3.default.DefaultLogger;
var DoubleType2 = import_3.default.DoubleType;
var DriverException2 = import_3.default.DriverException;
var EagerProps2 = import_3.default.EagerProps;
var Embeddable2 = import_3.default.Embeddable;
var Embedded2 = import_3.default.Embedded;
var EnsureRequestContext2 = import_3.default.EnsureRequestContext;
var Entity2 = import_3.default.Entity;
var EntityAssigner2 = import_3.default.EntityAssigner;
var EntityCaseNamingStrategy2 = import_3.default.EntityCaseNamingStrategy;
var EntityComparator2 = import_3.default.EntityComparator;
var EntityFactory2 = import_3.default.EntityFactory;
var EntityHelper2 = import_3.default.EntityHelper;
var EntityIdentifier2 = import_3.default.EntityIdentifier;
var EntityLoader2 = import_3.default.EntityLoader;
var EntityManager2 = import_3.default.EntityManager;
var EntityManagerType2 = import_3.default.EntityManagerType;
var EntityMetadata2 = import_3.default.EntityMetadata;
var EntityRepository2 = import_3.default.EntityRepository;
var EntityRepositoryType2 = import_3.default.EntityRepositoryType;
var EntitySchema2 = import_3.default.EntitySchema;
var EntitySerializer2 = import_3.default.EntitySerializer;
var EntityTransformer2 = import_3.default.EntityTransformer;
var EntityValidator2 = import_3.default.EntityValidator;
var Enum3 = import_3.default.Enum;
var EnumArrayType2 = import_3.default.EnumArrayType;
var EnumType2 = import_3.default.EnumType;
var EventManager2 = import_3.default.EventManager;
var EventType2 = import_3.default.EventType;
var EventTypeMap2 = import_3.default.EventTypeMap;
var ExceptionConverter2 = import_3.default.ExceptionConverter;
var FileCacheAdapter2 = import_3.default.FileCacheAdapter;
var Filter2 = import_3.default.Filter;
var FloatType2 = import_3.default.FloatType;
var FlushMode2 = import_3.default.FlushMode;
var ForeignKeyConstraintViolationException2 = import_3.default.ForeignKeyConstraintViolationException;
var Formula2 = import_3.default.Formula;
var GeneratedCacheAdapter2 = import_3.default.GeneratedCacheAdapter;
var GroupOperator2 = import_3.default.GroupOperator;
var HiddenProps2 = import_3.default.HiddenProps;
var Hydrator2 = import_3.default.Hydrator;
var IdentityMap2 = import_3.default.IdentityMap;
var Index3 = import_3.default.Index;
var IntegerType2 = import_3.default.IntegerType;
var IntervalType2 = import_3.default.IntervalType;
var InvalidFieldNameException2 = import_3.default.InvalidFieldNameException;
var IsolationLevel2 = import_3.default.IsolationLevel;
var JsonProperty2 = import_3.default.JsonProperty;
var JsonType2 = import_3.default.JsonType;
var LoadStrategy2 = import_3.default.LoadStrategy;
var LockMode2 = import_3.default.LockMode;
var LockWaitTimeoutException2 = import_3.default.LockWaitTimeoutException;
var ManyToMany2 = import_3.default.ManyToMany;
var ManyToOne2 = import_3.default.ManyToOne;
var MediumIntType2 = import_3.default.MediumIntType;
var MemoryCacheAdapter2 = import_3.default.MemoryCacheAdapter;
var MetadataDiscovery2 = import_3.default.MetadataDiscovery;
var MetadataError2 = import_3.default.MetadataError;
var MetadataProvider2 = import_3.default.MetadataProvider;
var MetadataStorage2 = import_3.default.MetadataStorage;
var MetadataValidator2 = import_3.default.MetadataValidator;
var MikroORM2 = import_3.default.MikroORM;
var MongoNamingStrategy2 = import_3.default.MongoNamingStrategy;
var NodeState2 = import_3.default.NodeState;
var NonUniqueFieldNameException2 = import_3.default.NonUniqueFieldNameException;
var NotFoundError2 = import_3.default.NotFoundError;
var NotNullConstraintViolationException2 = import_3.default.NotNullConstraintViolationException;
var NullCacheAdapter2 = import_3.default.NullCacheAdapter;
var NullHighlighter2 = import_3.default.NullHighlighter;
var ObjectBindingPattern2 = import_3.default.ObjectBindingPattern;
var ObjectHydrator2 = import_3.default.ObjectHydrator;
var OnInit2 = import_3.default.OnInit;
var OnLoad2 = import_3.default.OnLoad;
var OneToMany2 = import_3.default.OneToMany;
var OneToOne2 = import_3.default.OneToOne;
var OptimisticLockError2 = import_3.default.OptimisticLockError;
var OptionalProps2 = import_3.default.OptionalProps;
var PlainObject2 = import_3.default.PlainObject;
var Platform2 = import_3.default.Platform;
var PopulateHint2 = import_3.default.PopulateHint;
var PrimaryKey2 = import_3.default.PrimaryKey;
var PrimaryKeyProp2 = import_3.default.PrimaryKeyProp;
var Property3 = import_3.default.Property;
var QueryFlag2 = import_3.default.QueryFlag;
var QueryHelper2 = import_3.default.QueryHelper;
var QueryOperator2 = import_3.default.QueryOperator;
var QueryOrder2 = import_3.default.QueryOrder;
var QueryOrderNumeric2 = import_3.default.QueryOrderNumeric;
var RawQueryFragment2 = import_3.default.RawQueryFragment;
var ReadOnlyException2 = import_3.default.ReadOnlyException;
var Ref3 = import_3.default.Ref;
var Reference2 = import_3.default.Reference;
var ReferenceKind2 = import_3.default.ReferenceKind;
var ReflectMetadataProvider2 = import_3.default.ReflectMetadataProvider;
var RequestContext2 = import_3.default.RequestContext;
var SCALAR_TYPES2 = import_3.default.SCALAR_TYPES;
var ScalarReference2 = import_3.default.ScalarReference;
var SerializationContext2 = import_3.default.SerializationContext;
var SerializedPrimaryKey2 = import_3.default.SerializedPrimaryKey;
var ServerException2 = import_3.default.ServerException;
var SimpleLogger2 = import_3.default.SimpleLogger;
var SmallIntType2 = import_3.default.SmallIntType;
var StringType3 = import_3.default.StringType;
var SyntaxErrorException2 = import_3.default.SyntaxErrorException;
var TableExistsException2 = import_3.default.TableExistsException;
var TableNotFoundException2 = import_3.default.TableNotFoundException;
var TextType2 = import_3.default.TextType;
var TimeType2 = import_3.default.TimeType;
var TinyIntType2 = import_3.default.TinyIntType;
var TransactionContext2 = import_3.default.TransactionContext;
var TransactionEventBroadcaster2 = import_3.default.TransactionEventBroadcaster;
var Type3 = import_3.default.Type;
var Uint8ArrayType4 = import_3.default.Uint8ArrayType;
var UnderscoreNamingStrategy2 = import_3.default.UnderscoreNamingStrategy;
var Unique2 = import_3.default.Unique;
var UniqueConstraintViolationException2 = import_3.default.UniqueConstraintViolationException;
var UnitOfWork2 = import_3.default.UnitOfWork;
var UnknownType2 = import_3.default.UnknownType;
var Utils2 = import_3.default.Utils;
var UuidType2 = import_3.default.UuidType;
var ValidationError2 = import_3.default.ValidationError;
var WrappedEntity2 = import_3.default.WrappedEntity;
var assign2 = import_3.default.assign;
var colors2 = import_3.default.colors;
var compareArrays2 = import_3.default.compareArrays;
var compareBooleans2 = import_3.default.compareBooleans;
var compareBuffers2 = import_3.default.compareBuffers;
var compareObjects2 = import_3.default.compareObjects;
var createSqlFunction2 = import_3.default.createSqlFunction;
var defineConfig2 = import_3.default.defineConfig;
var equals2 = import_3.default.equals;
var getOnConflictFields2 = import_3.default.getOnConflictFields;
var getOnConflictReturningFields2 = import_3.default.getOnConflictReturningFields;
var helper2 = import_3.default.helper;
var parseJsonSafe2 = import_3.default.parseJsonSafe;
var raw2 = import_3.default.raw;
var ref4 = import_3.default.ref;
var rel2 = import_3.default.rel;
var serialize2 = import_3.default.serialize;
var sql2 = import_3.default.sql;
var t3 = import_3.default.t;
var types2 = import_3.default.types;
var wrap2 = import_3.default.wrap;

// src/index.ts
var app = new n().get("/", () => "Hello Elysia").listen("8080");
console.log(`\uD83E\uDD8A Elysia is running at ${app.server?.hostname}:${app.server?.port}`);

class Item {
}
__legacyDecorateClassTS([
  PrimaryKey2(),
  __legacyMetadataTS("design:type", typeof ObjectId === "undefined" ? Object : ObjectId)
], Item.prototype, "_id", undefined);
__legacyDecorateClassTS([
  Property3(),
  __legacyMetadataTS("design:type", String)
], Item.prototype, "name", undefined);
Item = __legacyDecorateClassTS([
  Entity2()
], Item);
var options = {
  entities: [Item],
  dbName: "mikro-orm-express-ts",
  highlighter: new mongo_highlighter.MongoHighlighter,
  debug: true
};
var config = {
  entities: [Item],
  dbName: "bundb",
  clientUrl: "mongodb+srv://mongo-b53ccec6.mongo.ondigitalocean.com"
};
var orm = await MikroORM.init(config);
export {
  Item
};
